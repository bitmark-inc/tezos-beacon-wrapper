(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":1,"buffer":3,"ieee754":5}],4:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],5:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],6:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],7:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],8:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":3}],9:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/lib/_stream_readable.js');
Stream.Writable = require('readable-stream/lib/_stream_writable.js');
Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
Stream.Transform = require('readable-stream/lib/_stream_transform.js');
Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js')
Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js')

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":4,"inherits":6,"readable-stream/lib/_stream_duplex.js":11,"readable-stream/lib/_stream_passthrough.js":12,"readable-stream/lib/_stream_readable.js":13,"readable-stream/lib/_stream_transform.js":14,"readable-stream/lib/_stream_writable.js":15,"readable-stream/lib/internal/streams/end-of-stream.js":19,"readable-stream/lib/internal/streams/pipeline.js":21}],10:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],11:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))
},{"./_stream_readable":13,"./_stream_writable":15,"_process":7,"inherits":6}],12:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":14,"inherits":6}],13:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":10,"./_stream_duplex":11,"./internal/streams/async_iterator":16,"./internal/streams/buffer_list":17,"./internal/streams/destroy":18,"./internal/streams/from":20,"./internal/streams/state":22,"./internal/streams/stream":23,"_process":7,"buffer":3,"events":4,"inherits":6,"string_decoder/":24,"util":2}],14:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":10,"./_stream_duplex":11,"inherits":6}],15:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":10,"./_stream_duplex":11,"./internal/streams/destroy":18,"./internal/streams/state":22,"./internal/streams/stream":23,"_process":7,"buffer":3,"inherits":6,"util-deprecate":25}],16:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))
},{"./end-of-stream":19,"_process":7}],17:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
},{"buffer":3,"util":2}],18:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))
},{"_process":7}],19:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
},{"../../../errors":10}],20:[function(require,module,exports){
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

},{}],21:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
},{"../../../errors":10,"./end-of-stream":19}],22:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":10}],23:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":4}],24:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":8}],25:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],26:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubstrateBlockchain = void 0;
var wallet_lists_1 = require("./ui/alert/wallet-lists");
var SubstrateBlockchain = /** @class */ (function () {
    function SubstrateBlockchain() {
        this.identifier = 'substrate';
    }
    SubstrateBlockchain.prototype.validateRequest = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // TODO: Validation
                if (input) {
                    return [2 /*return*/];
                }
                return [2 /*return*/];
            });
        });
    };
    SubstrateBlockchain.prototype.handleResponse = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // TODO: Validation
                if (input) {
                    return [2 /*return*/];
                }
                return [2 /*return*/];
            });
        });
    };
    SubstrateBlockchain.prototype.getWalletLists = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, {
                        extensionList: wallet_lists_1.extensionList,
                        desktopList: wallet_lists_1.desktopList,
                        webList: wallet_lists_1.webList,
                        iOSList: wallet_lists_1.iOSList
                    }];
            });
        });
    };
    SubstrateBlockchain.prototype.getAccountInfosFromPermissionResponse = function (permissionResponse) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, permissionResponse.blockchainData.accounts.map(function (account) { return ({
                        accountId: account.accountId,
                        address: account.address,
                        publicKey: account.publicKey
                    }); })];
            });
        });
    };
    return SubstrateBlockchain;
}());
exports.SubstrateBlockchain = SubstrateBlockchain;

},{"./ui/alert/wallet-lists":36}],27:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubstrateBlockchain = void 0;
var blockchain_1 = require("./blockchain");
Object.defineProperty(exports, "SubstrateBlockchain", { enumerable: true, get: function () { return blockchain_1.SubstrateBlockchain; } });
__exportStar(require("./types/message-type"), exports);
__exportStar(require("./types/permission-scope"), exports);
__exportStar(require("./types/messages/permission-request"), exports);
__exportStar(require("./types/messages/permission-response"), exports);
__exportStar(require("./types/messages/sign-payload-request"), exports);
__exportStar(require("./types/messages/sign-payload-response"), exports);
__exportStar(require("./types/messages/transfer-request"), exports);
__exportStar(require("./types/messages/transfer-response"), exports);

},{"./blockchain":26,"./types/message-type":28,"./types/messages/permission-request":29,"./types/messages/permission-response":30,"./types/messages/sign-payload-request":31,"./types/messages/sign-payload-response":32,"./types/messages/transfer-request":33,"./types/messages/transfer-response":34,"./types/permission-scope":35}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubstrateMessageType = void 0;
var SubstrateMessageType;
(function (SubstrateMessageType) {
    SubstrateMessageType["transfer_request"] = "transfer_request";
    SubstrateMessageType["sign_payload_request"] = "sign_payload_request";
})(SubstrateMessageType = exports.SubstrateMessageType || (exports.SubstrateMessageType = {}));

},{}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubstratePermissionScope = void 0;
var SubstratePermissionScope;
(function (SubstratePermissionScope) {
    SubstratePermissionScope["transfer"] = "transfer";
    SubstratePermissionScope["sign_payload_json"] = "sign_payload_json";
    SubstratePermissionScope["sign_payload_raw"] = "sign_payload_raw";
})(SubstratePermissionScope = exports.SubstratePermissionScope || (exports.SubstratePermissionScope = {}));

},{}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.iOSList = exports.webList = exports.desktopList = exports.extensionList = void 0;
exports.extensionList = [];
exports.desktopList = [];
exports.webList = [];
exports.iOSList = [
    {
        "key": "airgap_ios",
        "name": "AirGap Wallet",
        "shortName": "AirGap",
        "color": "rgb(4, 235, 204)",
        "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAJ60lEQVR4AeXBe2xdd2HA8e/vd865N9f34ce1r+36GcexnTRpmj4S2gbSkbYq64BVTKggJsYfLWxisEkriG4sgECjmjZRVIQ2dTw0aYitaFC2wUYofajQNU3S5uE4sWM7tuPY8eP6Xt/nOfec3zYhT4dbP37XsdM//PkI9b/YwiRbnGSLk2xxki1OssVJ3gYFz6VcpuTwdpDcQLN2gT86/Su6jz1Lua5jz/LoG69wrZjnRjK5AYqeyzdGBvjyxTdYcGzqrCDlbM/lH8Yu8uzVUf6iZx+f3L6boJRsNpNNpIDR1DzfuHSOv50YQkfKsXn83HG+OTLAl/pu45GW7Ugh2Cwmm0ABY+kkZ2aukioWyDg2awlKA3BYMpxb5CMnX+TJodMc7d3Pw83tCAQbzWQDeUoxkpqnf26adLFAJf6gfSd/PXSGcmfSSX7v+PPsidXy2e69fLBlO5aQbBSTDZB1bC4tzDKYnKNQcliPr+6+g72xWv78/AnG81nKnU0n+f2TL/G58yd4rKOXj7XvpGVbFdfLZJ0Kbonx9AKXU/Ncy2VQrEywNgF8pHUHH2ju5OmRfp4cOsO8XaTcRD7LXw6c5IsXTvFb9c18qKWL9ze3U2cFWQ+TCqTtIpOLKSYyKa7lMiilWE3QMNkVT5APh2F6DB0hw+Dx7r18vLOPp4bP8bVL/SSdIuVcpTg2M8mxmUk+8abkcH0T72tq57cTrXSFo+gy0XRiaoKB+WvoCFsB+uIJumvqMaXk9XyGSsVMi8/33MqfdN3M341e4Knhc1wp5FiOozyOzUxybGaSTwFHe2/laO9+dJhoyjo2qxFAUyTGztp6WiPVCCHYCFHT4s+69/Dprt384Opl/v7yAC/OTqFY2Wgugy4TTbZbYjl126roqK6lM1ZLlRVAh6JylpQ80rKdR1q2M5Jb5HsTw3x/coQz6STl5uwiukw02Z6LX1u0htsaW4gEgqwlKA38sq5D1i0RNkzWY3tVlCd69vFEzz4uZlL86dnX+Mm1CZYknSK6JJocz8MvURUhEgiiY3e0Gj/b8/jjM6+SdUtcr55INXfXJfBLlRx0mWgquS5+ppTo2huroy9SzUAmxZLvjA3yTxOXiBgWHgrFrzUGQxyqS/BYRy8HahvQETUt/NKOjS6JppLy8DOlRJcAntx9B+Vsz2PeKbLg2KQcm5RjczGT4ltjg9z18r/x2JuvUPRc1hI1LfwypRK6JJpKnoefISWVeG9TO1/edRu6FPDM5Yt88PVf4CnFaqoME7+sW0KXRIOrFOUMIanUEzv38cMDR+iNVKPrx1PjPD1yntVUGQZ+Rc/FUwodJho85VFOCsF6vK+pnfc2tXM6PU//4gK25yEAKQSuUrw0N8V3x4fwlGLJXw2e5g87+7CkZDlBw6Bc0fMIGQZrMdGglKKcFIL1EsC+WB37YnWU+2hbN7dXx/nkmVdZMl3M88vkNQ7Hm1hOQBiUs5VLCIO1SDQo3kog2Cwf7+yjxgrgd35xgZWYUlDO9RQ6JBqU4i2EYNMYQrBNGviVlGIlEkE5D4UOiQYheAvF5jk2M8lUMY9fZ1WEzWCiQSAop5SiUlm3xJxdRKFYjuN5PD97lc/1v45flWHyrngTK3GVopwhBDpMNEghKOcphQ7b83jm8gWeGbvIm6kkCkWlHuvsJWZarMRRHuUsIdFhokEKQTlXeaxlPJ/ld1/7OadSc6zXzdEavtS7n9UUXJdyQcNAh4kGKQRSCDylWFLyPFaTdGyO/PKnDGXTrNedNfX88MARIqbFarJuCb+AlFhCosNEkyUNim6JJY7rsprP9h9nKJtmPfZEa/lEZy+PdvZiCcla0o6NX9S00GWiKWgYFN0SS4quy0qmi3m+Oz6EX40V4It9+7mnrhFDCJZjCEFzsIp4IEgl5pwifnVWEF0mmoKmBXaRJYWSw0qOzUzieB5+zx24j0PxRjbDVCGPXyK4DV0STVWmhV/GKbKS4dwifr2Rag7FG9ksl3KL+LWGwuiSaIoFt+E3X8izEonAz/E8NtOJhVn8+iI16JJoioeq8Ms5NuligeX0RqrxG84t8tzUGJvh7GKSyUIOvwO19egy0ZSoiiCFwFOKJZfTC+xtaKLc/Q03UWWY5NwSSx55/QU+veNm3lHbgCEESwJC0hOpprMqwnr885UR/ILS4J11jegy0WRJg8ZwlKuZNEsuLcyyp74RIQR+1VaAT3Xt5quDp1lS8FyeHDzNSvZXx/nKrtt4MNGKLsfz+PbYIH73NdxExLTQJalAV3UdflnHZjSdZDlHe2/l7roEuk6l5njo1Z/xlYtvousfJ4a4Usjh99G2biohqUB7rJaQaeF3euYqrvIoF5QG//GOB3i4uQNdCvj8wEn+ZXKUtWTdEl+48AZ+baEw729upxKSCkgh2BVP4Jexi5ydmWI5MdPiB3e+m5/e9QAfuKmTpmAIwdoeP3ecklKs5gsDp5jIZ/H7TPdeLCGphEmFeuoauDA/Q9axWdI/N01LtJr6UJjlPNDQwgMNLfwfxW+at4t8pv843x4bZMlYPsMr89McjjexnBdmp/ja8Dn8usMxHu3opVKSChlCcntTK36eUrw8MUy+5LAWAQhAAAKIB4J885a7qbEC+J1NJ1nOeD7Lh068gKsUfl/fe5CAlFRKsg5t0Ro6qmvxyzkOvxi7hO26VCogJY3BEH5516XcvF3koVd/xnQxj9/H2nfyYKKV9ZCs08GmdqKBIH7JQo7nxwYpuiU22oxd4P5f/SdnF5P47YrW8NSeg6yXZJ0sw+Bw2w4saeA3l8/xXyMXWbSLVEJRRvD/LmRSHHr53zmVmsOvzgryr3e+m4hpsV6S61Ad3Mbhti4MIfFL2wV+MjzAaCqJPoWf4Ne+d2WYgy/9mMFsGr+wYfKjg/fRE6nmephcp8ZwlHvbd/Di+CVKnscSx3N55coIl9Pz3N7YSiQQpBKXcxkefu3n/GhqjHIR0+K5A0e4py7B9TLZAE3hKEc6dvLi+DCFkoPfxGKKyUyaHTVx+uIJYoFtLEcpfsPTI+dZTlMwxHMH7+OOmno2gskGqQ+Fec/2Xl6eGGE2n8XPU4rB5CyDyVkaw1HuuqmDsBWgUnfVJvj+HffSGgqzUSQbqMoKcH9nD7c0NCOFYDnT2UVOTE1QiYCUHO29lRcOvYfWUJiNZLLBpBDsbWimI1bLyekrXMmkKJe2C+h6MNHK39x8J7uiNWwGk00SC27j3vYdzOaz9M9OM5FJoZRChyEEDzW28Xj3Hu6pa2QzmWyy+lCYd7V1kS85jKaSjKbmUSjKmVJyS6yWD7fu4MMtXbSGwtwIJjdIyLTYFU+wK57AVR7l/vudv0PEtLjRJG8DQ0jKRUyLt4Nki5NscZItTrLFSba4/wG5rKPEn6lO8wAAAABJRU5ErkJggg==",
        "universalLink": "https://wallet.airgap.it",
        "deepLink": "airgap-wallet://"
    },
    {
        "key": "nova_ios",
        "name": "Nova Wallet",
        "shortName": "Nova",
        "color": "",
        "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAU9UlEQVR4Ac3By+/2+WEe5Ov+PM87Jzvjc2LHdp3EbhpEGiRQQW0XXbCgO9YsYFNRhMSfgKD/ABIb2LFnwYplFkgsKoEqKkHTRDRt4kN9TDI+ezwzz/e+eX/v24kdJ6QVLYjryr/9C39zXog/YTNPZoaZmVlqZpuZqaqZmaqZqaqZqZqtpmpmlpmZYWZm5snMk5kn86/a/XZekyGYn8gw2zyZmiczNdPUNlMzU1VTM1Vzqak6pqmpY6q2mapZJmZmmGGeBPPSzL8q93telUSwjGGeG0aYmWG2mVpqZmqmaquqqamqujmqaqqqZipqqTmy2maZmamJmRnmzzLzL+P+7Lwmiz8WbJ5MvVTbPFlqapuppbqZamouWzXV1VJdVU3VpWqqaqbqpKq6YiqWmZmZYZj3zUQ8mfl/4n4/r8v8sWDz3NgwMzPM1NTM1NRSXU1VzaVqqbos1V2a6m6q5lJVdVTVUU3NRG0zVbPMzAzDEMxMxJN5Mv+i7s/yBpkn8dyQebINw2w1Y7XVzkxtVTVVl6mluktduppqLnWZqqpLU9ulqqrqqKqjmqojaqtlamZmYuYn5slEzJP557nfb68x4knYxJPZhqG6YbbaampmLlNNbZeq7bJUXeqyVHfpLk3VZS5Vdamqy9TlclRNXI6py3J0EzWz1MzMzBAzDDHEzJ/nfs5rgiyexJjnZhvG5mSsltlqaqvlstVUXbpyLl3Npbl0l+ZSl6nuoaouzWUu3U1VXKbq0h1L1VF1UhUzXUwtMzPMMDHDEC/N/Fnut9uriCDDiOc2MzaMzVbMVlNbTW2XrZrLVnOpy1R3WS51aS7dpe7qMpe6dNVcqo6HrurS1Fyq6lJzVF2S2I6Zqm2WmZlhYuZnzfzEPbdXPQmyMGyCbGwYm22orWyWmtouW0XZpbscVZeTy3apy3ZpLs2le+guU1cuc6lLdzRVl+5SN3Wpo2qqjqqmprJjqmpmZmaGYd43xEsz992eiXhhWNi8sMmwsclqJqttoraay1JZLZeststZzaUebqq5dJe51MOv/OXP6C7/6Ld+T3epy3J3ucylLnWpS1d1qUtVVV1qTqoucWw1s1QNU8MwETNDcN/9GcLCJsIwbLbJsNkqG8bKKpvtstVS20Vqq+0yl7O77XJc6lJ18vDv/vt/3dTv/8OvqUtd6uHsUrU8dJe6XC7Npau61KVu6jJVR1VTUxPZLBM1MzPzJBjuuz8jYaxEGNlkGNtkY7OVYWVlZXfZxcqKyi5bzWWr7bJdksvZZe5++dc+a+qeV9WlLttdc6lLd9c8dJeTS12aS3dpLt2lbqrqUlWXqqmTqepiZqmZmZkn9z57JuJJGhlGNkaGTjaMDqNlY2VlN1ZpUVZ2obLLVtvFLnNx5gu/8VnMK7c3PPqe7bJcuktd6lIPdalLPdSlLnVpLtcuVXWpS91M1aUqKqmZqaqZmZl7X3kmCyLFyDCy0TGysdGJ0bLJxkrLSsoqLnaTlZVekrLLVh/71Ad98EOve/KJT33CH3ztLXOZS13qMpd6qEtduoe6NJe61OXm4XKpS3dpqi7dUVWXqpq5xDFVM3Xvs1fEc4sUI0PHvJCOjY5ONs5YZWOVllZOWW03WlZWcsnKyi6/+Ms/73Y/nnz6lz/p21//oaW2S13m0ly2h7rUpR7q0l3qobnU3dlDU/VQl7pcLs2lu6mqyxxVVUdV3PfKM4bFhpGhYxg6NoqWTTZaOlkl5UxWWlnJxSa9ZDdWVtnl01/4BUk8+ewXPuW3/5evsstSZ5ft0l2WyzxUNQ/dpXmoS3eph5NLXZqH7lKXk4e6NNVdLpe6xOWoqqi7Z3dbvDAUQ9mwUWx01slGR0snSisdq7TSyrlJy7lZK6vsojef/vzHve/TX/iEk1fNJYrLXE4uc9nuukvdzaUu3UNzaR5uu9Tl2kPzUJezu7o0l8vD2aW5XLtMXS7H5b5X7jK2MJR5rmyjYaOjbKNl4xqbdLTSykorrbSSyiqprLKbpH7513/B+37l1z/FecVZ2UVqu1jNZS4nl+1Sl7rMpS71UJd6uOVy7aEux0NdLg8nd/VwuZw8VMWlu9y9crOFYaxh6GxsKDbrKOvoOKOVjY6rskpHK630cjZpnV6sXnv9+PSvfNj7Pv35j3j1A2949+13ZWWXrKyo9bJdlstxmUtd5lKXeqhLXY6Herjlcu3h5uHapXk4Hrq7y8NxaS73vHJjsWGhKBsbyjYrOuus6OisY+OqnMnKVelkletYJ6nm5uzy0U9/0Gtv3L3v1Tee+egvftjXf/877HJ2Z2WXrHbKLlN22S7NZbtU1cM81OV4qEs9HA91uXm4PBwPl4fjrh4uD/e8cqNYPFlRDGVDWVlnnRWdFS0d59DJxq1yVTo5N22dVq7ajk/+8kc8e+Xmfc9eufn5z33E1770Q3azlU12sTqrrY5aL1LZZbmc1VzqoS7HQ126h5OH7qF5OB6Oy817Lg/XbuLmnmfHRsZEyopiKCuKzsauUVb0WEdHR0crZ7TSOle1k3M5vfn8r3/Mz/rU5z/i7//dbzqdro7SGyurrLLKKSorLtuluxx326W5dA/N5eyhHi4Px8PxcLmL98RDvOfulchiiwxDUVYUQ1lHcWOdXayso6Oza/RIRydXNXVa6dHO577wYT/rs3/xo67bK5Y6SutkrLSyscrKKim7TJ1ctktzObvUpR6OS/NwPFx7TzwcD8fN8XDc3PPKYWEoFsY6aeisKBo6isZu7Jo11llxG9fo6OQcp9Prks1ZffaXPuhnfeHXP+p69syuWmcprWxOykrHKquspLKyy1LZZbmcXbqH5tJd4uG4Ox6uvCe7iYe4uZ9nsUXGFoqRhqKkbKTsil1so+zEOmsou1jGRidnek1OpPPmB+8+8pFX/KyPfeJ1H/joG77/7XfcWutInc1Wp3NS2WhZWSVlldVcprgkD8elu2QPzU08ZDdxkzxkN/c8OzIsNjosTqdFI51TWnImt9BYx0FjnRU3dsWu0UnGQY9z1b/5Vz7m537umZ/1wTef+Tf+6i/4n3/z69a5tdY6m9OSsbFKJqussrKhzi7bZavjbrvwkNxcu4v3JHfpXbyH4367xxZPtjBWttBZUVpOcQvXtKSRw0oau0YRnNg1O+i45hOfeNXf/g//gsSfkvAf/cd/0f/xW9/3R9942zqndevslM46a53MWdl0lVaMXbLKarvMJbmpO3vIbnhwDm7suP3lv/mf/p3cIuc4tzgnciKJnHBwIgcnJHbICScWchAkJJzYiSUcPvzmM3/jr3zE3/nPPu+zn3rN/52fe/OZf+evfcJb33l46zsP77zLciyHHDvHcsghhxxyk3NwyOEcyZHcyCE3ccghN0nIQchxP/fYgtjYyGGblJSUFsUZV7SjLNHOOfHqq/GJD73isx9/1V/6C2/4wi++7pc++ZqPvnn35gfuEv9cn/nM6/7z//Jf9/3vv+fbb73rn37pR770T37gd3/7e77xlR956+s/9nj74WxO67bZ6mSyysrKyi52yW7iLnuIm7Ob7WZu7uccL8XExjpb5Ewap3M10kk5Nz76gVf8wodf8ZmPveqzH3/Nr37mDZ/7xKtee/V45X78y0h4881n3nzzmc/90gf89b/xCU/ee7fefvvy1S/9yO/9zvd89fd/4Btf/KFvfvlHvvPNt+WqrLLKym7WCxe7ZEccdmRHHPfbLYiJYWUnNtI5h3Z+5ROv+at/6U2f+/irPv/JN3zwtZvbicT/Z569cjx75XjzNz7kX/uND3mycT3qh99/+P3f+Z6v/KPv+19/8+u++DvflZVcqO3BbrhJDzviuJ9bEMTGEk+26Yl1cuKcuJ04J+L/b2Ki57huN4/bM70/k5Xe2GU77LIdy2EHcb+dkNiC2JjnFhnLZPNP33rHf/93v6WdjQ9/4OYXPvSKT3/kFZ/+2Gs+/8nXfebjr3r92c2ze/y/4d336u236ytf+bHf/d0f+soX3/a1L7/tm19527e/9Y5cdTZpndszWeWUHXbosR3bsUXF/RzEczHPLYaNjB7S2Jl00mnnOz+8/NH3f+S3vvxDvarjfvjozz3zyQ+94jMfe83nfv51v/aZN3z8zWd+7vW7xL+Qje/98PKtt9712//4bb/3pbd96Ss/9o1vvOMPv/Wu935UZ5zOrXM253ZzcpzNaZ1NWlmlh904D9uxxRZb3M9B4skEsWF0ZLGwTjLJJJNMWr24cqRzdb7x7Xd97Y/e8ff+8fdcFysffO3m3/r8m/7Wv/eLPvPxV/15vvzNd/w3/8M3/L1/+APf/e6Di1MyTjmN8+xY2WbldE7ntmnn7Mg150x2yUrLwmKLlY57TojnIoKY50bGxkoT2SRzTrX0Oq5Mrmq4QtCQkEzLD955+J/+wVv+wZd+4L/+27/qMx9/1Z/ly996x3/yX/0T3/jDd6XhhkTHabSjrNFxOqeczbno5nTOJmfOJo20nMpiw2Kl434OEj9twhjWWCZjI2E7kkkmnYark6sarpKSi2aSSOatH7zrv/vNr/ov/oNfkfgTNv7b//FrvvW9d+WOjoWy0k4ainLKTmyzxm7sYpt2TqebNCyyUJSJlW3uOSRDzEvBFsHCFhsbEuskk0xSyZFrGtpJqyWhJZ0TWv73L37P999+ePONu5/2vR89/G//5PvOvdZYw1hH0djoRRYtp7SxsM1Cx1m0k05KFhaKYayzzf0cJJ4EQ8TmudjY2NgiZmGLpJIjmWRykUxCMzHNnMyVaudH716+/YP3vPnG3U/7g+++5wc/fs+5o6y0IyHhTIrEhoseUjLWWMnoSEk5O3QyjBXDZp17DvFcPBebFxKGjI0thoUt1okjmZO5MkmcVi+uTDK9qiE5mmnmq2+943M//7qf9n9+9YduN85oZiGHlRWNnUkxdrBQVjJWTiMjJWULq/Sw0WMbO9bjfoL4Y0nMEMFGFhvDxMZCE2ezjEwyC0nkqmaukE467VydL//B2/7ar33YT/vit9727D5X4xzaacOZFmVDMQxFQzFWWjKyULJJQ8cOGw072uOeE08SLwwR89xIYsPIYoeZNYSVBYmkmkMmIZ002mqn15zU733zx37WV//ox+530tloo501kllmO3ZGyVjIQTEsVox1UjZSNGwsttDQuOd4IUIwz03Egk0SGxtGFjsYC2vENEcyySyRVDLn0GuuTMq3vveu9655dosn7z3mD7//rvs90lmjmZ5Yp1f0sNUWKys5Y7GGoQiGwzrGhpJirOHEGvdzgnhfwoT500LGhnHGFsOCsUQyzeSQzhrJpNXGt390+fG79ez1mydvv3f5zg8f7vc4jZWrtOzQMy1btLMza6xhszNr5KBsGIpOxs6sKDtjaNyTkCD+2BCCDUPIWFAkMrZZWCNjoSGhPZJpJqnkSKadr3/nHT/3+huefO2td1zjfj/aaUlpaSeH02jnnGjZmZWNjRUbDcVwsNlQFB1jHZn7OSFemCAyNi8kbBiC4ZCxkEVHzBYdB0sk004yTeRMWut88Q/e8aufesOTL37rx+734+qcTA9ttbR0rLTRcg4rO9PGxs4oO6wYyozOgtQOioNyzwmJl8IQstgY4rlgCIaNxZMTJoyzmdhYSOhIYpskmvrGd9/zvq9/5123+02uWqab5mjomXUaemhnY2WjnTY2nGlnBwtjnZ5xTc5ss46Ncs8JCSJDvLBhEWxkLGQMCxkbhoORRZHNFg2nMbMhJMc3v/uezQvf/O7D/XY00U4650w77SxzhbPZiW5WOk6nnY2VHFZmlJ3J6EEnm3VWlrmf20HMPzMvDcNI2MK8FDLmJ4JhOIctlBMWFrZIZ+YPf3i5Nk/+4AcP53Ykk8zJtHMyzTSTM2t0cxY9c0pDDjo9pOyw4czKNjmjs80666zczzmGiCfbGELG5qV6KZg/KWxkGEbG0EXMTmwMDd/7cf3onXryvR/X7XYsk8wyOdNOzqRzOg1n000WyyScsUPKOWyzzsYOKynCRoPMztxzIuJ9W2zEbGRsOGMYCRtGxsYwBMM8dzhjCxvzXJyx8uW33mWTRE4wJ7OMTjIrSS1zQjsx6Uwks80WJ9PNGjuss83CObRsk8zCxj3nIN6XMbNFxjYZGxvG5oVgQf35QhozPVgwX/v2uzZyO05nYWUJmXWW0WNmmSSySWaZMzZaFlIWNpbZWNhI2GhY2OZ+zjFP4oUNkY2xMj+xkI1hGA6GYRg2FobhoBzUcyf+/pd/ZOOEndgYNi8srCG1sMYyShZTW3TDbJHUOlt0sbHMSrBFMGxxT47EC/PcImYLG8FIo5uMed/8afMT8yccjDPW+ep33rWRQ8pED8ZBizNnx8wyLUdsM8c2KTlsbLHQTRodxlBhEzGxcc85xAsZwjaCjU02wxkbho2FjZHRsZGh/oQhntu8EC+NE3awOWXo4WCNmQaLE3am81woDmdsbMdaQQ8ZGxs5sUUSxRb3nJAINi9tslkinRm3UWwsMjbUCzPxUw46P22eixfiyYgXZjKEmXguCEMSzlgoB81I/MQEO9Fywso2O6ws0XJOaNyTSOKFYCSxzUtjwzA22WwoDjoE8xMjfsoY4ic2ixcylsmIJyMsc0YzL414IUEI6rn5YycMDeKlhM1JLLFwTw4n4p+ZlzY2DhZWOWxsKA7mpU3KRE08d1DPjSFjXpjnMvHcWMYQL22exCxkzMTMk0mQGTKE+SnjhIV6LhiCjHB3IgkinovnxiKbbWyyYxsdJme2aclhZYdtUi8NmQ2ZeC4zxGyemyfxZOaleDLDzJNgJuYnhhFsZJhtYmaexDAyNu+7JxEh8RPBSOgks42OU4Z64YRhZzJShAkZIxlmnstkM8TMk3lpnmR0bPPCPDeGzQsb89y8NIxhE7ONDRPDzMQwM3dPEkn8CcFwMMRLO3ScMi+NNIYczHMjyMzYmOeGYV6aFzY2xoaNsY5hY2xss2Fss84wY2PY2DDZbGWT1TY2VveIP5Z4XwTzZCHDQXHQg3JQckIxZJ4sIwTLvDQMM2Nj89JsY56bDRtjnY11NlYMGxvDZp2NbbYxtlpnKxutrazugiDxQiKezESCMREj9cJBY547pCEjCBsJwjbBlA1jwzDMOuvYbKyzzsY6G+us2GwY62xss7HONsY2Nt1obWO1jdZa/xfEQ9hyefLJWwAAAABJRU5ErkJggg==",
        "universalLink": "https://novawallet.io",
        "deepLink": "nova://"
    },
    {
        "key": "fearless_ios",
        "name": "Fearless Wallet",
        "shortName": "fearless",
        "color": "",
        "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAG4klEQVR4AeXBbW+dd2EH4Ot/+zYhTkp93EmktKvSUopo05KgQcfe0KmDoYmvMAYS0z7AXqBSTTxoU3nBSwRCIEBFaP0AvGFbpSJNLC5tHkpWCamK2i40sZbaThOfmJz4/1vNvej42CeJaZ6Ac13F/9vvyQN4gvI45vxxWsSzeOqIfz7sbcXb9nvys/gepk2GAb5wxL88XfZ78gDmMW2yDPBoS57AtMkzjSda8rjJ9XiDOZNrriUmWUtMspaYZI0J1xKTrCUmWUtMspa4moIYr+jEeAWxVUF0CmKrghivIMYrCIqhGK8tYrOgGFV0gmK8YryCGCo6xVAxFEPF5RXbV4zXEpsVl1eMV1xZsX3FtSu2pyUmWUtMspaYZC1xq9xvj3WvOOVWaYlb4UF3+SuPIP7DlJedcCu0xM22z90+6WHFuuKv7dOIY0642Vqqm+kR9/iUfYp1ccmn7dPgJa+7mVpi3d3mfNKDzjhvWd+yvjPOW9Z3xnkXrRlVEFdXdGK/e3zaQzqx2d94SCOOeN14BbEdrSm322nWjNvtNGvGrBm32+nfveyERetaguK0tzTiQe+1WcQ5v7Gsb0nfsvOW9S3rW9J3zm9EUHSCohNEUTzmA1rr4nIe8wFHvS7GiU4UxW479MyYNWPWjFk79cyYNWO3HYpis5POOO0txLqWIFZd8GMH/a2PucuszXp26NnhXj2bDaw547wlfcv6lvQtOW9J37K+VRdFPGPeZz1qxruM03fBM+ZFte7dWrNm9Mzo2alnRs+MWTNut9O0KVcWG/3ash973qqBS1riklUX/Mi8z/mYu83arlZjp1322GWr6Bt4wev+za887aDPe9Qu77LRigueNu+Ut3zKB/2Ze8yYRnF5sV3/Y9mPPG/VwEZTdzrwFRtctOaYN9xvTs8OjWhEIxrRiEY0ohGNaEQjGtGIRjSiEQ12aNyr591ah5wwY8r79TSiEY34ueOOesNnfMgn3GeHRoNGNKIRjWhEIxrRiEY0ohGNaEQjGtGIRpyw5IfmrRrYrCU2WzXwffP+3kft1XO9/KW99nqPPzWrFRs97l4PmHOvHuJ6edWS7/uFVReN0xLjrBp4xhH/5DHX0wN6OrHRtOIBs4jr6V8dsWrgclqqcfbY7R99XKvqFOMFRSdGFUSnIDoF0SmITkFQEJ2CoCAoiE7RiVEFse6LPu4b/suCc8ZpiXH+14rjTvuIPTpxeTFeDMVQDMVQdGIoOtGJoRgvLjnutNNWEOO0RWwUFKxZ812H/IMDPmqPP0S/cMp3HVZFsVXQEhsVnYI18R2HNPb7c3tQdGJU0YlRBTFUbBWdohNXVxCdgugUBMVBJ33HEWvicgpa4krWxLcd1viwv3Cn8WK8GBWXF9sXQzEU637uDd921Jq4mpbqatbwTYdVF33CXRrF76MqfubXvuWXqtiOltiOKr7pqB942Yf0POwO+8y5z3tMKa6noLi6NXHcW45ZdMybXrZkxcDvoiV+FysueMGCFyxYt8u0h/Q8bM4j7nCf20wptqcgtmtNHHfWS970S4v+25IVA9eiJa7Figuet+B5C9btMm2fng+b84g73O82jWK8uJIqXnHWS9501KJjlqwYuJ5a4npaccG8BfMWrNtt2j49+835iD9xv9tcySvOOuS0IxYds+ScgRupJW6kcy44aMFBCwq+6oDH7DHOc075ssPi5mmJmyX4uqPeb5e9dtvoVed83VERN1NDEARBEARBEARBEARBEARBEARBEATRd9GXvGjVwJSYEqsGvuRFfRcRBEEQBEEQBEEQBEEQBEEQBEEQBEE0VFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFSvOetrjiAivuyw15xFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRdUSFJ24WX7mlCcdEvynBbdK67fiVnjWSbdaSzXJWmKStcQ7VRB/2FrinYrxCuL6KIgbo6AtYl1QjAqKoaAYik5BUGxVEJ2CoOgEBUExFBRDBUHRiaGCoBgKCmKoIIaKTkusK7YqRhWjiqFiVDFUDBVDRacYVRAU4xWjilFFpyAoOsVWLfH7qBhVvDPFlTUmXEt1YxTEUEFsVRBDBdEpiO0piE5BUBBbFcS6xg0To2K8GBVDsX0xFJ0YLy5piUnWENcuOjFedGK8GBWj4kZpCeLaRSfGi06MF6NiVNwIDRZNrsWGPEsQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQ5NkGT2Fg8gzw1NRJr556n72v4TOYMhkG+MKLnvvplLed9OrR99n7E8yRO7HTH6dF/ITydy967qfe9n9NX/xavjIY5gAAAABJRU5ErkJggg==",
        "universalLink": "https://fearlesswallet.io",
        "deepLink": "fearless://"
    }
];

},{}],37:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TezosBlockchain = void 0;
var wallet_lists_1 = require("./ui/alert/wallet-lists");
var TezosBlockchain = /** @class */ (function () {
    function TezosBlockchain() {
        this.identifier = 'xtz';
    }
    TezosBlockchain.prototype.validateRequest = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // TODO: Validation
                if (input) {
                    return [2 /*return*/];
                }
                return [2 /*return*/];
            });
        });
    };
    TezosBlockchain.prototype.handleResponse = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // TODO: Validation
                if (input) {
                    return [2 /*return*/];
                }
                return [2 /*return*/];
            });
        });
    };
    TezosBlockchain.prototype.getWalletLists = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, {
                        extensionList: wallet_lists_1.extensionList,
                        desktopList: wallet_lists_1.desktopList,
                        webList: wallet_lists_1.webList,
                        iOSList: wallet_lists_1.iOSList
                    }];
            });
        });
    };
    TezosBlockchain.prototype.getAccountInfosFromPermissionResponse = function (_permissionResponse) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, [{ accountId: '', address: '', publicKey: '' }]];
            });
        });
    };
    return TezosBlockchain;
}());
exports.TezosBlockchain = TezosBlockchain;

},{"./ui/alert/wallet-lists":39}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TezosBlockchain = void 0;
var blockchain_1 = require("./blockchain");
Object.defineProperty(exports, "TezosBlockchain", { enumerable: true, get: function () { return blockchain_1.TezosBlockchain; } });

},{"./blockchain":37}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.iOSList = exports.webList = exports.desktopList = exports.extensionList = void 0;
exports.extensionList = [
    {
        "key": "spire_chrome",
        "id": "gpfndedineagiepkpinficbcbbgjoenn",
        "name": "Spire",
        "shortName": "Spire",
        "color": "",
        "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAIIElEQVR4Ae3Ba5BeZWEA4Oc9u9kkJGHZkIQkLhQziQmVBpJwOTDg7saKEIQwnYq2/WWnUjuxHTOOgbYq77ZqSVGrtZliae2P/gE74zQIodoZEmwrR6pQlTYJ0DWNuWAChBBIyN7exsGZL2e/3Xy3Xf3RPI+zzvr/LfgFyGMKCMPHX/JT7eec75RUxJD8nAVTKI/JKe1YjquxEsuwCHOPH/phm9ER5yy8fAQv4yCeww/wHezGcBGDqRJMgTymaejD+3AjFhvHC09+SRodtijfaAIH8CgexI4ihiGTLJhEeUzn4Q58CG9Vw7MP/po0OmL5b2xVhx/hPny5iOGoSRJMgjymmfgwNmGeOowOnfD0F5eQRq36yIBs2ix1OoR7saWI4YQWBS3IYwrowxasMLGEo3gK/4UfDXz9d+ce+t79HydZsPp3PrPk1vtfxBK8HatxLoKJ7cQGbC9i0KygSXlM0/EpbESbagl78QAewneLGAZVbMTnvWkT7vUzeUwduBK34b24CEG1YXwOdxcxnNSEoAl5TAvwAPpUS3gS9+CRIoYh43sYN3vTNtxsHHlMHViHu3AVgmqP4f1FDIc1KGhQHtMSPIIVqu3GXXioiGHUxGZhAAu86UUswTETyGPKsB6bsUy1nXhPEcOABgQNyGNagn/BEmXD+BI+WcTwmtquxJPKrsUTashjmo0/we+jXdkA3lXEMKBOQZ3ymBbgcaxQdgQfKGLYqn6bsFnZH+HP1CmP6TZ8BV3KdqKniOGwOrSpQx7TdGzFFcr24sYihsc15hNYqmwU/6BO+3b07+rujd/EOnSqmI813b3xwX07+kfUkKkhjyngU+hVthfvLmL4vsbMwRrVrkCnBhQxPI0b8GNla9Gfx6SWTG192KjsCG4tYtilcZdinmpdWKlBRQy7sB5HlH0UfWrInEEe00xsQZuKYXygiOH7mvOrJtarCUUMT+O3MayiHVvymGY6g8yZfRgrlP1lEcNWzesxsT5NKmL4J2xRdgk2OIPMBPKYunCnst24W/POxWoTW43zNO8TeF7Zx/KYOk0gM7EP4nwVCXcVMbymeavQZWKdWKVJRQzHsAlJxQLcYQKZceQxTcPvKfs2HtKatWrr1ZqteFLZh/KY2o0jM761uFhFwr1FDKNa06O2Pi0oYhjFPUgqlqDXODJj5DE55XZl/4ttWtOFy9V2OeZqzTbsVXa7cWSqteNGZQ8UMQxpzRXoVNscrNGCIoZB/KOydXlMbcbIVFuOxSoSvq51PerXo3VbkVS8BcuNkal2jbKj+K7WBPSq31oErfkPvKrsamNkql2q7HtFDINaMxeXqd9KnK8FRQwn8bSylcbIVFum7L+17irMVr9ZuFLrnlG21BiZ0+QxBSxWNqB1PRrXq3V7lC3OYwpOkykL6FJ2WGsCejVuLYLWHFI2F8FpMtVmKntda+Zjpca9HfO1ZlBZZozM1LsaMzVuJq42xTLVTiibpTU9mterNR3KRo2RKUs4omy+5mVYq3l9yDRvgbKXkZwmc5oihoQDypZo3gW4RPMuwQWad7GyA0UMyWky1Z5T9sual2OG5s1ArnmXKnveGJlqzyhbk8fUoTl9WterCXlM07FK2Q+Mkan2hLJOXKFxbejVuj60adyVOFfZd4yRqbYbB1QE3KJxC7Fc65ZjocatR1CxH7uNkak2jH9W9v48pmkacy06tK4D12pAHlMH3qtsWxHDiDEyYxQxOOWryn4J6zTmnSZPn8bcjIuUfdU4MuN7DHtUBHwsjylTnzZcb/L0oE0d8pgy3ImgYgA7jCMzjiKGIfy1smtxq/osxttMnrdhsfqsx1XK7itiGDaOzMTux0sqAu7JY5qttneg3eRpx3VqyGOagz9HUHEIf2MCmQkUMRzBZmXL0a+2PpNvrdr+FEuV3VvEcNQEMmf2V9il7A/ymNabWDuuM/muR7sJ5DHdhg3KdmKLM8icQRHDCWzAiIp2/H0e02XGdyGWmnxL0W0ceUyr8BW0qxjGhiKGE84gU9t2/IWyLjyUx7RCtR60mXxtuM4YeUwrsBVdyj6H7WrI1FDEkPBxbFd2Eb6Rx3SZsl5T551Ok8e0Ct/Ehcoew91FDGppU4d9O/pHunvjo7gF81R04n3dvXH3vh39uzANmzHX1JiN+zCax3QbvoYLlO3Ee4oYXlWHNnXat6P/9e7e+ChuQZeKmfj17t7YdeTZh38ydOzgnQimxnmzFq/52pqPHrgTn8UsZQO4qYhhvzq1acC+Hf1Hunvjw3g35qnIcI00+puvPPvIDFMnXNjX/1uzFq3pQaZsJ24qYhjQgEyDihgG0IPtxji299/mmGKv7nl8jmqPoaeIYUCDMk0oYjiEm/BZjDgljQw6tvffTbVjP/62NDLoZ4axGeuKGA5rQqZJRQwnsQk3YNcbL/+Pk6/sMdVOvrLHyVf2OGUnbsBdRQwnNSmYBHlMM/d/69Mb9//rZzaNDh3vNIWy9hlHu3s+uXnx9X/4hSKGE1oUTKKLb/ri/ENP/d2GwVf33zF84qVFJlH7jK4XOjq7vyylLccPPXPYJAmmwII1H+x44+Xn140Onbj9jRd33zj8xpEuTWibcd6R6Z0XfaN9ZteDM+Yu23boqb8dNMmCKfSWd/yx0eGT04ZeO3j56wefytPwyV8ZOv7israO2RekkcFFieCUQAptHQdHBl/7ybRz5j0X2qf/cNai1cW02Qv/M2ufMbT/W582VYJfgEXXfCQMHXshS2nET4XQZtqchaMHn/hCctZZZ/08/R8wPGmSSU1PIgAAAABJRU5ErkJggg==",
        "link": "https://spirewallet.com/"
    },
    {
        "key": "temple_chrome",
        "id": "ookjlbkiijinhpmnjffcofjonbfbgaoc",
        "name": "Temple Wallet",
        "shortName": "Temple",
        "color": "",
        "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAGbElEQVR4Ae3B32/ddR3H8efr/f1+z2m7dT1n3Vp+De22EsxmxARvCNDGhBvDj3/AaxdMJEpIUAOJxl8IXJnFGyNX3i3BiEG9ELIqZNSLmRBYYD+7CS3tuv5Y23N6es7n87Zd2uULxAXDt2cmnseDjo6Ojo6Ojo6Ojo7/S6Jgje/sGdTdu1+2ewZvwwQSMsAEJjCBBCYwwAQSMoEJDDCBBCYwgQmJN3XLH79JwUSBGt/dO4jzmqrlQ/bQEJhAQgaYwAQmkMAEBphAQiYwgQEmkMAEJjAhsYxU1eArLQpkFKTx5MAg0mskOuTLTVgLFErsBO6lYEZRTN8i0SESgQmfq1M4MUrBUoqS6E2xTgIBc6twWy8bfLkJszWukfgUgZMj1okN6iujQ3vYNAI8R4FSCiLTCaQGoozA51cRmxotwvFLEBxChOAQHYJDiHhwCA7RIUQIDsEBRweqZF/qBxPr7vfLj6Xa+4cWBUkpSOkXU/W1Z28fRzwIgloTmgFKKezuJnn4IAiQQIDENQIkJECsEwgQ+L+WCK9fxCeX0Z29rNsJ3Au8RUFSipTYGOJBNkj4QgMNpEjAQA+YwAQSmMAAE0jIBCYwwAQS2ttD+NM5/PQc3NnLNWIUeIuCGEVKdJxEkBgkgoUGn8uuMvSWiKeukDNCgYwiJTpBYg0SQSL8aoP/RnhtApyPSY98leTRg+Tc71ceSymIUaDSDy/WSTROIkgMVlvQinwW8Z3LhGPv49Mr5OmWHejOXeTsBN1LQYyimY0pMZQIJYKlBp+FBnaAwE/P8xmMUpCUginVceBZJAiR8Oo5MKHUIDVIDUoJ9pUBdFeVLRroQdUu4pk5bHQfG/zSVcKJD1EpgVICpQSVzCmnH1CQlKKZTiA1CLEcT07jy2uQJZAaZAalBB2s4HN1RJU83bUbPzMPDgioduFTy1BOoZxAOXVKdiR78tzvKIhRsOyJM3VCHI/jU/jCKh9jQkN9qDuDpTVYDeTZcBVfWsOnV9ig3hKqdLHJcT+SPXnuNxQoZRuEv33wbVbW9pEZeTZcfZSe7HFCxB18ro56etmi4d0g8LPz6NadbEge+uJL4ZWzx3DmSj+Y+AcFS9kGXS+vvgu8C5G8tRcH52jFx3Fng8/W0R29bNFAD6p0Ec8sYA/sY4P27aqUfj75F7aJ0U7BTxLiVYJDK+IzK3yShqv4uXlyRuLkw8Y2Mdqo9PSFFi1/g1aE4LDYgFqLPBuu4str+MwKm/qBw2wTo91CHCM4tCK0HJ9ZIU8HqyDhZxfIGWWbGO3WiscJEYJDiPjUCnna240qZeK5eXJG2CZGu0U/SStepRUhOD65xCfpYBU/v8B10oh/9IixDYw2K/1ssuXB3/AQ8VbE51dhpUmeHajgy018psamfuAw28C4GVpxjOAQIgTHJ5fI04EqkvDzC+SMsg1SbgL1ZL32tVtAYoN2d5OnPd2oUsbPL8B9t7NpBPgVBTParPG9vU95rfmMbutFBypouAr93XyMQPsrxAsL5Iz49KNGwYw2ajw1+BSpvUBm+EyNG9GBCiw38cs1rhH9wGEKZrTJ2vdv/bIye0FZgjLDZ2vciPZXQODnF7hOjFIwo11SO02W1MkMsgTmV7kR9XejvjJ+YZGcEQpmtEnppx82yOwEpQQyw+stWAvciPZXiBOL4GwZ8cuPGQVKaadSMob4OhJEJ/z+DHSlKDPoLZE8cAd0p2zRUAXeuQyzNRjsYV0/cBh4m4IYbaTMjitLkMBPzRLfu4KfmiVOLEK9hV+pk6ehPpCIE4vkjFIgo51SGwfq8Z/T+GKDa7pTbKgP3PGZGnnq70Z9ZfzCIteJEQqU0EY/+fNceOb2cNpn66+T6FUSe9UO7XkQKBMc1gI2XAUJJJDwj1bwS4sk990BEkgDP3r67hd//Pz7TgFS2qz80uIxctbu4RFC/Abu+HyAWgt2ZmzRUB/x1Cx+pY729rCuH3QYeJsCGDdbM4zRjNCM0Az41DJ5+kIfSPjEIjmjFCTlZmvG47iDA9EJf72ITk5DapAIMoNEhPEpfLoGBkg9FCTlZmvFkx79Ku67fHIZ5huQGaSGMoMdGSTCP1omzNbAdBT4JQUxbrLSc1MtmuENv7QEM3U+pRGgGdl0FHiifPSKU5CU/wE+ufI8l2t/JzH+I2eW6L8t/3rO6ejo6Ojo6Ojo6Ojo+Jz+DTK0Yr9D+W0JAAAAAElFTkSuQmCC",
        "link": "https://templewallet.com/"
    }
];
exports.desktopList = [
    {
        "key": "infinity_wallet",
        "name": "Infinity Wallet",
        "shortName": "Infinity Wallet",
        "color": "rgb(52, 147, 218)",
        "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAANkUlEQVR4AeXBf5DfdZ0f8Mfr/fl+d5NsdvODIBBJgkIi/iJwAkHUO+/wR394P7wbZ27sdari+Ud7106n7T/tzP5va2c602nnxrmj1Ws7vd5YqjhOiygWT9FDJeGHEqVAAgiEsEKy2c3ufr+fZ2NGcsAJJIF/zn08ynNs23Vd4ZfxMfwytqLzN9sYj+E2/Cd87eEffiV+pvzMtl3XnYM/wm+j+cXU4/P4xMM//MphJ3RO2LbrunNwM65D+cVVeCPet+Gc13/uyFMPLnTbdl3nhD/FdVaP87Frwzmv/x8N78YHrT6/iV9r+Bia1adwfcMvW73e1bDV6nVeQ7N6tWaVa1a5ZpVrVrlmlRtIvDrCeEzrnNSP6QZeFeMxrVHFeExrVHk1DOKVin7degu/8h7HL7vCeOMmEt3cYWu/d4d1f3GrWl52VqosXv0OC3uuNTrvAuk63dEjJu+719StN+ueOkyVV6Iu3PmrI3TORh/HL3+bZ/7e9fqJSRLPU6U7dtTGP/kPJh74EVVOSxhvOdfcJ/6J0XkX0Peep0qlN/2FPzf11Ztp5SyNu5nNr5tFc6bSW7zqHZ75+5+gmkpUqFChQiUymHD8yrebOPCA7vCTKC9ndO555v7pv9LPbFR9VKhQoUIlhOVL30o3MLH/+1Q5C+lmNl80i+ZMJI5fea1nPny9QoUKFSpUqFCh4oRy/Io9Jg4+oDt8iPKixueeZ+4P/6UMJ1WoaipUqFChQoXqY+XiNzAcmNh/L1XOULrpTRfNojld6S295Urz1/2O4cEnDA48YfD4nDa/KJNDhkMSgiCIE8rxK642PPig7qlDKC803nyOp3//X2hHlgx+fNjwoccMHnpcm1/Uz0zRGkEQBH2svH6XDIcm9t9DNWcg3czmHbNoTkd6S7v3mP/Ah9XK2ElVatxrRxZMHHhce/qIbJqmNRUqVKhQytLlewwPPqB76hDlr4zHjnz0Hxuft5XhgNZoTSXaT46a2H+QCTIzoxIVKlSoPkav28XEpIn77qaV05RuZvNFs2heTt9buuIaRz78CQYDGQ4YDhgMGAwYDrVjc2Zu/I/WfvOrlnbvYXINQRDESUtXXGPi4Qd1Tx2iyklV5n/9d+k6uo6JIa1J69Ro2fqvfNa6275kvGmL0dYdJARB0MfKRTtZs9bEfXfTmtOQbmbTjlk0LyWxdPkeR3/3E2o8dlLXGA6ZGMpwaDD3uOkbP00/VqMVa757u6W3XMWatSpUqFChwtLl1xg88qDu8BMkfmr5rVfKuhnlhCoZDrWVJTP//d9rx47Qmsl7vicbNhlv3aESFSpUqD5G2y+RNWtN7L+LKi8j3fSmHbNoXkx6y5dfY/5DH1fjsQoVKlTQmsGhR8185t8xHjlltGLNnd+y/KZfYnKdChUqVKjE8u49Bo88aOmKay1e+2vWfenPLV9+raqmlDZ/xIY//qR25CdOqTLx/TtlZpPx1h2qjwoVKlQfo+2XyJp1hj+8hyovId30xu2zaH6exPLuPeZ/5+P0IQiCOGnwyAEzf/JvWFnxQrWybHLvty2/6ZdkzRRBEARh+bKrjS7aqS0uWvvVm6y54zbdk4+bvPsO6z//X9TCvL+uTPxgr356o/HWHfQIgqCP0faLGUwa3n8PyotIN71pxyyaF0os797j2G9fr/qoUKFChcLwkQNmbvgUoxUvpkYrJvd928qll7NmSoUKFSpUqFCJNbd/WY1GBo89rHviUfrei6oycd8+Wb/ReOsO1UeFChXa0op+81ZZP2P4/+6lys+RbnrT9lk0z5VYvuwaC7/1MZWoUKFChQqDRw+Y/s+fYrTi5dRo2eRd37byhstZO6VChQoVKmidNd/4385IMdy/T9Zv1F+wQyUq1GisFo5rC8eNtl8iMxsN77+b8kLppjdun0VzSqxceoWFD/4+CUEQBKH78QHrP/Nv1WjF6arRiom7/9LKzstk7XqCIAhaZ/Jbt6jRyJkpw/379NMbjc/fwXisLS5pC0tqcYmuM7r4jTIYGj7wfZTnSIuIiIjo101b+PWPqr5XfVQf1Uf1UX0MHn3I+s98itGyiIiIiIiIiIiIiIgIi/Mm7turQvVRfVQf1Udp+rVTIiIiIiIiIiIiIiIiIlKsvemzJr97m7a4ohaW1MKSduw4VWo8tvz29xtt3ykiIiKiCYIgsbznPXRD+tCHPvShj+7HB0x99lOsrBAEQRAEQRAEQRBGF11q6R1/lxQpevShDz1ZN0MQBEEQBEEQBEEQJ5Q1X/ysie99XS0uaYtL6vgya9bQh/HY0js/wHhMEIQBcUo/Ntp5uRr3nq+0QwdN/em/Zjx2tgYP/sD0J/+hzJyj33COftMWmdms33guw6H25KOIs1Zl8qt/pvYs6s+/VNatpZoax0+NX3uJTEyq0YpnDTzXYChTG1Uff6XUM4dNffaT9L1XpEqtLKunHtOeeswpCelpnVesNRPf/oKVK4eW3vVuNe6d0jqZ2aTmDnnWIIlTEnov0Bvuf1DGI5RXReKkKqdUI/GqSIwuupBuQO85In0k8ayB5xqtaEeelpnNntUOPcXktJV3/p7hN/4biVdq+X2/J5NrtacPq6Nz6ukn1ZE57egcK8tUOWvpLX/g4/odl6o+nme0oh39iecaEKdU6e7fZ3T5uz2rzR2RiQnZcLHl915v4st/TOJsZc16o7e8k35s7IQqFFV+auLWPzO481bKmUss/+3rjXa9jXHvhbqD+1lepHWe1QRBnFCG3/myGo1UH21pRSVMTDAc6re9wdJv/AHVCIIgCIIgCIIgCEItLajlZdVH9VHjXo3HajQyuH+vwZ23OikIgiAIgiAIgiCx/P6PGu96mxr3qo/qo/qoPioMv3kT1REEoUVEREQ4Omd4y39VKbUyYmKC4ZDhkMFALnyD5d/4R9JKREREREREREREREREREYr2uKC6qP6qD6qj+ojW7brZ84RERERERERERERERERsfy+j+p3XanGveqj+qg+qo9KGd7+RfXYAyIiIiK69TMXzqI5pbQnH1aL87LtzSyvMDnJ5ASDjkSmt8j5r9f98Dskzkii33W1rJ0mCIKgm9Dvukp7YK86vuB0jd77Ef3Oq0hPEARxQtN952aD22+iygukWz/z2lk0z1WlPfGQOj4v297MxJDBQIUKlTCzRc6/WLv/DhKnL3LRZUxvUaFChQoVdEPZdZX24F61dMzLGb3nI/qdV6m+V6FChQpVzeC7NxvcfiNVfo40L6ZKu/c23R3/SwYTqqd6qqd6ahzZutPo7/wB1byUbH+z/tJrZf1mEjX/tArVUz3VUz3VUz2G64x+65/LhnO9qDC+7iNy8ZVq3Kue6qme6ilN992bdd+8kWpeTDc1vXUWzc9V6skD6tgzctFl9CEIgmD9OXLBxepHd5B4nsGE8W/+M/3u98q2N+vf+qvq6Sfohiwd191yg+zcQzWCIAi6oX7n1erBvRw/5vlifN1H5eK30YcgCOKEpu39svat/0k1LyHd1MxrZ9G8mCr15AE1/zQ7dqu+V6FChUpYfw7nX6Lu/0undAP93/pDtmxTiQqVyIVv1P2fP9Luv0MtHlUP7WPnNaqaChUqVKg2kJ171IN71dKCkxK59sNs302iUKhQoTRt3y3atz5H67yMdFPTW2fRvKRSTx5Q83Ns360SFSpUqIT1m+X8nepHt9M6rv4HTG2hj6qmqlSowYT6wW2sLPmpWpxXD+3jkj2qOhUqVKhQbcCua9RDe1l4ht0f5DWXqpWRGo0Y9ypRSlVTd92ifetztM5pSDc1vXUWzcupUocPMj/H9t0kBEEQTG3i4rdrEztUt4Zxr/ow7lG0xuJRdeeXUJ5Vx+fVQ/vk4j1U56QgCKqTS9+lzn2L6tep0YjRWK2MGI3VaKT6qHu/qt1xI61zmtKtm75gFs3pqOKpg+ronNq2W/VRoUKFCoZr5DXnMe7V4qJaXmbcqz4o9X9v4Nicv2ZpXh3cp15/tapOhQoVKlQws1E2bKCPWllRKyPSq8GQ+/+CfTfRmjOQbmr91lk0p6146mHm59h2GUEQBHFCsX5KNm+WDRuYmmLNJLfdwI/vQ/m5jh/j4F287kragBRBEATVmFonGzbIxk3MbOCBb3DnF6jmDKWbmr5gFs2ZqGLuEebn1IWXqUSFChUqVKhQSiV87dM8+n2qvKSleR6+W110pWoDFSpUqFChQoVC3XsL372Ras5Cuqn1F8yiOWPFTx7hJ4+prW9W1VSoUKFCpVg6Jl/7NI/vRzktS8c4uFdd8CY1MaUSFSpUqFDB3pvkri+hOUvpptafP4vmbB15nB99g36sJtZRA0YrcuQJ9t8m3/wMRw85Y8sL/OjrcuxpJtapbkjfy7GnOfA9+eZneORuqrwCqS3nXzFC5xULfU/rEPqe1nlV9GOqUUU/phpVXgXjgcSrphqJk6qReFVUc1JCNSclXg3NKjeQWM0GsboNiNVsIFa1AenRWZ36QXgM261Oh7q1615zJS6zOn2p4QbE6hPc0HArPm/1+SJu6RYXDlm77jVfwftxvtXhLnxo7vA9xzonLC4cWli77jWfwy68AeUXU/BFfGju8D2HnFCeY/OWtxSuw8fwLpyH5m+2HofwddyAW+YO3xM/8/8BSHXLEHo7BSYAAAAASUVORK5CYII=",
        "deepLink": "infinity://"
    },
    {
        "key": "galleon_desktop",
        "name": "Galleon",
        "shortName": "Galleon",
        "color": "",
        "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAN6ElEQVR4Ad3BC3SW9X3A8e/v/7yX3IAQCLdwhyCKGlARRBRorbdZaWu1lx27Xlydp+txW1vtXLs2nh0723o6e13VdhU7dahzFdGCchOEAAICohAScg/kfnnzXvI+z/P/7U0lPVlGIIE31O3zEYaZqoI2OerlTLfqzzJGJnmJ7rxAOJiFVZP0bTJkJKJOoEGUanGkFMdvhxGICMNNSDNVhY62IBnBpSpcD+5SVRagZINyRiIKUilGSnDZJMZ5lYycWhFhOAhpoloBfv6Vat0vqdXbUB1DOohYEXbiOE+JJJ/GjO0QEdJFOEdquyQRdz8WDsj9av1FDCeRTjHBXx1vbPnhpIJd9SJ3cK6Es6SqqI0tU899BOtfzvkkEhcn9KgY7yFxciOcA+EsWK87Dxv7kfr2TkD4UxFTK478tQRG/U5EOBvCEKgqfjK2QrR7FaqT+YAQE3wiltR7c0aMijFEDoOkWoF6oW/gJ54EcvkgUXtZKCC3fLf4W+uKH3yonSFwGAS11vG73V9i7TcBwweR6gTr+5/+bvHfbC5+8JF6BsnhDDQRDagXexrkc3zACeSgwU8X33//tuLvPVzNIDichlrfqO3+jar/Gf7vCKsjnywu/vbrxQ8+VM8ZOAxAVfGT7Q+j/j0MM5vsRpwAaRS2vr+y+MFvvVD84PfaOQ3DAGyy689F9RsMIzfSRndLA1UvPkW6CYy3rn0x2R3P4jQMp6Be9wVY95cMM7ezDT/RRe3a1cSO15B26hcFSD6qqgzE0I/aSMB6sadAszlPrO9R/uSPGQ5qvbvUi6xkAIZ+1NevonYh51nr/t207HmT4aC+9zP14yM4BUMf6sfHqe99hz+R8qd+hnoeaadaoL77gOpq+jOcpKokE7EHUB3FeeDFuvBiXfQVb6in9vfPMxzUevdGI9dNoh/DSWqTEwKOfJnzpOLZx/DicfqrfvEp3K5O0k41MyvD+bqq0pehl9/1V6hmch50lr1L/WsvcSpeLErVC79hOKj1v4StG0UfhhS10YBauYvzQK1P6eM/BFUGUv/6SySajpN2qiPVjvgsfRhS1Pc+jGoB50Ht2tVEq49xOup5VD73a4aD+v6dqkovo6rg2ds4DxJNJ6h6/jcMRuO214nVVZN2yiKiHZM5ydDUKCp6M+fB0V//CD/ZzWCoKlX/+STpp0aN3sRJhrwRc1AKGGZNJZtofXsnQ9G0YyPxEzWknWNWqCo9jNrkYlCGkxfrouzJnzBUqkrNmv8g3VTtYminhwEpYphVPPsYyfZWzkbD1nW4kQ7SS6fjB3JJMVh7AcOo8+gh6l9fw9myrsuJTWtJK1VRnzmkGIWpDBP1fUof/yGoci6Ob3wZVEknC1NJMaDjGSY1Lz9DtKaCcxVvqKf93X2kk7H+eFIMMJJhEG+oo+qFVaTL8U1rSSdfdQQpBtUQw+DoE49g3STp0rxrK148Sro4jgmRYgBLmjW88Xva3tlLOlk3SVPJJtJGxJJiEBMjjdxIO+VP/Zzh0LjtddLFT7oxUgxoK2lUvupnuF2dDIf29/aT7GglHZxQqJUUA1LHIFlrUQbWdmA3Ddte438TQAABBBAQ+hAGRZWW3dtIB1XqSQkI5phil3AG1lruL/457ZEY//T3dzE+P4/+wmPGMf87P+Z/EFKEPxAQThIwoRA9ir79I1BlMMKjx3LuBEHKSQlgvEP4nFYy6fL14l+wbssuetz02fv4yuc/zp133EAoGKCXk5FFtPYYg9Xd2kCPcN54BkVh5OyLOGdCVIKRSlICSOgtSDKQxuZ27v2HR9l76Ci9ovEE3//FM6x6fh1f/PTNfPKjy8jOyiQ0egxNJZtpKtnCcJj9hXsxwSBDYa3ltS17eOfdMv72nk9hjCFlHzLBJyUgSd2pjrioBuln85v7eOCfH6elrZNTOdHUykM/+S3/8thzXL98ITcsX8hVf/lNUEvTzq2k0+zP30vB9R9nMKxV9h8qY/2W3bz82nYaW9rpUd/QwsP/eA/BYHibiNAjQDQRkVGh7ar+Mk5qaGrl+z99hpc37GAwYt3d/Ne6bfxu3TYcY5hXOJWrE1nMz4iRDi9E80luOMYFFauZUjCO/DG55ORk4WDw1CcSidLY0k5VbQOHj1ax/1AZXfEE/b28sYSW9ghfu/v29ZwkpNhE+9+p+o80NrXx62de4ZkXXyfhuvQwIiiKtSACRgQFVJXTcUS5e0wr8zPjnItn23PZGMmhPxFSBFRRhkJa4k2HJ9ZVH3NJCZCy6ulnV+8+WPf998pqnDmzp3PNVQvooVZRAd9TMsLg++C6EAg6gI+Ig7VKIGA4VlVHWUUNyvt8FX7Zksfn89qYGkpyNkrcsTiXXc0NpIhQXllLWUUNiKBKijJUin2+rvqYy0kBepi5tT4n1o8ckXPTpq07sYAqgyICapUZUydx3bLFiCrGMRyrqqO0vIpfteQhDJ1y0pad/IEqs2ZM5vrlV4EqIhBLJDlaXkV9YzOO46CqnEnCDf4bfQgnTbtk5U3BUPIV0kGVGVMLuGDWNKwq8USCnXvfIel6pI0qmeEQhbOmM3H8GHzf8j5FRFCrBEMhPN9HfZduV/HV7nzj1R2LKys300s4KTD/MpnmjNsryHzOgghY35I/ZjSTC8YzJncUoVCIZLKb7KxsFl5xCQcOHKa5rR0siAHHOPjWJxwOknQ9GpvbqKiqIxKNImI4WyKCquK7HggEwyFCJkA4y3xiz8YXX6QPoY+pl3/01hDe7xgEVSU/L5eLLyok6Bh6iDE0t7RRU3eC5tZOPM8lEAzSQ1XpTwQEwfU8Ao7D+Pw8ZkwrYGRODmotCBw6coza442ICOfG7Kn0Wei9vVbpI0AfsUT1S8HgxI3iyIc4BccYFi6Yx6gR2YDQ3NLG9p37SHo+p+IEAqgqA1EFRXEcBwVONLVyoqmVXgJ87o5b6IrGiMYSHK2opryiBkQYIk3GE1/z3t2g9CP0M6Xo2gvDgex9QJgeqswtnMGMKZPwrWXX3ndoj3QhAoKgpKiipN81VxbR1NbJ4aMVqCqFM6cyZ8YURAxbS/bSGY0xGKr+qvLwlL9gx6/oT+jv9tuZVRa7LxDg4aWLFpCdmUEymcQ4BmsVARQLOCjvM6KoVUSEHj5wtKySmvoGEGGoFLhpxVW8d7SSqtrj9DU2L5eii+bQnXQZNSKbg++VU11/nIEI1HZ1ZRcdP/J8K6cgnMLd93zFXLH42nVHSyuv64onKK+qpbyiBjEGVeVMHCMUzpzOtMnjQZWE67HzrYMkkknOJOA4rLxxGZve3ENrewd9BRyHlTcu5/mXNyACqHLpRYVcueASXt24jboTTfTj+9Z+pGLfuk0MQBjAvKU35yei/i4xZjrnKBwKseSKS8nMCHO4rJJj1XWcSu7IHK67djFr1m2h23XpS4DbbrmONes20+169LrmyiKq6hoZm5dLwYSxbN25j/bOLnq4ycR9Eqn4QWVlJQMRTmPCrI9cnJMbeAMYTTqoMrdwJrOnFVBaUU3psWp6zZ09nakFE1i/pYT+FFh54wq2vLmTjkiMXpdfOpdorJvDZRX0EOCaxZeRGQ6xedvbj3eM9b5c+8oaTsfhNLrajjVOnFH4hu9zBxAmRQRUwXoWtRaL4DgGYRBEaG5tp7SimrGjc7l64Xyam9tZumgB8XiCHXsO0J8RuO3mFWx+8y06IlF6zb+oEAEOHi6nr6ra4zQ2Na1+4tEHvvjIfd9QzkAYhE996atXjcoZvTZgzGirihEwThAERC1J1wUMxoAxhtb2CAcOHSHpeigDK5iQzyf+7MOsWr2GjkiU/jJCIT56wzJe3bCNrlicXpfOLSQUNLx18Aj9+RL87fjM6BdKtm7wGARhkBbfcvvFTfWda0TMdE5DVckbNZKii+cQCgYQMZRVVFNWWYuI0CM7K4PlS66gsamV3fsPAUJ/UyaO4/KiC1mzfiu+tfS6/JILAGXPwVL6s+r+oK3KfrOtZaNlkIQhmHHhsnwysp52DNcxWKoUzpzKzOlTCAUcfN+SSCTZsmMPvlr6U4VrFy3A8z127DlIX1cvLKKto4t3S8vpJxpL2rtDGa3/Xrl7N0MhDFHBkmtNOJH5dSPmQSDMIMyYMomL5syksyvKm7vexqpyKuPGjmbpwgVs27WPxpY2eglw04eXcuhIOVW1x+lL0d3GDd159MBLRzgLwtm4/XYmVMcvzEqYn5qA+yFOIRQMsGRhEVkZGVTU1PFeaQWIcCrhYJAVS6+kIxJh++4DiPBHeaNGsGLpItZv3k4kGuOPNNDRnbTFMXPiJy0H9nicJeEc5M6YQzB/zq0jfa9YkPkoFM0rZNL4fJKux/bd+4l3dzOQjFCIa6+6DBQ273iLpOvxR6osvryIzIwQm7a/RR/xOP5j3SbwUPPuVxo5R0IaBJYslWmJSTd+8uZFX92xd//19Q1NDgNRZea0ycydPZ3uZJI3Svbheh59TRw3lsWXXULJ3gMcb2zhfVLneYEnWqIj/jWyIHmC554jHYR0Gnkr4yc0TM4MmDska9StjsoSgaAIzJs7m4IJ+QhCeVUtpeVVIEJf2VkZLF+ykKamVnbtP0RKXbdNvOIkEi90BXI2NB98zSPNhGGSPXEiubnTRnzuMx9bNH3yxCtWPbN2XkNL50zEFACjQTMBA7jhcCiy8sblDR0dsepX168/4pnAft/rLIn62aXthzcr/1/kXng15OQzadZCcifPkbyCQpORP5fr77qLd8rKgHmcb/8N3VaULP16cD8AAAAASUVORK5CYII=",
        "deepLink": "galleon://"
    },
    {
        "key": "umami_desktop",
        "name": "Umami",
        "shortName": "Umami",
        "color": "",
        "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAANSklEQVR4Ae3BC1RVZaLA8f+39z4HgQXiJBmgLWpEHRXFQhHMiJGsMTR5zJjL8Iosb2KOaRpZ4gulScXedWOIAequtGmC1mAjjSmWYyRpoGiTiEp6xgxWJ5QAOY/9XbhLW3DcoFQ+6/fjF7/4eRN0k5TSExgLhAD9AA+urCbgOFAB7BBCNNINgoskpQwBFgFxgDtXp2agAMgUQlRwEQQXIKXsCawHkgClsrKSwsJCSktLqampobGxESklV4IQAk9PTwIDAwkPDyc2Npbg4GBa6UAusFAIcYouCLogpRwIFAFBu3fvJjU1lZKSEtooioKfnx9eXl4IIbgSpJQ0NDTw1Vdfoes6baKioli7di2hoaG0OgRMFEIcpBOCTkgpBwIfSin7rFq1ivT0dHRdJyYmhuTkZKKiovD29uZqcPr0aUpKSsjJyWHTpk0oisKyZctYunQpQoivgTuFEFUYEBiQUvYEPpVSBs2aNYucnByCgoLIy8sjIiKCq9nHH3/MjBkzOHToEMnJyWRnZyOEOASMFEKcwoWCsfVA0KpVq8jJyWHMmDGUlZURERHB1S4iIoKysjLGjBlDTk4Oq1atolUQsB4DCi6klCFA0u7du0lPTycoKIhNmzbh4+PDtcLHx4dNmzYRFBREeno6u3fvplWSlDIEFxrnWwQoqamp6LpOXl4ePj4+uNKrPkP/9J/Ib2tR+g9Hvfe/kKe/wfF6BkhJByYz6p1xKIPDwHYGe/YS0HXOIxSUXwejjn8QVA2kxP7nJ8F2BkNCIHrdiDJyPMqA22jPx8eHvLw87rjjDlJTU9m2bZsCLAIepB2NdqSUnkBcZWUlJSUlTJw4kYiICDqwncH+0qM4PyrkHOfWtxCBQ1AG3Y785iv08u24cn6wEXP6X1EGhyF6B+DYsA4jzg/A+VEBpvkvIfrcjHbfTOx56ei7P6BTbz+POnYypj8+C+YenBMREUFMTAxFRUVUVlYSHBwcJ6X0FEI0cpZCR2MB98LCQtokJyfjyrE5D+dHhXQgdeyvPAYOO6Y5mQjPnpzHYcP+9Ezkfw6jTXkUbfJsOqP/+1Na5v8Wx9+zEH63YE57A/O6f6COmQSaCSPOHe9if3EBrpKTk2lTWFhIK3dgLO0odBRCq9LSUhRFISoqClfqyPFgMuNKHvsCx4ZMhG8A2py1GJGnrdhWPICsPY42Yzna7+fTqeZGHH9ZQcu8u3DueBfl18MwPZaFW045ptlrUEKjwcOL9pw73kWv+oz2oqKiUBSF0tJSzgqhHY2O+tGqpqYGPz8/vL296cBhR/jfinZ/Co6/PY8rR+HLKCGRqGMmIf/9KY5Nr+FK1lmwpcVjXvkW2rTHEb39sWcvAYcdI/I/h7GvT8Hxv39CvScRNTIe9d7pqPdOB92JtFSjWw4h6yxw2oowmWnP29sbPz8/jh49yln9aEejIw9aNTY24uXlhStHfjrq5Dlof5iP8+Mi5IkjdKDr2J+ZgzmzGC1pObrlEHrFh7iStcexPXE/piX5qPckIvoNwL4+BfnNV3RGfn0Mx+sZON74E8qAESghd6EMDkPcOgT15oF0xcvLi8bGRs7yoB0FA1JKhBC4kk3fYc9aDOYemOY9B4qKK/ltLfanZ4LDjjk1G+XWoRiR9XXYlsThLHkbZXAY5ue2ot5xPxckdfSDe3C8tR7b8j/QkjiElsQh2B4dj23lVPQDn+BKCIGUEiMK3aSX/RNnydsog0ai/f4RjOiHKrA/MwfcPDAt34DoNwBDtjPYn5+H/cUFCM2EadGrmNNeR/jdQnfIBiv6kUr08u04S/5Kdyj8APbsJciTNWhTHkUJHoMR565i7C8vRHj/CvOqvyECB9MZ59aNtDzyW/TPtqGE3o3bi9sx/fdTiBv86DYp6Q6FH6KpAXvmbHA6MC16FeHbFyPObW9hf2khwvtXuGUUoAwJpzOy9ji29GnYn5qBPPkl6oQk3LI+wTT/RZRBoVwqCj+QXr0X+6tPIHr2xrwkHzy8MOLcuhF7ZgqYe2BesRE1eipdcZa9T8u8KOzPzkVaqlHvSsD8dBFur+xEe/AJlEEjQdXonKA7NDqh6zrnUVTac27dgOgXhDY5BfPjr2FbnQh2G66cHxch67/G9HgOprnPoAy8HXt2GtjOYEh34vzwHZwfvoMyZDRq9FTUsN+hJcyDhHnQ3IheXYF+ZD/ScghZZ0HW10HjacTNA3Gl6zqd0ehEfX09rsSNfXHleH01orc/6h33Y1r4P9jXPQROB670z8uwLfodptQ/o949DeU3o7A/90f06r10RT/wCfqBT7CbUlGGjUEdEYUyZDTK4NEowWO4GPX19ZhMJoxodKK2tpa6ujp8fX05R42IwbEhE3Qn39N17M/NQ3h4oY6eAItexb4+BRx2XMk6C7YnJqM9+DjapNmY17yHY1M2jo3rofk7umRvQd+zDX3PNv6fmztKv4EI/1sRvv7Q0xfR60bUsZNpr66ujtraWgICAjCi0AkpJcXFxbQnAvqjTU7hPA4btqdnopeXoIbfh/nJfOjhgSGHDUfeKmxpsciTR9Hun43by/9CvXsaqBoXraUZvboC50cFON55CcdfliOPHsBVcXExUko6o9CFrKwsXGmJT6JNfQxMbnRga8H21Aycpf9AuS0K8+oChG8AndE/L6Nl/jgcbzyFcPfE9HAmbi99hBo9FUxmusXkhjb1MbTEJ3GVlZVFVzS6sHPnTgoKCoiLi+N7QqBNeRT13uno5R8iv/0akHzvzHe0UfoPx+3lf+Hc/QGy9hhISWf0w/tQhkYg/G7BNPcZtAefQN+1GdnUQNcEoteNKCPuQvTsjauCggJ27txJVzQuYPbs2dx2220EBgbSnujZG/WueLpk7oEaEUN3CR9f1Hum82PU1NQwe/ZsLkThAurq6oiOjqa6upprRXV1NdHR0dTV1XFOjx49MKJwEQ4fPszIkSPJzc1F13WuVrquk5uby6hRozh8+DDtBQQEYETjItXX1zNz5kzWrFlDUlIS48aNY8CAAXh5eSGE4EqQUtLQ0EBVVRVbt24lNzeXgwcPYuT222/HiEY3HTx4kMWLF3O5nDhxAqvVytChQ/kxYmJiMKLwMzBo0CAiIyMxovAzsHr1ahRFwYjCdW7KlCnEx8fz+eefY0ThOjZ69GhycnI4deoUKSkpGNG4Tt13331s2LABk8lEfHw8R44cwYjGdcbX15f09HQeeughmpqaiI+P5/3336d///4Y0bgO3HDDDYwePZrY2FgeeOABPD09qaioIDExkf3799Omb9++GNG4AqKjo0lJSSEkJAR3d3e60qdPH3x9fTlx4gRGPD098fb25pyqqioyMzPJzc3F4XBwTmhoKEY0LiMhBC+88AJz586lzZdffonVaqUrVquVzkgpsVgsWCwWysvL2bJlC7t27UJKiauJEydiROMyWrBgAXPnzmXPnj0kJSVRWVnJ5TB06FDGjh2LEY3LxN3dnbS0NE6ePMn48eOxWq1cLhkZGQghMKJwmYSFhdGrVy9yc3OxWq34+/uzb98+9u3bh7+/P5dKYmIikyZNYu/evRhRuEz69OlDm5qaGtpER0cTHBxMcHAw0dHRXAqRkZFkZWVhtVqZM2cORjQuE4vFQptBgwbRpqioiM2bN9OmqKiIn1pCQgL5+fkIIUhISODYsWMY0TAghOCnVlZWxsmTJ0lKSuLZZ5/l+PHjTJgwgZ9aQEAAGRkZTJ8+nYaGBhISEigpKaFfv34Y0eioiVaenp781Ox2O4sXLyYvL4/t27fz8MMPs2XLFpxOJz+GEIK+ffsSFhZGXFwccXFxuLm5sWvXLqZPn05VVRVtPDw8OKuJdjQ6Ok6rwMBAvvjiC35q+fn53HTTTWRkZLB582ZaWlpobm7mx/Dw8MBsNnPOvn37WLduHW+++Sa6rnNOYGAgZ1loR6OjClqFh4dTXFzMpbBmzRree+89Zs2axYgRI3B3d6crw4cPx+FwcODAAVxJKWlubsZisVBeXs6WLVvYu3cvRsLDwzmrgnY0OtoBNMfGxrovX76cS2X//v088sgjXIwTJ05gtVoZOXIkP0ZsbCytmoEdtKPQjhCiESgIDg4mKiqK60VkZCTDhg2j1btCiO9oR+F8mYC+du1aVFXlWqeqKmvXrqWVBDJxoeBCCFEB5IaGhrJs2TKudWlpaYwaNYpW+UKIz3ChYGwhcGjp0qUkJydzrUpKSmLZsmW0OgwswICCASHEKWCiEOLr7OxsVq5ciaqqXCtUVWX58uW89tprKIpSC8QIIeoxoNKJlStXfrNixYoiIcQ9kZGRN0yYMIHq6mpqamq4nBYuXEhzczOvvPIKFyMyMpKNGzcybdo0hBCHgfFCiC/ohOACpJQ9gfVAEqBUVlZSWFhIaWkpR48epampCSkll8qePXuor69n3LhxuBJC4OHhQWBgIOHh4cTGxjJs2DBaSSAfWCCEqKcLgoskpRwBLAJiAXeuTs3Au0CmEOIzLoKgm6SUnsCdwHCgH+DBldUEWIAKYIcQ4jt+8YtfXKz/A/OhBgM5KLZoAAAAAElFTkSuQmCC",
        "deepLink": "umami://"
    },
    {
        "key": "atomex_desktop",
        "name": "Atomex Wallet",
        "shortName": "Atomex",
        "color": "",
        "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAE6UlEQVR4AeXBe0xVdQDA8e/53XNFQFJ5e0NAAUXeMQHJByo+cM6Z+WrO0h66uelEatl0U9egnDa1rczN1eq/Mg39I8WQphYOo4z54K0Cgl6eQy6IXO49J/2DZk3k4r0c2c7nI6mPoGMCnRPonEDnBDon0DmBzgl0TqBzAp0T6JxA5wQ6J9A5gc7JvCD1ZgslpWasNoXJE7yJjvDjRZDRWGt7NzsPnCfv4k1UlX/FTPJj//Z0osJ90ZJAQ5YuK6u35nLmwk1Ulf+4XtnMii0nuFHVgpYEGjr4zWWqatroT9eDXj7cV4CqohmBRux2lR/zyhnI9cpmSqub0YpAI+aWTjo6e3BE5e02tCLQiFEWOMpoNKAVgUb8fTwJCvRiIJIkkTAlAK0INPTeqgQGsmhWGEGBXmhFoKF1y+JYPCec/kSEepOTlYaWZDQkhMQXuxaSHGvi6LES6s0dPDbay40VGVPY9nYyXp4j0JKMhn46W46/jyfrl8exbnkcza0PsNnsBPiOwmCQeBEEGjl/uZb39xZQeKWexyTA38cDU4AXBoPEr0U1HPr2D7Qm0ECD2UJmdj7R4b5krk/iacpvtvL5d8XUmzvQkmCIWXvtbNqdh6KqfPXxItxGyDzN6wsikSSJY2fK0JJgiOUcLuRqRRMHd85n/LiX6E+gnydpycEcP1OOoqhoReBCPVY795o66bHa6GNXVLZvnEZ6aigDWb04ioZGC7/9eQetyLhA3d37fHLkEgWXarD22jHKgtkpIezYNJ3sbWk4Kj01FN+xHuT+UkFacjBakHFSxa1WVm3Npb3jIX16bQr5hbcpKmng+0PLiJnkhyOMsmDf9rnIBoFWBE5QVcj69BztHQ95GkuXlczsfBRFxVHpqaGkJQfTR1FUhpKME65VNHG9splnqapto/jaPVLiTTjC2mvnh59Lyc2vpLSqmZ5eOwE+nsxMGs+7KxOInOiDK8k4oaq2DUdU17aREm9iIHV377Nh52nKb7XypHvNnRw7XcaJsxVkvZPM5rVTcRUZJ3i4G3GEx0gjF4vrOHWukplTg5mVNB7vMe48qbW9mzcyT9LQaKE/drvC/qNFGIRg05pEXEHGCUmxJoyyoNem0B+DkEhJMHG1vImLxXc4nleOEBLxkf7MTglhydwIwoLHknO4kIZGC4747OsiFsyYQFjwWJxl2PMIz8nD3UhHl5UrN8z0Z+3SWJbOm0R4iDcbViUwf8ZETH6jqLvbwclzVZRVtzBnWggf7C1AUVUcoSgqSBJzpoXgLBknfbQxlbb2bk6cLef/lsyNYNfmGfSRJImYCD9iIvzY/OZU7lt6UBSVS3/XY7MrDEbhX/W4goyTZFlwYMc8Vi+O4vSFaszNXfj7eJAxK4zpiUE8y2gvNx5rbOlisBpbOnEFGRdJiTeREm/ieXi4GxksT3cjriAYBmIn+zNYsZP9cQXBMBAV7suUMF8GY3lGJK4gGAYkYPeWmQgh4YhXE4PImDkRVxAME6mvvExO1mwMBolniY7w48s9C5EkCVeQGUbWLIkmIsSb7MO/U1LWyJM8PYy89VosW9cl4z5SxlVkhpmkuHGcOrKSmvp2blS10N1jY5z/KBKjA3F3k3E1mWEqNGgMoUFjGGoCnRPonEDnBDon0DmBzgl0TqBzAp0T6JxA5wQ6J9A5gc79A200jdqC2KUJAAAAAElFTkSuQmCC",
        "deepLink": "atomex://"
    }
];
exports.webList = [
    {
        "key": "kukai_web",
        "name": "Kukai Wallet",
        "shortName": "Kukai",
        "color": "",
        "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAHNklEQVR4Ae3BbWyUhQEA4Ofevg0f7d0RsAllEJSpQVy1K3SQIQro2HRoVIymS/Zj6w8xfk6NWzRzoJkO48d0MUaTZv6yMRFNxM2EIX4wIthSUJERgrCmjHZWCXdXapsWbgk/iLbvlXuPsgHjeZx11ln/1xJiaGjMV+NazMU0lDs1DKADm7GmuSnRqUgJRWhozF+AR7EMoVPbIFbjoeamxOeOI+E4Ghrzy/EMxjq99OGe5qbEi0ZQZgQNjfk/4HGETj8hltbUrRi3fevKdQooU0BDY345Hnf6u6ymbkXX9q0rt4gQiNDQmL8Azzhz/LGhMf9dEQLRHsVYZ46x+L0IgSEaGvPVWObMs6yhMV9tiNBw1yJ0EiQSVJ1D9WQmTmDsGEf19XPgIJ1ddH9JPu9kCHEtXvINoeHmGkXl5cyppb6Oiy8iWWlE2Rw7dtLSRus2BgaMprl4yTeEhptmFIwfz9VXsWQxyUpFSyWZV8+8enI9rF3P2+vo7TUaphkiNFy5IowZwyWzSCbZ287edsdcMZ+Gm0glnZBkJcuu40eLeOU1PtjomPOmM+Ncsjk+/Yy+fsUoN0SoBOfP4L7bSacds6mFtev56Y+ZXWtUpZIs/wX13+cva/nJlfxgtmMyGZ56nt17xBaKacwY7ruddNq3zKtnXr2TanYts2sNk05z3+3c8yD9/WIJxXTJLNJpJ+RQL51dZHOOSiWpnkzFeCVLp7lkFi1bxRKKadw4Jen+inc30NrGvv0iTZ3CnDoWLaBqktjGjRNbKKb2DrH0HOLV13lvA4ePGNG+/ezbz5q/snABt9xIZYWitXeILRBTewd/36QoO3fxwMO88z6Hjyja4SO88z4PPMzOXYqycTPtHWILlODFP/PxdiPa8jGPPc3BjJIdzPDY02z52Ii2fcoLTUoSKMHhw3T8S0E7d/HsCwwOOmGDgzz7Ajt3KWjffo4cUZJACcrLWThfpJ5DPPcig4NGzeAgz71IzyGRLv8h5eVKEijBnFoqK0V69XUOZhQlnSKVVJSDGV59XaRUkjm1ShIqQX2dSN1f8d4GI0qnuGEp8+pJJR2VzbGphTfeIpNV0HsbuO4aqiYZpr6OD1vEFogpkeB7s0R6dwOHjyjo/BmsWsmSxaSSjkklWbKYVSs5f4aCDh/h3Q0iXXwRiYTYAjFVnUNlhUitbQpKp7j/TlJJBaWS3H8n6ZSCWttESlZSdY7YAjFVTxbpUC/79ivohqWkko4rleSGpQrat59DvSJVTxZbIKaJE0Tq7DKiefWKNq/eiDq7RJo4QWyBmMaOESmbU1AqSSqpaKkkqaSCsjmRxo4RW+C/IJFwygrE1NcvUiqpoEyWbE7RsjmyOQWlkiL19YstENOBgyJVTzaiTS2KtqnFiKoni3TgoNgCMXV2iVQxnqlTFPTGW2Rzjiub4423FDR1ChXjRersElsgpu4v6Tkk0pw6BWWyPPknsjkFZbI8+ScyWQXNqRMp10P3l2ILxJTPs32HSIsWUBYoaPcefv071q4nm3NMNsfa9fxmBbv3KKgsYNECkT77B/m82EIlaGljXr1hqiaxcAHvvK+gTJaXX+HlV0glHZXNKcrCBVRNEqmlTUkCJWjdRk+PSLfcyIS0omRzZHOKMiHNLTeKlM3Ruk1JAiUYGOC9jSJVVnDXrYShUROG3HUrlRUifbCRgQElCZSgLGDqFAXNvJC7byMMnbAw5O7bmHmhgqZ+hyBQkkAJljdSW2NEsy/lwXuZkFayCWkevJfZlxpRbQ23NSpJIKbp05g/V1FmXsgTj3DlFZQFilYWcOUVPPEIMy9UlPlzmT5NbKGYpk8TS2UFjT/numt4dwOtbezbL9LUKcypY9ECqiaJbfo02jvEEorp66+VpGoSN1/PzddzqJfOLrI5R6WSVE+mYrwT8vXXYgvF9MkOMhnSaSWrGM/5M4yqTIZPdogtEFN/P089TybjWz7awiNPsGWbk2bLNh55go+2+JZMhqeep79fbKES7N7Drx6k5mJSSfb8k73tjtq5i8vn87ObSCWNimyOV17jg42O2rmL86Yz41yyOT79jL5+JQkNN6AIff20tIn0wUZat3L1VSxZTLJSSXI9rF3P2+vo7fUte9vZ2y6uAUOEhuswCnp7Wf0mb77NnFrq65g1k1TSiLI5duykpY3WbQwMGE0dhggNtxm/NEoGBviwhQ9bSCSoOofqyUycwNgxjurr58BBOrvo/pJ83smy2RCh4dbgeYRGWT7PF9180e1/YRBrDBEYorkp0YnVzjyrm5sSnYYIRPst+pw5+vCQCGUibN+68kBN3YqvsNSZ4Y7mpsTfRChTwPatK1tr6laMw2VOb6uamxKrFFBmBNu3rlxXU7fi37gKodNLH+5obkqsMoKEIjQ05i/Ao1iG0KltEKvxUHNT4nPHkRBDQ2O+GtdiLqah3KlhAB3YjDXNTYlOZ5111llF+A8aUDCF69BprwAAAABJRU5ErkJggg==",
        "links": {
            "mainnet": "https://wallet.kukai.app",
            "ghostnet": "https://ghostnet.kukai.app",
            "mondaynet": "https://dailynet.kukai.app",
            "delphinet": "https://testnet.kukai.app",
            "edonet": "https://edonet.kukai.app",
            "florencenet": "https://florencenet.kukai.app",
            "granadanet": "https://granadanet.kukai.app",
            "hangzhounet": "https://hangzhounet.kukai.app",
            "ithacanet": "https://ithacanet.kukai.app",
            "jakartanet": "https://jakartanet.kukai.app",
            "kathmandunet": "https://kathmandunet.kukai.app",
            "limanet": "https://limanet.kukai.app",
            "mumbainet": "https://mumbainet.kukai.app"
        }
    }
];
exports.iOSList = [
    {
        "key": "airgap_ios",
        "name": "AirGap Wallet",
        "shortName": "AirGap",
        "color": "rgb(4, 235, 204)",
        "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAJ60lEQVR4AeXBe2xdd2HA8e/vd865N9f34ce1r+36GcexnTRpmj4S2gbSkbYq64BVTKggJsYfLWxisEkriG4sgECjmjZRVIQ2dTw0aYitaFC2wUYofajQNU3S5uE4sWM7tuPY8eP6Xt/nOfec3zYhT4dbP37XsdM//PkI9b/YwiRbnGSLk2xxki1OssVJ3gYFz6VcpuTwdpDcQLN2gT86/Su6jz1Lua5jz/LoG69wrZjnRjK5AYqeyzdGBvjyxTdYcGzqrCDlbM/lH8Yu8uzVUf6iZx+f3L6boJRsNpNNpIDR1DzfuHSOv50YQkfKsXn83HG+OTLAl/pu45GW7Ugh2Cwmm0ABY+kkZ2aukioWyDg2awlKA3BYMpxb5CMnX+TJodMc7d3Pw83tCAQbzWQDeUoxkpqnf26adLFAJf6gfSd/PXSGcmfSSX7v+PPsidXy2e69fLBlO5aQbBSTDZB1bC4tzDKYnKNQcliPr+6+g72xWv78/AnG81nKnU0n+f2TL/G58yd4rKOXj7XvpGVbFdfLZJ0Kbonx9AKXU/Ncy2VQrEywNgF8pHUHH2ju5OmRfp4cOsO8XaTcRD7LXw6c5IsXTvFb9c18qKWL9ze3U2cFWQ+TCqTtIpOLKSYyKa7lMiilWE3QMNkVT5APh2F6DB0hw+Dx7r18vLOPp4bP8bVL/SSdIuVcpTg2M8mxmUk+8abkcH0T72tq57cTrXSFo+gy0XRiaoKB+WvoCFsB+uIJumvqMaXk9XyGSsVMi8/33MqfdN3M341e4Knhc1wp5FiOozyOzUxybGaSTwFHe2/laO9+dJhoyjo2qxFAUyTGztp6WiPVCCHYCFHT4s+69/Dprt384Opl/v7yAC/OTqFY2Wgugy4TTbZbYjl126roqK6lM1ZLlRVAh6JylpQ80rKdR1q2M5Jb5HsTw3x/coQz6STl5uwiukw02Z6LX1u0htsaW4gEgqwlKA38sq5D1i0RNkzWY3tVlCd69vFEzz4uZlL86dnX+Mm1CZYknSK6JJocz8MvURUhEgiiY3e0Gj/b8/jjM6+SdUtcr55INXfXJfBLlRx0mWgquS5+ppTo2huroy9SzUAmxZLvjA3yTxOXiBgWHgrFrzUGQxyqS/BYRy8HahvQETUt/NKOjS6JppLy8DOlRJcAntx9B+Vsz2PeKbLg2KQcm5RjczGT4ltjg9z18r/x2JuvUPRc1hI1LfwypRK6JJpKnoefISWVeG9TO1/edRu6FPDM5Yt88PVf4CnFaqoME7+sW0KXRIOrFOUMIanUEzv38cMDR+iNVKPrx1PjPD1yntVUGQZ+Rc/FUwodJho85VFOCsF6vK+pnfc2tXM6PU//4gK25yEAKQSuUrw0N8V3x4fwlGLJXw2e5g87+7CkZDlBw6Bc0fMIGQZrMdGglKKcFIL1EsC+WB37YnWU+2hbN7dXx/nkmVdZMl3M88vkNQ7Hm1hOQBiUs5VLCIO1SDQo3kog2Cwf7+yjxgrgd35xgZWYUlDO9RQ6JBqU4i2EYNMYQrBNGviVlGIlEkE5D4UOiQYheAvF5jk2M8lUMY9fZ1WEzWCiQSAop5SiUlm3xJxdRKFYjuN5PD97lc/1v45flWHyrngTK3GVopwhBDpMNEghKOcphQ7b83jm8gWeGbvIm6kkCkWlHuvsJWZarMRRHuUsIdFhokEKQTlXeaxlPJ/ld1/7OadSc6zXzdEavtS7n9UUXJdyQcNAh4kGKQRSCDylWFLyPFaTdGyO/PKnDGXTrNedNfX88MARIqbFarJuCb+AlFhCosNEkyUNim6JJY7rsprP9h9nKJtmPfZEa/lEZy+PdvZiCcla0o6NX9S00GWiKWgYFN0SS4quy0qmi3m+Oz6EX40V4It9+7mnrhFDCJZjCEFzsIp4IEgl5pwifnVWEF0mmoKmBXaRJYWSw0qOzUzieB5+zx24j0PxRjbDVCGPXyK4DV0STVWmhV/GKbKS4dwifr2Rag7FG9ksl3KL+LWGwuiSaIoFt+E3X8izEonAz/E8NtOJhVn8+iI16JJoioeq8Ms5NuligeX0RqrxG84t8tzUGJvh7GKSyUIOvwO19egy0ZSoiiCFwFOKJZfTC+xtaKLc/Q03UWWY5NwSSx55/QU+veNm3lHbgCEESwJC0hOpprMqwnr885UR/ILS4J11jegy0WRJg8ZwlKuZNEsuLcyyp74RIQR+1VaAT3Xt5quDp1lS8FyeHDzNSvZXx/nKrtt4MNGKLsfz+PbYIH73NdxExLTQJalAV3UdflnHZjSdZDlHe2/l7roEuk6l5njo1Z/xlYtvousfJ4a4Usjh99G2biohqUB7rJaQaeF3euYqrvIoF5QG//GOB3i4uQNdCvj8wEn+ZXKUtWTdEl+48AZ+baEw729upxKSCkgh2BVP4Jexi5ydmWI5MdPiB3e+m5/e9QAfuKmTpmAIwdoeP3ecklKs5gsDp5jIZ/H7TPdeLCGphEmFeuoauDA/Q9axWdI/N01LtJr6UJjlPNDQwgMNLfwfxW+at4t8pv843x4bZMlYPsMr89McjjexnBdmp/ja8Dn8usMxHu3opVKSChlCcntTK36eUrw8MUy+5LAWAQhAAAKIB4J885a7qbEC+J1NJ1nOeD7Lh068gKsUfl/fe5CAlFRKsg5t0Ro6qmvxyzkOvxi7hO26VCogJY3BEH5516XcvF3koVd/xnQxj9/H2nfyYKKV9ZCs08GmdqKBIH7JQo7nxwYpuiU22oxd4P5f/SdnF5P47YrW8NSeg6yXZJ0sw+Bw2w4saeA3l8/xXyMXWbSLVEJRRvD/LmRSHHr53zmVmsOvzgryr3e+m4hpsV6S61Ad3Mbhti4MIfFL2wV+MjzAaCqJPoWf4Ne+d2WYgy/9mMFsGr+wYfKjg/fRE6nmephcp8ZwlHvbd/Di+CVKnscSx3N55coIl9Pz3N7YSiQQpBKXcxkefu3n/GhqjHIR0+K5A0e4py7B9TLZAE3hKEc6dvLi+DCFkoPfxGKKyUyaHTVx+uIJYoFtLEcpfsPTI+dZTlMwxHMH7+OOmno2gskGqQ+Fec/2Xl6eGGE2n8XPU4rB5CyDyVkaw1HuuqmDsBWgUnfVJvj+HffSGgqzUSQbqMoKcH9nD7c0NCOFYDnT2UVOTE1QiYCUHO29lRcOvYfWUJiNZLLBpBDsbWimI1bLyekrXMmkKJe2C+h6MNHK39x8J7uiNWwGk00SC27j3vYdzOaz9M9OM5FJoZRChyEEDzW28Xj3Hu6pa2QzmWyy+lCYd7V1kS85jKaSjKbmUSjKmVJyS6yWD7fu4MMtXbSGwtwIJjdIyLTYFU+wK57AVR7l/vudv0PEtLjRJG8DQ0jKRUyLt4Nki5NscZItTrLFSba4/wG5rKPEn6lO8wAAAABJRU5ErkJggg==",
        "universalLink": "https://wallet.airgap.it",
        "deepLink": "airgap-wallet://"
    },
    {
        "key": "naan_ios",
        "name": "naan - your portal to web3 ",
        "shortName": "naan",
        "color": "",
        "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAACDklEQVR4Ae3BMWgTcRTA4d97/aNBI2SpOKmbgjrUBNvBQbsJOggd2sG14NCILg52sEPr3ExZnVwLTgUJggq2TUAwiJNkkapEdAjUoeR5NuAtSe3JUXt5fp9YsWSkZ0Ea9YdErFjaAnIMdlsa9erixOeCmH7j37ilOKc4pzinOKc4pzinOBfY3QdgnZ7rQJ4ho+yuJo36jDTqM8AnhpDinOKc4pzinOJcIHs6XewmAyhcA7nHHgWyZ3t+7fgzBlga/3KaBALZM/Jool0i0sU2H7we/Uhkabx9UQQ1654igUD2HDOzDXbYIjDPDntlRg6EJBTnFOcC6TpnxdI0PSNkQCBdU8AUGaI4pzinOKc4pzinOKc4F4A5BnvHb7YAUiA9L/nF2ALm+BsidWJ3gUAissF/zolRfgycZP+tCJVlIlbLV4EzpGNdJjv3iVjtaAXkAoOtBuAScJb91yRWBEqk4wexMeAyg7UU5xTnFOcU5xTnFOcCB9820KanAORIUeDga8pkZ4yI1fJPgGlSpDinOKc4pzinOBdITKpgX+lLRsFmyZBAcstC5T19GHfOA7NkiOJcIDFrGOUu8Fyo3CBilJ8CV8CUjAkkd4SeHLEckCeDFOcCw+ew1fIn6DnEHwSGz1Vgkz1SnFOcU5xTnFOcU5xTnAvAKtAkubfEXgDfSUTeEKsBLfprEVsDAump/wQutXPS0gaA0QAAAABJRU5ErkJggg==",
        "universalLink": "https://www.naan.app/",
        "deepLink": "naan://"
    },
    {
        "key": "altme_wallet",
        "name": "Altme Wallet",
        "shortName": "Altme",
        "color": "",
        "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAF7klEQVR4AeXBW5DVdQEA4O/3O/+zexYWlEWQe6W4hhJQDBdRCRaMFMfrjICAyjg+ODXm9NDlofGp0pp8sRqnxqeaQqbsMo1O4ziJ17QAwWuikxaKQiIBC8tyzvk1gzM0O8vZ5dz25XxfWCslLSxqcVGLi1pc1OKiFhe1uKjFRS0uanFRi8uMsJCn2EHWQdt0lDj+b8r95I6SikZUZiQVGH8xV9/J3B7GTiCVOfghO57gsQc58AaOGzGZkdJO91Xc/VPOnkgIThk9likzWbSaH93Ku0+jaEREIyFSmMpdDzDuXEIwSAhMmM5Xfkw8y4iJRkKBlbfQNdmwps1iwXXIGxFRswVCgRW3EoJhhcCXNlEebUREzZbjomWcO8MZu3ARUy8mZJouarKUsWIDIThjuYxl60mjNV3UTJGubuZdgaAql15L+3hETRU1USpw6Q10dKpa12TmrSJ0aKqoibLxLF2rJgErbya1a6qoSeIouuczdabaBC6Yz9TZhDZNEzVJMWPlJmLOIKlM7yHee5P33qT3ECkZpK3AF2+iFDRNpglCxvjzmLvUIB/v43f388Lj9O5z0qgJLL6C67/OuHOdEgKXXMsj36fvPU2RaYJUYPE1jDrLAB++y/fWs28n4Rip5KTDe3l8Nzu38u1fMek8p3RNYe4qXvwF6YSGi5qgnGfFRkJwSqnIT+5m33YcIZX8XwlH2L+TB75KueSUGLniNk5kmiJqtDwXLWHSpw2w+2+8vhXHVJT62P00rz1rgAsXMX0echouarByoOc2Ys4A25+jLRlWVmbnswbI2li6jtCp4aJGCoyZxoIrCcEAR3sJwfDK9B02yLK1xDGIGipqpAJL1lAYbZCJEyiXDC9H12RSMsDZ5/D5KwkdGipqpLPoudlpLbqKcgeiygKlHItXE4JBVq6n3KGhogYJBboXMuMipzVxBl++E2OcXiCMZdXXmHyewQKzFjFpJiGvYaIGKXfQs4EYnVYIrPsGX7ydNJ7QTsgRcoQCzuHyW1j/LRXl21m2jnKmYTKNkDF2Cl9YYUjtHdxxH0uu5i8Ps/cVEibPZvkaZl9OLlNRCFxyLb+/l+N9SOqWaYQCC6+hc5xh5TLmLGfOckpFJ+UyZ2zCdD63kr//GkV1ixogFOhZQ3BmUiIlQiREUkJyRmJkxW2UcxoiU6fQxswFzJiFYFjlEm/v5K+P8v52Yp4Z81lyDdO6CdGwZl3C1IXsfQ4ldcnUqYiejeTyhvXRHh76Jtv+RCwRfGL7o/zhPi7fyMZ76BxnSO0dXHYDW3YQjqhLVKexU5i/ihAMae873HMdO35DPIxeUi+pF0dIH/PUz/juag5+YFhLbyI/Ud2iOoQCC66nc5wh/Xc/P1jPgVfRj2SwhGO8s537N3DsiCF1TWLuUmKnukR1OJFn1a2EoKJSkYe+wwcvkfoM7zhvPs+WeymXVBQDq27neE5dolrlOX8Bn5qjopTY9hgv/hJHnbFwlD//nLd2IDm9wKxFTL6AkKlZVKsxrNhECCrqP8aWewl9qneYzT+kWFRRLmP5BlK7mkW1yNFxDotXqygldj3Jnl0oqVo6xhvP8NZLKgqBpTeSdSKoSVSLAguvpvNslSWe3EIsqlk6yNYthjR+CnNXIqcmUQ3CKJatMaSD+3n1GdIJtTvOtsfoPaSiEOnZhIKaRFUKbUy7mPPnEYLTSoltT9B3ACW1K3FoD7ueMqTZS5jQjZyqRVUqB+YtJ8sb0tMPE4+qW+jlqc2G1NbBZy8j5FUtqlJCrt2Q/vkyu18g9atfkZf/yJ5/IKkoC0iqFlUplnj+txzcR0oGSIn9/+LBO0gHkDRE6RgP3sXHH5KSAVLio/fZuZVUVLWwVkqqlTFxNpetY2q3k0pF3n6J5zdz6F0UNVaerm4W38hn5hBzJOx5nWc2859XUFa1TC2K7NvFI69RzDkpJHIJ/Uga7wQHXuPR3ZRyJJ/ISiiirCaZWpXRT2YEJfST0zhRi4taXNTiohYXtbioxUUtLmpxUYuLWtz/AIepoFxQZk61AAAAAElFTkSuQmCC",
        "universalLink": "https://app.altme.io/app/download"
    },
    {
        "key": "autonomy-app",
        "name": "Autonomy: Digital Art Wallet",
        "shortName": "Autonomy",
        "color": "",
        "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAADS0lEQVR4AeXBXWiVZQAA4Gcvh+lYP4xGBBsc7Wal2UyWQ9gWSAYzhSgcgtBUSCwKMfulS2+iG7vJlUGJSzHBqwSLZhAYKgmZNac3tQNbizpTapPJYTun6zGDL/e+dPE9T53aYE2OBTkX5FyQc0HOBTkX5FyQc0HOBTlXkMLpy5TKoireR2+72ApSODjEqR9EtekxetvFFuRckHNBzgU5F6QwUxHdTEUKQWyzc1wqie5Sidk5sQWxHTvH5LToJqc5fl5sQUzXJth3TDJ7j3JtQkxBDLNzfPYdXfspT0mmPEXXfo6cZXZODAVZnf6Rg2csMFPhUonJabfV3caWtRSbCUEm1SqlMie/59ur5ilP0f8Rrx5ldZGGegu89CS9j8qiIKvSJKd+kFlDPYd30dfpjr3yFCcusP0QMxXzTE5zZthtPb1aVkEqh3fR12nR+jo5vEsqQQpPPERfp2j6Ouluk0KQwnOPi27LWikEKRSbRVdslkKQwo2bortxUwpBCmeGRTc0LIUghc8vcHVCNCO/ceKCFIIUKrM8c4Cx6xZt7DrPvk9lVgoFqVyboP0d3tzElrUUmwl1MqnWGP2Tkxd59wuuT0ulTm2wZjFmKlz8lQ+GOHGemvT6Onl5Ax3Laai3GAWL1VBPdxvdbfS2s/MQ1ZokQh2fvEB/t1iCmPq72LdRMq9tpL9bTEFsb29mSUF0Swq8tVlsQWxNjaxZJro1y2hqFFuQQlOj6JoapRCkMFoW3WhZCkFsV8YZGRfdyDjDY2ILYqpW2TNITXw17D1KtSqmIJapW2wbYGhYMl//zLYPmb4lloKsSmV+GrPATIWLv3DkLL//ZYE6PNzCsmZCkEm1ymiZkXFq5jt+jm+G2d5Dx3Ia6i2wqpVisywKsjp9mRc/9Z9seIQD21jZ6o5cGWfPIEPD5vnjb9475V8N7GD3elkEqWxdx5evs7LVHVvRwldvsHWdVIIU7r+Hj3cSgkULgUM7eeBeKQQpbO/hrqWiuXspz3dJIUihY7noOh6UQpBCQ73oGuqlEORckHNBzgU5V5BVTxsDO2SyqlV0q1oZ2CGTnjZZFWS1ooUVLf43xWZ2rxdbkHNBzgU5F+RckHNBzgU5F+RckHP/AKis3ntPQOcLAAAAAElFTkSuQmCC",
        "universalLink": "https://autonomy.io/apps/tezos",
        "deepLink": "autonomy-tezos://"
    },
    {
        "key": "temple_ios",
        "name": "Temple Wallet",
        "shortName": "Temple",
        "color": "",
        "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAIAElEQVR4AeXB3W9b9RnA8e/znHOcOGliO3aiUkLfCyNDLdIkShtKIu2GiwlVbNP2d3C7m11Mu9jlNG2X7AJpm5i0MSGtEpu0ZKhMoxUVsJVBm5emaUtI7DiB+Pjl93uGXRzaDBGGT10kfz4CGD1M6XFKj1N6nNLjlB6n9Dilxyk9LiRBx8cizn7nARChRQAREED4hIAAAiJCiwAiIIAILQKIgHCbCAgg8KtfL7KyWiUpIQk5MRpy7uwQheceQIZSoAICqCAqIAIKiIAKCKACIqACAqICKiACCoiACoiAAipcXdjixd9fJylKAk6Mhpz7boaRwQBWt9jJjN0JX8Bomz6dJ0lKh06MhZz7fpaRwQBUsLUKX4mxO4OpyQJJUjo09VCKkYEAVCBQKMZ8FSLsTuDIwUHG96VJSkiHZpbqEAiI0GQ1B1t12JOipdLA1ipsEz4htAi3CRhNAsJnhNsCRR8fAwMEpifzvPjSdZIQ0qG3P6xTqsFIWkBosWKM7EnRUnP4vyyAN3AG3sAZeA/OwBt4A2eYN3AG3sAZeAPvkbFBZHwIGR2gafp0gRdfuk4SQjrkDV5brvHsI2laRGA9hv3DtGT60FMPghmfy/hixRj/zofY3DoyNkDT1GSepIQkYPZajWcfHQABRLD1KsJn5NE8IgIKiIAKCKACIqACAqICKiACCohApYG/eAt7rwgn94HAkUODjO9Lc/1GhU4pCZhZqEEgoAoqUHdQabDN+D8Z2wYjJNePv7xGmwDTkwWSoCTg7Q9qlKpAIBAIqGLlmG3C7oTbzADhTvLICNQ9rFVom57MkwQlAd7g79eqEAioQCBQrrHN+FL8Wyu4VxfZKTh7jOhn05BP0zY1WSAJSkJm52NQgUBBBdussk3YnYfGC+9gl1f5Mo4eGmR8X5pOKQmZmY8hEFCBQKDhoepoMXanIAeG8XPr4DxfxLht+qkCnQpJyNs3apRiIzeotHjD/3kOUgEEAoFAoBAI9AXot/YiuX7upA+P4K6UsMUN5GiWJlvdwr9xE8IAIkUihVCxSHGlmE6FJMQbvDZf5dnjg+ANf2kF26xCoBApEiqECn0BcjQHqxXI9bPNQI7lQMC/XyQ4mqVJ9qTw7xYhpUgqwFIhpJTnXynxm9l1OqUkaOZqBQz8GzexYkyL8JlAkENZJBVgxZid5FAGUgH2folt/SEyNgAIIBjw/Mtr/GJ2nSSEJOiv727x5qvLUIohUAiA0CDw9KeFb0zkoC/AnEG5CnUPqYA2CRU9lMXPl8EZhELTan4Py//5CCLHC29V+OU/NklKSIL+dbPKE6/wKc+dBlPKyiklcgZmYGDFGNk7SIvQIsdycLWELW4gR7I0/TPo5+wLq9wLSpd8XPNcWIzBeXAGzmOrW2wzWuRYDkTwV0q0nTk5gqpwLyhdNHOlAs7AGTiDlS3aRGjRAxlIKXalRFsuE3FiYph7Qemi2asVcB6cB2dYMYa6o8n4VKTowSy2UAZntE2fznMvKF10frFKrebBeXAenMdWtthJjmWxuseWNmibOpXnXlC6aKtuXFiqgjNwBg2PffAxLcY2OZIDAX+lRNuZkyOoCklTumx2PsacYc5jzrAbH7GTHsggqQCbW6ctl404MTFM0pQum1mogfPgDLxhqxWoOu4SCnIwgy2UwXnapk7nSZrSZa8v16jVPDgPzkPDYzc/AuEOghzJQt1jS5u0TZ/OkzSly7bqxoUbNXAGzsB5bHmTnfRIFlSwuXXazjyZR1VIUkiXjaaV0eMFgskxEAEB6QvBAGGb7B+GSPFz6+i3D9CUy0ScmBjmzXfKJEXpotG0cu57WR5OeSSfRgpppDAAmT4Q7hYqciCDLW6AN9qmJvMkSemS0QHl3A9yPLY3wkoxeGM3cjgLDYdd36Rt+nSBJCldoALnfjjCY3tTECkiYMWYuxj/Qw9nQQSbW6ftzJMjqApJUbrAG6T6FIkUCRVCxVYr7EYeGoJI8fNl2nLZFMcnhkmK0iWzS3UIFcIAQoVSzK5CRfZnsKUNcAZCy/RknqQoXTJzrQaRQqQQKbZRBW9sEz6XHs5A3WPLm7RNTRZISkiXzM7HECqIgADlKo2fX4RIIQogHRJMjqMTee4kh7Lwt2vYQhk5kAGBp5/Moyp4b3RK6ZJbm473Sg6JFDZq+H+vYeUqtlGDrTqST2NrW+wk40MQBfiFMggtI7mI498cJglKF83Mx1gpxl/6ALzRJKEih7MQCFaMsZrjLqEi+4expU1wRpMB05MFkhAAP6ZL1jcbVK6WuVgyLm7AxXXj8ZMFgv4QvIEzNJ9GhlMgAiIgAuUqNreOPpxDMv2IQFwzfveHZToV0kXnF6ucp83T9PgTDU7tD8AbGNitj5EHh7iTHMzArGALZWR/hqanT+VRFbw3OqHcZzPvV6DuoeGh4fA3NtlJxocgUmxxg7aRbMTxiWE6pdxnM3MxNBw0PDQ8rGxh1QZ3CQR5aAh/fRO80Tb1VIFOhdxnry9VqVU9kQBmsFGj/qNZCBVCRUKFVAD9AThP/afnIVRKVWPmj2U6pdxnW3XjwlIVGh5KMbZQhqqDqoOqw6oOnIe4AXUPdU9xo8EzL61z6VadTilfAzMLVSjG2HwZvLGT1R3W8DQVY+OZlze49GGDJIR8Dfz2ckz9lgcMFFAPaqAeVEAFVECFPy3WeWvNkZSQr4HLJcdPSnzKAKNblB6n9Dilxyk9TulxSo9TepzS4/4Lz8MqhS9ENeQAAAAASUVORK5CYII=",
        "universalLink": "https://templewallet.com",
        "deepLink": "temple://"
    },
    {
        "key": "atomex_ios",
        "name": "Atomex Wallet",
        "shortName": "Atomex",
        "color": "",
        "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAFIUlEQVR4AeXBfWyMdwDA8e/ze55r6dbW6Ol71cvKVekQZmyGMVtWzMu6YoRI9oeXTWJsppMzr40lnXbxNjYEwZiXKVWtlqMlq5eWVus1nWp7Srz2mHP3LP1DIovq1Z1Hk+fzkQwBJhUdE+icQOcEOifQOYHOCXROoHMCnRPonEDnBDon0DmBzgl0TuEVaRUeSo9unfEyGCgquUDBmXOoaE9BY8YWzUldModhcQORJIknThUW8+XXiRScLUFLsuxjNKMRfz9fstM20KdXdyRJ4mnBgUZGjYxjf5YF6/UbaEWgoTkzJ2OKaktdfF9/jVVL5yNJEloRaESWZcYmDKM+XTpHExvTAa0INBIaHEgzf19cEd2hHVoRaOSR3Y6rHj2yoxWBRqqs1ZRdvUZ9VFXl75OFaEWgoaXL11GfHXsOUHa1Aq0INLRszSa27UqnLufOX2LKjLloSZZ9jGY0oqoqO/Yc4Oat25ii2tDM349at+/cZdW6LYyf9C23bt9FS5IhwKSikTHxQ6iyVpN1KA9JkghsGYDBoFBReR2Hw8GrINDIoA/eY03qQvr36UktVVWpslZztbwSh8PBxwPfJ3HGJLQm0EBEeAhrlyVRcKaEeUuW8SydoqNI/GYSkRGhaEnwknl7e7F5TTJCSCRMnMbDh//yLBu37sapqowbNQwtCV6yxeYZdI2NYcLkWVwpK6cu1yqtZBw8wriEYQgh0IrAg7y9vQgLCaJJE2+eUGSZHxYkszcjh/qs3bidiLBgBrzfC60oeECbyHAWzplO3KB+eHkZsNsfk551mFlzf2LqzB9xVVrGIazVNxkdP5iM7CNoQZZ9jGbc0NH0Jof3bqJrbEdkWaaWLAvat2vNmPghZObkUmWtxhVOp5PSC1coOFvCpSv/oAWBGyRJ4rdfFtH8DX+exd/Pl7XLk5CFwFV7M3LIOHiEJ4QQvEwKbuga25EunaN5HlNUW3q93RVLXj6u8PIyMGHMSEZ/FkdsjIkm3l5UVF0nMyeXlJXrOVt8Hk9ScIMpqi2uMEW1xZKXT33aRIazbX0qMaYonhYWEsT40cP5In4oc5NSSfp5FZ6i4IYamw1X3LfZGNi3NwkjPiHzUC4Hso9y4+YtnmYMaE7Gjt+JCAuhLooiM2/2NJxOJ0tSVuMJCm44euwkdrsdg8FAXRwOB5bcfLp1iWFAv96MTfgUh8PJidNn2Z9lYevOfZReuEySeQYRYSG4wvzdV+zem0XpxSu4S5Z9jGZeUI3tAf5+vrzTvQt1+XXdVjb/mUbJ+cukrFjHX+nZlFdU0ToynISRccTGdCA98zCrUxcghMAVsiyolZ5lwV0Kbkqcn0xAi+aM/Xwo//fHzn1MT1zME06nyqnCYk4VFrM4eSXN/P2QZZm+7/ZAURQaon+fnniCgpvs9sdMnDKLtRu3M3zwh4QGB1JprWZnWibZlmM8z+07d6kVEtSShgoOaoknKHiIJS8fS14+L+J+jY2Gqqmx4QmCRuBkQRENdaKgCE8QNAKFRaUUFpXSEBu27MITBI2AqqpMn70Ih8OJK7Itx9mZloknyLKP0UwjUHb1Gtbr1Xw0oA9CCOpy+sw5RoydjM32AE+QZR+jmUbiZEExOZbjRLdvR2hIIE+7d7+GlBXrmTj1e+7cvYenSIYAk0oj1K5NK97qZKJp0yaUX6vieP5pbA8e4mkKjdTFy2VcvFzGyybQOYHOCXROoHMCnRPonEDnBDon0DmBzgl0TqBzAp0T6Nx/Vg+o6CnFmfYAAAAASUVORK5CYII=",
        "universalLink": "https://atomex.me",
        "deepLink": "atomex://"
    },
    {
        "key": "umami_ios",
        "name": "Umami Mobile",
        "shortName": "Umami Mobile",
        "color": "",
        "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAANSklEQVR4Ae3BC1RVZaLA8f+39z4HgQXiJBmgLWpEHRXFQhHMiJGsMTR5zJjL8Iosb2KOaRpZ4gulScXedWOIAequtGmC1mAjjSmWYyRpoGiTiEp6xgxWJ5QAOY/9XbhLW3DcoFQ+6/fjF7/4eRN0k5TSExgLhAD9AA+urCbgOFAB7BBCNNINgoskpQwBFgFxgDtXp2agAMgUQlRwEQQXIKXsCawHkgClsrKSwsJCSktLqampobGxESklV4IQAk9PTwIDAwkPDyc2Npbg4GBa6UAusFAIcYouCLogpRwIFAFBu3fvJjU1lZKSEtooioKfnx9eXl4IIbgSpJQ0NDTw1Vdfoes6baKioli7di2hoaG0OgRMFEIcpBOCTkgpBwIfSin7rFq1ivT0dHRdJyYmhuTkZKKiovD29uZqcPr0aUpKSsjJyWHTpk0oisKyZctYunQpQoivgTuFEFUYEBiQUvYEPpVSBs2aNYucnByCgoLIy8sjIiKCq9nHH3/MjBkzOHToEMnJyWRnZyOEOASMFEKcwoWCsfVA0KpVq8jJyWHMmDGUlZURERHB1S4iIoKysjLGjBlDTk4Oq1atolUQsB4DCi6klCFA0u7du0lPTycoKIhNmzbh4+PDtcLHx4dNmzYRFBREeno6u3fvplWSlDIEFxrnWwQoqamp6LpOXl4ePj4+uNKrPkP/9J/Ib2tR+g9Hvfe/kKe/wfF6BkhJByYz6p1xKIPDwHYGe/YS0HXOIxSUXwejjn8QVA2kxP7nJ8F2BkNCIHrdiDJyPMqA22jPx8eHvLw87rjjDlJTU9m2bZsCLAIepB2NdqSUnkBcZWUlJSUlTJw4kYiICDqwncH+0qM4PyrkHOfWtxCBQ1AG3Y785iv08u24cn6wEXP6X1EGhyF6B+DYsA4jzg/A+VEBpvkvIfrcjHbfTOx56ei7P6BTbz+POnYypj8+C+YenBMREUFMTAxFRUVUVlYSHBwcJ6X0FEI0cpZCR2MB98LCQtokJyfjyrE5D+dHhXQgdeyvPAYOO6Y5mQjPnpzHYcP+9Ezkfw6jTXkUbfJsOqP/+1Na5v8Wx9+zEH63YE57A/O6f6COmQSaCSPOHe9if3EBrpKTk2lTWFhIK3dgLO0odBRCq9LSUhRFISoqClfqyPFgMuNKHvsCx4ZMhG8A2py1GJGnrdhWPICsPY42Yzna7+fTqeZGHH9ZQcu8u3DueBfl18MwPZaFW045ptlrUEKjwcOL9pw73kWv+oz2oqKiUBSF0tJSzgqhHY2O+tGqpqYGPz8/vL296cBhR/jfinZ/Co6/PY8rR+HLKCGRqGMmIf/9KY5Nr+FK1lmwpcVjXvkW2rTHEb39sWcvAYcdI/I/h7GvT8Hxv39CvScRNTIe9d7pqPdOB92JtFSjWw4h6yxw2oowmWnP29sbPz8/jh49yln9aEejIw9aNTY24uXlhStHfjrq5Dlof5iP8+Mi5IkjdKDr2J+ZgzmzGC1pObrlEHrFh7iStcexPXE/piX5qPckIvoNwL4+BfnNV3RGfn0Mx+sZON74E8qAESghd6EMDkPcOgT15oF0xcvLi8bGRs7yoB0FA1JKhBC4kk3fYc9aDOYemOY9B4qKK/ltLfanZ4LDjjk1G+XWoRiR9XXYlsThLHkbZXAY5ue2ot5xPxckdfSDe3C8tR7b8j/QkjiElsQh2B4dj23lVPQDn+BKCIGUEiMK3aSX/RNnydsog0ai/f4RjOiHKrA/MwfcPDAt34DoNwBDtjPYn5+H/cUFCM2EadGrmNNeR/jdQnfIBiv6kUr08u04S/5Kdyj8APbsJciTNWhTHkUJHoMR565i7C8vRHj/CvOqvyECB9MZ59aNtDzyW/TPtqGE3o3bi9sx/fdTiBv86DYp6Q6FH6KpAXvmbHA6MC16FeHbFyPObW9hf2khwvtXuGUUoAwJpzOy9ji29GnYn5qBPPkl6oQk3LI+wTT/RZRBoVwqCj+QXr0X+6tPIHr2xrwkHzy8MOLcuhF7ZgqYe2BesRE1eipdcZa9T8u8KOzPzkVaqlHvSsD8dBFur+xEe/AJlEEjQdXonKA7NDqh6zrnUVTac27dgOgXhDY5BfPjr2FbnQh2G66cHxch67/G9HgOprnPoAy8HXt2GtjOYEh34vzwHZwfvoMyZDRq9FTUsN+hJcyDhHnQ3IheXYF+ZD/ScghZZ0HW10HjacTNA3Gl6zqd0ehEfX09rsSNfXHleH01orc/6h33Y1r4P9jXPQROB670z8uwLfodptQ/o949DeU3o7A/90f06r10RT/wCfqBT7CbUlGGjUEdEYUyZDTK4NEowWO4GPX19ZhMJoxodKK2tpa6ujp8fX05R42IwbEhE3Qn39N17M/NQ3h4oY6eAItexb4+BRx2XMk6C7YnJqM9+DjapNmY17yHY1M2jo3rofk7umRvQd+zDX3PNv6fmztKv4EI/1sRvv7Q0xfR60bUsZNpr66ujtraWgICAjCi0AkpJcXFxbQnAvqjTU7hPA4btqdnopeXoIbfh/nJfOjhgSGHDUfeKmxpsciTR9Hun43by/9CvXsaqBoXraUZvboC50cFON55CcdfliOPHsBVcXExUko6o9CFrKwsXGmJT6JNfQxMbnRga8H21Aycpf9AuS0K8+oChG8AndE/L6Nl/jgcbzyFcPfE9HAmbi99hBo9FUxmusXkhjb1MbTEJ3GVlZVFVzS6sHPnTgoKCoiLi+N7QqBNeRT13uno5R8iv/0akHzvzHe0UfoPx+3lf+Hc/QGy9hhISWf0w/tQhkYg/G7BNPcZtAefQN+1GdnUQNcEoteNKCPuQvTsjauCggJ27txJVzQuYPbs2dx2220EBgbSnujZG/WueLpk7oEaEUN3CR9f1Hum82PU1NQwe/ZsLkThAurq6oiOjqa6upprRXV1NdHR0dTV1XFOjx49MKJwEQ4fPszIkSPJzc1F13WuVrquk5uby6hRozh8+DDtBQQEYETjItXX1zNz5kzWrFlDUlIS48aNY8CAAXh5eSGE4EqQUtLQ0EBVVRVbt24lNzeXgwcPYuT222/HiEY3HTx4kMWLF3O5nDhxAqvVytChQ/kxYmJiMKLwMzBo0CAiIyMxovAzsHr1ahRFwYjCdW7KlCnEx8fz+eefY0ThOjZ69GhycnI4deoUKSkpGNG4Tt13331s2LABk8lEfHw8R44cwYjGdcbX15f09HQeeughmpqaiI+P5/3336d///4Y0bgO3HDDDYwePZrY2FgeeOABPD09qaioIDExkf3799Omb9++GNG4AqKjo0lJSSEkJAR3d3e60qdPH3x9fTlx4gRGPD098fb25pyqqioyMzPJzc3F4XBwTmhoKEY0LiMhBC+88AJz586lzZdffonVaqUrVquVzkgpsVgsWCwWysvL2bJlC7t27UJKiauJEydiROMyWrBgAXPnzmXPnj0kJSVRWVnJ5TB06FDGjh2LEY3LxN3dnbS0NE6ePMn48eOxWq1cLhkZGQghMKJwmYSFhdGrVy9yc3OxWq34+/uzb98+9u3bh7+/P5dKYmIikyZNYu/evRhRuEz69OlDm5qaGtpER0cTHBxMcHAw0dHRXAqRkZFkZWVhtVqZM2cORjQuE4vFQptBgwbRpqioiM2bN9OmqKiIn1pCQgL5+fkIIUhISODYsWMY0TAghOCnVlZWxsmTJ0lKSuLZZ5/l+PHjTJgwgZ9aQEAAGRkZTJ8+nYaGBhISEigpKaFfv34Y0eioiVaenp781Ox2O4sXLyYvL4/t27fz8MMPs2XLFpxOJz+GEIK+ffsSFhZGXFwccXFxuLm5sWvXLqZPn05VVRVtPDw8OKuJdjQ6Ok6rwMBAvvjiC35q+fn53HTTTWRkZLB582ZaWlpobm7mx/Dw8MBsNnPOvn37WLduHW+++Sa6rnNOYGAgZ1loR6OjClqFh4dTXFzMpbBmzRree+89Zs2axYgRI3B3d6crw4cPx+FwcODAAVxJKWlubsZisVBeXs6WLVvYu3cvRsLDwzmrgnY0OtoBNMfGxrovX76cS2X//v088sgjXIwTJ05gtVoZOXIkP0ZsbCytmoEdtKPQjhCiESgIDg4mKiqK60VkZCTDhg2j1btCiO9oR+F8mYC+du1aVFXlWqeqKmvXrqWVBDJxoeBCCFEB5IaGhrJs2TKudWlpaYwaNYpW+UKIz3ChYGwhcGjp0qUkJydzrUpKSmLZsmW0OgwswICCASHEKWCiEOLr7OxsVq5ciaqqXCtUVWX58uW89tprKIpSC8QIIeoxoNKJlStXfrNixYoiIcQ9kZGRN0yYMIHq6mpqamq4nBYuXEhzczOvvPIKFyMyMpKNGzcybdo0hBCHgfFCiC/ohOACpJQ9gfVAEqBUVlZSWFhIaWkpR48epampCSkll8qePXuor69n3LhxuBJC4OHhQWBgIOHh4cTGxjJs2DBaSSAfWCCEqKcLgoskpRwBLAJiAXeuTs3Au0CmEOIzLoKgm6SUnsCdwHCgH+DBldUEWIAKYIcQ4jt+8YtfXKz/A/OhBgM5KLZoAAAAAElFTkSuQmCC",
        "deepLink": "umami://",
        "universalLink": "https://umamiwallet.com/"
    }
];

},{}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.clearMockWindowState = exports.windowRef = void 0;
var cbs = [function (_) { return undefined; }];
/**
 * A mock for postmessage if run in node.js environment
 */
var windowRef = {
    postMessage: function (message, _target) {
        console.log('GOT MOCK POST MESSAGE', message);
        cbs.forEach(function (callbackElement) {
            callbackElement({ data: message });
        });
    },
    addEventListener: function (_name, eventCallback) {
        cbs.push(eventCallback);
    },
    removeEventListener: function (_name, eventCallback) {
        cbs.splice(cbs.indexOf(function (element) { return element === eventCallback; }), 1);
    },
    location: {
        origin: '*'
    }
};
exports.windowRef = windowRef;
try {
    if (typeof window !== 'undefined') {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        exports.windowRef = windowRef = window;
    }
}
catch (windowError) {
    console.log("not defined: ".concat(windowError));
}
var clearMockWindowState = function () {
    cbs.length = 0;
};
exports.clearMockWindowState = clearMockWindowState;

},{}],41:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Serializer = void 0;
var bs58check = require("bs58check");
/**
 * @internalapi
 *
 * The Serializer is used to serialize / deserialize JSON objects and encode them with bs58check
 */
var Serializer = /** @class */ (function () {
    function Serializer() {
    }
    /**
     * Serialize and bs58check encode an object
     *
     * @param message JSON object to serialize
     */
    Serializer.prototype.serialize = function (message) {
        return __awaiter(this, void 0, void 0, function () {
            var str;
            return __generator(this, function (_a) {
                str = JSON.stringify(message);
                return [2 /*return*/, bs58check.encode(Buffer.from(str))];
            });
        });
    };
    /**
     * Deserialize a bs58check encoded string
     *
     * @param encoded String to be deserialized
     */
    Serializer.prototype.deserialize = function (encoded) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (typeof encoded !== 'string') {
                    throw new Error('Encoded payload needs to be a string');
                }
                return [2 /*return*/, JSON.parse(bs58check.decode(encoded).toString())];
            });
        });
    };
    return Serializer;
}());
exports.Serializer = Serializer;

}).call(this)}).call(this,require("buffer").Buffer)
},{"bs58check":251,"buffer":3}],42:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BeaconClient = void 0;
var beacon_utils_1 = require("@airgap/beacon-utils");
var beacon_utils_2 = require("@airgap/beacon-utils");
var beacon_types_1 = require("@airgap/beacon-types");
var constants_1 = require("../../constants");
var MockWindow_1 = require("../../MockWindow");
/**
 * @internalapi
 *
 * The beacon client is an abstract client that handles everything that is shared between all other clients.
 * Specifically, it handles managing the beaconId and and the local keypair.
 */
var BeaconClient = /** @class */ (function () {
    function BeaconClient(config) {
        /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).
         * This is used inside a message to specify the sender, for example.
         */
        this._beaconId = new beacon_utils_1.ExposedPromise();
        /**
         * The local keypair that is used for the communication encryption
         */
        this._keyPair = new beacon_utils_1.ExposedPromise();
        if (!config.name) {
            throw new Error('Name not set');
        }
        if (!config.storage) {
            throw new Error('Storage not set');
        }
        this.name = config.name;
        this.iconUrl = config.iconUrl;
        this.appUrl = config.appUrl;
        this.storage = config.storage;
        // TODO: This is a temporary "workaround" to prevent users from creating multiple Client instances
        if (MockWindow_1.windowRef.beaconCreatedClientInstance) {
            console.error('[BEACON] It looks like you created multiple Beacon SDK Client instances. This can lead to problems. Only create one instance and re-use it everywhere.');
        }
        else {
            ;
            MockWindow_1.windowRef.beaconCreatedClientInstance = true;
        }
        this.initSDK().catch(console.error);
    }
    Object.defineProperty(BeaconClient.prototype, "beaconId", {
        get: function () {
            return this._beaconId.promise;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BeaconClient.prototype, "keyPair", {
        get: function () {
            return this._keyPair.promise;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.
     */
    BeaconClient.prototype.destroy = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.removeBeaconEntriesFromStorage()];
                    case 1:
                        _a.sent();
                        MockWindow_1.windowRef.beaconCreatedClientInstance = false;
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * This method initializes the SDK by setting some values in the storage and generating a keypair.
     */
    BeaconClient.prototype.initSDK = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                this.storage.set(beacon_types_1.StorageKey.BEACON_SDK_VERSION, constants_1.SDK_VERSION).catch(console.error);
                this.loadOrCreateBeaconSecret().catch(console.error);
                return [2 /*return*/, this.keyPair.then(function (keyPair) {
                        _this._beaconId.resolve((0, beacon_utils_2.toHex)(keyPair.publicKey));
                    })];
            });
        });
    };
    /**
     * Removes all beacon values from the storage.
     */
    BeaconClient.prototype.removeBeaconEntriesFromStorage = function () {
        return __awaiter(this, void 0, void 0, function () {
            var allKeys;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        allKeys = Object.values(beacon_types_1.StorageKey);
                        return [4 /*yield*/, Promise.all(allKeys.map(function (key) { return _this.storage.delete(key); }))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * This method tries to load the seed from storage, if it doesn't exist, a new one will be created and persisted.
     */
    BeaconClient.prototype.loadOrCreateBeaconSecret = function () {
        return __awaiter(this, void 0, void 0, function () {
            var storageValue, _a, _b, key, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0: return [4 /*yield*/, this.storage.get(beacon_types_1.StorageKey.BEACON_SDK_SECRET_SEED)];
                    case 1:
                        storageValue = _e.sent();
                        if (!(storageValue && typeof storageValue === 'string')) return [3 /*break*/, 3];
                        _b = (_a = this._keyPair).resolve;
                        return [4 /*yield*/, (0, beacon_utils_2.getKeypairFromSeed)(storageValue)];
                    case 2:
                        _b.apply(_a, [_e.sent()]);
                        return [3 /*break*/, 7];
                    case 3: return [4 /*yield*/, (0, beacon_utils_2.generateGUID)()];
                    case 4:
                        key = _e.sent();
                        return [4 /*yield*/, this.storage.set(beacon_types_1.StorageKey.BEACON_SDK_SECRET_SEED, key)];
                    case 5:
                        _e.sent();
                        _d = (_c = this._keyPair).resolve;
                        return [4 /*yield*/, (0, beacon_utils_2.getKeypairFromSeed)(key)];
                    case 6:
                        _d.apply(_c, [_e.sent()]);
                        _e.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    return BeaconClient;
}());
exports.BeaconClient = BeaconClient;

},{"../../MockWindow":40,"../../constants":44,"@airgap/beacon-types":104,"@airgap/beacon-utils":136}],43:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
var beacon_utils_1 = require("@airgap/beacon-utils");
var beacon_types_1 = require("@airgap/beacon-types");
var __1 = require("../..");
var BeaconClient_1 = require("../beacon-client/BeaconClient");
var AccountManager_1 = require("../../managers/AccountManager");
var get_sender_id_1 = require("../../utils/get-sender-id");
var Logger_1 = require("../../utils/Logger");
var logger = new Logger_1.Logger('Client');
/**
 * @internalapi
 *
 * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.
 * For example, it selects and manages the transport and accounts.
 */
var Client = /** @class */ (function (_super) {
    __extends(Client, _super);
    function Client(config) {
        var _this = this;
        var _a;
        _this = _super.call(this, config) || this;
        /**
         * How many requests can be sent after another
         */
        _this.rateLimit = 2;
        /**
         * The time window in seconds in which the "rateLimit" is checked
         */
        _this.rateLimitWindowInSeconds = 5;
        /**
         * Stores the times when requests have been made to determine if the rate limit has been reached
         */
        _this.requestCounter = [];
        _this._transport = new beacon_utils_1.ExposedPromise();
        _this.accountManager = new AccountManager_1.AccountManager(config.storage);
        _this.matrixNodes = (_a = config.matrixNodes) !== null && _a !== void 0 ? _a : {};
        _this.handleResponse = function (message, connectionInfo) {
            throw new Error("not overwritten".concat(JSON.stringify(message), " - ").concat(JSON.stringify(connectionInfo)));
        };
        return _this;
    }
    Object.defineProperty(Client.prototype, "transport", {
        get: function () {
            return this._transport.promise;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Client.prototype, "connectionStatus", {
        /**
         * Returns the connection status of the Client
         */
        get: function () {
            var _a, _b;
            return (_b = (_a = this._transport.promiseResult) === null || _a === void 0 ? void 0 : _a.connectionStatus) !== null && _b !== void 0 ? _b : beacon_types_1.TransportStatus.NOT_CONNECTED;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Client.prototype, "ready", {
        /**
         * Returns whether or not the transaport is ready
         */
        get: function () {
            return this.transport.then(function () { return undefined; });
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Return all locally known accounts
     */
    Client.prototype.getAccounts = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.accountManager.getAccounts()];
            });
        });
    };
    /**
     * Return the account by ID
     * @param accountIdentifier The ID of an account
     */
    Client.prototype.getAccount = function (accountIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.accountManager.getAccount(accountIdentifier)];
            });
        });
    };
    /**
     * Remove the account by ID
     * @param accountIdentifier The ID of an account
     */
    Client.prototype.removeAccount = function (accountIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.accountManager.removeAccount(accountIdentifier)];
            });
        });
    };
    /**
     * Remove all locally stored accounts
     */
    Client.prototype.removeAllAccounts = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.accountManager.removeAllAccounts()];
            });
        });
    };
    /**
     * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit
     */
    Client.prototype.addRequestAndCheckIfRateLimited = function () {
        return __awaiter(this, void 0, void 0, function () {
            var now;
            var _this = this;
            return __generator(this, function (_a) {
                now = new Date().getTime();
                this.requestCounter = this.requestCounter.filter(function (date) { return date + _this.rateLimitWindowInSeconds * 1000 > now; });
                this.requestCounter.push(now);
                return [2 /*return*/, this.requestCounter.length > this.rateLimit];
            });
        });
    };
    /**
     * This method initializes the client. It will check if the connection should be established to a
     * browser extension or if the P2P transport should be used.
     *
     * @param transport A transport that can be provided by the user
     */
    Client.prototype.init = function (transport) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this._transport.status === beacon_utils_1.ExposedPromiseStatus.RESOLVED)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.transport];
                    case 1: return [2 /*return*/, (_a.sent()).type];
                    case 2: return [4 /*yield*/, this.setTransport(transport)]; // Let users define their own transport
                    case 3:
                        _a.sent(); // Let users define their own transport
                        return [2 /*return*/, transport.type];
                }
            });
        });
    };
    /**
     * Returns the metadata of this DApp
     */
    Client.prototype.getOwnAppMetadata = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            var _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = {};
                        _a = get_sender_id_1.getSenderId;
                        return [4 /*yield*/, this.beaconId];
                    case 1: return [4 /*yield*/, _a.apply(void 0, [_c.sent()])];
                    case 2: return [2 /*return*/, (_b.senderId = _c.sent(),
                            _b.name = this.name,
                            _b.icon = this.iconUrl,
                            _b)];
                }
            });
        });
    };
    /**
     * Return all known peers
     */
    Client.prototype.getPeers = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.transport];
                    case 1: return [2 /*return*/, (_a.sent()).getPeers()];
                }
            });
        });
    };
    /**
     * Add a new peer to the known peers
     * @param peer The new peer to add
     */
    Client.prototype.addPeer = function (peer) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.transport];
                    case 1: return [2 /*return*/, (_a.sent()).addPeer(peer)];
                }
            });
        });
    };
    Client.prototype.destroy = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this._transport.status === beacon_utils_1.ExposedPromiseStatus.RESOLVED)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.transport];
                    case 1: return [4 /*yield*/, (_a.sent()).disconnect()];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [4 /*yield*/, _super.prototype.destroy.call(this)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * A "setter" for when the transport needs to be changed.
     */
    Client.prototype.setTransport = function (transport) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (transport) {
                    if (this._transport.isSettled()) {
                        // If the promise has already been resolved we need to create a new one.
                        this._transport = beacon_utils_1.ExposedPromise.resolve(transport);
                    }
                    else {
                        this._transport.resolve(transport);
                    }
                }
                else {
                    if (this._transport.isSettled()) {
                        // If the promise has already been resolved we need to create a new one.
                        this._transport = new beacon_utils_1.ExposedPromise();
                    }
                }
                return [2 /*return*/];
            });
        });
    };
    Client.prototype.addListener = function (transport) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                transport
                    .addListener(function (message, connectionInfo) { return __awaiter(_this, void 0, void 0, function () {
                    var deserializedMessage;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!(typeof message === 'string')) return [3 /*break*/, 2];
                                return [4 /*yield*/, new __1.Serializer().deserialize(message)];
                            case 1:
                                deserializedMessage = (_a.sent());
                                this.handleResponse(deserializedMessage, connectionInfo);
                                _a.label = 2;
                            case 2: return [2 /*return*/];
                        }
                    });
                }); })
                    .catch(function (error) { return logger.error('addListener', error); });
                return [2 /*return*/];
            });
        });
    };
    Client.prototype.sendDisconnectToPeer = function (peer, transport) {
        return __awaiter(this, void 0, void 0, function () {
            var request, _a, payload, selectedTransport, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _c = {};
                        return [4 /*yield*/, (0, beacon_utils_1.generateGUID)()];
                    case 1:
                        _c.id = _d.sent(),
                            _c.version = peer.version;
                        _a = get_sender_id_1.getSenderId;
                        return [4 /*yield*/, this.beaconId];
                    case 2: return [4 /*yield*/, _a.apply(void 0, [_d.sent()])];
                    case 3:
                        request = (_c.senderId = _d.sent(),
                            _c.type = beacon_types_1.BeaconMessageType.Disconnect,
                            _c);
                        return [4 /*yield*/, new __1.Serializer().serialize(request)];
                    case 4:
                        payload = _d.sent();
                        if (!(transport !== null && transport !== void 0)) return [3 /*break*/, 5];
                        _b = transport;
                        return [3 /*break*/, 7];
                    case 5: return [4 /*yield*/, this.transport];
                    case 6:
                        _b = (_d.sent());
                        _d.label = 7;
                    case 7:
                        selectedTransport = _b;
                        return [4 /*yield*/, selectedTransport.send(payload, peer)];
                    case 8:
                        _d.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return Client;
}(BeaconClient_1.BeaconClient));
exports.Client = Client;

},{"../..":58,"../../managers/AccountManager":59,"../../utils/Logger":71,"../../utils/get-sender-id":74,"../beacon-client/BeaconClient":42,"@airgap/beacon-types":104,"@airgap/beacon-utils":136}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NOTIFICATION_ORACLE_URL = exports.BEACON_VERSION = exports.SDK_VERSION = void 0;
exports.SDK_VERSION = '3.3.4';
exports.BEACON_VERSION = '3';
exports.NOTIFICATION_ORACLE_URL = 'https://beacon-notification-oracle.dev.gke.papers.tech';

},{}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDebugEnabled = exports.setDebugEnabled = void 0;
var MockWindow_1 = require("./MockWindow");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var debug = MockWindow_1.windowRef.beaconSdkDebugEnabled ? true : false;
if (debug) {
    // eslint-disable-next-line no-console
    console.log('[BEACON]: Debug mode is ON (turned on either by the developer or a browser extension)');
}
var setDebugEnabled = function (enabled) {
    debug = enabled;
};
exports.setDebugEnabled = setDebugEnabled;
var getDebugEnabled = function () { return debug; };
exports.getDebugEnabled = getDebugEnabled;

},{"./MockWindow":40}],46:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbortedBeaconError = void 0;
var __1 = require("..");
var beacon_types_1 = require("@airgap/beacon-types");
/**
 * @category Error
 */
var AbortedBeaconError = /** @class */ (function (_super) {
    __extends(AbortedBeaconError, _super);
    function AbortedBeaconError() {
        var _this = _super.call(this, beacon_types_1.BeaconErrorType.ABORTED_ERROR, 'The action was aborted by the user.') || this;
        _this.name = 'UnknownBeaconError';
        _this.title = 'Aborted';
        return _this;
    }
    return AbortedBeaconError;
}(__1.BeaconError));
exports.AbortedBeaconError = AbortedBeaconError;

},{"..":58,"@airgap/beacon-types":104}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BeaconError = void 0;
var assert_never_1 = require("../utils/assert-never");
var __1 = require("..");
var beacon_types_1 = require("@airgap/beacon-types");
/**
 * @category Error
 */
var BeaconError = /** @class */ (function () {
    function BeaconError(errorType, message) {
        this.name = 'BeaconError';
        this.title = 'Error'; // Visible in the UI
        this.message = "[".concat(errorType, "]:").concat(message);
        this.description = message;
    }
    Object.defineProperty(BeaconError.prototype, "fullDescription", {
        get: function () {
            return { description: this.description };
        },
        enumerable: false,
        configurable: true
    });
    BeaconError.getError = function (errorType, errorData) {
        switch (errorType) {
            case beacon_types_1.BeaconErrorType.BROADCAST_ERROR:
                return new __1.BroadcastBeaconError();
            case beacon_types_1.BeaconErrorType.NETWORK_NOT_SUPPORTED:
                return new __1.NetworkNotSupportedBeaconError();
            case beacon_types_1.BeaconErrorType.NO_ADDRESS_ERROR:
                return new __1.NoAddressBeaconError();
            case beacon_types_1.BeaconErrorType.NO_PRIVATE_KEY_FOUND_ERROR:
                return new __1.NoPrivateKeyBeaconError();
            case beacon_types_1.BeaconErrorType.NOT_GRANTED_ERROR:
                return new __1.NotGrantedBeaconError();
            case beacon_types_1.BeaconErrorType.PARAMETERS_INVALID_ERROR:
                return new __1.ParametersInvalidBeaconError();
            case beacon_types_1.BeaconErrorType.TOO_MANY_OPERATIONS:
                return new __1.TooManyOperationsBeaconError();
            case beacon_types_1.BeaconErrorType.TRANSACTION_INVALID_ERROR:
                return new __1.TransactionInvalidBeaconError(errorData);
            case beacon_types_1.BeaconErrorType.SIGNATURE_TYPE_NOT_SUPPORTED:
                return new __1.SignatureTypeNotSupportedBeaconError();
            // case BeaconErrorType.ENCRYPTION_TYPE_NOT_SUPPORTED:
            //   return new EncryptionTypeNotSupportedBeaconError()
            case beacon_types_1.BeaconErrorType.ABORTED_ERROR:
                return new __1.AbortedBeaconError();
            case beacon_types_1.BeaconErrorType.UNKNOWN_ERROR:
                return new __1.UnknownBeaconError();
            default:
                (0, assert_never_1.assertNever)(errorType);
        }
    };
    return BeaconError;
}());
exports.BeaconError = BeaconError;

},{"..":58,"../utils/assert-never":72,"@airgap/beacon-types":104}],48:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.BroadcastBeaconError = void 0;
var __1 = require("..");
var beacon_types_1 = require("@airgap/beacon-types");
/**
 * @category Error
 */
var BroadcastBeaconError = /** @class */ (function (_super) {
    __extends(BroadcastBeaconError, _super);
    function BroadcastBeaconError() {
        var _this = _super.call(this, beacon_types_1.BeaconErrorType.BROADCAST_ERROR, 'The transaction could not be broadcast to the network. Please try again.') || this;
        _this.name = 'BroadcastBeaconError';
        _this.title = 'Broadcast Error';
        return _this;
    }
    return BroadcastBeaconError;
}(__1.BeaconError));
exports.BroadcastBeaconError = BroadcastBeaconError;

},{"..":58,"@airgap/beacon-types":104}],49:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkNotSupportedBeaconError = void 0;
var __1 = require("..");
var beacon_types_1 = require("@airgap/beacon-types");
/**
 * @category Error
 */
var NetworkNotSupportedBeaconError = /** @class */ (function (_super) {
    __extends(NetworkNotSupportedBeaconError, _super);
    function NetworkNotSupportedBeaconError() {
        var _this = _super.call(this, beacon_types_1.BeaconErrorType.NETWORK_NOT_SUPPORTED, 'The wallet does not support this network. Please select another one.') || this;
        _this.name = 'NetworkNotSupportedBeaconError';
        _this.title = 'Network Error';
        return _this;
    }
    return NetworkNotSupportedBeaconError;
}(__1.BeaconError));
exports.NetworkNotSupportedBeaconError = NetworkNotSupportedBeaconError;

},{"..":58,"@airgap/beacon-types":104}],50:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoAddressBeaconError = void 0;
var __1 = require("..");
var beacon_types_1 = require("@airgap/beacon-types");
/**
 * @category Error
 */
var NoAddressBeaconError = /** @class */ (function (_super) {
    __extends(NoAddressBeaconError, _super);
    function NoAddressBeaconError() {
        var _this = _super.call(this, beacon_types_1.BeaconErrorType.NO_ADDRESS_ERROR, 'The wallet does not have an account set up. Please make sure to set up your wallet and try again.') || this;
        _this.name = 'NoAddressBeaconError';
        _this.title = 'No Address';
        return _this;
    }
    return NoAddressBeaconError;
}(__1.BeaconError));
exports.NoAddressBeaconError = NoAddressBeaconError;

},{"..":58,"@airgap/beacon-types":104}],51:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoPrivateKeyBeaconError = void 0;
var __1 = require("..");
var beacon_types_1 = require("@airgap/beacon-types");
/**
 * @category Error
 */
var NoPrivateKeyBeaconError = /** @class */ (function (_super) {
    __extends(NoPrivateKeyBeaconError, _super);
    function NoPrivateKeyBeaconError() {
        var _this = _super.call(this, beacon_types_1.BeaconErrorType.NO_PRIVATE_KEY_FOUND_ERROR, 'The account you are trying to interact with is not available. Please make sure to add the account to your wallet and try again.') || this;
        _this.name = 'NoPrivateKeyBeaconError';
        _this.title = 'Account Not Found';
        return _this;
    }
    return NoPrivateKeyBeaconError;
}(__1.BeaconError));
exports.NoPrivateKeyBeaconError = NoPrivateKeyBeaconError;

},{"..":58,"@airgap/beacon-types":104}],52:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotGrantedBeaconError = void 0;
var __1 = require("..");
var beacon_types_1 = require("@airgap/beacon-types");
/**
 * @category Error
 */
var NotGrantedBeaconError = /** @class */ (function (_super) {
    __extends(NotGrantedBeaconError, _super);
    function NotGrantedBeaconError() {
        var _this = _super.call(this, beacon_types_1.BeaconErrorType.NOT_GRANTED_ERROR, 'You do not have the necessary permissions to perform this action. Please initiate another permission request and give the necessary permissions.') || this;
        _this.name = 'NotGrantedBeaconError';
        _this.title = 'Permission Not Granted';
        return _this;
    }
    return NotGrantedBeaconError;
}(__1.BeaconError));
exports.NotGrantedBeaconError = NotGrantedBeaconError;

},{"..":58,"@airgap/beacon-types":104}],53:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParametersInvalidBeaconError = void 0;
var __1 = require("..");
var beacon_types_1 = require("@airgap/beacon-types");
/**
 * @category Error
 */
var ParametersInvalidBeaconError = /** @class */ (function (_super) {
    __extends(ParametersInvalidBeaconError, _super);
    function ParametersInvalidBeaconError() {
        var _this = _super.call(this, beacon_types_1.BeaconErrorType.PARAMETERS_INVALID_ERROR, 'Some of the parameters you provided are invalid and the request could not be completed. Please check your inputs and try again.') || this;
        _this.name = 'ParametersInvalidBeaconError';
        _this.title = 'Parameters Invalid';
        return _this;
    }
    return ParametersInvalidBeaconError;
}(__1.BeaconError));
exports.ParametersInvalidBeaconError = ParametersInvalidBeaconError;

},{"..":58,"@airgap/beacon-types":104}],54:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignatureTypeNotSupportedBeaconError = void 0;
var __1 = require("..");
var beacon_types_1 = require("@airgap/beacon-types");
/**
 * @category Error
 */
var SignatureTypeNotSupportedBeaconError = /** @class */ (function (_super) {
    __extends(SignatureTypeNotSupportedBeaconError, _super);
    function SignatureTypeNotSupportedBeaconError() {
        var _this = _super.call(this, beacon_types_1.BeaconErrorType.SIGNATURE_TYPE_NOT_SUPPORTED, 'The wallet is not able to sign payloads of this type.') || this;
        _this.name = 'SignatureTypeNotSupportedBeaconError';
        _this.title = 'Signature Type Not Supported';
        return _this;
    }
    return SignatureTypeNotSupportedBeaconError;
}(__1.BeaconError));
exports.SignatureTypeNotSupportedBeaconError = SignatureTypeNotSupportedBeaconError;

},{"..":58,"@airgap/beacon-types":104}],55:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.TooManyOperationsBeaconError = void 0;
var __1 = require("..");
var beacon_types_1 = require("@airgap/beacon-types");
/**
 * @category Error
 */
var TooManyOperationsBeaconError = /** @class */ (function (_super) {
    __extends(TooManyOperationsBeaconError, _super);
    function TooManyOperationsBeaconError() {
        var _this = _super.call(this, beacon_types_1.BeaconErrorType.TOO_MANY_OPERATIONS, 'The request contains too many transactions. Please include fewer operations and try again.') || this;
        _this.name = 'TooManyOperationsBeaconError';
        _this.title = 'Too Many Operations';
        return _this;
    }
    return TooManyOperationsBeaconError;
}(__1.BeaconError));
exports.TooManyOperationsBeaconError = TooManyOperationsBeaconError;

},{"..":58,"@airgap/beacon-types":104}],56:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionInvalidBeaconError = void 0;
var __1 = require("..");
var beacon_types_1 = require("@airgap/beacon-types");
/**
 * @category Error
 */
var TransactionInvalidBeaconError = /** @class */ (function (_super) {
    __extends(TransactionInvalidBeaconError, _super);
    function TransactionInvalidBeaconError(data) {
        var _this = _super.call(this, beacon_types_1.BeaconErrorType.TRANSACTION_INVALID_ERROR, "The transaction is invalid and the node did not accept it.") || this;
        _this.data = data;
        _this.name = 'TransactionInvalidBeaconError';
        _this.title = 'Transaction Invalid';
        _this.data = data;
        return _this;
    }
    Object.defineProperty(TransactionInvalidBeaconError.prototype, "fullDescription", {
        get: function () {
            return { description: this.description, data: JSON.stringify(this.data, undefined, 2) };
        },
        enumerable: false,
        configurable: true
    });
    return TransactionInvalidBeaconError;
}(__1.BeaconError));
exports.TransactionInvalidBeaconError = TransactionInvalidBeaconError;

},{"..":58,"@airgap/beacon-types":104}],57:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnknownBeaconError = void 0;
var __1 = require("..");
var beacon_types_1 = require("@airgap/beacon-types");
/**
 * @category Error
 */
var UnknownBeaconError = /** @class */ (function (_super) {
    __extends(UnknownBeaconError, _super);
    function UnknownBeaconError() {
        var _this = _super.call(this, beacon_types_1.BeaconErrorType.UNKNOWN_ERROR, 'An unknown error occured. Please try again or report it to a developer.') || this;
        _this.name = 'UnknownBeaconError';
        _this.title = 'Error';
        return _this;
    }
    return UnknownBeaconError;
}(__1.BeaconError));
exports.UnknownBeaconError = UnknownBeaconError;

},{"..":58,"@airgap/beacon-types":104}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NOTIFICATION_ORACLE_URL = exports.getDebugEnabled = exports.setDebugEnabled = exports.getLogger = exports.setLogger = exports.Logger = exports.Serializer = exports.windowRef = exports.getAccountIdentifier = exports.getSenderId = exports.BEACON_VERSION = exports.SDK_VERSION = exports.PermissionManager = exports.AppMetadataManager = exports.AccountManager = exports.PeerManager = exports.getStorage = exports.LocalStorage = exports.ChromeStorage = exports.CommunicationClient = exports.MessageBasedClient = exports.Transport = exports.UnknownBeaconError = exports.SignatureTypeNotSupportedBeaconError = exports.TransactionInvalidBeaconError = exports.TooManyOperationsBeaconError = exports.ParametersInvalidBeaconError = exports.NotGrantedBeaconError = exports.NoPrivateKeyBeaconError = exports.NoAddressBeaconError = exports.NetworkNotSupportedBeaconError = exports.BroadcastBeaconError = exports.AbortedBeaconError = exports.BeaconError = exports.Client = exports.BeaconClient = void 0;
/**
 * General docs
 * @module public
 */
var Client_1 = require("./clients/client/Client");
Object.defineProperty(exports, "Client", { enumerable: true, get: function () { return Client_1.Client; } });
var BeaconError_1 = require("./errors/BeaconError");
Object.defineProperty(exports, "BeaconError", { enumerable: true, get: function () { return BeaconError_1.BeaconError; } });
var BroadcastBeaconError_1 = require("./errors/BroadcastBeaconError");
Object.defineProperty(exports, "BroadcastBeaconError", { enumerable: true, get: function () { return BroadcastBeaconError_1.BroadcastBeaconError; } });
var NetworkNotSupportedBeaconError_1 = require("./errors/NetworkNotSupportedBeaconError");
Object.defineProperty(exports, "NetworkNotSupportedBeaconError", { enumerable: true, get: function () { return NetworkNotSupportedBeaconError_1.NetworkNotSupportedBeaconError; } });
var NoAddressBeaconError_1 = require("./errors/NoAddressBeaconError");
Object.defineProperty(exports, "NoAddressBeaconError", { enumerable: true, get: function () { return NoAddressBeaconError_1.NoAddressBeaconError; } });
var NoPrivateKeyBeaconError_1 = require("./errors/NoPrivateKeyBeaconError");
Object.defineProperty(exports, "NoPrivateKeyBeaconError", { enumerable: true, get: function () { return NoPrivateKeyBeaconError_1.NoPrivateKeyBeaconError; } });
var NotGrantedBeaconError_1 = require("./errors/NotGrantedBeaconError");
Object.defineProperty(exports, "NotGrantedBeaconError", { enumerable: true, get: function () { return NotGrantedBeaconError_1.NotGrantedBeaconError; } });
var ParametersInvalidBeaconError_1 = require("./errors/ParametersInvalidBeaconError");
Object.defineProperty(exports, "ParametersInvalidBeaconError", { enumerable: true, get: function () { return ParametersInvalidBeaconError_1.ParametersInvalidBeaconError; } });
var TooManyOperationsBeaconError_1 = require("./errors/TooManyOperationsBeaconError");
Object.defineProperty(exports, "TooManyOperationsBeaconError", { enumerable: true, get: function () { return TooManyOperationsBeaconError_1.TooManyOperationsBeaconError; } });
var TransactionInvalidBeaconError_1 = require("./errors/TransactionInvalidBeaconError");
Object.defineProperty(exports, "TransactionInvalidBeaconError", { enumerable: true, get: function () { return TransactionInvalidBeaconError_1.TransactionInvalidBeaconError; } });
var UnknownBeaconError_1 = require("./errors/UnknownBeaconError");
Object.defineProperty(exports, "UnknownBeaconError", { enumerable: true, get: function () { return UnknownBeaconError_1.UnknownBeaconError; } });
var Transport_1 = require("./transports/Transport");
Object.defineProperty(exports, "Transport", { enumerable: true, get: function () { return Transport_1.Transport; } });
var ChromeStorage_1 = require("./storage/ChromeStorage");
Object.defineProperty(exports, "ChromeStorage", { enumerable: true, get: function () { return ChromeStorage_1.ChromeStorage; } });
var LocalStorage_1 = require("./storage/LocalStorage");
Object.defineProperty(exports, "LocalStorage", { enumerable: true, get: function () { return LocalStorage_1.LocalStorage; } });
var getStorage_1 = require("./storage/getStorage");
Object.defineProperty(exports, "getStorage", { enumerable: true, get: function () { return getStorage_1.getStorage; } });
var Serializer_1 = require("./Serializer");
Object.defineProperty(exports, "Serializer", { enumerable: true, get: function () { return Serializer_1.Serializer; } });
var constants_1 = require("./constants");
Object.defineProperty(exports, "SDK_VERSION", { enumerable: true, get: function () { return constants_1.SDK_VERSION; } });
Object.defineProperty(exports, "BEACON_VERSION", { enumerable: true, get: function () { return constants_1.BEACON_VERSION; } });
var AccountManager_1 = require("./managers/AccountManager");
Object.defineProperty(exports, "AccountManager", { enumerable: true, get: function () { return AccountManager_1.AccountManager; } });
var AppMetadataManager_1 = require("./managers/AppMetadataManager");
Object.defineProperty(exports, "AppMetadataManager", { enumerable: true, get: function () { return AppMetadataManager_1.AppMetadataManager; } });
var PermissionManager_1 = require("./managers/PermissionManager");
Object.defineProperty(exports, "PermissionManager", { enumerable: true, get: function () { return PermissionManager_1.PermissionManager; } });
var BeaconClient_1 = require("./clients/beacon-client/BeaconClient");
Object.defineProperty(exports, "BeaconClient", { enumerable: true, get: function () { return BeaconClient_1.BeaconClient; } });
var get_account_identifier_1 = require("./utils/get-account-identifier");
Object.defineProperty(exports, "getAccountIdentifier", { enumerable: true, get: function () { return get_account_identifier_1.getAccountIdentifier; } });
var AbortedBeaconError_1 = require("./errors/AbortedBeaconError");
Object.defineProperty(exports, "AbortedBeaconError", { enumerable: true, get: function () { return AbortedBeaconError_1.AbortedBeaconError; } });
var get_sender_id_1 = require("./utils/get-sender-id");
Object.defineProperty(exports, "getSenderId", { enumerable: true, get: function () { return get_sender_id_1.getSenderId; } });
var PeerManager_1 = require("./managers/PeerManager");
Object.defineProperty(exports, "PeerManager", { enumerable: true, get: function () { return PeerManager_1.PeerManager; } });
var MessageBasedClient_1 = require("./transports/clients/MessageBasedClient");
Object.defineProperty(exports, "MessageBasedClient", { enumerable: true, get: function () { return MessageBasedClient_1.MessageBasedClient; } });
var debug_1 = require("./debug");
Object.defineProperty(exports, "setDebugEnabled", { enumerable: true, get: function () { return debug_1.setDebugEnabled; } });
Object.defineProperty(exports, "getDebugEnabled", { enumerable: true, get: function () { return debug_1.getDebugEnabled; } });
// import { EncryptPayloadRequest } from './types/beacon/messages/EncryptPayloadRequest'
// import { EncryptPayloadResponse } from './types/beacon/messages/EncryptPayloadResponse'
// import { EncryptionTypeNotSupportedBeaconError } from './errors/EncryptionTypeNotSupportedBeaconError'
var SignatureTypeNotSupportedBeaconError_1 = require("./errors/SignatureTypeNotSupportedBeaconError");
Object.defineProperty(exports, "SignatureTypeNotSupportedBeaconError", { enumerable: true, get: function () { return SignatureTypeNotSupportedBeaconError_1.SignatureTypeNotSupportedBeaconError; } });
var Logger_1 = require("./utils/Logger");
Object.defineProperty(exports, "getLogger", { enumerable: true, get: function () { return Logger_1.getLogger; } });
Object.defineProperty(exports, "Logger", { enumerable: true, get: function () { return Logger_1.Logger; } });
Object.defineProperty(exports, "setLogger", { enumerable: true, get: function () { return Logger_1.setLogger; } });
var MockWindow_1 = require("./MockWindow");
Object.defineProperty(exports, "windowRef", { enumerable: true, get: function () { return MockWindow_1.windowRef; } });
var CommunicationClient_1 = require("./transports/clients/CommunicationClient");
Object.defineProperty(exports, "CommunicationClient", { enumerable: true, get: function () { return CommunicationClient_1.CommunicationClient; } });
var constants_2 = require("./constants");
Object.defineProperty(exports, "NOTIFICATION_ORACLE_URL", { enumerable: true, get: function () { return constants_2.NOTIFICATION_ORACLE_URL; } });

},{"./MockWindow":40,"./Serializer":41,"./clients/beacon-client/BeaconClient":42,"./clients/client/Client":43,"./constants":44,"./debug":45,"./errors/AbortedBeaconError":46,"./errors/BeaconError":47,"./errors/BroadcastBeaconError":48,"./errors/NetworkNotSupportedBeaconError":49,"./errors/NoAddressBeaconError":50,"./errors/NoPrivateKeyBeaconError":51,"./errors/NotGrantedBeaconError":52,"./errors/ParametersInvalidBeaconError":53,"./errors/SignatureTypeNotSupportedBeaconError":54,"./errors/TooManyOperationsBeaconError":55,"./errors/TransactionInvalidBeaconError":56,"./errors/UnknownBeaconError":57,"./managers/AccountManager":59,"./managers/AppMetadataManager":60,"./managers/PeerManager":61,"./managers/PermissionManager":62,"./storage/ChromeStorage":65,"./storage/LocalStorage":66,"./storage/getStorage":67,"./transports/Transport":68,"./transports/clients/CommunicationClient":69,"./transports/clients/MessageBasedClient":70,"./utils/Logger":71,"./utils/get-account-identifier":73,"./utils/get-sender-id":74}],59:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountManager = void 0;
var beacon_types_1 = require("@airgap/beacon-types");
var StorageManager_1 = require("./StorageManager");
var PermissionValidator_1 = require("./PermissionValidator");
/**
 * @internalapi
 *
 * The AccountManager provides CRUD functionality for account entities and persists them to the provided storage.
 */
var AccountManager = /** @class */ (function () {
    function AccountManager(storage) {
        this.storageManager = new StorageManager_1.StorageManager(storage, beacon_types_1.StorageKey.ACCOUNTS);
    }
    AccountManager.prototype.getAccounts = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.getAll()];
            });
        });
    };
    AccountManager.prototype.getAccount = function (accountIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.getOne(function (account) { return account.accountIdentifier === accountIdentifier; })];
            });
        });
    };
    AccountManager.prototype.addAccount = function (accountInfo) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.addOne(accountInfo, function (account) { return account.accountIdentifier === accountInfo.accountIdentifier; })];
            });
        });
    };
    AccountManager.prototype.removeAccount = function (accountIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.remove(function (account) { return account.accountIdentifier === accountIdentifier; })];
            });
        });
    };
    AccountManager.prototype.removeAccounts = function (accountIdentifiers) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.remove(function (account) {
                        return accountIdentifiers.includes(account.accountIdentifier);
                    })];
            });
        });
    };
    AccountManager.prototype.removeAllAccounts = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.removeAll()];
            });
        });
    };
    AccountManager.prototype.hasPermission = function (message) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, PermissionValidator_1.PermissionValidator.hasPermission(message, this.getAccount.bind(this), this.getAccounts.bind(this))];
            });
        });
    };
    return AccountManager;
}());
exports.AccountManager = AccountManager;

},{"./PermissionValidator":63,"./StorageManager":64,"@airgap/beacon-types":104}],60:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppMetadataManager = void 0;
var beacon_types_1 = require("@airgap/beacon-types");
var StorageManager_1 = require("./StorageManager");
/**
 * @internalapi
 *
 * The AppMetadataManager provides CRUD functionality for app-metadata entities and persists them to the provided storage.
 */
var AppMetadataManager = /** @class */ (function () {
    function AppMetadataManager(storage) {
        this.storageManager = new StorageManager_1.StorageManager(storage, beacon_types_1.StorageKey.APP_METADATA_LIST);
    }
    AppMetadataManager.prototype.getAppMetadataList = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.getAll()];
            });
        });
    };
    AppMetadataManager.prototype.getAppMetadata = function (senderId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.getOne(function (appMetadata) { return appMetadata.senderId === senderId; })];
            });
        });
    };
    AppMetadataManager.prototype.addAppMetadata = function (appMetadata) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.addOne(appMetadata, function (appMetadataElement) { return appMetadataElement.senderId === appMetadata.senderId; })];
            });
        });
    };
    AppMetadataManager.prototype.removeAppMetadata = function (senderId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.remove(function (appMetadata) { return appMetadata.senderId === senderId; })];
            });
        });
    };
    AppMetadataManager.prototype.removeAppMetadatas = function (senderIds) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.remove(function (appMetadata) {
                        return senderIds.includes(appMetadata.senderId);
                    })];
            });
        });
    };
    AppMetadataManager.prototype.removeAllAppMetadata = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.removeAll()];
            });
        });
    };
    return AppMetadataManager;
}());
exports.AppMetadataManager = AppMetadataManager;

},{"./StorageManager":64,"@airgap/beacon-types":104}],61:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PeerManager = void 0;
var StorageManager_1 = require("./StorageManager");
/**
 * @internalapi
 *
 * The PeerManager provides CRUD functionality for peer entities and persists them to the provided storage.
 */
var PeerManager = /** @class */ (function () {
    function PeerManager(storage, key) {
        this.storageManager = new StorageManager_1.StorageManager(storage, key);
    }
    PeerManager.prototype.hasPeer = function (publicKey) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getPeer(publicKey)];
                    case 1: return [2 /*return*/, (_a.sent()) ? true : false];
                }
            });
        });
    };
    PeerManager.prototype.getPeers = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.getAll()];
            });
        });
    };
    PeerManager.prototype.getPeer = function (publicKey) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.getOne(function (peer) { return peer.publicKey === publicKey; })];
            });
        });
    };
    PeerManager.prototype.addPeer = function (peerInfo) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.addOne(peerInfo, function (peer) { return peer.publicKey === peerInfo.publicKey; })];
            });
        });
    };
    PeerManager.prototype.removePeer = function (publicKey) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.remove(function (peer) { return peer.publicKey === publicKey; })];
            });
        });
    };
    PeerManager.prototype.removePeers = function (publicKeys) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.remove(function (peer) { return publicKeys.includes(peer.publicKey); })];
            });
        });
    };
    PeerManager.prototype.removeAllPeers = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.removeAll()];
            });
        });
    };
    return PeerManager;
}());
exports.PeerManager = PeerManager;

},{"./StorageManager":64}],62:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionManager = void 0;
var beacon_types_1 = require("@airgap/beacon-types");
var StorageManager_1 = require("./StorageManager");
var PermissionValidator_1 = require("./PermissionValidator");
/**
 * @internalapi
 *
 * The PermissionManager provides CRUD functionality for permission entities and persists them to the provided storage.
 */
var PermissionManager = /** @class */ (function () {
    function PermissionManager(storage) {
        this.storageManager = new StorageManager_1.StorageManager(storage, beacon_types_1.StorageKey.PERMISSION_LIST);
    }
    PermissionManager.prototype.getPermissions = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.getAll()];
            });
        });
    };
    PermissionManager.prototype.getPermission = function (accountIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.getOne(function (permission) { return permission.accountIdentifier === accountIdentifier; })];
            });
        });
    };
    PermissionManager.prototype.addPermission = function (permissionInfo) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.addOne(permissionInfo, function (permission) {
                        return permission.accountIdentifier === permissionInfo.accountIdentifier;
                    })];
            });
        });
    };
    PermissionManager.prototype.removePermission = function (accountIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.remove(function (permissionInfo) { return permissionInfo.accountIdentifier === accountIdentifier; })];
            });
        });
    };
    PermissionManager.prototype.removePermissions = function (accountIdentifiers) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.remove(function (permission) {
                        return accountIdentifiers.includes(permission.accountIdentifier);
                    })];
            });
        });
    };
    PermissionManager.prototype.removeAllPermissions = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storageManager.removeAll()];
            });
        });
    };
    PermissionManager.prototype.hasPermission = function (message) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, PermissionValidator_1.PermissionValidator.hasPermission(message, this.getPermission.bind(this), this.getPermissions.bind(this))];
            });
        });
    };
    return PermissionManager;
}());
exports.PermissionManager = PermissionManager;

},{"./PermissionValidator":63,"./StorageManager":64,"@airgap/beacon-types":104}],63:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionValidator = void 0;
var beacon_types_1 = require("@airgap/beacon-types");
var get_account_identifier_1 = require("../utils/get-account-identifier");
/**
 * @internalapi
 *
 * The PermissionValidator is used to check if permissions for a certain message type have been given
 */
var PermissionValidator = /** @class */ (function () {
    function PermissionValidator() {
    }
    /**
     * Check if permissions were given for a certain message type.
     *
     * PermissionRequest and BroadcastRequest will always return true.
     *
     * @param message Beacon Message
     */
    PermissionValidator.hasPermission = function (message, getOne, getAll) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, accountIdentifier, permission, permissions, filteredPermissions;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = message.type;
                        switch (_a) {
                            case beacon_types_1.BeaconMessageType.PermissionRequest: return [3 /*break*/, 1];
                            case beacon_types_1.BeaconMessageType.BroadcastRequest: return [3 /*break*/, 1];
                            case beacon_types_1.BeaconMessageType.OperationRequest: return [3 /*break*/, 2];
                            case beacon_types_1.BeaconMessageType.SignPayloadRequest: return [3 /*break*/, 5];
                        }
                        return [3 /*break*/, 7];
                    case 1:
                        {
                            return [2 /*return*/, true];
                        }
                        _b.label = 2;
                    case 2: return [4 /*yield*/, (0, get_account_identifier_1.getAccountIdentifier)(message.sourceAddress, message.network)];
                    case 3:
                        accountIdentifier = _b.sent();
                        return [4 /*yield*/, getOne(accountIdentifier)];
                    case 4:
                        permission = _b.sent();
                        if (!permission) {
                            return [2 /*return*/, false];
                        }
                        return [2 /*return*/, permission.scopes.includes(beacon_types_1.PermissionScope.OPERATION_REQUEST)];
                    case 5: return [4 /*yield*/, getAll()];
                    case 6:
                        permissions = _b.sent();
                        filteredPermissions = permissions.filter(function (permission) { return permission.address === message.sourceAddress; });
                        if (filteredPermissions.length === 0) {
                            return [2 /*return*/, false];
                        }
                        return [2 /*return*/, filteredPermissions.some(function (permission) {
                                return permission.scopes.includes(beacon_types_1.PermissionScope.SIGN);
                            })];
                    case 7: throw new Error('Message not handled');
                }
            });
        });
    };
    return PermissionValidator;
}());
exports.PermissionValidator = PermissionValidator;

},{"../utils/get-account-identifier":73,"@airgap/beacon-types":104}],64:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageManager = void 0;
/* eslint-disable prefer-arrow/prefer-arrow-functions */
function fixArrayType(array) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return array;
}
/* eslint-enable prefer-arrow/prefer-arrow-functions */
/**
 * @internalapi
 *
 * The StorageManager provides CRUD functionality for specific entities and persists them to the provided storage.
 */
var StorageManager = /** @class */ (function () {
    function StorageManager(storage, storageKey) {
        this.storage = storage;
        this.storageKey = storageKey;
    }
    StorageManager.prototype.getAll = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storage.get(this.storageKey)];
            });
        });
    };
    StorageManager.prototype.getOne = function (predicate) {
        return __awaiter(this, void 0, void 0, function () {
            var entities;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.storage.get(this.storageKey)];
                    case 1:
                        entities = _a.sent();
                        return [2 /*return*/, fixArrayType(entities).find(predicate)];
                }
            });
        });
    };
    StorageManager.prototype.addOne = function (element, predicate, overwrite) {
        if (overwrite === void 0) { overwrite = true; }
        return __awaiter(this, void 0, void 0, function () {
            var entities, i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.storage.get(this.storageKey)];
                    case 1:
                        entities = _a.sent();
                        if (!fixArrayType(entities).some(predicate)) {
                            fixArrayType(entities).push(element);
                        }
                        else if (overwrite) {
                            for (i = 0; i < entities.length; i++) {
                                if (predicate(fixArrayType(entities)[i])) {
                                    entities[i] = element;
                                }
                            }
                        }
                        return [2 /*return*/, this.storage.set(this.storageKey, entities)];
                }
            });
        });
    };
    StorageManager.prototype.remove = function (predicate) {
        return __awaiter(this, void 0, void 0, function () {
            var entities, filteredEntities;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.storage.get(this.storageKey)];
                    case 1:
                        entities = _a.sent();
                        filteredEntities = fixArrayType(entities).filter(function (entity) { return !predicate(entity); });
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        return [2 /*return*/, this.storage.set(this.storageKey, filteredEntities)];
                }
            });
        });
    };
    StorageManager.prototype.removeAll = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.storage.delete(this.storageKey)];
            });
        });
    };
    return StorageManager;
}());
exports.StorageManager = StorageManager;

},{}],65:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChromeStorage = void 0;
var beacon_types_1 = require("@airgap/beacon-types");
/**
 * @internalapi
 *
 * A storage that can be used in chrome extensions
 */
var ChromeStorage = /** @class */ (function () {
    function ChromeStorage() {
    }
    ChromeStorage.isSupported = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (typeof window !== 'undefined' &&
                        typeof chrome !== 'undefined' &&
                        Boolean(chrome) &&
                        Boolean(chrome.runtime) &&
                        Boolean(chrome.runtime.id))];
            });
        });
    };
    ChromeStorage.prototype.get = function (key) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) {
                        chrome.storage.local.get(null, function (storageContent) {
                            if (storageContent[key]) {
                                resolve(storageContent[key]);
                            }
                            else {
                                if (typeof beacon_types_1.defaultValues[key] === 'object') {
                                    resolve(JSON.parse(JSON.stringify(beacon_types_1.defaultValues[key])));
                                }
                                else {
                                    resolve(beacon_types_1.defaultValues[key]);
                                }
                            }
                        });
                    })];
            });
        });
    };
    ChromeStorage.prototype.set = function (key, value) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) {
                        var _a;
                        chrome.storage.local.set((_a = {}, _a[key] = value, _a), function () {
                            resolve();
                        });
                    })];
            });
        });
    };
    ChromeStorage.prototype.delete = function (key) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) {
                        var _a;
                        chrome.storage.local.set((_a = {}, _a[key] = undefined, _a), function () {
                            resolve();
                        });
                    })];
            });
        });
    };
    return ChromeStorage;
}());
exports.ChromeStorage = ChromeStorage;

},{"@airgap/beacon-types":104}],66:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalStorage = void 0;
var beacon_types_1 = require("@airgap/beacon-types");
/**
 * @internalapi
 *
 * A storage that can be used in the browser
 */
var LocalStorage = /** @class */ (function () {
    function LocalStorage(prefix) {
        this.prefix = prefix;
    }
    LocalStorage.isSupported = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, Promise.resolve(Boolean(typeof window !== 'undefined') && Boolean(window.localStorage))];
            });
        });
    };
    LocalStorage.prototype.get = function (key) {
        return __awaiter(this, void 0, void 0, function () {
            var value;
            return __generator(this, function (_a) {
                value = localStorage.getItem(this.getPrefixedKey(key));
                if (!value) {
                    if (typeof beacon_types_1.defaultValues[key] === 'object') {
                        return [2 /*return*/, JSON.parse(JSON.stringify(beacon_types_1.defaultValues[key]))];
                    }
                    else {
                        return [2 /*return*/, beacon_types_1.defaultValues[key]];
                    }
                }
                else {
                    try {
                        return [2 /*return*/, JSON.parse(value)];
                    }
                    catch (jsonParseError) {
                        return [2 /*return*/, value]; // TODO: Validate storage
                    }
                }
                return [2 /*return*/];
            });
        });
    };
    LocalStorage.prototype.set = function (key, value) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (typeof value === 'string') {
                    return [2 /*return*/, localStorage.setItem(this.getPrefixedKey(key), value)];
                }
                else {
                    return [2 /*return*/, localStorage.setItem(this.getPrefixedKey(key), JSON.stringify(value))];
                }
                return [2 /*return*/];
            });
        });
    };
    LocalStorage.prototype.delete = function (key) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, Promise.resolve(localStorage.removeItem(this.getPrefixedKey(key)))];
            });
        });
    };
    LocalStorage.prototype.getPrefixedKey = function (key) {
        return this.prefix ? "".concat(this.prefix, "-").concat(key) : key;
    };
    return LocalStorage;
}());
exports.LocalStorage = LocalStorage;

},{"@airgap/beacon-types":104}],67:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStorage = void 0;
var Logger_1 = require("../utils/Logger");
var __1 = require("..");
var logger = new Logger_1.Logger('STORAGE');
/**
 * Get a supported storage on this platform
 */
var getStorage = function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, __1.ChromeStorage.isSupported()];
            case 1:
                if (!_a.sent()) return [3 /*break*/, 2];
                logger.log('getStorage', 'USING CHROME STORAGE');
                return [2 /*return*/, new __1.ChromeStorage()];
            case 2: return [4 /*yield*/, __1.LocalStorage.isSupported()];
            case 3:
                if (_a.sent()) {
                    logger.log('getStorage', 'USING LOCAL STORAGE');
                    return [2 /*return*/, new __1.LocalStorage()];
                }
                else {
                    throw new Error('no storage type supported');
                }
                _a.label = 4;
            case 4: return [2 /*return*/];
        }
    });
}); };
exports.getStorage = getStorage;

},{"..":58,"../utils/Logger":71}],68:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transport = void 0;
var Logger_1 = require("../utils/Logger");
var beacon_types_1 = require("@airgap/beacon-types");
var logger = new Logger_1.Logger('Transport');
/**
 * @internalapi
 *
 *
 */
var Transport = /** @class */ (function () {
    function Transport(name, client, peerManager) {
        /**
         * The type of the transport
         */
        this.type = beacon_types_1.TransportType.POST_MESSAGE;
        /**
         * The status of the transport
         */
        this._isConnected = beacon_types_1.TransportStatus.NOT_CONNECTED;
        /**
         * The listeners that will be notified when new messages are coming in
         */
        this.listeners = [];
        this.name = name;
        this.client = client;
        this.peerManager = peerManager;
    }
    Object.defineProperty(Transport.prototype, "connectionStatus", {
        /**
         * Return the status of the connection
         */
        get: function () {
            return this._isConnected;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns a promise that resolves to true if the transport is available, false if it is not
     */
    Transport.isAvailable = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, Promise.resolve(false)];
            });
        });
    };
    /**
     * Connect the transport
     */
    Transport.prototype.connect = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                logger.log('connect');
                this._isConnected = beacon_types_1.TransportStatus.CONNECTED;
                return [2 /*return*/];
            });
        });
    };
    /**
     * Disconnect the transport
     */
    Transport.prototype.disconnect = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                logger.log('disconnect');
                this._isConnected = beacon_types_1.TransportStatus.NOT_CONNECTED;
                return [2 /*return*/];
            });
        });
    };
    /**
     * Send a message through the transport
     *
     * @param message The message to send
     * @param recipient The recipient of the message
     */
    Transport.prototype.send = function (message, peer) {
        return __awaiter(this, void 0, void 0, function () {
            var knownPeers, promises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!peer) return [3 /*break*/, 1];
                        return [2 /*return*/, this.client.sendMessage(message, peer)];
                    case 1: return [4 /*yield*/, this.getPeers()
                        // A broadcast request has to be sent everywhere.
                    ];
                    case 2:
                        knownPeers = _a.sent();
                        promises = knownPeers.map(function (peerEl) { return _this.client.sendMessage(message, peerEl); });
                        return [4 /*yield*/, Promise.all(promises)];
                    case 3: return [2 /*return*/, (_a.sent())[0]];
                }
            });
        });
    };
    /**
     * Add a listener to be called when a new message is received
     *
     * @param listener The listener that will be registered
     */
    Transport.prototype.addListener = function (listener) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                logger.debug('addListener');
                this.listeners.push(listener);
                return [2 /*return*/];
            });
        });
    };
    /**
     * Remove a listener
     *
     * @param listener
     */
    Transport.prototype.removeListener = function (listener) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                logger.log('removeListener');
                this.listeners = this.listeners.filter(function (element) { return element !== listener; });
                return [2 /*return*/];
            });
        });
    };
    Transport.prototype.getPeers = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.peerManager.getPeers()]; // TODO: Fix type
            });
        });
    };
    Transport.prototype.addPeer = function (newPeer, _sendPairingResponse) {
        if (_sendPairingResponse === void 0) { _sendPairingResponse = true; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        logger.log('addPeer', 'adding peer', newPeer);
                        return [4 /*yield*/, this.peerManager.addPeer(newPeer)]; // TODO: Fix type
                    case 1:
                        _a.sent(); // TODO: Fix type
                        return [4 /*yield*/, this.listen(newPeer.publicKey)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Transport.prototype.removePeer = function (peerToBeRemoved) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        logger.log('removePeer', 'removing peer', peerToBeRemoved);
                        return [4 /*yield*/, this.peerManager.removePeer(peerToBeRemoved.publicKey)];
                    case 1:
                        _a.sent();
                        if (!this.client) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.client.unsubscribeFromEncryptedMessage(peerToBeRemoved.publicKey)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    Transport.prototype.removeAllPeers = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        logger.log('removeAllPeers');
                        return [4 /*yield*/, this.peerManager.removeAllPeers()];
                    case 1:
                        _a.sent();
                        if (!this.client) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.client.unsubscribeFromEncryptedMessages()];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Notify the listeners when a new message comes in
     *
     * @param message Message
     * @param connectionInfo Context info about the connection
     */
    Transport.prototype.notifyListeners = function (message, connectionInfo) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.listeners.length === 0) {
                    logger.warn('notifyListeners', '0 listeners notified!', this);
                }
                else {
                    logger.log('notifyListeners', "Notifying ".concat(this.listeners.length, " listeners"), this);
                }
                this.listeners.forEach(function (listener) {
                    listener(message, connectionInfo);
                });
                return [2 /*return*/];
            });
        });
    };
    return Transport;
}());
exports.Transport = Transport;

},{"../utils/Logger":71,"@airgap/beacon-types":104}],69:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommunicationClient = void 0;
var beacon_utils_1 = require("@airgap/beacon-utils");
var ed25519_1 = require("@stablelib/ed25519");
var x25519_session_1 = require("@stablelib/x25519-session");
/**
 * @internalapi
 *
 *
 */
var CommunicationClient = /** @class */ (function () {
    function CommunicationClient(keyPair) {
        this.keyPair = keyPair;
    }
    /**
     * Get the public key
     */
    CommunicationClient.prototype.getPublicKey = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, beacon_utils_1.toHex)(this.keyPair.publicKey)];
            });
        });
    };
    /**
     * get the public key hash
     */
    CommunicationClient.prototype.getPublicKeyHash = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, beacon_utils_1.getHexHash)(this.keyPair.publicKey)];
            });
        });
    };
    /**
     * Create a cryptobox server
     *
     * @param otherPublicKey
     * @param selfKeypair
     */
    CommunicationClient.prototype.createCryptoBoxServer = function (otherPublicKey, selfKeypair) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, x25519_session_1.serverSessionKeys)({
                        publicKey: (0, ed25519_1.convertPublicKeyToX25519)(selfKeypair.publicKey),
                        secretKey: (0, ed25519_1.convertSecretKeyToX25519)(selfKeypair.secretKey)
                    }, (0, ed25519_1.convertPublicKeyToX25519)(Buffer.from(otherPublicKey, 'hex')))];
            });
        });
    };
    /**
     * Create a cryptobox client
     *
     * @param otherPublicKey
     * @param selfKeypair
     */
    CommunicationClient.prototype.createCryptoBoxClient = function (otherPublicKey, selfKeypair) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, x25519_session_1.clientSessionKeys)({
                        publicKey: (0, ed25519_1.convertPublicKeyToX25519)(selfKeypair.publicKey),
                        secretKey: (0, ed25519_1.convertSecretKeyToX25519)(selfKeypair.secretKey)
                    }, (0, ed25519_1.convertPublicKeyToX25519)(Buffer.from(otherPublicKey, 'hex')))];
            });
        });
    };
    /**
     * Encrypt a message for a specific publicKey (receiver, asymmetric)
     *
     * @param recipientPublicKey
     * @param message
     */
    CommunicationClient.prototype.encryptMessageAsymmetric = function (recipientPublicKey, message) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, beacon_utils_1.sealCryptobox)(message, Buffer.from(recipientPublicKey, 'hex'))];
            });
        });
    };
    return CommunicationClient;
}());
exports.CommunicationClient = CommunicationClient;

}).call(this)}).call(this,require("buffer").Buffer)
},{"@airgap/beacon-utils":136,"@stablelib/ed25519":150,"@stablelib/x25519-session":165,"buffer":3}],70:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageBasedClient = void 0;
var constants_1 = require("../../constants");
var beacon_utils_1 = require("@airgap/beacon-utils");
var CommunicationClient_1 = require("./CommunicationClient");
/**
 * @internalapi
 *
 *
 */
var MessageBasedClient = /** @class */ (function (_super) {
    __extends(MessageBasedClient, _super);
    function MessageBasedClient(name, keyPair) {
        var _this = _super.call(this, keyPair) || this;
        _this.name = name;
        _this.init().catch(console.error);
        return _this;
    }
    /**
     * start the client and make sure all dependencies are ready
     */
    MessageBasedClient.prototype.start = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.resolve()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get the pairing request information. This will be shared with the peer during the connection setup
     */
    MessageBasedClient.prototype.getPairingRequestInfo = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = {};
                        return [4 /*yield*/, (0, beacon_utils_1.generateGUID)()];
                    case 1:
                        _a.id = _b.sent(),
                            _a.type = 'postmessage-pairing-request',
                            _a.name = this.name,
                            _a.version = constants_1.BEACON_VERSION;
                        return [4 /*yield*/, this.getPublicKey()];
                    case 2: return [2 /*return*/, (_a.publicKey = _b.sent(),
                            _a)];
                }
            });
        });
    };
    /**
     * Get the pairing response information. This will be shared with the peer during the connection setup
     */
    MessageBasedClient.prototype.getPairingResponseInfo = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = {
                            id: request.id,
                            type: 'postmessage-pairing-response',
                            name: this.name,
                            version: request.version
                        };
                        return [4 /*yield*/, this.getPublicKey()];
                    case 1: return [2 /*return*/, (_a.publicKey = _b.sent(),
                            _a)];
                }
            });
        });
    };
    /**
     * Unsubscribe from encrypted messages from a specific peer
     *
     * @param senderPublicKey
     */
    MessageBasedClient.prototype.unsubscribeFromEncryptedMessage = function (senderPublicKey) {
        return __awaiter(this, void 0, void 0, function () {
            var listener;
            return __generator(this, function (_a) {
                listener = this.activeListeners.get(senderPublicKey);
                if (!listener) {
                    return [2 /*return*/];
                }
                this.activeListeners.delete(senderPublicKey);
                return [2 /*return*/];
            });
        });
    };
    /**
     * Unsubscribe from all encrypted messages
     */
    MessageBasedClient.prototype.unsubscribeFromEncryptedMessages = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.activeListeners.clear();
                return [2 /*return*/];
            });
        });
    };
    /**
     * Decrypt a message from a specific peer
     *
     * @param senderPublicKey
     * @param payload
     */
    MessageBasedClient.prototype.decryptMessage = function (senderPublicKey, payload) {
        return __awaiter(this, void 0, void 0, function () {
            var sharedKey, hexPayload, decryptionError_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.createCryptoBoxServer(senderPublicKey, this.keyPair)];
                    case 1:
                        sharedKey = _a.sent();
                        hexPayload = Buffer.from(payload, 'hex');
                        if (!(hexPayload.length >= beacon_utils_1.secretbox_NONCEBYTES + beacon_utils_1.secretbox_MACBYTES)) return [3 /*break*/, 5];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, (0, beacon_utils_1.decryptCryptoboxPayload)(hexPayload, sharedKey.receive)];
                    case 3: return [2 /*return*/, _a.sent()];
                    case 4:
                        decryptionError_1 = _a.sent();
                        return [3 /*break*/, 5];
                    case 5: throw new Error('Could not decrypt message');
                }
            });
        });
    };
    /**
     * Encrypt a message for a specific publicKey (receiver)
     *
     * @param recipientPublicKey
     * @param message
     */
    MessageBasedClient.prototype.encryptMessage = function (recipientPublicKey, message) {
        return __awaiter(this, void 0, void 0, function () {
            var sharedKey;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.createCryptoBoxClient(recipientPublicKey, this.keyPair)];
                    case 1:
                        sharedKey = _a.sent();
                        return [2 /*return*/, (0, beacon_utils_1.encryptCryptoboxPayload)(message, sharedKey.send)];
                }
            });
        });
    };
    return MessageBasedClient;
}(CommunicationClient_1.CommunicationClient));
exports.MessageBasedClient = MessageBasedClient;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../constants":44,"./CommunicationClient":69,"@airgap/beacon-utils":136,"buffer":3}],71:[function(require,module,exports){
"use strict";
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable no-console */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLogger = exports.setLogger = exports.Logger = exports.InternalLogger = void 0;
var debug_1 = require("../debug");
/**
 * The logger that is used internally
 */
var InternalLogger = /** @class */ (function () {
    function InternalLogger() {
    }
    InternalLogger.prototype.debug = function (name, method) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        this._log('debug', name, method, args);
    };
    InternalLogger.prototype.log = function (name, method) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        this._log('log', name, method, args);
    };
    InternalLogger.prototype.warn = function (name, method) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        this._log('warn', name, method, args);
    };
    InternalLogger.prototype.error = function (name, method) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        this._log('error', name, method, args);
    };
    InternalLogger.prototype._log = function (type, name, method, args) {
        if (args === void 0) { args = []; }
        if (!(0, debug_1.getDebugEnabled)()) {
            return;
        }
        var groupText = "[BEACON] ".concat(new Date().toISOString(), " [").concat(name, "](").concat(method, ")");
        var data = args;
        if (args[0] && typeof args[0] === 'string') {
            groupText += " ".concat(args[0]);
            data = args.slice(1);
        }
        switch (type) {
            case 'error':
                console.group(groupText);
                console.error.apply(console, data);
                break;
            case 'warn':
                console.group(groupText);
                console.warn.apply(console, data);
                break;
            case 'debug':
                console.groupCollapsed(groupText);
                console.debug.apply(console, data);
                break;
            default:
                console.group(groupText);
                console.log.apply(console, data);
        }
        console.groupEnd();
        // echo.group(echo.asWarning(`[BEACON] ${message}`))
        // echo.log(echo.asWarning(`[${this.name}]`), echo.asAlert(`(${method})`), ...args)
        // echo.groupEnd()
    };
    return InternalLogger;
}());
exports.InternalLogger = InternalLogger;
var Logger = /** @class */ (function () {
    function Logger(service) {
        this.name = service;
    }
    Logger.prototype.debug = function (method) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        logger.debug(this.name, method, args);
    };
    Logger.prototype.log = function (method) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        logger.log(this.name, method, args);
    };
    Logger.prototype.warn = function (method) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        logger.warn(this.name, method, args);
    };
    Logger.prototype.error = function (method) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        logger.error(this.name, method, args);
    };
    return Logger;
}());
exports.Logger = Logger;
var loggerWrapper = new Logger('');
var logger = new InternalLogger();
var setLogger = function (newLogger) {
    logger = newLogger;
};
exports.setLogger = setLogger;
var getLogger = function () { return loggerWrapper; };
exports.getLogger = getLogger;

},{"../debug":45}],72:[function(require,module,exports){
"use strict";
/* eslint-disable prefer-arrow/prefer-arrow-functions */
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertNever = void 0;
/**
 * A helper function to make sure if/elses and switch/cases are exhaustive
 *
 * @param empty The data that has to be empty
 */
function assertNever(empty) {
    return empty;
}
exports.assertNever = assertNever;
/* eslint-enable prefer-arrow/prefer-arrow-functions */

},{}],73:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAccountIdentifier = void 0;
var bs58check = require("bs58check");
var blake2b_1 = require("@stablelib/blake2b");
var utf8_1 = require("@stablelib/utf8");
/**
 * @internalapi
 *
 * Generate a deterministic account identifier based on an address and a network
 *
 * @param address
 * @param network
 */
var getAccountIdentifier = function (address, network) { return __awaiter(void 0, void 0, void 0, function () {
    var data, buffer;
    return __generator(this, function (_a) {
        data = [address, network.type];
        if (network.name) {
            data.push("name:".concat(network.name));
        }
        if (network.rpcUrl) {
            data.push("rpc:".concat(network.rpcUrl));
        }
        buffer = Buffer.from((0, blake2b_1.hash)((0, utf8_1.encode)(data.join('-')), 10));
        return [2 /*return*/, bs58check.encode(buffer)];
    });
}); };
exports.getAccountIdentifier = getAccountIdentifier;

}).call(this)}).call(this,require("buffer").Buffer)
},{"@stablelib/blake2b":147,"@stablelib/utf8":162,"bs58check":251,"buffer":3}],74:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSenderId = void 0;
var blake2b_1 = require("@stablelib/blake2b");
var bs58check = require("bs58check");
/**
 * @internalapi
 *
 * Generate a deterministic sender identifier based on a public key
 *
 * @param publicKey
 */
var getSenderId = function (publicKey) { return __awaiter(void 0, void 0, void 0, function () {
    var buffer;
    return __generator(this, function (_a) {
        buffer = Buffer.from((0, blake2b_1.hash)(Buffer.from(publicKey, 'hex'), 5));
        return [2 /*return*/, bs58check.encode(buffer)];
    });
}); };
exports.getSenderId = getSenderId;

}).call(this)}).call(this,require("buffer").Buffer)
},{"@stablelib/blake2b":147,"bs58check":251,"buffer":3}],75:[function(require,module,exports){
"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.messageEvents = void 0;
var events_1 = require("./events");
var beacon_types_1 = require("@airgap/beacon-types");
exports.messageEvents = (_a = {},
    _a[beacon_types_1.BeaconMessageType.BlockchainRequest] = {
        sent: events_1.BeaconEvent.UNKNOWN,
        success: events_1.BeaconEvent.UNKNOWN,
        error: events_1.BeaconEvent.UNKNOWN
    },
    _a[beacon_types_1.BeaconMessageType.BlockchainResponse] = {
        sent: events_1.BeaconEvent.UNKNOWN,
        success: events_1.BeaconEvent.UNKNOWN,
        error: events_1.BeaconEvent.UNKNOWN
    },
    _a[beacon_types_1.BeaconMessageType.PermissionRequest] = {
        sent: events_1.BeaconEvent.PERMISSION_REQUEST_SENT,
        success: events_1.BeaconEvent.PERMISSION_REQUEST_SUCCESS,
        error: events_1.BeaconEvent.PERMISSION_REQUEST_ERROR
    },
    _a[beacon_types_1.BeaconMessageType.PermissionResponse] = {
        sent: events_1.BeaconEvent.UNKNOWN,
        success: events_1.BeaconEvent.UNKNOWN,
        error: events_1.BeaconEvent.UNKNOWN
    },
    _a[beacon_types_1.BeaconMessageType.OperationRequest] = {
        sent: events_1.BeaconEvent.OPERATION_REQUEST_SENT,
        success: events_1.BeaconEvent.OPERATION_REQUEST_SUCCESS,
        error: events_1.BeaconEvent.OPERATION_REQUEST_ERROR
    },
    _a[beacon_types_1.BeaconMessageType.OperationResponse] = {
        sent: events_1.BeaconEvent.UNKNOWN,
        success: events_1.BeaconEvent.UNKNOWN,
        error: events_1.BeaconEvent.UNKNOWN
    },
    _a[beacon_types_1.BeaconMessageType.SignPayloadRequest] = {
        sent: events_1.BeaconEvent.SIGN_REQUEST_SENT,
        success: events_1.BeaconEvent.SIGN_REQUEST_SUCCESS,
        error: events_1.BeaconEvent.SIGN_REQUEST_ERROR
    },
    _a[beacon_types_1.BeaconMessageType.SignPayloadResponse] = {
        sent: events_1.BeaconEvent.UNKNOWN,
        success: events_1.BeaconEvent.UNKNOWN,
        error: events_1.BeaconEvent.UNKNOWN
    },
    // TODO: ENCRYPTION
    // [BeaconMessageType.EncryptPayloadRequest]: {
    //   sent: BeaconEvent.ENCRYPT_REQUEST_SENT,
    //   success: BeaconEvent.ENCRYPT_REQUEST_SUCCESS,
    //   error: BeaconEvent.ENCRYPT_REQUEST_ERROR
    // },
    // [BeaconMessageType.EncryptPayloadResponse]: {
    //   sent: BeaconEvent.UNKNOWN,
    //   success: BeaconEvent.UNKNOWN,
    //   error: BeaconEvent.UNKNOWN
    // },
    _a[beacon_types_1.BeaconMessageType.BroadcastRequest] = {
        sent: events_1.BeaconEvent.BROADCAST_REQUEST_SENT,
        success: events_1.BeaconEvent.BROADCAST_REQUEST_SUCCESS,
        error: events_1.BeaconEvent.BROADCAST_REQUEST_ERROR
    },
    _a[beacon_types_1.BeaconMessageType.BroadcastResponse] = {
        sent: events_1.BeaconEvent.UNKNOWN,
        success: events_1.BeaconEvent.UNKNOWN,
        error: events_1.BeaconEvent.UNKNOWN
    },
    _a[beacon_types_1.BeaconMessageType.Acknowledge] = {
        sent: events_1.BeaconEvent.UNKNOWN,
        success: events_1.BeaconEvent.UNKNOWN,
        error: events_1.BeaconEvent.UNKNOWN
    },
    _a[beacon_types_1.BeaconMessageType.Disconnect] = {
        sent: events_1.BeaconEvent.UNKNOWN,
        success: events_1.BeaconEvent.UNKNOWN,
        error: events_1.BeaconEvent.UNKNOWN
    },
    _a[beacon_types_1.BeaconMessageType.Error] = {
        sent: events_1.BeaconEvent.UNKNOWN,
        success: events_1.BeaconEvent.UNKNOWN,
        error: events_1.BeaconEvent.UNKNOWN
    },
    _a);

},{"./events":77,"@airgap/beacon-types":104}],76:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DAppClient = void 0;
var axios_1 = require("axios");
var bs58check = require("bs58check");
var events_1 = require("../events");
var beacon_types_1 = require("@airgap/beacon-types");
var beacon_core_1 = require("@airgap/beacon-core");
var beacon_utils_1 = require("@airgap/beacon-utils");
var beacon_message_events_1 = require("../beacon-message-events");
var tzkt_blockexplorer_1 = require("../utils/tzkt-blockexplorer");
var beacon_ui_1 = require("@airgap/beacon-ui");
var beacon_dapp_1 = require("@airgap/beacon-dapp");
var DappPostMessageTransport_1 = require("../transports/DappPostMessageTransport");
var DappP2PTransport_1 = require("../transports/DappP2PTransport");
var beacon_transport_postmessage_1 = require("@airgap/beacon-transport-postmessage");
var beacon_ui_2 = require("@airgap/beacon-ui");
var beacon_utils_2 = require("@airgap/beacon-utils");
var logger = new beacon_core_1.Logger('DAppClient');
/**
 * @publicapi
 *
 * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible
 * wallets and sending requests.
 *
 * @category DApp
 */
var DAppClient = /** @class */ (function (_super) {
    __extends(DAppClient, _super);
    function DAppClient(config) {
        var _this = this;
        var _a, _b, _c, _d, _e;
        _this = _super.call(this, __assign({ storage: config && config.storage ? config.storage : new beacon_core_1.LocalStorage() }, config)) || this;
        _this.events = new beacon_dapp_1.BeaconEventHandler();
        /**
         * A map of requests that are currently "open", meaning we have sent them to a wallet and are still awaiting a response.
         */
        _this.openRequests = new Map();
        /**
         * The currently active account. For all requests that are associated to a specific request (operation request, signing request),
         * the active account is used to determine the network and destination wallet
         */
        _this._activeAccount = new beacon_utils_1.ExposedPromise();
        /**
         * The currently active peer. This is used to address a peer in case the active account is not set. (Eg. for permission requests)
         */
        _this._activePeer = new beacon_utils_1.ExposedPromise();
        _this.blockchains = new Map();
        _this.events = new beacon_dapp_1.BeaconEventHandler(config.eventHandlers, (_a = config.disableDefaultEvents) !== null && _a !== void 0 ? _a : false);
        _this.blockExplorer = (_b = config.blockExplorer) !== null && _b !== void 0 ? _b : new tzkt_blockexplorer_1.TzktBlockExplorer();
        _this.preferredNetwork = (_c = config.preferredNetwork) !== null && _c !== void 0 ? _c : beacon_types_1.NetworkType.MAINNET;
        (0, beacon_ui_2.setColorMode)((_d = config.colorMode) !== null && _d !== void 0 ? _d : beacon_types_1.ColorMode.LIGHT);
        _this.disclaimerText = config.disclaimerText;
        _this.errorMessages = (_e = config.errorMessages) !== null && _e !== void 0 ? _e : {};
        _this.appMetadataManager = new beacon_core_1.AppMetadataManager(_this.storage);
        _this.activeAccountLoaded = _this.storage
            .get(beacon_types_1.StorageKey.ACTIVE_ACCOUNT)
            .then(function (activeAccountIdentifier) { return __awaiter(_this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!activeAccountIdentifier) return [3 /*break*/, 3];
                        _a = this.setActiveAccount;
                        return [4 /*yield*/, this.accountManager.getAccount(activeAccountIdentifier)];
                    case 1: return [4 /*yield*/, _a.apply(this, [_b.sent()])];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, this.setActiveAccount(undefined)];
                    case 4:
                        _b.sent();
                        _b.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        }); })
            .catch(function (storageError) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.setActiveAccount(undefined)];
                    case 1:
                        _a.sent();
                        console.error(storageError);
                        return [2 /*return*/];
                }
            });
        }); });
        _this.handleResponse = function (message, connectionInfo) { return __awaiter(_this, void 0, void 0, function () {
            var openRequest, typedMessage, _a, _b, _c, appMetadata, relevantTransport, _d, _e, peers, peer, typedMessage, _f, _g, _h, relevantTransport, _j, _k, peers, peer;
            var _l, _m;
            var _o, _p;
            return __generator(this, function (_q) {
                switch (_q.label) {
                    case 0:
                        openRequest = this.openRequests.get(message.id);
                        logger.log('handleResponse', 'Received message', message, connectionInfo);
                        if (!(message.version === '3')) return [3 /*break*/, 19];
                        typedMessage = message;
                        if (!(openRequest && typedMessage.message.type === beacon_types_1.BeaconMessageType.Acknowledge)) return [3 /*break*/, 2];
                        logger.log("acknowledge message received for ".concat(message.id));
                        console.timeLog(message.id, 'acknowledge');
                        _b = (_a = this.events)
                            .emit;
                        _c = [events_1.BeaconEvent.ACKNOWLEDGE_RECEIVED];
                        _l = {
                            message: typedMessage.message,
                            extraInfo: {}
                        };
                        return [4 /*yield*/, this.getWalletInfo()];
                    case 1:
                        _b.apply(_a, _c.concat([(_l.walletInfo = _q.sent(),
                                _l)]))
                            .catch(console.error);
                        return [3 /*break*/, 18];
                    case 2:
                        if (!openRequest) return [3 /*break*/, 5];
                        appMetadata = typedMessage.message /* Why is this unkown cast needed? */.blockchainData.appMetadata;
                        if (!(typedMessage.message.type === beacon_types_1.BeaconMessageType.PermissionResponse && appMetadata)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.appMetadataManager.addAppMetadata(appMetadata)];
                    case 3:
                        _q.sent();
                        _q.label = 4;
                    case 4:
                        console.timeLog(typedMessage.id, 'response');
                        console.timeEnd(typedMessage.id);
                        if (typedMessage.message.type === beacon_types_1.BeaconMessageType.Error) {
                            openRequest.reject(typedMessage.message);
                        }
                        else {
                            openRequest.resolve({ message: message, connectionInfo: connectionInfo });
                        }
                        this.openRequests.delete(typedMessage.id);
                        return [3 /*break*/, 18];
                    case 5:
                        if (!(typedMessage.message.type === beacon_types_1.BeaconMessageType.Disconnect)) return [3 /*break*/, 17];
                        if (!(connectionInfo.origin === beacon_types_1.Origin.P2P)) return [3 /*break*/, 6];
                        _d = this.p2pTransport;
                        return [3 /*break*/, 10];
                    case 6:
                        if (!((_o = this.postMessageTransport) !== null && _o !== void 0)) return [3 /*break*/, 7];
                        _e = _o;
                        return [3 /*break*/, 9];
                    case 7: return [4 /*yield*/, this.transport];
                    case 8:
                        _e = (_q.sent());
                        _q.label = 9;
                    case 9:
                        _d = _e;
                        _q.label = 10;
                    case 10:
                        relevantTransport = _d;
                        if (!relevantTransport) return [3 /*break*/, 16];
                        return [4 /*yield*/, relevantTransport.getPeers()];
                    case 11:
                        peers = _q.sent();
                        peer = peers.find(function (peerEl) { return peerEl.senderId === message.senderId; });
                        if (!peer) return [3 /*break*/, 15];
                        return [4 /*yield*/, relevantTransport.removePeer(peer)];
                    case 12:
                        _q.sent();
                        return [4 /*yield*/, this.removeAccountsForPeers([peer])];
                    case 13:
                        _q.sent();
                        return [4 /*yield*/, this.events.emit(events_1.BeaconEvent.CHANNEL_CLOSED)];
                    case 14:
                        _q.sent();
                        return [3 /*break*/, 16];
                    case 15:
                        logger.error('handleDisconnect', 'cannot find peer for sender ID', message.senderId);
                        _q.label = 16;
                    case 16: return [3 /*break*/, 18];
                    case 17:
                        logger.error('handleResponse', 'no request found for id ', message.id, message);
                        _q.label = 18;
                    case 18: return [3 /*break*/, 37];
                    case 19:
                        typedMessage = message;
                        if (!(openRequest && typedMessage.type === beacon_types_1.BeaconMessageType.Acknowledge)) return [3 /*break*/, 21];
                        logger.log("acknowledge message received for ".concat(message.id));
                        console.timeLog(message.id, 'acknowledge');
                        _g = (_f = this.events)
                            .emit;
                        _h = [events_1.BeaconEvent.ACKNOWLEDGE_RECEIVED];
                        _m = {
                            message: typedMessage,
                            extraInfo: {}
                        };
                        return [4 /*yield*/, this.getWalletInfo()];
                    case 20:
                        _g.apply(_f, _h.concat([(_m.walletInfo = _q.sent(),
                                _m)]))
                            .catch(console.error);
                        return [3 /*break*/, 37];
                    case 21:
                        if (!openRequest) return [3 /*break*/, 24];
                        if (!(typedMessage.type === beacon_types_1.BeaconMessageType.PermissionResponse &&
                            typedMessage.appMetadata)) return [3 /*break*/, 23];
                        return [4 /*yield*/, this.appMetadataManager.addAppMetadata(typedMessage.appMetadata)];
                    case 22:
                        _q.sent();
                        _q.label = 23;
                    case 23:
                        console.timeLog(typedMessage.id, 'response');
                        console.timeEnd(typedMessage.id);
                        if (typedMessage.type === beacon_types_1.BeaconMessageType.Error || message.errorType) {
                            // TODO: Remove "any" once we remove support for v1 wallets
                            openRequest.reject(typedMessage);
                        }
                        else {
                            openRequest.resolve({ message: message, connectionInfo: connectionInfo });
                        }
                        this.openRequests.delete(typedMessage.id);
                        return [3 /*break*/, 37];
                    case 24:
                        if (!(typedMessage.type === beacon_types_1.BeaconMessageType.Disconnect ||
                            message.typedMessage.type === beacon_types_1.BeaconMessageType.Disconnect) // TODO: TYPE
                        ) return [3 /*break*/, 36]; // TODO: TYPE
                        if (!(connectionInfo.origin === beacon_types_1.Origin.P2P)) return [3 /*break*/, 25];
                        _j = this.p2pTransport;
                        return [3 /*break*/, 29];
                    case 25:
                        if (!((_p = this.postMessageTransport) !== null && _p !== void 0)) return [3 /*break*/, 26];
                        _k = _p;
                        return [3 /*break*/, 28];
                    case 26: return [4 /*yield*/, this.transport];
                    case 27:
                        _k = (_q.sent());
                        _q.label = 28;
                    case 28:
                        _j = _k;
                        _q.label = 29;
                    case 29:
                        relevantTransport = _j;
                        if (!relevantTransport) return [3 /*break*/, 35];
                        return [4 /*yield*/, relevantTransport.getPeers()];
                    case 30:
                        peers = _q.sent();
                        peer = peers.find(function (peerEl) { return peerEl.senderId === message.senderId; });
                        if (!peer) return [3 /*break*/, 34];
                        return [4 /*yield*/, relevantTransport.removePeer(peer)];
                    case 31:
                        _q.sent();
                        return [4 /*yield*/, this.removeAccountsForPeers([peer])];
                    case 32:
                        _q.sent();
                        return [4 /*yield*/, this.events.emit(events_1.BeaconEvent.CHANNEL_CLOSED)];
                    case 33:
                        _q.sent();
                        return [3 /*break*/, 35];
                    case 34:
                        logger.error('handleDisconnect', 'cannot find peer for sender ID', message.senderId);
                        _q.label = 35;
                    case 35: return [3 /*break*/, 37];
                    case 36:
                        logger.error('handleResponse', 'no request found for id ', message.id, message);
                        _q.label = 37;
                    case 37: return [2 /*return*/];
                }
            });
        }); };
        return _this;
    }
    DAppClient.prototype.initInternalTransports = function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyPair;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.keyPair];
                    case 1:
                        keyPair = _a.sent();
                        if (this.postMessageTransport || this.p2pTransport) {
                            return [2 /*return*/];
                        }
                        this.postMessageTransport = new DappPostMessageTransport_1.DappPostMessageTransport(this.name, keyPair, this.storage);
                        return [4 /*yield*/, this.addListener(this.postMessageTransport)];
                    case 2:
                        _a.sent();
                        this.p2pTransport = new DappP2PTransport_1.DappP2PTransport(this.name, keyPair, this.storage, this.matrixNodes, this.iconUrl, this.appUrl);
                        return [4 /*yield*/, this.addListener(this.p2pTransport)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    DAppClient.prototype.init = function (transport) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (this._initPromise) {
                            return [2 /*return*/, this._initPromise];
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.activeAccountLoaded];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        _a = _b.sent();
                        return [3 /*break*/, 4];
                    case 4:
                        this._initPromise = new Promise(function (resolve) { return __awaiter(_this, void 0, void 0, function () {
                            var _a, _b, _c, _d, _e, activeAccount, stopListening_1, origin_1, _f, _g, p2pTransport_1, postMessageTransport_1;
                            var _this = this;
                            return __generator(this, function (_h) {
                                switch (_h.label) {
                                    case 0:
                                        if (!transport) return [3 /*break*/, 3];
                                        return [4 /*yield*/, this.addListener(transport)];
                                    case 1:
                                        _h.sent();
                                        _a = resolve;
                                        return [4 /*yield*/, _super.prototype.init.call(this, transport)];
                                    case 2:
                                        _a.apply(void 0, [_h.sent()]);
                                        return [3 /*break*/, 16];
                                    case 3:
                                        if (!this._transport.isSettled()) return [3 /*break*/, 8];
                                        return [4 /*yield*/, this.transport];
                                    case 4: return [4 /*yield*/, (_h.sent()).connect()];
                                    case 5:
                                        _h.sent();
                                        _b = resolve;
                                        _d = (_c = _super.prototype.init).call;
                                        _e = [this];
                                        return [4 /*yield*/, this.transport];
                                    case 6: return [4 /*yield*/, _d.apply(_c, _e.concat([_h.sent()]))];
                                    case 7:
                                        _b.apply(void 0, [_h.sent()]);
                                        return [3 /*break*/, 16];
                                    case 8: return [4 /*yield*/, this.getActiveAccount()];
                                    case 9:
                                        activeAccount = _h.sent();
                                        stopListening_1 = function () {
                                            if (_this.postMessageTransport) {
                                                _this.postMessageTransport.stopListeningForNewPeers().catch(console.error);
                                            }
                                            if (_this.p2pTransport) {
                                                _this.p2pTransport.stopListeningForNewPeers().catch(console.error);
                                            }
                                        };
                                        return [4 /*yield*/, this.initInternalTransports()];
                                    case 10:
                                        _h.sent();
                                        if (!this.postMessageTransport || !this.p2pTransport) {
                                            return [2 /*return*/];
                                        }
                                        this.postMessageTransport.connect().then().catch(console.error);
                                        if (!(activeAccount && activeAccount.origin)) return [3 /*break*/, 15];
                                        origin_1 = activeAccount.origin.type;
                                        if (!(origin_1 === beacon_types_1.Origin.EXTENSION)) return [3 /*break*/, 12];
                                        _f = resolve;
                                        return [4 /*yield*/, _super.prototype.init.call(this, this.postMessageTransport)];
                                    case 11:
                                        _f.apply(void 0, [_h.sent()]);
                                        return [3 /*break*/, 14];
                                    case 12:
                                        if (!(origin_1 === beacon_types_1.Origin.P2P)) return [3 /*break*/, 14];
                                        _g = resolve;
                                        return [4 /*yield*/, _super.prototype.init.call(this, this.p2pTransport)];
                                    case 13:
                                        _g.apply(void 0, [_h.sent()]);
                                        _h.label = 14;
                                    case 14: return [3 /*break*/, 16];
                                    case 15:
                                        p2pTransport_1 = this.p2pTransport;
                                        postMessageTransport_1 = this.postMessageTransport;
                                        postMessageTransport_1
                                            .listenForNewPeer(function (peer) {
                                            logger.log('init', 'postmessage transport peer connected', peer);
                                            _this.events
                                                .emit(events_1.BeaconEvent.PAIR_SUCCESS, peer)
                                                .catch(function (emitError) { return console.warn(emitError); });
                                            _this.setActivePeer(peer).catch(console.error);
                                            _this.setTransport(_this.postMessageTransport).catch(console.error);
                                            stopListening_1();
                                            resolve(beacon_types_1.TransportType.POST_MESSAGE);
                                        })
                                            .catch(console.error);
                                        p2pTransport_1
                                            .listenForNewPeer(function (peer) {
                                            logger.log('init', 'p2p transport peer connected', peer);
                                            _this.events
                                                .emit(events_1.BeaconEvent.PAIR_SUCCESS, peer)
                                                .catch(function (emitError) { return console.warn(emitError); });
                                            _this.setActivePeer(peer).catch(console.error);
                                            _this.setTransport(_this.p2pTransport).catch(console.error);
                                            stopListening_1();
                                            resolve(beacon_types_1.TransportType.P2P);
                                        })
                                            .catch(console.error);
                                        beacon_transport_postmessage_1.PostMessageTransport.getAvailableExtensions()
                                            .then(function () { return __awaiter(_this, void 0, void 0, function () {
                                            var _this = this;
                                            return __generator(this, function (_a) {
                                                this.events
                                                    .emit(events_1.BeaconEvent.PAIR_INIT, {
                                                    p2pPeerInfo: function () {
                                                        p2pTransport_1.connect().then().catch(console.error);
                                                        return p2pTransport_1.getPairingRequestInfo();
                                                    },
                                                    postmessagePeerInfo: function () { return postMessageTransport_1.getPairingRequestInfo(); },
                                                    preferredNetwork: this.preferredNetwork,
                                                    abortedHandler: function () {
                                                        console.log('ABORTED');
                                                        _this._initPromise = undefined;
                                                    },
                                                    disclaimerText: this.disclaimerText
                                                })
                                                    .catch(function (emitError) { return console.warn(emitError); });
                                                return [2 /*return*/];
                                            });
                                        }); })
                                            .catch(function (error) {
                                            _this._initPromise = undefined;
                                            console.error(error);
                                        });
                                        _h.label = 16;
                                    case 16: return [2 /*return*/];
                                }
                            });
                        }); });
                        return [2 /*return*/, this._initPromise];
                }
            });
        });
    };
    /**
     * Returns the active account
     */
    DAppClient.prototype.getActiveAccount = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._activeAccount.promise];
            });
        });
    };
    /**
     * Sets the active account
     *
     * @param account The account that will be set as the active account
     */
    DAppClient.prototype.setActiveAccount = function (account) {
        return __awaiter(this, void 0, void 0, function () {
            var origin_2, peer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._activeAccount.isSettled()) {
                            // If the promise has already been resolved we need to create a new one.
                            this._activeAccount = beacon_utils_1.ExposedPromise.resolve(account);
                        }
                        else {
                            this._activeAccount.resolve(account);
                        }
                        if (!account) return [3 /*break*/, 8];
                        origin_2 = account.origin.type;
                        return [4 /*yield*/, this.initInternalTransports()
                            // Select the transport that matches the active account
                        ];
                    case 1:
                        _a.sent();
                        if (!(origin_2 === beacon_types_1.Origin.EXTENSION)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.setTransport(this.postMessageTransport)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 3:
                        if (!(origin_2 === beacon_types_1.Origin.P2P)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.setTransport(this.p2pTransport)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [4 /*yield*/, this.getPeer(account)];
                    case 6:
                        peer = _a.sent();
                        return [4 /*yield*/, this.setActivePeer(peer)];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 11];
                    case 8: return [4 /*yield*/, this.setActivePeer(undefined)];
                    case 9:
                        _a.sent();
                        return [4 /*yield*/, this.setTransport(undefined)];
                    case 10:
                        _a.sent();
                        _a.label = 11;
                    case 11: return [4 /*yield*/, this.storage.set(beacon_types_1.StorageKey.ACTIVE_ACCOUNT, account ? account.accountIdentifier : undefined)];
                    case 12:
                        _a.sent();
                        return [4 /*yield*/, this.events.emit(events_1.BeaconEvent.ACTIVE_ACCOUNT_SET, account)];
                    case 13:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Clear the active account
     */
    DAppClient.prototype.clearActiveAccount = function () {
        return this.setActiveAccount();
    };
    DAppClient.prototype.setColorMode = function (colorMode) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, beacon_ui_2.setColorMode)(colorMode)];
            });
        });
    };
    DAppClient.prototype.getColorMode = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, beacon_ui_2.getColorMode)()];
            });
        });
    };
    /**
     * @deprecated
     *
     * Use getOwnAppMetadata instead
     */
    DAppClient.prototype.getAppMetadata = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.getOwnAppMetadata()];
            });
        });
    };
    DAppClient.prototype.showPrepare = function () {
        return __awaiter(this, void 0, void 0, function () {
            var walletInfo;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (function () { return __awaiter(_this, void 0, void 0, function () {
                            var _a;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        _b.trys.push([0, 2, , 3]);
                                        return [4 /*yield*/, this.getWalletInfo()];
                                    case 1: return [2 /*return*/, _b.sent()];
                                    case 2:
                                        _a = _b.sent();
                                        return [2 /*return*/, undefined];
                                    case 3: return [2 /*return*/];
                                }
                            });
                        }); })()];
                    case 1:
                        walletInfo = _a.sent();
                        return [4 /*yield*/, this.events.emit(events_1.BeaconEvent.SHOW_PREPARE, { walletInfo: walletInfo })];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    DAppClient.prototype.hideUI = function (elements) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.events.emit(events_1.BeaconEvent.HIDE_UI, elements)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Will remove the account from the local storage and set a new active account if necessary.
     *
     * @param accountIdentifier ID of the account
     */
    DAppClient.prototype.removeAccount = function (accountIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            var removeAccountResult, activeAccount;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        removeAccountResult = _super.prototype.removeAccount.call(this, accountIdentifier);
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 1:
                        activeAccount = _a.sent();
                        if (!(activeAccount && activeAccount.accountIdentifier === accountIdentifier)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.setActiveAccount(undefined)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2 /*return*/, removeAccountResult];
                }
            });
        });
    };
    /**
     * Remove all accounts and set active account to undefined
     */
    DAppClient.prototype.removeAllAccounts = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, _super.prototype.removeAllAccounts.call(this)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.setActiveAccount(undefined)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes a peer and all the accounts that have been connected through that peer
     *
     * @param peer Peer to be removed
     */
    DAppClient.prototype.removePeer = function (peer, sendDisconnectToPeer) {
        if (sendDisconnectToPeer === void 0) { sendDisconnectToPeer = false; }
        return __awaiter(this, void 0, void 0, function () {
            var transport, removePeerResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.transport];
                    case 1:
                        transport = _a.sent();
                        removePeerResult = transport.removePeer(peer);
                        return [4 /*yield*/, this.removeAccountsForPeers([peer])];
                    case 2:
                        _a.sent();
                        if (!sendDisconnectToPeer) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.sendDisconnectToPeer(peer, transport)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [2 /*return*/, removePeerResult];
                }
            });
        });
    };
    /**
     * Remove all peers and all accounts that have been connected through those peers
     */
    DAppClient.prototype.removeAllPeers = function (sendDisconnectToPeers) {
        if (sendDisconnectToPeers === void 0) { sendDisconnectToPeers = false; }
        return __awaiter(this, void 0, void 0, function () {
            var transport, peers, removePeerResult, disconnectPromises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.transport];
                    case 1:
                        transport = _a.sent();
                        return [4 /*yield*/, transport.getPeers()];
                    case 2:
                        peers = _a.sent();
                        removePeerResult = transport.removeAllPeers();
                        return [4 /*yield*/, this.removeAccountsForPeers(peers)];
                    case 3:
                        _a.sent();
                        if (!sendDisconnectToPeers) return [3 /*break*/, 5];
                        disconnectPromises = peers.map(function (peer) { return _this.sendDisconnectToPeer(peer, transport); });
                        return [4 /*yield*/, Promise.all(disconnectPromises)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [2 /*return*/, removePeerResult];
                }
            });
        });
    };
    /**
     * Allows the user to subscribe to specific events that are fired in the SDK
     *
     * @param internalEvent The event to subscribe to
     * @param eventCallback The callback that will be called when the event occurs
     */
    DAppClient.prototype.subscribeToEvent = function (internalEvent, eventCallback) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.events.on(internalEvent, eventCallback)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Check if we have permissions to send the specific message type to the active account.
     * If no active account is set, only permission requests are allowed.
     *
     * @param type The type of the message
     */
    DAppClient.prototype.checkPermissions = function (type) {
        return __awaiter(this, void 0, void 0, function () {
            var activeAccount, permissions;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (type === beacon_types_1.BeaconMessageType.PermissionRequest) {
                            return [2 /*return*/, true];
                        }
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 1:
                        activeAccount = _a.sent();
                        if (!!activeAccount) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.sendInternalError('No active account set!')];
                    case 2: throw _a.sent();
                    case 3:
                        permissions = activeAccount.scopes;
                        switch (type) {
                            case beacon_types_1.BeaconMessageType.OperationRequest:
                                return [2 /*return*/, permissions.includes(beacon_types_1.PermissionScope.OPERATION_REQUEST)];
                            case beacon_types_1.BeaconMessageType.SignPayloadRequest:
                                return [2 /*return*/, permissions.includes(beacon_types_1.PermissionScope.SIGN)
                                    // TODO: ENCRYPTION
                                    // case BeaconMessageType.EncryptPayloadRequest:
                                    //   return permissions.includes(PermissionScope.ENCRYPT)
                                ];
                            // TODO: ENCRYPTION
                            // case BeaconMessageType.EncryptPayloadRequest:
                            //   return permissions.includes(PermissionScope.ENCRYPT)
                            case beacon_types_1.BeaconMessageType.BroadcastRequest:
                                return [2 /*return*/, true];
                            default:
                                return [2 /*return*/, false];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    DAppClient.prototype.sendNotification = function (title, message, payload, protocolIdentifier) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function () {
            var activeAccount, url;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, this.getActiveAccount()];
                    case 1:
                        activeAccount = _d.sent();
                        if (!activeAccount ||
                            (activeAccount &&
                                !activeAccount.scopes.includes(beacon_types_1.PermissionScope.NOTIFICATION) &&
                                !activeAccount.notification)) {
                            throw new Error('notification permissions not given');
                        }
                        if (!((_a = activeAccount.notification) === null || _a === void 0 ? void 0 : _a.token)) {
                            throw new Error('No AccessToken');
                        }
                        url = (_b = activeAccount.notification) === null || _b === void 0 ? void 0 : _b.apiUrl;
                        if (!url) {
                            throw new Error('No Push URL set');
                        }
                        return [2 /*return*/, this.sendNotificationWithAccessToken({
                                url: url,
                                recipient: activeAccount.address,
                                title: title,
                                body: message,
                                payload: payload,
                                protocolIdentifier: protocolIdentifier,
                                accessToken: (_c = activeAccount.notification) === null || _c === void 0 ? void 0 : _c.token
                            })];
                }
            });
        });
    };
    DAppClient.prototype.addBlockchain = function (chain) {
        this.blockchains.set(chain.identifier, chain);
        chain.getWalletLists().then(function (walletLists) {
            (0, beacon_ui_2.setDesktopList)(walletLists.desktopList);
            (0, beacon_ui_2.setExtensionList)(walletLists.extensionList);
            (0, beacon_ui_2.setWebList)(walletLists.webList);
            (0, beacon_ui_2.setiOSList)(walletLists.iOSList);
        });
    };
    DAppClient.prototype.removeBlockchain = function (chainIdentifier) {
        this.blockchains.delete(chainIdentifier);
    };
    /** Generic messages */
    DAppClient.prototype.permissionRequest = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            var blockchain, request, _a, _b, _c, response, connectionInfo, partialAccountInfos, accountInfo, _d, _e, _f, _g;
            var _h, _j, _k, _l;
            var _this = this;
            return __generator(this, function (_m) {
                switch (_m.label) {
                    case 0:
                        console.log('PERMISSION REQUEST');
                        blockchain = this.blockchains.get(input.blockchainIdentifier);
                        if (!blockchain) {
                            throw new Error("Blockchain \"".concat(input.blockchainIdentifier, "\" not supported by dAppClient"));
                        }
                        _a = [__assign({}, input)];
                        _h = { type: beacon_types_1.BeaconMessageType.PermissionRequest };
                        _b = [__assign({}, input.blockchainData)];
                        _j = {};
                        return [4 /*yield*/, this.getOwnAppMetadata()];
                    case 1:
                        request = __assign.apply(void 0, _a.concat([(_h.blockchainData = __assign.apply(void 0, _b.concat([(_j.appMetadata = _m.sent(), _j)])), _h)]));
                        console.log('REQUESTION PERMIMISSION V3', 'xxx', request);
                        return [4 /*yield*/, this.makeRequestV3(request).catch(function (_requestError) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    throw new Error('TODO');
                                });
                            }); })];
                    case 2:
                        _c = _m.sent(), response = _c.message, connectionInfo = _c.connectionInfo;
                        console.log('RESPONSE V3', response, connectionInfo);
                        return [4 /*yield*/, blockchain.getAccountInfosFromPermissionResponse(response.message)
                            // const accountInfo: AccountInfo = {
                        ];
                    case 3:
                        partialAccountInfos = _m.sent();
                        accountInfo = {
                            accountIdentifier: partialAccountInfos[0].accountId,
                            senderId: response.senderId,
                            origin: {
                                type: connectionInfo.origin,
                                id: connectionInfo.id
                            },
                            address: partialAccountInfos[0].address,
                            publicKey: partialAccountInfos[0].publicKey,
                            scopes: response.message.blockchainData.scopes,
                            connectedAt: new Date().getTime(),
                            chainData: response.message.blockchainData
                        };
                        return [4 /*yield*/, this.accountManager.addAccount(accountInfo)];
                    case 4:
                        _m.sent();
                        return [4 /*yield*/, this.setActiveAccount(accountInfo)];
                    case 5:
                        _m.sent();
                        _e = (_d = blockchain).handleResponse;
                        _k = {
                            request: request,
                            account: accountInfo,
                            output: response,
                            blockExplorer: this.blockExplorer,
                            connectionContext: connectionInfo
                        };
                        return [4 /*yield*/, this.getWalletInfo()];
                    case 6: return [4 /*yield*/, _e.apply(_d, [(_k.walletInfo = _m.sent(),
                                _k)])];
                    case 7:
                        _m.sent();
                        _f = this.notifySuccess;
                        _g = [request];
                        _l = {
                            account: accountInfo,
                            output: {
                                address: partialAccountInfos[0].address,
                                network: { type: beacon_types_1.NetworkType.MAINNET },
                                scopes: [beacon_types_1.PermissionScope.OPERATION_REQUEST]
                            },
                            blockExplorer: this.blockExplorer,
                            connectionContext: connectionInfo
                        };
                        return [4 /*yield*/, this.getWalletInfo()];
                    case 8: return [4 /*yield*/, _f.apply(this, _g.concat([(_l.walletInfo = _m.sent(),
                                _l)]))
                        // return output
                    ];
                    case 9:
                        _m.sent();
                        // return output
                        return [2 /*return*/, response.message];
                }
            });
        });
    };
    DAppClient.prototype.request = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            var blockchain, activeAccount, request, _a, response, connectionInfo, _b, _c;
            var _d;
            var _this = this;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        console.log('REQUEST', input);
                        blockchain = this.blockchains.get(input.blockchainIdentifier);
                        if (!blockchain) {
                            throw new Error("Blockchain \"".concat(blockchain, "\" not supported by dAppClient"));
                        }
                        return [4 /*yield*/, blockchain.validateRequest(input)];
                    case 1:
                        _e.sent();
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 2:
                        activeAccount = _e.sent();
                        if (!!activeAccount) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.sendInternalError('No active account!')];
                    case 3: throw _e.sent();
                    case 4:
                        request = __assign(__assign({}, input), { type: beacon_types_1.BeaconMessageType.BlockchainRequest, accountId: activeAccount.accountIdentifier });
                        return [4 /*yield*/, this.makeRequestV3(request).catch(function (requestError) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    console.error(requestError);
                                    throw new Error('TODO');
                                });
                            }); })];
                    case 5:
                        _a = _e.sent(), response = _a.message, connectionInfo = _a.connectionInfo;
                        _c = (_b = blockchain).handleResponse;
                        _d = {
                            request: request,
                            account: activeAccount,
                            output: response,
                            blockExplorer: this.blockExplorer,
                            connectionContext: connectionInfo
                        };
                        return [4 /*yield*/, this.getWalletInfo()];
                    case 6: return [4 /*yield*/, _c.apply(_b, [(_d.walletInfo = _e.sent(),
                                _d)])];
                    case 7:
                        _e.sent();
                        return [2 /*return*/, response.message];
                }
            });
        });
    };
    /**
     * Send a permission request to the DApp. This should be done as the first step. The wallet will respond
     * with an publicKey and permissions that were given. The account returned will be set as the "activeAccount"
     * and will be used for the following requests.
     *
     * @param input The message details we need to prepare the PermissionRequest message.
     */
    DAppClient.prototype.requestPermissions = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            var request, _a, message, connectionInfo, publicKey, address, accountInfo, output, _b, _c;
            var _d, _e, _f;
            var _this = this;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        _d = {};
                        return [4 /*yield*/, this.getOwnAppMetadata()];
                    case 1:
                        request = (_d.appMetadata = _g.sent(),
                            _d.type = beacon_types_1.BeaconMessageType.PermissionRequest,
                            _d.network = input && input.network ? input.network : { type: beacon_types_1.NetworkType.MAINNET },
                            _d.scopes = input && input.scopes
                                ? input.scopes
                                : [beacon_types_1.PermissionScope.OPERATION_REQUEST, beacon_types_1.PermissionScope.SIGN],
                            _d);
                        return [4 /*yield*/, this.makeRequest(request).catch(function (requestError) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.handleRequestError(request, requestError)];
                                        case 1: throw _a.sent();
                                    }
                                });
                            }); })
                            // TODO: Migration code. Remove sometime after 1.0.0 release.
                        ];
                    case 2:
                        _a = _g.sent(), message = _a.message, connectionInfo = _a.connectionInfo;
                        publicKey = message.publicKey || message.pubkey || message.pubKey;
                        return [4 /*yield*/, (0, beacon_utils_1.getAddressFromPublicKey)(publicKey)];
                    case 3:
                        address = _g.sent();
                        _e = {};
                        return [4 /*yield*/, (0, beacon_core_1.getAccountIdentifier)(address, message.network)];
                    case 4:
                        accountInfo = (_e.accountIdentifier = _g.sent(),
                            _e.senderId = message.senderId,
                            _e.origin = {
                                type: connectionInfo.origin,
                                id: connectionInfo.id
                            },
                            _e.address = address,
                            _e.publicKey = publicKey,
                            _e.network = message.network,
                            _e.scopes = message.scopes,
                            _e.threshold = message.threshold,
                            _e.notification = message.notification,
                            _e.connectedAt = new Date().getTime(),
                            _e);
                        return [4 /*yield*/, this.accountManager.addAccount(accountInfo)];
                    case 5:
                        _g.sent();
                        return [4 /*yield*/, this.setActiveAccount(accountInfo)];
                    case 6:
                        _g.sent();
                        output = __assign(__assign({}, message), { address: address, accountInfo: accountInfo });
                        _b = this.notifySuccess;
                        _c = [request];
                        _f = {
                            account: accountInfo,
                            output: output,
                            blockExplorer: this.blockExplorer,
                            connectionContext: connectionInfo
                        };
                        return [4 /*yield*/, this.getWalletInfo()];
                    case 7: return [4 /*yield*/, _b.apply(this, _c.concat([(_f.walletInfo = _g.sent(),
                                _f)]))];
                    case 8:
                        _g.sent();
                        return [2 /*return*/, output];
                }
            });
        });
    };
    /**
     * This method will send a "SignPayloadRequest" to the wallet. This method is meant to be used to sign
     * arbitrary data (eg. a string). It will return the signature in the format of "edsig..."
     *
     * @param input The message details we need to prepare the SignPayloadRequest message.
     */
    DAppClient.prototype.requestSignPayload = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            var activeAccount, payload, signingType, request, _a, message, connectionInfo, _b, _c;
            var _d;
            var _this = this;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!!input.payload) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.sendInternalError('Payload must be provided')];
                    case 1: throw _e.sent();
                    case 2: return [4 /*yield*/, this.getActiveAccount()];
                    case 3:
                        activeAccount = _e.sent();
                        if (!!activeAccount) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.sendInternalError('No active account!')];
                    case 4: throw _e.sent();
                    case 5:
                        payload = input.payload;
                        if (typeof payload !== 'string') {
                            throw new Error('Payload must be a string');
                        }
                        signingType = (function () {
                            switch (input.signingType) {
                                case beacon_types_1.SigningType.OPERATION:
                                    if (!payload.startsWith('03')) {
                                        throw new Error('When using signing type "OPERATION", the payload must start with prefix "03"');
                                    }
                                    return beacon_types_1.SigningType.OPERATION;
                                case beacon_types_1.SigningType.MICHELINE:
                                    if (!payload.startsWith('05')) {
                                        throw new Error('When using signing type "MICHELINE", the payload must start with prefix "05"');
                                    }
                                    return beacon_types_1.SigningType.MICHELINE;
                                case beacon_types_1.SigningType.RAW:
                                default:
                                    return beacon_types_1.SigningType.RAW;
                            }
                        })();
                        request = {
                            type: beacon_types_1.BeaconMessageType.SignPayloadRequest,
                            signingType: signingType,
                            payload: payload,
                            sourceAddress: input.sourceAddress || activeAccount.address
                        };
                        return [4 /*yield*/, this.makeRequest(request).catch(function (requestError) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.handleRequestError(request, requestError)];
                                        case 1: throw _a.sent();
                                    }
                                });
                            }); })];
                    case 6:
                        _a = _e.sent(), message = _a.message, connectionInfo = _a.connectionInfo;
                        _b = this.notifySuccess;
                        _c = [request];
                        _d = {
                            account: activeAccount,
                            output: message,
                            connectionContext: connectionInfo
                        };
                        return [4 /*yield*/, this.getWalletInfo()];
                    case 7: return [4 /*yield*/, _b.apply(this, _c.concat([(_d.walletInfo = _e.sent(),
                                _d)]))];
                    case 8:
                        _e.sent();
                        return [2 /*return*/, message];
                }
            });
        });
    };
    /**
     * This method will send an "EncryptPayloadRequest" to the wallet. This method is meant to be used to encrypt or decrypt
     * arbitrary data (eg. a string). It will return the encrypted or decrypted payload
     *
     * @param input The message details we need to prepare the EncryptPayloadRequest message.
     */
    // TODO: ENCRYPTION
    // public async requestEncryptPayload(
    //   input: RequestEncryptPayloadInput
    // ): Promise<EncryptPayloadResponseOutput> {
    //   if (!input.payload) {
    //     throw await this.sendInternalError('Payload must be provided')
    //   }
    //   const activeAccount: AccountInfo | undefined = await this.getActiveAccount()
    //   if (!activeAccount) {
    //     throw await this.sendInternalError('No active account!')
    //   }
    //   const payload = input.payload
    //   if (typeof payload !== 'string') {
    //     throw new Error('Payload must be a string')
    //   }
    //   if (typeof input.encryptionCryptoOperation === 'undefined') {
    //     throw new Error('encryptionCryptoOperation must be defined')
    //   }
    //   if (typeof input.encryptionType === 'undefined') {
    //     throw new Error('encryptionType must be defined')
    //   }
    //   const request: EncryptPayloadRequestInput = {
    //     type: BeaconMessageType.EncryptPayloadRequest,
    //     cryptoOperation: input.encryptionCryptoOperation,
    //     encryptionType: input.encryptionType,
    //     payload,
    //     sourceAddress: input.sourceAddress || activeAccount.address
    //   }
    //   const { message, connectionInfo } = await this.makeRequest<
    //     EncryptPayloadRequest,
    //     EncryptPayloadResponse
    //   >(request).catch(async (requestError: ErrorResponse) => {
    //     throw await this.handleRequestError(request, requestError)
    //   })
    //   await this.notifySuccess(request, {
    //     account: activeAccount,
    //     output: message,
    //     connectionContext: connectionInfo,
    //     walletInfo: await this.getWalletInfo()
    //   })
    //   return message
    // }
    /**
     * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,
     * eg. transaction or delegation. Not all properties have to be provided. Data like "counter" and fees will be
     * fetched and calculated by the wallet (but they can still be provided if required).
     *
     * @param input The message details we need to prepare the OperationRequest message.
     */
    DAppClient.prototype.requestOperation = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            var activeAccount, request, _a, message, connectionInfo, _b, _c;
            var _d;
            var _this = this;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!!input.operationDetails) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.sendInternalError('Operation details must be provided')];
                    case 1: throw _e.sent();
                    case 2: return [4 /*yield*/, this.getActiveAccount()];
                    case 3:
                        activeAccount = _e.sent();
                        if (!!activeAccount) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.sendInternalError('No active account!')];
                    case 4: throw _e.sent();
                    case 5:
                        request = {
                            type: beacon_types_1.BeaconMessageType.OperationRequest,
                            network: activeAccount.network || { type: beacon_types_1.NetworkType.MAINNET },
                            operationDetails: input.operationDetails,
                            sourceAddress: activeAccount.address || ''
                        };
                        return [4 /*yield*/, this.makeRequest(request).catch(function (requestError) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.handleRequestError(request, requestError)];
                                        case 1: throw _a.sent();
                                    }
                                });
                            }); })];
                    case 6:
                        _a = _e.sent(), message = _a.message, connectionInfo = _a.connectionInfo;
                        _b = this.notifySuccess;
                        _c = [request];
                        _d = {
                            account: activeAccount,
                            output: message,
                            blockExplorer: this.blockExplorer,
                            connectionContext: connectionInfo
                        };
                        return [4 /*yield*/, this.getWalletInfo()];
                    case 7: return [4 /*yield*/, _b.apply(this, _c.concat([(_d.walletInfo = _e.sent(),
                                _d)]))];
                    case 8:
                        _e.sent();
                        return [2 /*return*/, message];
                }
            });
        });
    };
    /**
     * Sends a "BroadcastRequest" to the wallet. This method can be used to inject an already signed transaction
     * to the network.
     *
     * @param input The message details we need to prepare the BroadcastRequest message.
     */
    DAppClient.prototype.requestBroadcast = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            var network, request, _a, message, connectionInfo, _b, _c;
            var _d;
            var _this = this;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!!input.signedTransaction) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.sendInternalError('Signed transaction must be provided')];
                    case 1: throw _e.sent();
                    case 2:
                        network = input.network || { type: beacon_types_1.NetworkType.MAINNET };
                        request = {
                            type: beacon_types_1.BeaconMessageType.BroadcastRequest,
                            network: network,
                            signedTransaction: input.signedTransaction
                        };
                        return [4 /*yield*/, this.makeRequest(request).catch(function (requestError) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.handleRequestError(request, requestError)];
                                        case 1: throw _a.sent();
                                    }
                                });
                            }); })];
                    case 3:
                        _a = _e.sent(), message = _a.message, connectionInfo = _a.connectionInfo;
                        _b = this.notifySuccess;
                        _c = [request];
                        _d = {
                            network: network,
                            output: message,
                            blockExplorer: this.blockExplorer,
                            connectionContext: connectionInfo
                        };
                        return [4 /*yield*/, this.getWalletInfo()];
                    case 4: return [4 /*yield*/, _b.apply(this, _c.concat([(_d.walletInfo = _e.sent(),
                                _d)]))];
                    case 5:
                        _e.sent();
                        return [2 /*return*/, message];
                }
            });
        });
    };
    DAppClient.prototype.setActivePeer = function (peer) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._activePeer.isSettled()) {
                            // If the promise has already been resolved we need to create a new one.
                            this._activePeer = beacon_utils_1.ExposedPromise.resolve(peer);
                        }
                        else {
                            this._activePeer.resolve(peer);
                        }
                        if (!peer) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.initInternalTransports()];
                    case 1:
                        _a.sent();
                        if (!(peer.type === 'postmessage-pairing-response')) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.setTransport(this.postMessageTransport)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 3:
                        if (!(peer.type === 'p2p-pairing-response')) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.setTransport(this.p2pTransport)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * A "setter" for when the transport needs to be changed.
     */
    DAppClient.prototype.setTransport = function (transport) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!transport) {
                            this._initPromise = undefined;
                        }
                        result = _super.prototype.setTransport.call(this, transport);
                        return [4 /*yield*/, this.events.emit(events_1.BeaconEvent.ACTIVE_TRANSPORT_SET, transport)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * This method will emit an internal error message.
     *
     * @param errorMessage The error message to send.
     */
    DAppClient.prototype.sendInternalError = function (errorMessage) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.events.emit(events_1.BeaconEvent.INTERNAL_ERROR, { text: errorMessage })];
                    case 1:
                        _a.sent();
                        throw new Error(errorMessage);
                }
            });
        });
    };
    /**
     * This method will remove all accounts associated with a specific peer.
     *
     * @param peersToRemove An array of peers for which accounts should be removed
     */
    DAppClient.prototype.removeAccountsForPeers = function (peersToRemove) {
        return __awaiter(this, void 0, void 0, function () {
            var accounts, peerIdsToRemove, accountsToRemove, accountIdentifiersToRemove, activeAccount;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.accountManager.getAccounts()];
                    case 1:
                        accounts = _a.sent();
                        peerIdsToRemove = peersToRemove.map(function (peer) { return peer.senderId; });
                        accountsToRemove = accounts.filter(function (account) {
                            return peerIdsToRemove.includes(account.senderId);
                        });
                        accountIdentifiersToRemove = accountsToRemove.map(function (accountInfo) { return accountInfo.accountIdentifier; });
                        return [4 /*yield*/, this.accountManager.removeAccounts(accountIdentifiersToRemove)
                            // Check if one of the accounts that was removed was the active account and if yes, set it to undefined
                        ];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 3:
                        activeAccount = _a.sent();
                        if (!activeAccount) return [3 /*break*/, 5];
                        if (!accountIdentifiersToRemove.includes(activeAccount.accountIdentifier)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.setActiveAccount(undefined)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * This message handles errors that we receive from the wallet.
     *
     * @param request The request we sent
     * @param beaconError The error we received
     */
    DAppClient.prototype.handleRequestError = function (request, beaconError) {
        return __awaiter(this, void 0, void 0, function () {
            var buttons, actionCallback, peer, activeAccount, _a, _b, _c, _d;
            var _e;
            var _this = this;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        logger.error('handleRequestError', 'error response', beaconError);
                        if (!beaconError.errorType) return [3 /*break*/, 9];
                        buttons = [];
                        if (beaconError.errorType === beacon_types_1.BeaconErrorType.NO_PRIVATE_KEY_FOUND_ERROR) {
                            actionCallback = function () { return __awaiter(_this, void 0, void 0, function () {
                                var operationRequest, accountInfo, accountIdentifier;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            operationRequest = request;
                                            if (!(operationRequest.sourceAddress && operationRequest.network)) return [3 /*break*/, 4];
                                            return [4 /*yield*/, (0, beacon_core_1.getAccountIdentifier)(operationRequest.sourceAddress, operationRequest.network)];
                                        case 1:
                                            accountIdentifier = _a.sent();
                                            return [4 /*yield*/, this.getAccount(accountIdentifier)];
                                        case 2:
                                            accountInfo = _a.sent();
                                            if (!accountInfo) return [3 /*break*/, 4];
                                            return [4 /*yield*/, this.removeAccount(accountInfo.accountIdentifier)];
                                        case 3:
                                            _a.sent();
                                            _a.label = 4;
                                        case 4: return [2 /*return*/];
                                    }
                                });
                            }); };
                            buttons.push({ text: 'Remove account', actionCallback: actionCallback });
                        }
                        return [4 /*yield*/, this.getPeer()];
                    case 1:
                        peer = _f.sent();
                        return [4 /*yield*/, this.getActiveAccount()
                            // If we sent a permission request, received an error and there is no active account, we need to reset the DAppClient.
                            // This most likely means that the user rejected the first permission request after pairing a wallet, so we "forget" the paired wallet to allow the user to pair again.
                        ];
                    case 2:
                        activeAccount = _f.sent();
                        _a = request.type === beacon_types_1.BeaconMessageType.PermissionRequest;
                        if (!_a) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 3:
                        _a = (_f.sent()) === undefined;
                        _f.label = 4;
                    case 4:
                        if (!_a) return [3 /*break*/, 7];
                        this._initPromise = undefined;
                        this.postMessageTransport = undefined;
                        this.p2pTransport = undefined;
                        return [4 /*yield*/, this.setTransport()];
                    case 5:
                        _f.sent();
                        return [4 /*yield*/, this.setActivePeer()];
                    case 6:
                        _f.sent();
                        _f.label = 7;
                    case 7:
                        _c = (_b = this.events)
                            .emit;
                        _d = [beacon_message_events_1.messageEvents[request.type].error];
                        _e = {
                            errorResponse: beaconError
                        };
                        return [4 /*yield*/, this.getWalletInfo(peer, activeAccount)];
                    case 8:
                        _c.apply(_b, _d.concat([(_e.walletInfo = _f.sent(),
                                _e.errorMessages = this.errorMessages,
                                _e), buttons]))
                            .catch(function (emitError) { return logger.error('handleRequestError', emitError); });
                        throw beacon_core_1.BeaconError.getError(beaconError.errorType, beaconError.errorData);
                    case 9: throw beaconError;
                }
            });
        });
    };
    /**
     * This message will send an event when we receive a successful response to one of the requests we sent.
     *
     * @param request The request we sent
     * @param response The response we received
     */
    DAppClient.prototype.notifySuccess = function (request, response) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.events
                    .emit(beacon_message_events_1.messageEvents[request.type].success, response)
                    .catch(function (emitError) { return console.warn(emitError); });
                return [2 /*return*/];
            });
        });
    };
    DAppClient.prototype.getWalletInfo = function (peer, account) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var selectedAccount, _c, selectedPeer, _d, walletInfo, typedPeer, lowerCaseCompare, selectedApp, type, deeplink;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!account) return [3 /*break*/, 1];
                        _c = account;
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.getActiveAccount()];
                    case 2:
                        _c = _e.sent();
                        _e.label = 3;
                    case 3:
                        selectedAccount = _c;
                        if (!peer) return [3 /*break*/, 4];
                        _d = peer;
                        return [3 /*break*/, 6];
                    case 4: return [4 /*yield*/, this.getPeer(selectedAccount)];
                    case 5:
                        _d = _e.sent();
                        _e.label = 6;
                    case 6:
                        selectedPeer = _d;
                        if (!selectedAccount) return [3 /*break*/, 8];
                        return [4 /*yield*/, this.appMetadataManager.getAppMetadata(selectedAccount.senderId)];
                    case 7:
                        walletInfo = _e.sent();
                        _e.label = 8;
                    case 8:
                        typedPeer = selectedPeer;
                        if (!walletInfo) {
                            walletInfo = {
                                name: typedPeer.name,
                                icon: typedPeer.icon
                            };
                        }
                        lowerCaseCompare = function (str1, str2) {
                            if (str1 && str2) {
                                return str1.toLowerCase() === str2.toLowerCase();
                            }
                            return false;
                        };
                        // TODO: Remove once all wallets send the icon?
                        if ((0, beacon_ui_2.getiOSList)().find(function (app) { return lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name); })) {
                            selectedApp = (0, beacon_ui_2.getiOSList)().find(function (app) { return lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name); });
                            type = 'mobile';
                        }
                        else if ((0, beacon_ui_2.getWebList)().find(function (app) { return lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name); })) {
                            selectedApp = (0, beacon_ui_2.getWebList)().find(function (app) { return lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name); });
                            type = 'web';
                        }
                        else if ((0, beacon_ui_2.getDesktopList)().find(function (app) { return lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name); })) {
                            selectedApp = (0, beacon_ui_2.getDesktopList)().find(function (app) { return lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name); });
                            type = 'desktop';
                        }
                        else if ((0, beacon_ui_2.getExtensionList)().find(function (app) { return lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name); })) {
                            selectedApp = (0, beacon_ui_2.getExtensionList)().find(function (app) { return lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name); });
                            type = 'extension';
                        }
                        if (selectedApp) {
                            deeplink = void 0;
                            if (selectedApp.hasOwnProperty('links')) {
                                deeplink = selectedApp.links[(_a = selectedAccount === null || selectedAccount === void 0 ? void 0 : selectedAccount.network.type) !== null && _a !== void 0 ? _a : this.preferredNetwork];
                            }
                            else if (selectedApp.hasOwnProperty('deepLink')) {
                                deeplink = selectedApp.deepLink;
                            }
                            return [2 /*return*/, {
                                    name: walletInfo.name,
                                    icon: (_b = walletInfo.icon) !== null && _b !== void 0 ? _b : selectedApp.logo,
                                    deeplink: deeplink,
                                    type: type
                                }];
                        }
                        return [2 /*return*/, walletInfo];
                }
            });
        });
    };
    DAppClient.prototype.getPeer = function (account) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function () {
            var peer, postMessagePeers, p2pPeers, peers;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!account) return [3 /*break*/, 3];
                        logger.log('getPeer', 'We have an account', account);
                        return [4 /*yield*/, ((_a = this.postMessageTransport) === null || _a === void 0 ? void 0 : _a.getPeers())];
                    case 1:
                        postMessagePeers = (_b = (_e.sent())) !== null && _b !== void 0 ? _b : [];
                        return [4 /*yield*/, ((_c = this.p2pTransport) === null || _c === void 0 ? void 0 : _c.getPeers())];
                    case 2:
                        p2pPeers = (_d = (_e.sent())) !== null && _d !== void 0 ? _d : [];
                        peers = __spreadArray(__spreadArray([], postMessagePeers, true), p2pPeers, true);
                        logger.log('getPeer', 'Found peers', peers, account);
                        peer = peers.find(function (peerEl) { return peerEl.senderId === account.senderId; });
                        if (!peer) {
                            // We could not find an exact match for a sender, so we most likely received it over a relay
                            peer = peers.find(function (peerEl) { return peerEl.extensionId === account.origin.id; });
                        }
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, this._activePeer.promise];
                    case 4:
                        peer = _e.sent();
                        logger.log('getPeer', 'Active peer', peer);
                        _e.label = 5;
                    case 5:
                        if (!peer) {
                            throw new Error('No matching peer found.');
                        }
                        return [2 /*return*/, peer];
                }
            });
        });
    };
    /**
     * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected
     * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent
     * to the DApp over the transport.
     *
     * @param requestInput The BeaconMessage to be sent to the wallet
     * @param account The account that the message will be sent to
     */
    DAppClient.prototype.makeRequest = function (requestInput) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var messageId, request, _b, exposed, payload, account, peer, walletInfo, sendError_1;
            var _c;
            var _this = this;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, (0, beacon_utils_1.generateGUID)()];
                    case 1:
                        messageId = _d.sent();
                        console.time(messageId);
                        logger.log('makeRequest', 'starting');
                        return [4 /*yield*/, this.init()];
                    case 2:
                        _d.sent();
                        console.timeLog(messageId, 'init done');
                        logger.log('makeRequest', 'after init');
                        return [4 /*yield*/, this.addRequestAndCheckIfRateLimited()];
                    case 3:
                        if (_d.sent()) {
                            this.events
                                .emit(events_1.BeaconEvent.LOCAL_RATE_LIMIT_REACHED)
                                .catch(function (emitError) { return console.warn(emitError); });
                            throw new Error('rate limit reached');
                        }
                        return [4 /*yield*/, this.checkPermissions(requestInput.type)];
                    case 4:
                        if (!(_d.sent())) {
                            this.events.emit(events_1.BeaconEvent.NO_PERMISSIONS).catch(function (emitError) { return console.warn(emitError); });
                            throw new Error('No permissions to send this request to wallet!');
                        }
                        if (!!this.beaconId) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.sendInternalError('BeaconID not defined')];
                    case 5: throw _d.sent();
                    case 6:
                        _c = { id: messageId, version: '2' };
                        _b = beacon_core_1.getSenderId;
                        return [4 /*yield*/, this.beaconId];
                    case 7: return [4 /*yield*/, _b.apply(void 0, [_d.sent()])];
                    case 8:
                        request = __assign.apply(void 0, [(_c.senderId = _d.sent(), _c), requestInput]);
                        exposed = new beacon_utils_1.ExposedPromise();
                        this.addOpenRequest(request.id, exposed);
                        return [4 /*yield*/, new beacon_core_1.Serializer().serialize(request)];
                    case 9:
                        payload = _d.sent();
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 10:
                        account = _d.sent();
                        return [4 /*yield*/, this.getPeer(account)];
                    case 11:
                        peer = _d.sent();
                        return [4 /*yield*/, this.getWalletInfo(peer, account)];
                    case 12:
                        walletInfo = _d.sent();
                        logger.log('makeRequest', 'sending message', request);
                        console.timeLog(messageId, 'sending');
                        _d.label = 13;
                    case 13:
                        _d.trys.push([13, 16, , 17]);
                        return [4 /*yield*/, this.transport];
                    case 14: return [4 /*yield*/, (_d.sent()).send(payload, peer)];
                    case 15:
                        _d.sent();
                        return [3 /*break*/, 17];
                    case 16:
                        sendError_1 = _d.sent();
                        this.events.emit(events_1.BeaconEvent.INTERNAL_ERROR, {
                            text: 'Unable to send message. If this problem persists, please reset the connection and pair your wallet again.',
                            buttons: [
                                {
                                    text: 'Reset Connection',
                                    actionCallback: function () { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0: return [4 /*yield*/, (0, beacon_ui_1.closeToast)()];
                                                case 1:
                                                    _a.sent();
                                                    this.disconnect();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); }
                                }
                            ]
                        });
                        console.timeLog(messageId, 'send error');
                        throw sendError_1;
                    case 17:
                        console.timeLog(messageId, 'sent');
                        this.events
                            .emit(beacon_message_events_1.messageEvents[requestInput.type].sent, {
                            walletInfo: __assign(__assign({}, walletInfo), { name: (_a = walletInfo.name) !== null && _a !== void 0 ? _a : 'Wallet' }),
                            extraInfo: {
                                resetCallback: function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        this.disconnect();
                                        return [2 /*return*/];
                                    });
                                }); }
                            }
                        })
                            .catch(function (emitError) { return console.warn(emitError); });
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        return [2 /*return*/, exposed.promise]; // TODO: fix type
                }
            });
        });
    };
    /**
     * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected
     * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent
     * to the DApp over the transport.
     *
     * @param requestInput The BeaconMessage to be sent to the wallet
     * @param account The account that the message will be sent to
     */
    DAppClient.prototype.makeRequestV3 = function (requestInput) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var messageId, request, _b, exposed, payload, account, peer, walletInfo, sendError_2, index;
            var _c;
            var _this = this;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, (0, beacon_utils_1.generateGUID)()];
                    case 1:
                        messageId = _d.sent();
                        console.time(messageId);
                        logger.log('makeRequest', 'starting');
                        return [4 /*yield*/, this.init()];
                    case 2:
                        _d.sent();
                        console.timeLog(messageId, 'init done');
                        logger.log('makeRequest', 'after init');
                        return [4 /*yield*/, this.addRequestAndCheckIfRateLimited()];
                    case 3:
                        if (_d.sent()) {
                            this.events
                                .emit(events_1.BeaconEvent.LOCAL_RATE_LIMIT_REACHED)
                                .catch(function (emitError) { return console.warn(emitError); });
                            throw new Error('rate limit reached');
                        }
                        if (!!this.beaconId) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.sendInternalError('BeaconID not defined')];
                    case 4: throw _d.sent();
                    case 5:
                        _c = {
                            id: messageId,
                            version: '3'
                        };
                        _b = beacon_core_1.getSenderId;
                        return [4 /*yield*/, this.beaconId];
                    case 6: return [4 /*yield*/, _b.apply(void 0, [_d.sent()])];
                    case 7:
                        request = (_c.senderId = _d.sent(),
                            _c.message = requestInput,
                            _c);
                        exposed = new beacon_utils_1.ExposedPromise();
                        this.addOpenRequest(request.id, exposed);
                        return [4 /*yield*/, new beacon_core_1.Serializer().serialize(request)];
                    case 8:
                        payload = _d.sent();
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 9:
                        account = _d.sent();
                        return [4 /*yield*/, this.getPeer(account)];
                    case 10:
                        peer = _d.sent();
                        return [4 /*yield*/, this.getWalletInfo(peer, account)];
                    case 11:
                        walletInfo = _d.sent();
                        logger.log('makeRequest', 'sending message', request);
                        console.timeLog(messageId, 'sending');
                        _d.label = 12;
                    case 12:
                        _d.trys.push([12, 15, , 16]);
                        return [4 /*yield*/, this.transport];
                    case 13: return [4 /*yield*/, (_d.sent()).send(payload, peer)];
                    case 14:
                        _d.sent();
                        return [3 /*break*/, 16];
                    case 15:
                        sendError_2 = _d.sent();
                        this.events.emit(events_1.BeaconEvent.INTERNAL_ERROR, {
                            text: 'Unable to send message. If this problem persists, please reset the connection and pair your wallet again.',
                            buttons: [
                                {
                                    text: 'Reset Connection',
                                    actionCallback: function () { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0: return [4 /*yield*/, (0, beacon_ui_1.closeToast)()];
                                                case 1:
                                                    _a.sent();
                                                    this.disconnect();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); }
                                }
                            ]
                        });
                        console.timeLog(messageId, 'send error');
                        throw sendError_2;
                    case 16:
                        console.timeLog(messageId, 'sent');
                        index = requestInput.type;
                        this.events
                            .emit(beacon_message_events_1.messageEvents[index].sent, {
                            walletInfo: __assign(__assign({}, walletInfo), { name: (_a = walletInfo.name) !== null && _a !== void 0 ? _a : 'Wallet' }),
                            extraInfo: {
                                resetCallback: function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        this.disconnect();
                                        return [2 /*return*/];
                                    });
                                }); }
                            }
                        })
                            .catch(function (emitError) { return console.warn(emitError); });
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        return [2 /*return*/, exposed.promise]; // TODO: fix type
                }
            });
        });
    };
    DAppClient.prototype.disconnect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        this.postMessageTransport = undefined;
                        this.p2pTransport = undefined;
                        _b = (_a = Promise).all;
                        _c = [this.clearActiveAccount()];
                        return [4 /*yield*/, this.transport];
                    case 1: return [4 /*yield*/, _b.apply(_a, [_c.concat([(_d.sent()).disconnect()])])];
                    case 2:
                        _d.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Adds a requests to the "openRequests" set so we know what messages have already been answered/handled.
     *
     * @param id The ID of the message
     * @param promise A promise that resolves once the response for that specific message is received
     */
    DAppClient.prototype.addOpenRequest = function (id, promise) {
        logger.log('addOpenRequest', this.name, "adding request ".concat(id, " and waiting for answer"));
        this.openRequests.set(id, promise);
    };
    DAppClient.prototype.sendNotificationWithAccessToken = function (notification) {
        return __awaiter(this, void 0, void 0, function () {
            var url, recipient, title, body, payload, protocolIdentifier, accessToken, timestamp, keypair, rawPublicKey, prefix, publicKey, constructedString, bytes, payloadBytes, signature, notificationResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = notification.url, recipient = notification.recipient, title = notification.title, body = notification.body, payload = notification.payload, protocolIdentifier = notification.protocolIdentifier, accessToken = notification.accessToken;
                        timestamp = new Date().toISOString();
                        return [4 /*yield*/, this.keyPair];
                    case 1:
                        keypair = _a.sent();
                        rawPublicKey = keypair.publicKey;
                        prefix = Buffer.from(new Uint8Array([13, 15, 37, 217]));
                        publicKey = bs58check.encode(Buffer.concat([prefix, Buffer.from(rawPublicKey)]));
                        constructedString = [
                            'Tezos Signed Message: ',
                            recipient,
                            title,
                            body,
                            timestamp,
                            payload
                        ].join(' ');
                        bytes = (0, beacon_utils_1.toHex)(constructedString);
                        payloadBytes = '05' + '01' + bytes.length.toString(16).padStart(8, '0') + bytes;
                        return [4 /*yield*/, (0, beacon_utils_2.signMessage)(payloadBytes, {
                                secretKey: Buffer.from(keypair.secretKey)
                            })];
                    case 2:
                        signature = _a.sent();
                        return [4 /*yield*/, axios_1.default.post("".concat(url, "/send"), {
                                recipient: recipient,
                                title: title,
                                body: body,
                                timestamp: timestamp,
                                payload: payload,
                                accessToken: accessToken,
                                protocolIdentifier: protocolIdentifier,
                                sender: {
                                    name: this.name,
                                    publicKey: publicKey,
                                    signature: signature
                                }
                            })];
                    case 3:
                        notificationResponse = _a.sent();
                        return [2 /*return*/, notificationResponse.data];
                }
            });
        });
    };
    return DAppClient;
}(beacon_core_1.Client));
exports.DAppClient = DAppClient;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../beacon-message-events":75,"../events":77,"../transports/DappP2PTransport":79,"../transports/DappPostMessageTransport":80,"../utils/tzkt-blockexplorer":84,"@airgap/beacon-core":58,"@airgap/beacon-dapp":78,"@airgap/beacon-transport-postmessage":103,"@airgap/beacon-types":104,"@airgap/beacon-ui":122,"@airgap/beacon-utils":136,"axios":212,"bs58check":251,"buffer":3}],77:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BeaconEventHandler = exports.defaultEventCallbacks = exports.BeaconEvent = void 0;
var beacon_dapp_1 = require("@airgap/beacon-dapp");
var beacon_types_1 = require("@airgap/beacon-types");
var beacon_core_1 = require("@airgap/beacon-core");
var shorten_string_1 = require("./utils/shorten-string");
var beacon_ui_1 = require("@airgap/beacon-ui");
var logger = new beacon_core_1.Logger('BeaconEvents');
var SUCCESS_TIMER = 5 * 1000;
/**
 * The different events that can be emitted by the beacon-sdk
 */
var BeaconEvent;
(function (BeaconEvent) {
    BeaconEvent["PERMISSION_REQUEST_SENT"] = "PERMISSION_REQUEST_SENT";
    BeaconEvent["PERMISSION_REQUEST_SUCCESS"] = "PERMISSION_REQUEST_SUCCESS";
    BeaconEvent["PERMISSION_REQUEST_ERROR"] = "PERMISSION_REQUEST_ERROR";
    BeaconEvent["OPERATION_REQUEST_SENT"] = "OPERATION_REQUEST_SENT";
    BeaconEvent["OPERATION_REQUEST_SUCCESS"] = "OPERATION_REQUEST_SUCCESS";
    BeaconEvent["OPERATION_REQUEST_ERROR"] = "OPERATION_REQUEST_ERROR";
    BeaconEvent["SIGN_REQUEST_SENT"] = "SIGN_REQUEST_SENT";
    BeaconEvent["SIGN_REQUEST_SUCCESS"] = "SIGN_REQUEST_SUCCESS";
    BeaconEvent["SIGN_REQUEST_ERROR"] = "SIGN_REQUEST_ERROR";
    // TODO: ENCRYPTION
    // ENCRYPT_REQUEST_SENT = 'ENCRYPT_REQUEST_SENT',
    // ENCRYPT_REQUEST_SUCCESS = 'ENCRYPT_REQUEST_SUCCESS',
    // ENCRYPT_REQUEST_ERROR = 'ENCRYPT_REQUEST_ERROR',
    BeaconEvent["BROADCAST_REQUEST_SENT"] = "BROADCAST_REQUEST_SENT";
    BeaconEvent["BROADCAST_REQUEST_SUCCESS"] = "BROADCAST_REQUEST_SUCCESS";
    BeaconEvent["BROADCAST_REQUEST_ERROR"] = "BROADCAST_REQUEST_ERROR";
    BeaconEvent["ACKNOWLEDGE_RECEIVED"] = "ACKNOWLEDGE_RECEIVED";
    BeaconEvent["LOCAL_RATE_LIMIT_REACHED"] = "LOCAL_RATE_LIMIT_REACHED";
    BeaconEvent["NO_PERMISSIONS"] = "NO_PERMISSIONS";
    BeaconEvent["ACTIVE_ACCOUNT_SET"] = "ACTIVE_ACCOUNT_SET";
    BeaconEvent["ACTIVE_TRANSPORT_SET"] = "ACTIVE_TRANSPORT_SET";
    BeaconEvent["SHOW_PREPARE"] = "SHOW_PREPARE";
    BeaconEvent["HIDE_UI"] = "HIDE_UI";
    BeaconEvent["PAIR_INIT"] = "PAIR_INIT";
    BeaconEvent["PAIR_SUCCESS"] = "PAIR_SUCCESS";
    BeaconEvent["CHANNEL_CLOSED"] = "CHANNEL_CLOSED";
    BeaconEvent["INTERNAL_ERROR"] = "INTERNAL_ERROR";
    BeaconEvent["UNKNOWN"] = "UNKNOWN";
})(BeaconEvent = exports.BeaconEvent || (exports.BeaconEvent = {}));
/**
 * Show a "Request sent" toast
 */
var showSentToast = function (data) { return __awaiter(void 0, void 0, void 0, function () {
    var openWalletAction, actions, link_1;
    return __generator(this, function (_a) {
        actions = [];
        if (data.walletInfo.deeplink) {
            if (data.walletInfo.type === 'web' ||
                (data.walletInfo.type === 'mobile' && (0, beacon_ui_1.isMobile)(window)) ||
                (data.walletInfo.type === 'desktop' && !(0, beacon_ui_1.isMobile)(window))) {
                link_1 = data.walletInfo.deeplink;
                openWalletAction = function () { return __awaiter(void 0, void 0, void 0, function () {
                    var a;
                    return __generator(this, function (_a) {
                        a = document.createElement('a');
                        a.setAttribute('href', link_1);
                        a.setAttribute('target', '_blank');
                        a.dispatchEvent(new MouseEvent('click', { view: window, bubbles: true, cancelable: true }));
                        return [2 /*return*/];
                    });
                }); };
            }
        }
        actions.push({
            text: "No answer from your wallet received yet. Please make sure the wallet is open.",
            isBold: true
        });
        actions.push({
            text: 'Did you make a mistake?',
            actionText: 'Cancel Request',
            actionCallback: function () { return __awaiter(void 0, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, beacon_dapp_1.closeToast)()];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); }
        });
        actions.push({
            text: 'Wallet not receiving request?',
            actionText: 'Reset Connection',
            actionCallback: function () { return __awaiter(void 0, void 0, void 0, function () {
                var resetCallback;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, beacon_dapp_1.closeToast)()
                            // eslint-disable-next-line @typescript-eslint/unbound-method
                        ];
                        case 1:
                            _a.sent();
                            resetCallback = data.extraInfo.resetCallback;
                            if (!resetCallback) return [3 /*break*/, 3];
                            logger.log('showSentToast', 'resetCallback invoked');
                            return [4 /*yield*/, resetCallback()];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3: return [2 /*return*/];
                    }
                });
            }); }
        });
        (0, beacon_dapp_1.openToast)({
            body: "Request sent to\u00A0 {{wallet}}",
            walletInfo: data.walletInfo,
            state: 'loading',
            actions: actions,
            openWalletAction: openWalletAction
        }).catch(function (toastError) { return console.error(toastError); });
        return [2 /*return*/];
    });
}); };
var showAcknowledgedToast = function (data) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        (0, beacon_dapp_1.openToast)({
            body: 'Awaiting confirmation in\u00A0 {{wallet}}',
            state: 'acknowledge',
            walletInfo: data.walletInfo
        }).catch(function (toastError) { return console.error(toastError); });
        return [2 /*return*/];
    });
}); };
var showPrepare = function (data) { return __awaiter(void 0, void 0, void 0, function () {
    var text;
    return __generator(this, function (_a) {
        text = data.walletInfo
            ? "Preparing Request for\u00A0 {{wallet}}..."
            : 'Preparing Request...';
        (0, beacon_dapp_1.openToast)({
            body: text,
            state: 'prepare',
            walletInfo: data.walletInfo
        }).catch(function (toastError) { return console.error(toastError); });
        return [2 /*return*/];
    });
}); };
var hideUI = function (elements) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        if (elements) {
            if (elements.includes('alert')) {
                (0, beacon_dapp_1.closeAlerts)();
            }
            if (elements.includes('toast')) {
                (0, beacon_dapp_1.closeToast)();
            }
        }
        else {
            (0, beacon_dapp_1.closeToast)();
        }
        return [2 /*return*/];
    });
}); };
/**
 * Show a "No Permission" alert
 */
var showNoPermissionAlert = function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, beacon_dapp_1.openAlert)({
                    title: 'No Permission',
                    body: 'Please allow the wallet to handle this type of request.'
                })];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };
/**
 * Show an error toast
 *
 * @param beaconError The beacon error
 */
var showErrorToast = function (response, buttons) { return __awaiter(void 0, void 0, void 0, function () {
    var error, actions, err, errorMessages, hasHumandReadableError, errCode, contractErrors;
    var _a, _b, _c, _d, _e, _f;
    return __generator(this, function (_g) {
        switch (_g.label) {
            case 0:
                error = response.errorResponse.errorType
                    ? beacon_core_1.BeaconError.getError(response.errorResponse.errorType, response.errorResponse.errorData)
                    : new beacon_core_1.UnknownBeaconError();
                actions = [
                    {
                        text: error.title,
                        isBold: true
                    }
                ];
                if (response.errorResponse.errorType === beacon_types_1.BeaconErrorType.TRANSACTION_INVALID_ERROR &&
                    response.errorResponse.errorData) {
                    err = response.errorResponse.errorData;
                    errorMessages = response.errorMessages;
                    hasHumandReadableError = false;
                    if (((_a = err[0]) === null || _a === void 0 ? void 0 : _a.contract_handle) && errorMessages && (errorMessages === null || errorMessages === void 0 ? void 0 : errorMessages[err[0].contract_handle])) {
                        errCode = (_d = (_c = (_b = err[1]) === null || _b === void 0 ? void 0 : _b.with) === null || _c === void 0 ? void 0 : _c.int) !== null && _d !== void 0 ? _d : (_f = (_e = err[1]) === null || _e === void 0 ? void 0 : _e.with) === null || _f === void 0 ? void 0 : _f.string;
                        contractErrors = errorMessages === null || errorMessages === void 0 ? void 0 : errorMessages[err[0].contract_handle];
                        if (errCode && (contractErrors === null || contractErrors === void 0 ? void 0 : contractErrors[errCode])) {
                            actions.push({
                                text: contractErrors === null || contractErrors === void 0 ? void 0 : contractErrors[errCode],
                                isBold: true
                            });
                            hasHumandReadableError = true;
                        }
                    }
                    if (!hasHumandReadableError) {
                        actions.push({
                            text: error.description
                        });
                    }
                    actions.push({
                        text: '',
                        actionText: 'Show Details',
                        actionCallback: function () { return __awaiter(void 0, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, (0, beacon_dapp_1.closeToast)()];
                                    case 1:
                                        _a.sent();
                                        return [4 /*yield*/, (0, beacon_dapp_1.openAlert)({
                                                title: error.title,
                                                // eslint-disable-next-line @typescript-eslint/unbound-method
                                                body: error.fullDescription.description,
                                                data: error.fullDescription.data,
                                                buttons: buttons
                                            })];
                                    case 2:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); }
                    });
                }
                return [4 /*yield*/, (0, beacon_dapp_1.openToast)({
                        body: "{{wallet}}\u00A0 has returned an error",
                        timer: response.errorResponse.errorType === beacon_types_1.BeaconErrorType.ABORTED_ERROR
                            ? SUCCESS_TIMER
                            : undefined,
                        state: 'finished',
                        walletInfo: response.walletInfo,
                        actions: actions
                    })];
            case 1:
                _g.sent();
                return [2 /*return*/];
        }
    });
}); };
/**
 * Show a rate limit reached toast
 */
var showRateLimitReached = function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        (0, beacon_dapp_1.openAlert)({
            title: 'Error',
            body: 'Rate limit reached. Please slow down',
            buttons: [{ text: 'Done', style: 'outline' }],
            timer: 3000
        }).catch(function (toastError) { return console.error(toastError); });
        return [2 /*return*/];
    });
}); };
/**
 * Show a "connection successful" alert for 1.5 seconds
 */
var showExtensionConnectedAlert = function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, beacon_dapp_1.closeAlerts)()];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };
/**
 * Show a "channel closed" alert for 1.5 seconds
 */
var showChannelClosedAlert = function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, beacon_dapp_1.openAlert)({
                    title: 'Channel closed',
                    body: "Your peer has closed the connection.",
                    buttons: [{ text: 'Done', style: 'outline' }],
                    timer: 1500
                })];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };
var showInternalErrorAlert = function (data) { return __awaiter(void 0, void 0, void 0, function () {
    var buttons, alertConfig;
    var _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                buttons = __spreadArray([], ((_a = data.buttons) !== null && _a !== void 0 ? _a : []), true);
                buttons.push({ text: 'Done', style: 'outline' });
                alertConfig = {
                    title: 'Internal Error',
                    body: data.text,
                    buttons: buttons
                };
                return [4 /*yield*/, (0, beacon_dapp_1.openAlert)(alertConfig)];
            case 1:
                _b.sent();
                return [2 /*return*/];
        }
    });
}); };
/**
 * Show a connect alert with QR code
 *
 * @param data The data that is emitted by the PAIR_INIT event
 */
var showPairAlert = function (data) { return __awaiter(void 0, void 0, void 0, function () {
    var alertConfig;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                alertConfig = {
                    title: 'Choose your preferred wallet',
                    body: "<p></p>",
                    pairingPayload: {
                        p2pSyncCode: data.p2pPeerInfo,
                        postmessageSyncCode: data.postmessagePeerInfo,
                        preferredNetwork: data.preferredNetwork
                    },
                    // eslint-disable-next-line @typescript-eslint/unbound-method
                    closeButtonCallback: data.abortedHandler,
                    disclaimerText: data.disclaimerText
                };
                return [4 /*yield*/, (0, beacon_dapp_1.openAlert)(alertConfig)];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };
/**
 * Show a "Permission Granted" alert
 *
 * @param data The data that is emitted by the PERMISSION_REQUEST_SUCCESS event
 */
var showPermissionSuccessAlert = function (data) { return __awaiter(void 0, void 0, void 0, function () {
    var output;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                output = data.output;
                return [4 /*yield*/, (0, beacon_dapp_1.openToast)({
                        body: "{{wallet}}\u00A0 has granted permission",
                        timer: SUCCESS_TIMER,
                        walletInfo: data.walletInfo,
                        state: 'finished',
                        actions: [
                            {
                                text: 'Address',
                                actionText: (0, shorten_string_1.shortenString)(output.address),
                                isBold: true
                            },
                            {
                                text: 'Network',
                                actionText: "".concat(output.network.type)
                            },
                            {
                                text: 'Permissions',
                                actionText: output.scopes.join(', ')
                            }
                        ]
                    })];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };
/**
 * Show an "Operation Broadcasted" alert
 *
 * @param data The data that is emitted by the OPERATION_REQUEST_SUCCESS event
 */
var showOperationSuccessAlert = function (data) { return __awaiter(void 0, void 0, void 0, function () {
    var account, output, blockExplorer;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                account = data.account, output = data.output, blockExplorer = data.blockExplorer;
                return [4 /*yield*/, (0, beacon_dapp_1.openToast)({
                        body: "{{wallet}}\u00A0 successfully submitted operation",
                        timer: SUCCESS_TIMER,
                        state: 'finished',
                        walletInfo: data.walletInfo,
                        actions: [
                            {
                                text: (0, shorten_string_1.shortenString)(output.transactionHash),
                                isBold: true,
                                actionText: "Open Blockexplorer",
                                actionLogo: 'external',
                                actionCallback: function () { return __awaiter(void 0, void 0, void 0, function () {
                                    var link;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, blockExplorer.getTransactionLink(output.transactionHash, account.network)];
                                            case 1:
                                                link = _a.sent();
                                                window.open(link, '_blank');
                                                return [4 /*yield*/, (0, beacon_dapp_1.closeToast)()];
                                            case 2:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); }
                            }
                        ]
                    })];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };
/**
 * Show a "Transaction Signed" alert
 *
 * @param data The data that is emitted by the SIGN_REQUEST_SUCCESS event
 */
var showSignSuccessAlert = function (data) { return __awaiter(void 0, void 0, void 0, function () {
    var output;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                output = data.output;
                return [4 /*yield*/, (0, beacon_dapp_1.openToast)({
                        body: "{{wallet}}\u00A0 successfully signed payload",
                        timer: SUCCESS_TIMER,
                        state: 'finished',
                        walletInfo: data.walletInfo,
                        actions: [
                            {
                                text: "Signature: ".concat((0, shorten_string_1.shortenString)(output.signature)),
                                actionText: 'Copy to clipboard',
                                actionCallback: function () { return __awaiter(void 0, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                navigator.clipboard.writeText(output.signature).then(function () {
                                                    logger.log('showSignSuccessAlert', 'Copying to clipboard was successful!');
                                                }, function (err) {
                                                    logger.error('showSignSuccessAlert', 'Could not copy text to clipboard: ', err);
                                                });
                                                return [4 /*yield*/, (0, beacon_dapp_1.closeToast)()];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); }
                            }
                        ]
                    })];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };
/**
 * Show a "Transaction Signed" alert
 *
 * @param data The data that is emitted by the ENCRYPT_REQUEST_SUCCESS event
 */
// TODO: ENCRYPTION
// const showEncryptSuccessAlert = async (
//   data: BeaconEventType[BeaconEvent.ENCRYPT_REQUEST_SUCCESS]
// ): Promise<void> => {
//   const output = data.output
//   await openToast({
//     body: `{{wallet}}\u00A0 successfully ${
//       data.output.cryptoOperation === EncryptionOperation.ENCRYPT ? 'encrypted' : 'decrypted'
//     } payload`,
//     timer: SUCCESS_TIMER,
//     state: 'finished',
//     walletInfo: data.walletInfo,
//     actions: [
//       {
//         text: `Payload: <strong>${shortenString(output.payload)}</strong>`,
//         actionText: 'Copy to clipboard',
//         actionCallback: async (): Promise<void> => {
//           navigator.clipboard.writeText(output.payload).then(
//             () => {
//               logger.log('showSignSuccessAlert', 'Copying to clipboard was successful!')
//             },
//             (err) => {
//               logger.error('showSignSuccessAlert', 'Could not copy text to clipboard: ', err)
//             }
//           )
//           await closeToast()
//         }
//       }
//     ]
//   })
// }
/**
 * Show a "Broadcasted" alert
 *
 * @param data The data that is emitted by the BROADCAST_REQUEST_SUCCESS event
 */
var showBroadcastSuccessAlert = function (data) { return __awaiter(void 0, void 0, void 0, function () {
    var network, output, blockExplorer;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                network = data.network, output = data.output, blockExplorer = data.blockExplorer;
                return [4 /*yield*/, (0, beacon_dapp_1.openToast)({
                        body: "{{wallet}}\u00A0 successfully injected operation",
                        timer: SUCCESS_TIMER,
                        state: 'finished',
                        walletInfo: data.walletInfo,
                        actions: [
                            {
                                text: (0, shorten_string_1.shortenString)(output.transactionHash),
                                isBold: true,
                                actionText: "Open Blockexplorer",
                                actionLogo: 'external',
                                actionCallback: function () { return __awaiter(void 0, void 0, void 0, function () {
                                    var link;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, blockExplorer.getTransactionLink(output.transactionHash, network)];
                                            case 1:
                                                link = _a.sent();
                                                window.open(link, '_blank');
                                                return [4 /*yield*/, (0, beacon_dapp_1.closeToast)()];
                                            case 2:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); }
                            }
                        ]
                    })];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };
var emptyHandler = function () { return function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/];
    });
}); }; };
/**
 * The default event handlers
 */
exports.defaultEventCallbacks = (_a = {},
    _a[BeaconEvent.PERMISSION_REQUEST_SENT] = showSentToast,
    _a[BeaconEvent.PERMISSION_REQUEST_SUCCESS] = showPermissionSuccessAlert,
    _a[BeaconEvent.PERMISSION_REQUEST_ERROR] = showErrorToast,
    _a[BeaconEvent.OPERATION_REQUEST_SENT] = showSentToast,
    _a[BeaconEvent.OPERATION_REQUEST_SUCCESS] = showOperationSuccessAlert,
    _a[BeaconEvent.OPERATION_REQUEST_ERROR] = showErrorToast,
    _a[BeaconEvent.SIGN_REQUEST_SENT] = showSentToast,
    _a[BeaconEvent.SIGN_REQUEST_SUCCESS] = showSignSuccessAlert,
    _a[BeaconEvent.SIGN_REQUEST_ERROR] = showErrorToast,
    // TODO: ENCRYPTION
    // [BeaconEvent.ENCRYPT_REQUEST_SENT]: showSentToast,
    // [BeaconEvent.ENCRYPT_REQUEST_SUCCESS]: showEncryptSuccessAlert,
    // [BeaconEvent.ENCRYPT_REQUEST_ERROR]: showErrorToast,
    _a[BeaconEvent.BROADCAST_REQUEST_SENT] = showSentToast,
    _a[BeaconEvent.BROADCAST_REQUEST_SUCCESS] = showBroadcastSuccessAlert,
    _a[BeaconEvent.BROADCAST_REQUEST_ERROR] = showErrorToast,
    _a[BeaconEvent.ACKNOWLEDGE_RECEIVED] = showAcknowledgedToast,
    _a[BeaconEvent.LOCAL_RATE_LIMIT_REACHED] = showRateLimitReached,
    _a[BeaconEvent.NO_PERMISSIONS] = showNoPermissionAlert,
    _a[BeaconEvent.ACTIVE_ACCOUNT_SET] = emptyHandler(),
    _a[BeaconEvent.ACTIVE_TRANSPORT_SET] = emptyHandler(),
    _a[BeaconEvent.SHOW_PREPARE] = showPrepare,
    _a[BeaconEvent.HIDE_UI] = hideUI,
    _a[BeaconEvent.PAIR_INIT] = showPairAlert,
    _a[BeaconEvent.PAIR_SUCCESS] = showExtensionConnectedAlert,
    _a[BeaconEvent.CHANNEL_CLOSED] = showChannelClosedAlert,
    _a[BeaconEvent.INTERNAL_ERROR] = showInternalErrorAlert,
    _a[BeaconEvent.UNKNOWN] = emptyHandler(),
    _a);
/**
 * @internalapi
 *
 * Handles beacon events
 */
var BeaconEventHandler = /** @class */ (function () {
    function BeaconEventHandler(eventsToOverride, overrideAll) {
        var _a;
        if (eventsToOverride === void 0) { eventsToOverride = {}; }
        this.callbackMap = (_a = {},
            _a[BeaconEvent.PERMISSION_REQUEST_SENT] = [exports.defaultEventCallbacks.PERMISSION_REQUEST_SENT],
            _a[BeaconEvent.PERMISSION_REQUEST_SUCCESS] = [exports.defaultEventCallbacks.PERMISSION_REQUEST_SUCCESS],
            _a[BeaconEvent.PERMISSION_REQUEST_ERROR] = [exports.defaultEventCallbacks.PERMISSION_REQUEST_ERROR],
            _a[BeaconEvent.OPERATION_REQUEST_SENT] = [exports.defaultEventCallbacks.OPERATION_REQUEST_SENT],
            _a[BeaconEvent.OPERATION_REQUEST_SUCCESS] = [exports.defaultEventCallbacks.OPERATION_REQUEST_SUCCESS],
            _a[BeaconEvent.OPERATION_REQUEST_ERROR] = [exports.defaultEventCallbacks.OPERATION_REQUEST_ERROR],
            _a[BeaconEvent.SIGN_REQUEST_SENT] = [exports.defaultEventCallbacks.SIGN_REQUEST_SENT],
            _a[BeaconEvent.SIGN_REQUEST_SUCCESS] = [exports.defaultEventCallbacks.SIGN_REQUEST_SUCCESS],
            _a[BeaconEvent.SIGN_REQUEST_ERROR] = [exports.defaultEventCallbacks.SIGN_REQUEST_ERROR],
            // TODO: ENCRYPTION
            // [BeaconEvent.ENCRYPT_REQUEST_SENT]: [defaultEventCallbacks.ENCRYPT_REQUEST_SENT],
            // [BeaconEvent.ENCRYPT_REQUEST_SUCCESS]: [defaultEventCallbacks.ENCRYPT_REQUEST_SUCCESS],
            // [BeaconEvent.ENCRYPT_REQUEST_ERROR]: [defaultEventCallbacks.ENCRYPT_REQUEST_ERROR],
            _a[BeaconEvent.BROADCAST_REQUEST_SENT] = [exports.defaultEventCallbacks.BROADCAST_REQUEST_SENT],
            _a[BeaconEvent.BROADCAST_REQUEST_SUCCESS] = [exports.defaultEventCallbacks.BROADCAST_REQUEST_SUCCESS],
            _a[BeaconEvent.BROADCAST_REQUEST_ERROR] = [exports.defaultEventCallbacks.BROADCAST_REQUEST_ERROR],
            _a[BeaconEvent.ACKNOWLEDGE_RECEIVED] = [exports.defaultEventCallbacks.ACKNOWLEDGE_RECEIVED],
            _a[BeaconEvent.LOCAL_RATE_LIMIT_REACHED] = [exports.defaultEventCallbacks.LOCAL_RATE_LIMIT_REACHED],
            _a[BeaconEvent.NO_PERMISSIONS] = [exports.defaultEventCallbacks.NO_PERMISSIONS],
            _a[BeaconEvent.ACTIVE_ACCOUNT_SET] = [exports.defaultEventCallbacks.ACTIVE_ACCOUNT_SET],
            _a[BeaconEvent.ACTIVE_TRANSPORT_SET] = [exports.defaultEventCallbacks.ACTIVE_TRANSPORT_SET],
            _a[BeaconEvent.SHOW_PREPARE] = [exports.defaultEventCallbacks.SHOW_PREPARE],
            _a[BeaconEvent.HIDE_UI] = [exports.defaultEventCallbacks.HIDE_UI],
            _a[BeaconEvent.PAIR_INIT] = [exports.defaultEventCallbacks.PAIR_INIT],
            _a[BeaconEvent.PAIR_SUCCESS] = [exports.defaultEventCallbacks.PAIR_SUCCESS],
            _a[BeaconEvent.CHANNEL_CLOSED] = [exports.defaultEventCallbacks.CHANNEL_CLOSED],
            _a[BeaconEvent.INTERNAL_ERROR] = [exports.defaultEventCallbacks.INTERNAL_ERROR],
            _a[BeaconEvent.UNKNOWN] = [exports.defaultEventCallbacks.UNKNOWN],
            _a);
        if (overrideAll) {
            this.setAllHandlers();
        }
        this.overrideDefaults(eventsToOverride);
    }
    /**
     * A method to subscribe to a specific beacon event and register a callback
     *
     * @param event The event being emitted
     * @param eventCallback The callback that will be invoked
     */
    BeaconEventHandler.prototype.on = function (event, eventCallback) {
        return __awaiter(this, void 0, void 0, function () {
            var listeners;
            return __generator(this, function (_a) {
                listeners = this.callbackMap[event] || [];
                listeners.push(eventCallback);
                this.callbackMap[event] = listeners;
                return [2 /*return*/];
            });
        });
    };
    /**
     * Emit a beacon event
     *
     * @param event The event being emitted
     * @param data The data to be emit
     */
    BeaconEventHandler.prototype.emit = function (event, data, eventCallback) {
        return __awaiter(this, void 0, void 0, function () {
            var listeners;
            var _this = this;
            return __generator(this, function (_a) {
                listeners = this.callbackMap[event];
                if (listeners && listeners.length > 0) {
                    listeners.forEach(function (listener) { return __awaiter(_this, void 0, void 0, function () {
                        var listenerError_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    _a.trys.push([0, 2, , 3]);
                                    return [4 /*yield*/, listener(data, eventCallback)];
                                case 1:
                                    _a.sent();
                                    return [3 /*break*/, 3];
                                case 2:
                                    listenerError_1 = _a.sent();
                                    logger.error("error handling event ".concat(event), listenerError_1);
                                    return [3 /*break*/, 3];
                                case 3: return [2 /*return*/];
                            }
                        });
                    }); });
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Override beacon event default callbacks. This can be used to disable default alert/toast behaviour
     *
     * @param eventsToOverride An object with the events to override
     */
    BeaconEventHandler.prototype.overrideDefaults = function (eventsToOverride) {
        var _this = this;
        Object.keys(eventsToOverride).forEach(function (untypedEvent) {
            var eventType = untypedEvent;
            var event = eventsToOverride[eventType];
            if (event) {
                _this.callbackMap[eventType] = [event.handler];
            }
        });
    };
    /**
     * Set all event callbacks to a specific handler.
     */
    BeaconEventHandler.prototype.setAllHandlers = function (handler) {
        var _this = this;
        Object.keys(this.callbackMap).forEach(function (untypedEvent) {
            var eventType = untypedEvent;
            _this.callbackMap[eventType] = [];
            if (handler) {
                _this.callbackMap[eventType].push(handler);
            }
            else {
                _this.callbackMap[eventType].push(function () {
                    var data = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        data[_i] = arguments[_i];
                    }
                    logger.log.apply(logger, __spreadArray([untypedEvent], data, false));
                });
            }
        });
    };
    return BeaconEventHandler;
}());
exports.BeaconEventHandler = BeaconEventHandler;

},{"./utils/shorten-string":83,"@airgap/beacon-core":58,"@airgap/beacon-dapp":78,"@airgap/beacon-types":104,"@airgap/beacon-ui":122}],78:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TezblockBlockExplorer = exports.TzktBlockExplorer = exports.BlockExplorer = exports.defaultEventCallbacks = exports.BeaconEventHandler = exports.BeaconEvent = exports.getDAppClientInstance = exports.DAppClient = void 0;
__exportStar(require("@airgap/beacon-core"), exports);
__exportStar(require("@airgap/beacon-transport-matrix"), exports);
__exportStar(require("@airgap/beacon-transport-postmessage"), exports);
__exportStar(require("@airgap/beacon-types"), exports);
__exportStar(require("@airgap/beacon-utils"), exports);
__exportStar(require("@airgap/beacon-ui"), exports);
var DAppClient_1 = require("./dapp-client/DAppClient");
Object.defineProperty(exports, "DAppClient", { enumerable: true, get: function () { return DAppClient_1.DAppClient; } });
var events_1 = require("./events");
Object.defineProperty(exports, "BeaconEvent", { enumerable: true, get: function () { return events_1.BeaconEvent; } });
Object.defineProperty(exports, "BeaconEventHandler", { enumerable: true, get: function () { return events_1.BeaconEventHandler; } });
Object.defineProperty(exports, "defaultEventCallbacks", { enumerable: true, get: function () { return events_1.defaultEventCallbacks; } });
var block_explorer_1 = require("./utils/block-explorer");
Object.defineProperty(exports, "BlockExplorer", { enumerable: true, get: function () { return block_explorer_1.BlockExplorer; } });
var tzkt_blockexplorer_1 = require("./utils/tzkt-blockexplorer");
Object.defineProperty(exports, "TzktBlockExplorer", { enumerable: true, get: function () { return tzkt_blockexplorer_1.TzktBlockExplorer; } });
Object.defineProperty(exports, "TezblockBlockExplorer", { enumerable: true, get: function () { return tzkt_blockexplorer_1.TzktBlockExplorer; } });
var get_instance_1 = require("./utils/get-instance");
Object.defineProperty(exports, "getDAppClientInstance", { enumerable: true, get: function () { return get_instance_1.getDAppClientInstance; } });

},{"./dapp-client/DAppClient":76,"./events":77,"./utils/block-explorer":81,"./utils/get-instance":82,"./utils/tzkt-blockexplorer":84,"@airgap/beacon-core":58,"@airgap/beacon-transport-matrix":88,"@airgap/beacon-transport-postmessage":103,"@airgap/beacon-types":104,"@airgap/beacon-ui":122,"@airgap/beacon-utils":136}],79:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DappP2PTransport = void 0;
var beacon_types_1 = require("@airgap/beacon-types");
var beacon_core_1 = require("@airgap/beacon-core");
var beacon_transport_matrix_1 = require("@airgap/beacon-transport-matrix");
var logger = new beacon_core_1.Logger('DappP2PTransport');
/**
 * @internalapi
 *
 *
 */
var DappP2PTransport = /** @class */ (function (_super) {
    __extends(DappP2PTransport, _super);
    function DappP2PTransport(name, keyPair, storage, matrixNodes, iconUrl, appUrl) {
        return _super.call(this, name, keyPair, storage, matrixNodes, beacon_types_1.StorageKey.TRANSPORT_P2P_PEERS_DAPP, iconUrl, appUrl) || this;
    }
    DappP2PTransport.prototype.startOpenChannelListener = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.client.listenForChannelOpening(function (peer) { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    logger.log('listenForNewPeer', "new publicKey", peer.publicKey);
                                    return [4 /*yield*/, this.addPeer(peer)];
                                case 1:
                                    _a.sent();
                                    this._isConnected = beacon_types_1.TransportStatus.CONNECTED;
                                    if (this.newPeerListener) {
                                        this.newPeerListener(peer);
                                        this.newPeerListener = undefined; // TODO: Remove this once we use the id
                                    }
                                    return [2 /*return*/];
                            }
                        });
                    }); })];
            });
        });
    };
    DappP2PTransport.prototype.listenForNewPeer = function (newPeerListener) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                logger.log('listenForNewPeer');
                this.newPeerListener = newPeerListener;
                return [2 /*return*/];
            });
        });
    };
    DappP2PTransport.prototype.stopListeningForNewPeers = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                logger.log('stopListeningForNewPeers');
                this.newPeerListener = undefined;
                return [2 /*return*/];
            });
        });
    };
    return DappP2PTransport;
}(beacon_transport_matrix_1.P2PTransport));
exports.DappP2PTransport = DappP2PTransport;

},{"@airgap/beacon-core":58,"@airgap/beacon-transport-matrix":88,"@airgap/beacon-types":104}],80:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DappPostMessageTransport = void 0;
var beacon_types_1 = require("@airgap/beacon-types");
var beacon_core_1 = require("@airgap/beacon-core");
var beacon_transport_postmessage_1 = require("@airgap/beacon-transport-postmessage");
var logger = new beacon_core_1.Logger('DappPostMessageTransport');
/**
 * @internalapi
 *
 *
 */
var DappPostMessageTransport = /** @class */ (function (_super) {
    __extends(DappPostMessageTransport, _super);
    function DappPostMessageTransport(name, keyPair, storage) {
        return _super.call(this, name, keyPair, storage, beacon_types_1.StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP) || this;
    }
    DappPostMessageTransport.prototype.startOpenChannelListener = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.client.listenForChannelOpening(function (peer) { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    logger.log('connect', "received PostMessagePairingResponse", peer);
                                    return [4 /*yield*/, this.addPeer(peer)];
                                case 1:
                                    _a.sent();
                                    this._isConnected = beacon_types_1.TransportStatus.CONNECTED;
                                    if (this.newPeerListener) {
                                        this.newPeerListener(peer);
                                        this.newPeerListener = undefined; // TODO: Remove this once we use the id
                                    }
                                    return [2 /*return*/];
                            }
                        });
                    }); })];
            });
        });
    };
    DappPostMessageTransport.prototype.listenForNewPeer = function (newPeerListener) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                logger.log('listenForNewPeer');
                this.newPeerListener = newPeerListener;
                return [2 /*return*/];
            });
        });
    };
    DappPostMessageTransport.prototype.stopListeningForNewPeers = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                logger.log('stopListeningForNewPeers');
                this.newPeerListener = undefined;
                return [2 /*return*/];
            });
        });
    };
    return DappPostMessageTransport;
}(beacon_transport_postmessage_1.PostMessageTransport));
exports.DappPostMessageTransport = DappPostMessageTransport;

},{"@airgap/beacon-core":58,"@airgap/beacon-transport-postmessage":103,"@airgap/beacon-types":104}],81:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockExplorer = void 0;
var BlockExplorer = /** @class */ (function () {
    function BlockExplorer(rpcUrls) {
        this.rpcUrls = rpcUrls;
    }
    BlockExplorer.prototype.getLinkForNetwork = function (network) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.rpcUrls[network.type]];
            });
        });
    };
    return BlockExplorer;
}());
exports.BlockExplorer = BlockExplorer;

},{}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDAppClientInstance = void 0;
var __1 = require("..");
var _instance;
/** Get a DAppClient instance. Will make sure only one dAppClient exists. After the first instance has been created, the config will be ignored, unless "reset" is set */
var getDAppClientInstance = function (config, reset) {
    if (_instance && reset) {
        _instance.disconnect();
        _instance = undefined;
    }
    if (_instance) {
        return _instance;
    }
    if (!_instance) {
        _instance = new __1.DAppClient(config);
    }
    return _instance;
};
exports.getDAppClientInstance = getDAppClientInstance;

},{"..":78}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shortenString = void 0;
var shortenString = function (text) {
    if (text.length >= 12) {
        return "".concat(text.substr(0, 5), "...").concat(text.substr(-5));
    }
    return text;
};
exports.shortenString = shortenString;

},{}],84:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TzktBlockExplorer = void 0;
var beacon_types_1 = require("@airgap/beacon-types");
var block_explorer_1 = require("./block-explorer");
var TzktBlockExplorer = /** @class */ (function (_super) {
    __extends(TzktBlockExplorer, _super);
    function TzktBlockExplorer(rpcUrls) {
        var _a;
        if (rpcUrls === void 0) { rpcUrls = (_a = {},
            _a[beacon_types_1.NetworkType.MAINNET] = 'https://tzkt.io',
            _a[beacon_types_1.NetworkType.GHOSTNET] = 'https://ghostnet.tzkt.io',
            _a[beacon_types_1.NetworkType.MONDAYNET] = 'https://mondaynet.tzkt.io',
            _a[beacon_types_1.NetworkType.DAILYNET] = 'https://dailynet.tzkt.io',
            _a[beacon_types_1.NetworkType.DELPHINET] = 'https://delphinet.tzkt.io',
            _a[beacon_types_1.NetworkType.EDONET] = 'https://edonet.tzkt.io',
            _a[beacon_types_1.NetworkType.FLORENCENET] = 'https://florencenet.tzkt.io',
            _a[beacon_types_1.NetworkType.GRANADANET] = 'https://granadanet.tzkt.io',
            _a[beacon_types_1.NetworkType.HANGZHOUNET] = 'https://hangzhounet.tzkt.io',
            _a[beacon_types_1.NetworkType.ITHACANET] = 'https://ithacanet.tzkt.io',
            _a[beacon_types_1.NetworkType.JAKARTANET] = 'https://jakartanet.tzkt.io',
            _a[beacon_types_1.NetworkType.KATHMANDUNET] = 'https://kathmandunet.tzkt.io',
            _a[beacon_types_1.NetworkType.LIMANET] = 'https://limanet.tzkt.io',
            _a[beacon_types_1.NetworkType.MUMBAINET] = 'https://mumbainet.tzkt.io',
            _a[beacon_types_1.NetworkType.CUSTOM] = 'https://mumbainet.tzkt.io',
            _a); }
        var _this = _super.call(this, rpcUrls) || this;
        _this.rpcUrls = rpcUrls;
        return _this;
    }
    TzktBlockExplorer.prototype.getAddressLink = function (address, network) {
        return __awaiter(this, void 0, void 0, function () {
            var blockExplorer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getLinkForNetwork(network)];
                    case 1:
                        blockExplorer = _a.sent();
                        return [2 /*return*/, "".concat(blockExplorer, "/").concat(address)];
                }
            });
        });
    };
    TzktBlockExplorer.prototype.getTransactionLink = function (transactionId, network) {
        return __awaiter(this, void 0, void 0, function () {
            var blockExplorer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getLinkForNetwork(network)];
                    case 1:
                        blockExplorer = _a.sent();
                        return [2 /*return*/, "".concat(blockExplorer, "/").concat(transactionId)];
                }
            });
        });
    };
    return TzktBlockExplorer;
}(block_explorer_1.BlockExplorer));
exports.TzktBlockExplorer = TzktBlockExplorer;

},{"./block-explorer":81,"@airgap/beacon-types":104}],85:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("@airgap/beacon-blockchain-substrate"), exports);
__exportStar(require("@airgap/beacon-blockchain-tezos"), exports);
__exportStar(require("@airgap/beacon-core"), exports);
__exportStar(require("@airgap/beacon-dapp"), exports);
__exportStar(require("@airgap/beacon-transport-matrix"), exports);
__exportStar(require("@airgap/beacon-transport-postmessage"), exports);
__exportStar(require("@airgap/beacon-types"), exports);
// export * from '@airgap/beacon-ui'
__exportStar(require("@airgap/beacon-utils"), exports);
__exportStar(require("@airgap/beacon-wallet"), exports);

},{"@airgap/beacon-blockchain-substrate":27,"@airgap/beacon-blockchain-tezos":38,"@airgap/beacon-core":58,"@airgap/beacon-dapp":78,"@airgap/beacon-transport-matrix":88,"@airgap/beacon-transport-postmessage":103,"@airgap/beacon-types":104,"@airgap/beacon-utils":136,"@airgap/beacon-wallet":142}],86:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.P2PTransport = void 0;
var beacon_core_1 = require("@airgap/beacon-core");
var beacon_types_1 = require("@airgap/beacon-types");
var beacon_transport_matrix_1 = require("@airgap/beacon-transport-matrix");
var logger = new beacon_core_1.Logger('P2PTransport');
/**
 * @internalapi
 *
 *
 */
var P2PTransport = /** @class */ (function (_super) {
    __extends(P2PTransport, _super);
    function P2PTransport(name, keyPair, storage, matrixNodes, storageKey, iconUrl, appUrl) {
        var _this = _super.call(this, name, new beacon_transport_matrix_1.P2PCommunicationClient(name, keyPair, 1, storage, matrixNodes, iconUrl, appUrl), new beacon_core_1.PeerManager(storage, storageKey)) || this;
        _this.type = beacon_types_1.TransportType.P2P;
        return _this;
    }
    P2PTransport.isAvailable = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, Promise.resolve(true)];
            });
        });
    };
    P2PTransport.prototype.connect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var knownPeers, connectionPromises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._isConnected !== beacon_types_1.TransportStatus.NOT_CONNECTED) {
                            return [2 /*return*/];
                        }
                        logger.log('connect');
                        this._isConnected = beacon_types_1.TransportStatus.CONNECTING;
                        return [4 /*yield*/, this.client.start()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.getPeers()];
                    case 2:
                        knownPeers = _a.sent();
                        if (knownPeers.length > 0) {
                            logger.log('connect', "connecting to ".concat(knownPeers.length, " peers"));
                            connectionPromises = knownPeers.map(function (peer) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2 /*return*/, this.listen(peer.publicKey)];
                            }); }); });
                            Promise.all(connectionPromises).catch(function (error) { return logger.error('connect', error); });
                        }
                        return [4 /*yield*/, this.startOpenChannelListener()];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, _super.prototype.connect.call(this)];
                }
            });
        });
    };
    P2PTransport.prototype.disconnect = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.client.stop()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, _super.prototype.disconnect.call(this)];
                }
            });
        });
    };
    P2PTransport.prototype.startOpenChannelListener = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/];
            });
        });
    };
    P2PTransport.prototype.getPairingRequestInfo = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.client.getPairingRequestInfo()];
            });
        });
    };
    P2PTransport.prototype.listen = function (publicKey) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.client
                            .listenForEncryptedMessage(publicKey, function (message) {
                            var connectionContext = {
                                origin: beacon_types_1.Origin.P2P,
                                id: publicKey
                            };
                            _this.notifyListeners(message, connectionContext).catch(function (error) {
                                throw error;
                            });
                        })
                            .catch(function (error) {
                            throw error;
                        })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return P2PTransport;
}(beacon_core_1.Transport));
exports.P2PTransport = P2PTransport;

},{"@airgap/beacon-core":58,"@airgap/beacon-transport-matrix":88,"@airgap/beacon-types":104}],87:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.P2PCommunicationClient = void 0;
var ed25519_1 = require("@stablelib/ed25519");
var axios_1 = require("axios");
var beacon_utils_1 = require("@airgap/beacon-utils");
var MatrixClient_1 = require("../matrix-client/MatrixClient");
var MatrixClientEvent_1 = require("../matrix-client/models/MatrixClientEvent");
var MatrixMessage_1 = require("../matrix-client/models/MatrixMessage");
var beacon_types_1 = require("@airgap/beacon-types");
var beacon_core_1 = require("@airgap/beacon-core");
var beacon_utils_2 = require("@airgap/beacon-utils");
var blake2b_1 = require("@stablelib/blake2b");
var utf8_1 = require("@stablelib/utf8");
var logger = new beacon_core_1.Logger('P2PCommunicationClient');
var REGIONS_AND_SERVERS = (_a = {},
    _a[beacon_types_1.Regions.EUROPE_WEST] = [
        'beacon-node-1.diamond.papers.tech',
        'beacon-node-1.sky.papers.tech',
        'beacon-node-2.sky.papers.tech',
        'beacon-node-1.hope.papers.tech',
        'beacon-node-1.hope-2.papers.tech',
        'beacon-node-1.hope-3.papers.tech',
        'beacon-node-1.hope-4.papers.tech',
        'beacon-node-1.hope-5.papers.tech'
    ],
    _a);
/**
 * @internalapi
 */
var P2PCommunicationClient = /** @class */ (function (_super) {
    __extends(P2PCommunicationClient, _super);
    function P2PCommunicationClient(name, keyPair, replicationCount, storage, matrixNodes, iconUrl, appUrl) {
        var _this = _super.call(this, keyPair) || this;
        _this.name = name;
        _this.replicationCount = replicationCount;
        _this.storage = storage;
        _this.iconUrl = iconUrl;
        _this.appUrl = appUrl;
        _this.client = new beacon_utils_2.ExposedPromise();
        _this.activeListeners = new Map();
        _this.ignoredRooms = [];
        _this.loginCounter = 0;
        logger.log('constructor', 'P2PCommunicationClient created');
        _this.ENABLED_RELAY_SERVERS = REGIONS_AND_SERVERS;
        if (matrixNodes) {
            _this.ENABLED_RELAY_SERVERS = __assign(__assign({}, REGIONS_AND_SERVERS), matrixNodes);
        }
        return _this;
    }
    P2PCommunicationClient.prototype.getPairingRequestInfo = function () {
        return __awaiter(this, void 0, void 0, function () {
            var info;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = {};
                        return [4 /*yield*/, (0, beacon_utils_2.generateGUID)()];
                    case 1:
                        _a.id = _b.sent(),
                            _a.type = 'p2p-pairing-request',
                            _a.name = this.name,
                            _a.version = beacon_core_1.BEACON_VERSION;
                        return [4 /*yield*/, this.getPublicKey()];
                    case 2:
                        _a.publicKey = _b.sent();
                        return [4 /*yield*/, this.getRelayServer()];
                    case 3:
                        info = (_a.relayServer = (_b.sent()).server,
                            _a);
                        if (this.iconUrl) {
                            info.icon = this.iconUrl;
                        }
                        if (this.appUrl) {
                            info.appUrl = this.appUrl;
                        }
                        return [2 /*return*/, info];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.getPairingResponseInfo = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var info;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = {
                            id: request.id,
                            type: 'p2p-pairing-response',
                            name: this.name,
                            version: request.version
                        };
                        return [4 /*yield*/, this.getPublicKey()];
                    case 1:
                        _a.publicKey = _b.sent();
                        return [4 /*yield*/, this.getRelayServer()];
                    case 2:
                        info = (_a.relayServer = (_b.sent()).server,
                            _a);
                        if (this.iconUrl) {
                            info.icon = this.iconUrl;
                        }
                        if (this.appUrl) {
                            info.appUrl = this.appUrl;
                        }
                        return [2 /*return*/, info];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.findBestRegion = function () {
        return __awaiter(this, void 0, void 0, function () {
            var keys, allPromises, region;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.selectedRegion) {
                            return [2 /*return*/, this.selectedRegion];
                        }
                        keys = Object.keys(this.ENABLED_RELAY_SERVERS);
                        allPromises = [];
                        keys.forEach(function (key) {
                            var _a;
                            var nodes = (_a = _this.ENABLED_RELAY_SERVERS[key]) !== null && _a !== void 0 ? _a : [];
                            var index = Math.floor(Math.random() * nodes.length);
                            allPromises.push(_this.getBeaconInfo(nodes[index])
                                .then(function (res) { return ({
                                region: key,
                                server: nodes[index],
                                response: res
                            }); })
                                .catch(function (err) {
                                return new Promise(function (_resolve, reject) {
                                    // This workaround is done because Promise.race stops at the first failure, but we need the first success.
                                    // TODO: If all promises have been rejected, let's not wait 2000 and abort earlier.
                                    setTimeout(function () { return reject(err); }, 2000);
                                });
                            }));
                        });
                        return [4 /*yield*/, Promise.race(allPromises)];
                    case 1:
                        region = _a.sent();
                        this.selectedRegion = region.region;
                        return [2 /*return*/, region.region
                            // Select random server from each region.
                            // Start request to random server from each region
                            // Fastest response wins, region is selected
                        ];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.getRelayServer = function () {
        return __awaiter(this, void 0, void 0, function () {
            var relayServer, info, node, info, region, regionNodes, nodes, index, server, response, relayError_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.relayServer) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.relayServer.promise
                            // We make sure the locally cached timestamp is not older than 1 minute, if it is, we refresh it
                        ];
                    case 1:
                        relayServer = _a.sent();
                        // We make sure the locally cached timestamp is not older than 1 minute, if it is, we refresh it
                        if (Date.now() - relayServer.localTimestamp < 60 * 1000) {
                            return [2 /*return*/, { server: relayServer.server, timestamp: relayServer.timestamp }];
                        }
                        return [4 /*yield*/, this.getBeaconInfo(relayServer.server)];
                    case 2:
                        info = _a.sent();
                        this.relayServer.resolve({
                            server: relayServer.server,
                            timestamp: info.timestamp,
                            localTimestamp: new Date().getTime()
                        });
                        return [2 /*return*/, { server: relayServer.server, timestamp: info.timestamp }];
                    case 3:
                        this.relayServer = new beacon_utils_2.ExposedPromise();
                        _a.label = 4;
                    case 4: return [4 /*yield*/, this.storage.get(beacon_types_1.StorageKey.MATRIX_SELECTED_NODE)];
                    case 5:
                        node = _a.sent();
                        if (!(node && node.length > 0)) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.getBeaconInfo(node)];
                    case 6:
                        info = _a.sent();
                        this.relayServer.resolve({
                            server: node,
                            timestamp: info.timestamp,
                            localTimestamp: new Date().getTime()
                        });
                        return [2 /*return*/, { server: node, timestamp: info.timestamp }];
                    case 7: return [4 /*yield*/, this.findBestRegion()];
                    case 8:
                        region = _a.sent();
                        regionNodes = this.ENABLED_RELAY_SERVERS[region];
                        if (!regionNodes) {
                            throw new Error("No servers found for region ".concat(region));
                        }
                        nodes = __spreadArray([], regionNodes, true);
                        _a.label = 9;
                    case 9:
                        if (!(nodes.length > 0)) return [3 /*break*/, 14];
                        index = Math.floor(Math.random() * nodes.length);
                        server = nodes[index];
                        _a.label = 10;
                    case 10:
                        _a.trys.push([10, 12, , 13]);
                        return [4 /*yield*/, this.getBeaconInfo(server)];
                    case 11:
                        response = _a.sent();
                        this.storage
                            .set(beacon_types_1.StorageKey.MATRIX_SELECTED_NODE, server)
                            .catch(function (error) { return logger.log(error); });
                        this.relayServer.resolve({
                            server: server,
                            timestamp: response.timestamp,
                            localTimestamp: new Date().getTime()
                        });
                        return [2 /*return*/, { server: server, timestamp: response.timestamp }];
                    case 12:
                        relayError_1 = _a.sent();
                        logger.log("Ignoring server \"".concat(server, "\", trying another one..."));
                        nodes.splice(index, 1);
                        return [3 /*break*/, 13];
                    case 13: return [3 /*break*/, 9];
                    case 14:
                        this.relayServer.reject("No matrix server reachable!");
                        throw new Error("No matrix server reachable!");
                }
            });
        });
    };
    P2PCommunicationClient.prototype.getBeaconInfo = function (server) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, axios_1.default
                        .get("https://".concat(server, "/_synapse/client/beacon/info"))
                        .then(function (res) { return ({
                        region: res.data.region,
                        known_servers: res.data.known_servers,
                        timestamp: Math.floor(res.data.timestamp)
                    }); })];
            });
        });
    };
    P2PCommunicationClient.prototype.tryJoinRooms = function (roomId, retry) {
        if (retry === void 0) { retry = 1; }
        return __awaiter(this, void 0, void 0, function () {
            var error_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        return [4 /*yield*/, this.client.promise];
                    case 1: return [4 /*yield*/, (_a.sent()).joinRooms(roomId)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        if (retry <= 10 && error_1.errcode === 'M_FORBIDDEN') {
                            // If we join the room too fast after receiving the invite, the server can accidentally reject our join. This seems to be a problem only when using a federated multi-node setup. Usually waiting for a couple milliseconds solves the issue, but to handle lag, we will keep retrying for 2 seconds.
                            logger.log("Retrying to join...", error_1);
                            setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.tryJoinRooms(roomId, retry + 1)];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }); }, 200);
                        }
                        else {
                            logger.log("Failed to join after ".concat(retry, " tries."), error_1);
                        }
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.start = function () {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var relayServer, client, time, loginString, _c, _d, _e, _f, _g, loginRawDigest, secretKey, rawSignature, _h, _j, _k, _l, error_2;
            var _m;
            var _this = this;
            return __generator(this, function (_o) {
                switch (_o.label) {
                    case 0:
                        logger.log('start', 'starting client');
                        logger.log('start', "connecting to server");
                        return [4 /*yield*/, this.getRelayServer()];
                    case 1:
                        relayServer = _o.sent();
                        client = MatrixClient_1.MatrixClient.create({
                            baseUrl: "https://".concat(relayServer.server),
                            storage: this.storage
                        });
                        this.initialListener = function (event) { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                if (this.initialEvent && this.initialEvent.timestamp && event && event.timestamp) {
                                    if (this.initialEvent.timestamp < event.timestamp) {
                                        this.initialEvent = event;
                                    }
                                }
                                else {
                                    this.initialEvent = event;
                                }
                                return [2 /*return*/];
                            });
                        }); };
                        client.subscribe(MatrixClientEvent_1.MatrixClientEventType.MESSAGE, this.initialListener);
                        client.subscribe(MatrixClientEvent_1.MatrixClientEventType.INVITE, function (event) { return __awaiter(_this, void 0, void 0, function () {
                            var member;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (event.content.members.length === 1) {
                                            // If there is only one member we know it's a new room
                                            // TODO: Use the "sender" of the event instead
                                            member = event.content.members[0];
                                        }
                                        return [4 /*yield*/, this.tryJoinRooms(event.content.roomId)];
                                    case 1:
                                        _a.sent();
                                        if (!member) return [3 /*break*/, 4];
                                        return [4 /*yield*/, this.updateRelayServer(member)];
                                    case 2:
                                        _a.sent();
                                        return [4 /*yield*/, this.updatePeerRoom(member, event.content.roomId)];
                                    case 3:
                                        _a.sent();
                                        _a.label = 4;
                                    case 4: return [2 /*return*/];
                                }
                            });
                        }); });
                        if (!relayServer.timestamp) {
                            throw new Error('No timestamp received from relay server');
                        }
                        time = Math.floor(relayServer.timestamp);
                        loginString = "login:".concat(Math.floor(time / (5 * 60)));
                        _d = (_c = logger).log;
                        _e = ['start'];
                        _g = (_f = "login ".concat(loginString, ", ")).concat;
                        return [4 /*yield*/, this.getPublicKeyHash()];
                    case 2:
                        _d.apply(_c, _e.concat([_g.apply(_f, [_o.sent(), " on "]).concat(relayServer.server)]));
                        loginRawDigest = (0, blake2b_1.hash)((0, utf8_1.encode)(loginString), 32);
                        secretKey = (_a = this.keyPair.secretKey) !== null && _a !== void 0 ? _a : this.keyPair.privateKey;
                        rawSignature = (0, ed25519_1.sign)(secretKey, loginRawDigest);
                        _o.label = 3;
                    case 3:
                        _o.trys.push([3, 7, , 9]);
                        _j = (_h = client).start;
                        _m = {};
                        return [4 /*yield*/, this.getPublicKeyHash()];
                    case 4:
                        _m.id = _o.sent();
                        _l = (_k = "ed:".concat((0, beacon_utils_1.toHex)(rawSignature), ":")).concat;
                        return [4 /*yield*/, this.getPublicKey()];
                    case 5: return [4 /*yield*/, _j.apply(_h, [(_m.password = _l.apply(_k, [_o.sent()]),
                                _m.deviceId = (0, beacon_utils_1.toHex)(this.keyPair.publicKey),
                                _m)])];
                    case 6:
                        _o.sent();
                        return [3 /*break*/, 9];
                    case 7:
                        error_2 = _o.sent();
                        logger.error('start', 'Could not log in, retrying');
                        return [4 /*yield*/, this.reset()]; // If we can't log in, let's reset
                    case 8:
                        _o.sent(); // If we can't log in, let's reset
                        if (!this.selectedRegion) {
                            throw new Error('No region selected.');
                        }
                        if (this.loginCounter <= ((_b = this.ENABLED_RELAY_SERVERS[this.selectedRegion]) !== null && _b !== void 0 ? _b : []).length) {
                            this.loginCounter++;
                            this.start();
                            return [2 /*return*/];
                        }
                        else {
                            logger.error('start', 'Tried to log in to every known beacon node, but no login was successful.');
                            throw new Error('Could not connect to any beacon nodes. Try again later.');
                        }
                        return [3 /*break*/, 9];
                    case 9:
                        logger.log('start', 'login successful, client is ready');
                        this.client.resolve(client);
                        return [2 /*return*/];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.stop = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        logger.log('stop', 'stopping client');
                        if (!this.client.isResolved()) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.client.promise];
                    case 1: return [4 /*yield*/, (_a.sent()).stop().catch(function (error) { return logger.error(error); })];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [4 /*yield*/, this.reset()];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.reset = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        logger.log('reset', 'resetting connection');
                        return [4 /*yield*/, this.storage.delete(beacon_types_1.StorageKey.MATRIX_PEER_ROOM_IDS).catch(function (error) { return logger.log(error); })];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.storage.delete(beacon_types_1.StorageKey.MATRIX_PRESERVED_STATE).catch(function (error) { return logger.log(error); })];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.storage.delete(beacon_types_1.StorageKey.MATRIX_SELECTED_NODE).catch(function (error) { return logger.log(error); })
                            // Instead of resetting everything, maybe we should make sure a new instance is created?
                        ];
                    case 3:
                        _a.sent();
                        // Instead of resetting everything, maybe we should make sure a new instance is created?
                        this.relayServer = undefined;
                        this.client = new beacon_utils_2.ExposedPromise();
                        this.initialEvent = undefined;
                        this.initialListener = undefined;
                        return [2 /*return*/];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.listenForEncryptedMessage = function (senderPublicKey, messageCallback) {
        return __awaiter(this, void 0, void 0, function () {
            var sharedKey, callbackFunction, lastEvent, initialListener;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.activeListeners.has(senderPublicKey)) {
                            return [2 /*return*/];
                        }
                        logger.log('listenForEncryptedMessage', "start listening for encrypted messages from publicKey ".concat(senderPublicKey));
                        return [4 /*yield*/, this.createCryptoBoxServer(senderPublicKey, this.keyPair)];
                    case 1:
                        sharedKey = _a.sent();
                        callbackFunction = function (event) { return __awaiter(_this, void 0, void 0, function () {
                            var _a, payload, decryptedMessage, decryptionError_1;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        _a = this.isTextMessage(event.content);
                                        if (!_a) return [3 /*break*/, 2];
                                        return [4 /*yield*/, this.isSender(event, senderPublicKey)];
                                    case 1:
                                        _a = (_b.sent());
                                        _b.label = 2;
                                    case 2:
                                        if (!_a) return [3 /*break*/, 8];
                                        payload = void 0;
                                        return [4 /*yield*/, this.updateRelayServer(event.content.message.sender)];
                                    case 3:
                                        _b.sent();
                                        return [4 /*yield*/, this.updatePeerRoom(event.content.message.sender, event.content.roomId)];
                                    case 4:
                                        _b.sent();
                                        try {
                                            payload = Buffer.from(event.content.message.content, 'hex');
                                            // content can be non-hex if it's a connection open request
                                        }
                                        catch (_c) {
                                            /* */
                                        }
                                        if (!(payload && payload.length >= beacon_utils_1.secretbox_NONCEBYTES + beacon_utils_1.secretbox_MACBYTES)) return [3 /*break*/, 8];
                                        _b.label = 5;
                                    case 5:
                                        _b.trys.push([5, 7, , 8]);
                                        return [4 /*yield*/, (0, beacon_utils_1.decryptCryptoboxPayload)(payload, sharedKey.receive)];
                                    case 6:
                                        decryptedMessage = _b.sent();
                                        logger.log('listenForEncryptedMessage', "received a message from ".concat(senderPublicKey), decryptedMessage);
                                        // logger.log(
                                        //   'listenForEncryptedMessage',
                                        //   'encrypted message received',
                                        //   decryptedMessage,
                                        //   await new Serializer().deserialize(decryptedMessage)
                                        // )
                                        // console.log('calculated sender ID', await getSenderId(senderPublicKey))
                                        // TODO: Add check for correct decryption key / sender ID
                                        messageCallback(decryptedMessage);
                                        return [3 /*break*/, 8];
                                    case 7:
                                        decryptionError_1 = _b.sent();
                                        return [3 /*break*/, 8];
                                    case 8: return [2 /*return*/];
                                }
                            });
                        }); };
                        this.activeListeners.set(senderPublicKey, callbackFunction);
                        return [4 /*yield*/, this.client.promise];
                    case 2:
                        (_a.sent()).subscribe(MatrixClientEvent_1.MatrixClientEventType.MESSAGE, callbackFunction);
                        lastEvent = this.initialEvent;
                        if (!(lastEvent &&
                            lastEvent.timestamp &&
                            new Date().getTime() - lastEvent.timestamp < 5 * 60 * 1000)) return [3 /*break*/, 4];
                        logger.log('listenForEncryptedMessage', 'Handling previous event');
                        return [4 /*yield*/, callbackFunction(lastEvent)];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        logger.log('listenForEncryptedMessage', 'No previous event found');
                        _a.label = 5;
                    case 5:
                        initialListener = this.initialListener;
                        if (!initialListener) return [3 /*break*/, 7];
                        ;
                        return [4 /*yield*/, this.client.promise];
                    case 6:
                        (_a.sent()).unsubscribe(MatrixClientEvent_1.MatrixClientEventType.MESSAGE, initialListener);
                        _a.label = 7;
                    case 7:
                        this.initialListener = undefined;
                        this.initialEvent = undefined;
                        return [2 /*return*/];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.unsubscribeFromEncryptedMessage = function (senderPublicKey) {
        return __awaiter(this, void 0, void 0, function () {
            var listener;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        listener = this.activeListeners.get(senderPublicKey);
                        if (!listener) {
                            return [2 /*return*/];
                        }
                        ;
                        return [4 /*yield*/, this.client.promise];
                    case 1:
                        (_a.sent()).unsubscribe(MatrixClientEvent_1.MatrixClientEventType.MESSAGE, listener);
                        this.activeListeners.delete(senderPublicKey);
                        return [2 /*return*/];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.unsubscribeFromEncryptedMessages = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        ;
                        return [4 /*yield*/, this.client.promise];
                    case 1:
                        (_a.sent()).unsubscribeAll(MatrixClientEvent_1.MatrixClientEventType.MESSAGE);
                        this.activeListeners.clear();
                        return [2 /*return*/];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.sendMessage = function (message, peer) {
        return __awaiter(this, void 0, void 0, function () {
            var sharedKey, recipientHash, recipient, roomId, encryptedMessage;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.createCryptoBoxClient(peer.publicKey, this.keyPair)];
                    case 1:
                        sharedKey = _a.sent();
                        return [4 /*yield*/, (0, beacon_utils_1.getHexHash)(Buffer.from(peer.publicKey, 'hex'))];
                    case 2:
                        recipientHash = _a.sent();
                        recipient = (0, beacon_utils_1.recipientString)(recipientHash, peer.relayServer);
                        return [4 /*yield*/, this.getRelevantRoom(recipient)
                            // Before we send the message, we have to wait for the join to be accepted.
                        ];
                    case 3:
                        roomId = _a.sent();
                        // Before we send the message, we have to wait for the join to be accepted.
                        return [4 /*yield*/, this.waitForJoin(roomId)]; // TODO: This can probably be removed because we are now waiting inside the get room method
                    case 4:
                        // Before we send the message, we have to wait for the join to be accepted.
                        _a.sent(); // TODO: This can probably be removed because we are now waiting inside the get room method
                        return [4 /*yield*/, (0, beacon_utils_1.encryptCryptoboxPayload)(message, sharedKey.send)];
                    case 5:
                        encryptedMessage = _a.sent();
                        logger.log('sendMessage', 'sending encrypted message', peer.publicKey, roomId, message);
                        return [4 /*yield*/, this.client.promise];
                    case 6:
                        (_a.sent()).sendTextMessage(roomId, encryptedMessage).catch(function (error) { return __awaiter(_this, void 0, void 0, function () {
                            var newRoomId_1;
                            var _this = this;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (!(error.errcode === 'M_FORBIDDEN')) return [3 /*break*/, 4];
                                        // Room doesn't exist
                                        logger.log("sendMessage", "M_FORBIDDEN", roomId, error);
                                        return [4 /*yield*/, this.deleteRoomIdFromRooms(roomId)];
                                    case 1:
                                        _a.sent();
                                        return [4 /*yield*/, this.getRelevantRoom(recipient)];
                                    case 2:
                                        newRoomId_1 = _a.sent();
                                        logger.log("sendMessage", "Old room deleted, new room created", newRoomId_1);
                                        return [4 /*yield*/, this.client.promise];
                                    case 3:
                                        (_a.sent())
                                            .sendTextMessage(newRoomId_1, encryptedMessage)
                                            .catch(function (error2) { return __awaiter(_this, void 0, void 0, function () {
                                            return __generator(this, function (_a) {
                                                logger.log("sendMessage", "inner error", newRoomId_1, error2);
                                                return [2 /*return*/];
                                            });
                                        }); });
                                        return [3 /*break*/, 5];
                                    case 4:
                                        logger.log("sendMessage", "unexpected error", error);
                                        _a.label = 5;
                                    case 5: return [2 /*return*/];
                                }
                            });
                        }); });
                        return [2 /*return*/];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.updatePeerRoom = function (sender, roomId) {
        return __awaiter(this, void 0, void 0, function () {
            var split, roomIds, room;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        logger.log("updatePeerRoom", sender, roomId);
                        split = sender.split(':');
                        if (split.length < 2 || !split[0].startsWith('@')) {
                            throw new Error('Invalid sender');
                        }
                        return [4 /*yield*/, this.storage.get(beacon_types_1.StorageKey.MATRIX_PEER_ROOM_IDS)];
                    case 1:
                        roomIds = _a.sent();
                        room = roomIds[sender];
                        if (room === roomId) {
                            logger.debug("updatePeerRoom", "rooms are the same, not updating");
                        }
                        logger.debug("updatePeerRoom", "current room", room, 'new room', roomId);
                        if (room && room[1]) {
                            // If we have a room already, let's ignore it. We need to do this, otherwise it will be loaded from the matrix cache.
                            logger.log("updatePeerRoom", "adding room \"".concat(room[1], "\" to ignored array"));
                            this.ignoredRooms.push(room[1]);
                        }
                        roomIds[sender] = roomId;
                        return [4 /*yield*/, this.storage.set(beacon_types_1.StorageKey.MATRIX_PEER_ROOM_IDS, roomIds)
                            // TODO: We also need to delete the room from the sync state
                            // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state
                        ];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.deleteRoomIdFromRooms = function (roomId) {
        return __awaiter(this, void 0, void 0, function () {
            var roomIds, newRoomIds;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.storage.get(beacon_types_1.StorageKey.MATRIX_PEER_ROOM_IDS)];
                    case 1:
                        roomIds = _a.sent();
                        newRoomIds = Object.entries(roomIds)
                            .filter(function (entry) { return entry[1] !== roomId; })
                            .reduce(function (pv, cv) {
                            var _a;
                            return (__assign(__assign({}, pv), (_a = {}, _a[cv[0]] = cv[1], _a)));
                        }, {});
                        return [4 /*yield*/, this.storage.set(beacon_types_1.StorageKey.MATRIX_PEER_ROOM_IDS, newRoomIds)
                            // TODO: We also need to delete the room from the sync state
                            // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state
                        ];
                    case 2:
                        _a.sent();
                        // TODO: We also need to delete the room from the sync state
                        // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state
                        this.ignoredRooms.push(roomId);
                        return [2 /*return*/];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.listenForChannelOpening = function (messageCallback) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        logger.debug("listenForChannelOpening");
                        return [4 /*yield*/, this.client.promise];
                    case 1:
                        (_a.sent()).subscribe(MatrixClientEvent_1.MatrixClientEventType.MESSAGE, function (event) { return __awaiter(_this, void 0, void 0, function () {
                            var _a, splits, payload, pairingResponse, _b, _c, _d, _e, decryptionError_2;
                            var _f;
                            return __generator(this, function (_g) {
                                switch (_g.label) {
                                    case 0:
                                        _a = this.isTextMessage(event.content);
                                        if (!_a) return [3 /*break*/, 2];
                                        return [4 /*yield*/, this.isChannelOpenMessage(event.content)];
                                    case 1:
                                        _a = (_g.sent());
                                        _g.label = 2;
                                    case 2:
                                        if (!_a) return [3 /*break*/, 9];
                                        logger.log("listenForChannelOpening", "channel opening received, trying to decrypt", JSON.stringify(event));
                                        return [4 /*yield*/, this.updateRelayServer(event.content.message.sender)];
                                    case 3:
                                        _g.sent();
                                        return [4 /*yield*/, this.updatePeerRoom(event.content.message.sender, event.content.roomId)];
                                    case 4:
                                        _g.sent();
                                        splits = event.content.message.content.split(':');
                                        payload = Buffer.from(splits[splits.length - 1], 'hex');
                                        if (!(payload.length >= beacon_utils_1.secretbox_NONCEBYTES + beacon_utils_1.secretbox_MACBYTES)) return [3 /*break*/, 9];
                                        _g.label = 5;
                                    case 5:
                                        _g.trys.push([5, 8, , 9]);
                                        _c = (_b = JSON).parse;
                                        return [4 /*yield*/, (0, beacon_utils_1.openCryptobox)(payload, this.keyPair.publicKey, this.keyPair.secretKey)];
                                    case 6:
                                        pairingResponse = _c.apply(_b, [_g.sent()]);
                                        logger.log("listenForChannelOpening", "channel opening received and decrypted", JSON.stringify(pairingResponse));
                                        _d = messageCallback;
                                        _e = [__assign({}, pairingResponse)];
                                        _f = {};
                                        return [4 /*yield*/, (0, beacon_core_1.getSenderId)(pairingResponse.publicKey)];
                                    case 7:
                                        _d.apply(void 0, [__assign.apply(void 0, _e.concat([(_f.senderId = _g.sent(), _f)]))]);
                                        return [3 /*break*/, 9];
                                    case 8:
                                        decryptionError_2 = _g.sent();
                                        return [3 /*break*/, 9];
                                    case 9: return [2 /*return*/];
                                }
                            });
                        }); });
                        return [2 /*return*/];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.waitForJoin = function (roomId, retry) {
        if (retry === void 0) { retry = 0; }
        return __awaiter(this, void 0, void 0, function () {
            var room;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.client.promise];
                    case 1: return [4 /*yield*/, (_a.sent()).getRoomById(roomId)];
                    case 2:
                        room = _a.sent();
                        logger.log("waitForJoin", "Currently ".concat(room.members.length, " members, we need at least 2"));
                        if (room.members.length >= 2 || room.members.length === 0) {
                            // 0 means it's an unknown room, we don't need to wait
                            return [2 /*return*/];
                        }
                        else {
                            if (retry <= 200) {
                                // On mobile, due to app switching, we potentially have to wait for a long time
                                logger.log("Waiting for join... Try: ".concat(retry));
                                return [2 /*return*/, new Promise(function (resolve) {
                                        setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                                            return __generator(this, function (_a) {
                                                resolve(this.waitForJoin(roomId, retry + 1));
                                                return [2 /*return*/];
                                            });
                                        }); }, 100 * (retry > 50 ? 10 : 1)); // After the initial 5 seconds, retry only once per second
                                    })];
                            }
                            else {
                                throw new Error("No one joined after ".concat(retry, " tries."));
                            }
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.sendPairingResponse = function (pairingRequest) {
        return __awaiter(this, void 0, void 0, function () {
            var recipientHash, recipient, roomId, message, _a, _b, _c, encryptedMessage, msg;
            var _this = this;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        logger.log("sendPairingResponse");
                        return [4 /*yield*/, (0, beacon_utils_1.getHexHash)(Buffer.from(pairingRequest.publicKey, 'hex'))];
                    case 1:
                        recipientHash = _d.sent();
                        recipient = (0, beacon_utils_1.recipientString)(recipientHash, pairingRequest.relayServer);
                        return [4 /*yield*/, this.client.promise];
                    case 2: return [4 /*yield*/, (_d.sent()).createTrustedPrivateRoom(recipient)];
                    case 3:
                        roomId = _d.sent();
                        logger.debug("sendPairingResponse", "Connecting to room \"".concat(roomId, "\""));
                        return [4 /*yield*/, this.updatePeerRoom(recipient, roomId)
                            // Before we send the message, we have to wait for the join to be accepted.
                        ];
                    case 4:
                        _d.sent();
                        // Before we send the message, we have to wait for the join to be accepted.
                        return [4 /*yield*/, this.waitForJoin(roomId)]; // TODO: This can probably be removed because we are now waiting inside the get room method
                    case 5:
                        // Before we send the message, we have to wait for the join to be accepted.
                        _d.sent(); // TODO: This can probably be removed because we are now waiting inside the get room method
                        logger.debug("sendPairingResponse", "Successfully joined room.");
                        if (!(typeof pairingRequest.version === 'undefined')) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.getPublicKey()]; // v1
                    case 6:
                        _a = _d.sent(); // v1
                        return [3 /*break*/, 9];
                    case 7:
                        _c = (_b = JSON).stringify;
                        return [4 /*yield*/, this.getPairingResponseInfo(pairingRequest)];
                    case 8:
                        _a = _c.apply(_b, [_d.sent()]); // v2
                        _d.label = 9;
                    case 9:
                        message = _a;
                        logger.debug("sendPairingResponse", "Sending pairing response", message);
                        return [4 /*yield*/, this.encryptMessageAsymmetric(pairingRequest.publicKey, message)];
                    case 10:
                        encryptedMessage = _d.sent();
                        msg = ['@channel-open', recipient, encryptedMessage].join(':');
                        return [4 /*yield*/, this.client.promise];
                    case 11:
                        (_d.sent()).sendTextMessage(roomId, msg).catch(function (error) { return __awaiter(_this, void 0, void 0, function () {
                            var newRoomId_2;
                            var _this = this;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (!(error.errcode === 'M_FORBIDDEN')) return [3 /*break*/, 4];
                                        // Room doesn't exist
                                        logger.log("sendPairingResponse", "M_FORBIDDEN", roomId, error);
                                        return [4 /*yield*/, this.deleteRoomIdFromRooms(roomId)];
                                    case 1:
                                        _a.sent();
                                        return [4 /*yield*/, this.getRelevantRoom(recipient)];
                                    case 2:
                                        newRoomId_2 = _a.sent();
                                        logger.log("sendPairingResponse", "Old room deleted, new room created", newRoomId_2);
                                        return [4 /*yield*/, this.client.promise];
                                    case 3:
                                        (_a.sent()).sendTextMessage(newRoomId_2, msg).catch(function (error2) { return __awaiter(_this, void 0, void 0, function () {
                                            return __generator(this, function (_a) {
                                                logger.log("sendPairingResponse", "inner error", newRoomId_2, error2);
                                                return [2 /*return*/];
                                            });
                                        }); });
                                        return [3 /*break*/, 5];
                                    case 4:
                                        logger.log("sendPairingResponse", "unexpected error", error);
                                        _a.label = 5;
                                    case 5: return [2 /*return*/];
                                }
                            });
                        }); });
                        return [2 /*return*/];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.isTextMessage = function (content) {
        return content.message.type === MatrixMessage_1.MatrixMessageType.TEXT;
    };
    P2PCommunicationClient.prototype.updateRelayServer = function (sender) {
        return __awaiter(this, void 0, void 0, function () {
            var split, senderHash, relayServer, manager, peers, promiseArray;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        logger.log("updateRelayServer", sender);
                        split = sender.split(':');
                        if (split.length < 2 || !split[0].startsWith('@')) {
                            throw new Error('Invalid sender');
                        }
                        senderHash = split.shift();
                        relayServer = split.join(':');
                        manager = localStorage.getItem('beacon:communication-peers-dapp')
                            ? new beacon_core_1.PeerManager(this.storage, beacon_types_1.StorageKey.TRANSPORT_P2P_PEERS_DAPP)
                            : new beacon_core_1.PeerManager(this.storage, beacon_types_1.StorageKey.TRANSPORT_P2P_PEERS_WALLET);
                        return [4 /*yield*/, manager.getPeers()];
                    case 1:
                        peers = _a.sent();
                        promiseArray = peers.map(function (peer) { return __awaiter(_this, void 0, void 0, function () {
                            var hash, _a;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        _a = "@".concat;
                                        return [4 /*yield*/, (0, beacon_utils_1.getHexHash)(Buffer.from(peer.publicKey, 'hex'))];
                                    case 1:
                                        hash = _a.apply("@", [_b.sent()]);
                                        if (!(hash === senderHash)) return [3 /*break*/, 3];
                                        if (!(peer.relayServer !== relayServer)) return [3 /*break*/, 3];
                                        peer.relayServer = relayServer;
                                        return [4 /*yield*/, manager.addPeer(peer)];
                                    case 2:
                                        _b.sent();
                                        _b.label = 3;
                                    case 3: return [2 /*return*/];
                                }
                            });
                        }); });
                        return [4 /*yield*/, Promise.all(promiseArray)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.isChannelOpenMessage = function (content) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, _c, _d, _e, _f;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        _b = (_a = content.message.content).startsWith;
                        _c = "@channel-open:@".concat;
                        _d = beacon_utils_1.getHexHash;
                        _f = (_e = Buffer).from;
                        return [4 /*yield*/, this.getPublicKey()];
                    case 1: return [4 /*yield*/, _d.apply(void 0, [_f.apply(_e, [_g.sent(), 'hex'])])];
                    case 2: return [2 /*return*/, _b.apply(_a, [_c.apply("@channel-open:@", [_g.sent()])])];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.isSender = function (event, senderPublicKey) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _b = (_a = event.content.message.sender).startsWith;
                        _c = "@".concat;
                        return [4 /*yield*/, (0, beacon_utils_1.getHexHash)(Buffer.from(senderPublicKey, 'hex'))];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.apply("@", [_d.sent()])])];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.getRelevantRoom = function (recipient) {
        return __awaiter(this, void 0, void 0, function () {
            var roomIds, roomId, room;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.storage.get(beacon_types_1.StorageKey.MATRIX_PEER_ROOM_IDS)];
                    case 1:
                        roomIds = _a.sent();
                        roomId = roomIds[recipient];
                        if (!!roomId) return [3 /*break*/, 4];
                        logger.log("getRelevantRoom", "No room found for peer ".concat(recipient, ", checking joined ones."));
                        return [4 /*yield*/, this.getRelevantJoinedRoom(recipient)];
                    case 2:
                        room = _a.sent();
                        roomId = room.id;
                        roomIds[recipient] = room.id;
                        return [4 /*yield*/, this.storage.set(beacon_types_1.StorageKey.MATRIX_PEER_ROOM_IDS, roomIds)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        logger.log("getRelevantRoom", "Using room ".concat(roomId));
                        return [2 /*return*/, roomId];
                }
            });
        });
    };
    P2PCommunicationClient.prototype.getRelevantJoinedRoom = function (recipient) {
        return __awaiter(this, void 0, void 0, function () {
            var joinedRooms, relevantRooms, room, roomId;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.client.promise];
                    case 1: return [4 /*yield*/, (_a.sent()).joinedRooms];
                    case 2:
                        joinedRooms = _a.sent();
                        logger.log('checking joined rooms', joinedRooms, recipient);
                        relevantRooms = joinedRooms
                            .filter(function (roomElement) { return !_this.ignoredRooms.some(function (id) { return roomElement.id === id; }); })
                            .filter(function (roomElement) {
                            return roomElement.members.some(function (member) { return member === recipient; });
                        });
                        if (!(relevantRooms.length === 0 || this.ignoredRooms.length > 0)) return [3 /*break*/, 8];
                        logger.log("getRelevantJoinedRoom", "no relevant rooms found, creating new one");
                        return [4 /*yield*/, this.client.promise];
                    case 3: return [4 /*yield*/, (_a.sent()).createTrustedPrivateRoom(recipient)];
                    case 4:
                        roomId = _a.sent();
                        return [4 /*yield*/, this.client.promise];
                    case 5: return [4 /*yield*/, (_a.sent()).getRoomById(roomId)];
                    case 6:
                        room = _a.sent();
                        logger.log("getRelevantJoinedRoom", "waiting for other party to join room: ".concat(room.id));
                        return [4 /*yield*/, this.waitForJoin(roomId)];
                    case 7:
                        _a.sent();
                        logger.log("getRelevantJoinedRoom", "new room created and peer invited: ".concat(room.id));
                        return [3 /*break*/, 9];
                    case 8:
                        room = relevantRooms[0];
                        logger.log("getRelevantJoinedRoom", "channel already open, reusing room ".concat(room.id));
                        _a.label = 9;
                    case 9: return [2 /*return*/, room];
                }
            });
        });
    };
    return P2PCommunicationClient;
}(beacon_core_1.CommunicationClient));
exports.P2PCommunicationClient = P2PCommunicationClient;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../matrix-client/MatrixClient":90,"../matrix-client/models/MatrixClientEvent":94,"../matrix-client/models/MatrixMessage":95,"@airgap/beacon-core":58,"@airgap/beacon-types":104,"@airgap/beacon-utils":136,"@stablelib/blake2b":147,"@stablelib/ed25519":150,"@stablelib/utf8":162,"axios":212,"buffer":3}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.P2PTransport = exports.P2PCommunicationClient = void 0;
var P2PCommunicationClient_1 = require("./communication-client/P2PCommunicationClient");
Object.defineProperty(exports, "P2PCommunicationClient", { enumerable: true, get: function () { return P2PCommunicationClient_1.P2PCommunicationClient; } });
var P2PTransport_1 = require("./P2PTransport");
Object.defineProperty(exports, "P2PTransport", { enumerable: true, get: function () { return P2PTransport_1.P2PTransport; } });

},{"./P2PTransport":86,"./communication-client/P2PCommunicationClient":87}],89:[function(require,module,exports){
"use strict";
// https://gist.github.com/mudge/5830382?permalink_comment_id=2658721#gistcomment-2658721
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventEmitter = void 0;
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this.events = {};
    }
    EventEmitter.prototype.on = function (event, listener) {
        var _this = this;
        if (typeof this.events[event] !== 'object') {
            this.events[event] = [];
        }
        this.events[event].push(listener);
        return function () { return _this.removeListener(event, listener); };
    };
    EventEmitter.prototype.removeListener = function (event, listener) {
        if (typeof this.events[event] !== 'object') {
            return;
        }
        if (!listener) {
            this.events[event] = [];
            return;
        }
        var idx = this.events[event].indexOf(listener);
        if (idx > -1) {
            this.events[event].splice(idx, 1);
        }
    };
    EventEmitter.prototype.removeAllListeners = function () {
        var _this = this;
        Object.keys(this.events).forEach(function (event) {
            return _this.events[event].splice(0, _this.events[event].length);
        });
    };
    EventEmitter.prototype.emit = function (event) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (typeof this.events[event] !== 'object') {
            return;
        }
        ;
        __spreadArray([], this.events[event], true).forEach(function (listener) { return listener.apply(_this, args); });
    };
    EventEmitter.prototype.once = function (event, listener) {
        var _this = this;
        var remove = this.on(event, function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            remove();
            listener.apply(_this, args);
        });
        return remove;
    };
    return EventEmitter;
}());
exports.EventEmitter = EventEmitter;

},{}],90:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MatrixClient = void 0;
var beacon_core_1 = require("@airgap/beacon-core");
var beacon_utils_1 = require("@airgap/beacon-utils");
var MatrixClientStore_1 = require("./MatrixClientStore");
var MatrixHttpClient_1 = require("./MatrixHttpClient");
var MatrixRoom_1 = require("./models/MatrixRoom");
var MatrixRoomService_1 = require("./services/MatrixRoomService");
var MatrixUserService_1 = require("./services/MatrixUserService");
var MatrixEventService_1 = require("./services/MatrixEventService");
var MatrixClientEventEmitter_1 = require("./MatrixClientEventEmitter");
var logger = new beacon_core_1.Logger('MatrixClient');
var IMMEDIATE_POLLING_RETRIES = 3;
var RETRY_INTERVAL = 5000;
/**
 * The matrix client used to connect to the matrix network
 */
var MatrixClient = /** @class */ (function () {
    function MatrixClient(store, eventEmitter, userService, roomService, eventService, httpClient) {
        var _this = this;
        this.store = store;
        this.eventEmitter = eventEmitter;
        this.userService = userService;
        this.roomService = roomService;
        this.eventService = eventService;
        this.httpClient = httpClient;
        this.isActive = true;
        this._isReady = new beacon_utils_1.ExposedPromise();
        this.store.onStateChanged(function (oldState, newState, stateChange) {
            _this.eventEmitter.onStateChanged(oldState, newState, stateChange);
        }, 'rooms');
    }
    /**
     * Create a matrix client based on the options provided
     *
     * @param config
     */
    MatrixClient.create = function (config) {
        var store = new MatrixClientStore_1.MatrixClientStore(config.storage);
        var eventEmitter = new MatrixClientEventEmitter_1.MatrixClientEventEmitter();
        var httpClient = new MatrixHttpClient_1.MatrixHttpClient(config.baseUrl);
        var accountService = new MatrixUserService_1.MatrixUserService(httpClient);
        var roomService = new MatrixRoomService_1.MatrixRoomService(httpClient);
        var eventService = new MatrixEventService_1.MatrixEventService(httpClient);
        return new MatrixClient(store, eventEmitter, accountService, roomService, eventService, httpClient);
    };
    Object.defineProperty(MatrixClient.prototype, "joinedRooms", {
        /**
         * Return all the rooms we are currently part of
         */
        get: function () {
            var _this = this;
            return new Promise(function (resolve) { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.isConnected()];
                        case 1:
                            _a.sent();
                            resolve(Object.values(this.store.get('rooms')).filter(function (room) { return room.status === MatrixRoom_1.MatrixRoomStatus.JOINED; }));
                            return [2 /*return*/];
                    }
                });
            }); });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MatrixClient.prototype, "invitedRooms", {
        /**
         * Return all the rooms to which we have received invitations
         */
        get: function () {
            var _this = this;
            return new Promise(function (resolve) { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.isConnected()];
                        case 1:
                            _a.sent();
                            resolve(Object.values(this.store.get('rooms')).filter(function (room) { return room.status === MatrixRoom_1.MatrixRoomStatus.INVITED; }));
                            return [2 /*return*/];
                    }
                });
            }); });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MatrixClient.prototype, "leftRooms", {
        /**
         * Return all the rooms that we left
         */
        get: function () {
            var _this = this;
            return new Promise(function (resolve) { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.isConnected()];
                        case 1:
                            _a.sent();
                            resolve(Object.values(this.store.get('rooms')).filter(function (room) { return room.status === MatrixRoom_1.MatrixRoomStatus.LEFT; }));
                            return [2 /*return*/];
                    }
                });
            }); });
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Initiate the connection to the matrix node and log in
     *
     * @param user
     */
    MatrixClient.prototype.start = function (user) {
        return __awaiter(this, void 0, void 0, function () {
            var response, initialPollingResult;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.userService.login(user.id, user.password, user.deviceId)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, this.store.update({
                                accessToken: response.access_token
                            })];
                    case 2:
                        _a.sent();
                        initialPollingResult = new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                            var _this = this;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this.poll(0, function (pollingResponse) { return __awaiter(_this, void 0, void 0, function () {
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        if (!this.store.get('isRunning')) {
                                                            resolve();
                                                        }
                                                        return [4 /*yield*/, this.store.update({
                                                                isRunning: true,
                                                                syncToken: pollingResponse.next_batch,
                                                                pollingTimeout: 30000,
                                                                pollingRetries: 0,
                                                                rooms: MatrixRoom_1.MatrixRoom.fromSync(pollingResponse.rooms)
                                                            })];
                                                    case 1:
                                                        _a.sent();
                                                        return [2 /*return*/];
                                                }
                                            });
                                        }); }, function (error) { return __awaiter(_this, void 0, void 0, function () {
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        if (!this.store.get('isRunning')) {
                                                            reject(error);
                                                        }
                                                        return [4 /*yield*/, this.store.update({
                                                                isRunning: false,
                                                                pollingRetries: this.store.get('pollingRetries') + 1
                                                            })];
                                                    case 1:
                                                        _a.sent();
                                                        return [2 /*return*/];
                                                }
                                            });
                                        }); })];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                        initialPollingResult
                            .then(function () {
                            _this._isReady.resolve();
                        })
                            .catch(console.error);
                        return [2 /*return*/, initialPollingResult];
                }
            });
        });
    };
    MatrixClient.prototype.isConnected = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._isReady.promise];
            });
        });
    };
    /**
     * Stop all running requests
     */
    MatrixClient.prototype.stop = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                logger.log("MATRIX CLIENT STOPPED");
                this.isActive = false;
                this._isReady = new beacon_utils_1.ExposedPromise();
                return [2 /*return*/, this.httpClient.cancelAllRequests()];
            });
        });
    };
    /**
     * Subscribe to new matrix events
     *
     * @param event
     * @param listener
     */
    MatrixClient.prototype.subscribe = function (event, listener) {
        this.eventEmitter.on(event, listener);
    };
    /**
     * Unsubscribe from matrix events
     *
     * @param event
     * @param listener
     */
    MatrixClient.prototype.unsubscribe = function (event, listener) {
        if (listener) {
            this.eventEmitter.removeListener(event, listener);
        }
    };
    /**
     * Unsubscribe from all matrix events of this type
     *
     * @param event
     * @param listener
     */
    MatrixClient.prototype.unsubscribeAll = function (event) {
        this.eventEmitter.removeListener(event);
    };
    MatrixClient.prototype.getRoomById = function (id) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.isConnected()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.store.getRoom(id)];
                }
            });
        });
    };
    /**
     * Create a private room with the supplied members
     *
     * @param members Members that will be in the room
     */
    MatrixClient.prototype.createTrustedPrivateRoom = function () {
        var members = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            members[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.isConnected()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.requiresAuthorization('createRoom', function (accessToken) { return __awaiter(_this, void 0, void 0, function () {
                                var response;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.roomService.createRoom(accessToken, {
                                                room_version: '5',
                                                invite: members,
                                                preset: 'public_chat',
                                                is_direct: true
                                            })];
                                        case 1:
                                            response = _a.sent();
                                            return [2 /*return*/, response.room_id];
                                    }
                                });
                            }); })];
                }
            });
        });
    };
    /**
     * Invite user to rooms
     *
     * @param user The user to be invited
     * @param roomsOrIds The rooms the user will be invited to
     */
    MatrixClient.prototype.inviteToRooms = function (user) {
        var roomsOrIds = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            roomsOrIds[_i - 1] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.isConnected()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.requiresAuthorization('invite', function (accessToken) {
                                return Promise.all(roomsOrIds.map(function (roomOrId) {
                                    var room = _this.store.getRoom(roomOrId);
                                    _this.roomService
                                        .inviteToRoom(accessToken, user, room)
                                        .catch(function (error) { return logger.warn('inviteToRooms', error); });
                                }));
                            })];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Join rooms
     *
     * @param roomsOrIds
     */
    MatrixClient.prototype.joinRooms = function () {
        var roomsOrIds = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            roomsOrIds[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.isConnected()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.requiresAuthorization('join', function (accessToken) {
                                return Promise.all(roomsOrIds.map(function (roomOrId) {
                                    var room = _this.store.getRoom(roomOrId);
                                    return _this.roomService.joinRoom(accessToken, room);
                                }));
                            })];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Send a text message
     *
     * @param roomOrId
     * @param message
     */
    MatrixClient.prototype.sendTextMessage = function (roomId, message) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.isConnected()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.requiresAuthorization('send', function (accessToken) { return __awaiter(_this, void 0, void 0, function () {
                                var txnId;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.createTxnId()];
                                        case 1:
                                            txnId = _a.sent();
                                            return [2 /*return*/, this.eventService.sendMessage(accessToken, roomId, {
                                                    msgtype: 'm.text',
                                                    body: message
                                                }, txnId)];
                                    }
                                });
                            }); })];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Poll the server to get the latest data and get notified of changes
     *
     * @param interval
     * @param onSyncSuccess
     * @param onSyncError
     */
    MatrixClient.prototype.poll = function (interval, onSyncSuccess, onSyncError) {
        return __awaiter(this, void 0, void 0, function () {
            var store, sync, pollSync;
            var _this = this;
            return __generator(this, function (_a) {
                store = this.store;
                sync = this.sync.bind(this);
                pollSync = function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                    var syncingRetries, response, error_1;
                    var _this = this;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                syncingRetries = 0;
                                _a.label = 1;
                            case 1:
                                _a.trys.push([1, 3, 4, 5]);
                                return [4 /*yield*/, sync()];
                            case 2:
                                response = _a.sent();
                                onSyncSuccess(response);
                                return [3 /*break*/, 5];
                            case 3:
                                error_1 = _a.sent();
                                onSyncError(error_1);
                                syncingRetries = store.get('pollingRetries');
                                // console.warn('Could not sync:', error)
                                if (this.isActive) {
                                    logger.log("Retry syncing... ".concat(syncingRetries, " retries so far"));
                                }
                                return [3 /*break*/, 5];
                            case 4:
                                if (this.isActive) {
                                    setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0: return [4 /*yield*/, pollSync(resolve, reject)];
                                                case 1:
                                                    _a.sent();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); }, syncingRetries > IMMEDIATE_POLLING_RETRIES ? RETRY_INTERVAL + interval : interval);
                                }
                                else {
                                    reject(new Error("Syncing stopped manually."));
                                }
                                return [7 /*endfinally*/];
                            case 5: return [2 /*return*/];
                        }
                    });
                }); };
                return [2 /*return*/, new Promise(pollSync)];
            });
        });
    };
    /**
     * Get state from server
     */
    MatrixClient.prototype.sync = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.requiresAuthorization('sync', function (accessToken) { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.eventService.sync(accessToken, {
                                    pollingTimeout: this.store.get('pollingTimeout'),
                                    syncToken: this.store.get('syncToken')
                                })];
                        });
                    }); })];
            });
        });
    };
    /**
     * A helper method that makes sure an access token is provided
     *
     * @param name
     * @param action
     */
    MatrixClient.prototype.requiresAuthorization = function (name, action) {
        return __awaiter(this, void 0, void 0, function () {
            var storedToken;
            return __generator(this, function (_a) {
                storedToken = this.store.get('accessToken');
                if (!storedToken) {
                    return [2 /*return*/, Promise.reject("".concat(name, " requires authorization but no access token has been provided."))];
                }
                return [2 /*return*/, action(storedToken)];
            });
        });
    };
    /**
     * Create a transaction ID
     */
    MatrixClient.prototype.createTxnId = function () {
        return __awaiter(this, void 0, void 0, function () {
            var timestamp, counter;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        timestamp = new Date().getTime();
                        counter = this.store.get('txnNo');
                        return [4 /*yield*/, this.store.update({
                                txnNo: counter + 1
                            })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, "m".concat(timestamp, ".").concat(counter)];
                }
            });
        });
    };
    return MatrixClient;
}());
exports.MatrixClient = MatrixClient;

},{"./MatrixClientEventEmitter":91,"./MatrixClientStore":92,"./MatrixHttpClient":93,"./models/MatrixRoom":96,"./services/MatrixEventService":97,"./services/MatrixRoomService":98,"./services/MatrixUserService":99,"@airgap/beacon-core":58,"@airgap/beacon-utils":136}],91:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.MatrixClientEventEmitter = void 0;
var EventEmitter_1 = require("./EventEmitter");
var beacon_utils_1 = require("@airgap/beacon-utils");
var MatrixRoom_1 = require("./models/MatrixRoom");
var MatrixClientEvent_1 = require("./models/MatrixClientEvent");
var MatrixClientEventEmitter = /** @class */ (function (_super) {
    __extends(MatrixClientEventEmitter, _super);
    function MatrixClientEventEmitter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.eventEmitProviders = new Map([
            [MatrixClientEvent_1.MatrixClientEventType.INVITE, function () { return [_this.isInvite, _this.emitInvite.bind(_this)]; }],
            [MatrixClientEvent_1.MatrixClientEventType.MESSAGE, function () { return [_this.isMessage, _this.emitMessage.bind(_this)]; }]
        ]);
        return _this;
    }
    /**
     * This method is called every time the state is changed
     *
     * @param _oldState
     * @param _newState
     * @param stateChange
     */
    MatrixClientEventEmitter.prototype.onStateChanged = function (_oldState, _newState, stateChange) {
        for (var _i = 0, _a = (0, beacon_utils_1.keys)(MatrixClientEvent_1.MatrixClientEventType); _i < _a.length; _i++) {
            var event_1 = _a[_i];
            this.emitIfEvent(MatrixClientEvent_1.MatrixClientEventType[event_1], stateChange);
        }
    };
    /**
     * Emit the message if we have listeners registered for that type
     *
     * @param eventType
     * @param object
     */
    MatrixClientEventEmitter.prototype.emitIfEvent = function (eventType, object) {
        var provider = this.eventEmitProviders.get(eventType);
        if (provider) {
            var _a = provider(), predicate = _a[0], emitter = _a[1];
            if (predicate(object)) {
                emitter(eventType, object);
            }
        }
    };
    /**
     * Emit a client event
     *
     * @param eventType
     * @param content
     */
    MatrixClientEventEmitter.prototype.emitClientEvent = function (eventType, content, timestamp) {
        this.emit(eventType, {
            type: eventType,
            content: content,
            timestamp: timestamp
        });
    };
    /**
     * Check if event is an invite
     *
     * @param stateChange
     */
    MatrixClientEventEmitter.prototype.isInvite = function (stateChange) {
        return stateChange.rooms
            ? stateChange.rooms.some(function (room) { return room.status === MatrixRoom_1.MatrixRoomStatus.INVITED; })
            : false;
    };
    /**
     * Emit an invite
     *
     * @param eventType
     * @param stateChange
     */
    MatrixClientEventEmitter.prototype.emitInvite = function (eventType, stateChange) {
        var _this = this;
        stateChange.rooms
            .filter(function (room) { return room.status === MatrixRoom_1.MatrixRoomStatus.INVITED; })
            .map(function (room) { return [room.id, room.members]; })
            .forEach(function (_a) {
            var id = _a[0], members = _a[1];
            _this.emitClientEvent(eventType, {
                roomId: id,
                members: members
            });
        });
    };
    /**
     * Check if event is a message
     *
     * @param stateChange
     */
    MatrixClientEventEmitter.prototype.isMessage = function (stateChange) {
        return stateChange.rooms ? stateChange.rooms.some(function (room) { return room.messages.length > 0; }) : false;
    };
    /**
     * Emit an event to all rooms
     *
     * @param eventType
     * @param stateChange
     */
    MatrixClientEventEmitter.prototype.emitMessage = function (eventType, stateChange) {
        var _this = this;
        stateChange.rooms
            .filter(function (room) { return room.messages.length > 0; })
            .map(function (room) {
            return room.messages.map(function (message) {
                return [room.id, message, message.timestamp];
            });
        })
            .reduce(function (flatten, toFlatten) { return flatten.concat(toFlatten); }, [])
            .forEach(function (_a) {
            var roomId = _a[0], message = _a[1], timestamp = _a[2];
            _this.emitClientEvent(eventType, {
                roomId: roomId,
                message: message
            }, timestamp);
        });
    };
    return MatrixClientEventEmitter;
}(EventEmitter_1.EventEmitter));
exports.MatrixClientEventEmitter = MatrixClientEventEmitter;

},{"./EventEmitter":89,"./models/MatrixClientEvent":94,"./models/MatrixRoom":96,"@airgap/beacon-utils":136}],92:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MatrixClientStore = void 0;
var beacon_utils_1 = require("@airgap/beacon-utils");
var MatrixRoom_1 = require("./models/MatrixRoom");
var beacon_types_1 = require("@airgap/beacon-types");
var PRESERVED_FIELDS = ['syncToken', 'rooms'];
/**
 * The class managing the local state of matrix
 */
var MatrixClientStore = /** @class */ (function () {
    function MatrixClientStore(storage) {
        var _this = this;
        this.storage = storage;
        /**
         * The state of the matrix client
         */
        this.state = {
            isRunning: false,
            userId: undefined,
            deviceId: undefined,
            txnNo: 0,
            accessToken: undefined,
            syncToken: undefined,
            pollingTimeout: undefined,
            pollingRetries: 0,
            rooms: {}
        };
        /**
         * Listeners that will be called when the state changes
         */
        this.onStateChangedListeners = new Map();
        /**
         * A promise that resolves once the client is ready
         */
        this.waitReadyPromise = new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
            var error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.initFromStorage()];
                    case 1:
                        _a.sent();
                        resolve();
                        return [3 /*break*/, 3];
                    case 2:
                        error_1 = _a.sent();
                        reject(error_1);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
    }
    /**
     * Get an item from the state
     *
     * @param key
     */
    MatrixClientStore.prototype.get = function (key) {
        return this.state[key];
    };
    /**
     * Get the room from an ID or room instance
     *
     * @param roomOrId
     */
    MatrixClientStore.prototype.getRoom = function (roomOrId) {
        var room = MatrixRoom_1.MatrixRoom.from(roomOrId, MatrixRoom_1.MatrixRoomStatus.UNKNOWN);
        return this.state.rooms[room.id] || room;
    };
    /**
     * Update the state with a partial state
     *
     * @param stateUpdate
     */
    MatrixClientStore.prototype.update = function (stateUpdate) {
        return __awaiter(this, void 0, void 0, function () {
            var oldState;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.waitReady()];
                    case 1:
                        _a.sent();
                        oldState = Object.assign({}, this.state);
                        this.setState(stateUpdate);
                        this.updateStorage(stateUpdate);
                        this.notifyListeners(oldState, this.state, stateUpdate);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Register listeners that are called once the state has changed
     *
     * @param listener
     * @param subscribed
     */
    MatrixClientStore.prototype.onStateChanged = function (listener) {
        var _this = this;
        var subscribed = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            subscribed[_i - 1] = arguments[_i];
        }
        if (subscribed.length > 0) {
            subscribed.forEach(function (key) {
                _this.onStateChangedListeners.set(key, listener);
            });
        }
        else {
            this.onStateChangedListeners.set('all', listener);
        }
    };
    /**
     * A promise that resolves once the client is ready
     */
    MatrixClientStore.prototype.waitReady = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.waitReadyPromise];
            });
        });
    };
    /**
     * Read state from storage
     */
    MatrixClientStore.prototype.initFromStorage = function () {
        return __awaiter(this, void 0, void 0, function () {
            var preserved;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.storage.get(beacon_types_1.StorageKey.MATRIX_PRESERVED_STATE)];
                    case 1:
                        preserved = _a.sent();
                        this.setState(preserved);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Prepare data before persisting it in storage
     *
     * @param toStore
     */
    MatrixClientStore.prototype.prepareData = function (toStore) {
        var requiresPreparation = ['rooms'];
        var toStoreCopy = requiresPreparation.some(function (key) { return toStore[key] !== undefined; })
            ? JSON.parse(JSON.stringify(toStore))
            : toStore;
        // there is no need for saving messages in a persistent storage
        Object.values(toStoreCopy.rooms || {}).forEach(function (room) {
            room.messages = [];
        });
        return toStoreCopy;
    };
    /**
     * Persist state in storage
     *
     * @param stateUpdate
     */
    MatrixClientStore.prototype.updateStorage = function (stateUpdate) {
        var _this = this;
        var updatedCachedFields = Object.entries(stateUpdate).filter(function (_a) {
            var key = _a[0], value = _a[1];
            return PRESERVED_FIELDS.includes(key) && Boolean(value);
        });
        if (updatedCachedFields.length > 0) {
            var filteredState_1 = {};
            PRESERVED_FIELDS.forEach(function (key) {
                filteredState_1[key] = _this.state[key];
            });
            this.storage.set(beacon_types_1.StorageKey.MATRIX_PRESERVED_STATE, this.prepareData(filteredState_1));
        }
    };
    /**
     * Set the state
     *
     * @param partialState
     */
    MatrixClientStore.prototype.setState = function (partialState) {
        this.state = {
            isRunning: partialState.isRunning || this.state.isRunning,
            userId: partialState.userId || this.state.userId,
            deviceId: partialState.deviceId || this.state.deviceId,
            txnNo: partialState.txnNo || this.state.txnNo,
            accessToken: partialState.accessToken || this.state.accessToken,
            syncToken: partialState.syncToken || this.state.syncToken,
            pollingTimeout: partialState.pollingTimeout || this.state.pollingTimeout,
            pollingRetries: partialState.pollingRetries || this.state.pollingRetries,
            rooms: this.mergeRooms(this.state.rooms, partialState.rooms)
        };
    };
    /**
     * Merge room records and eliminate duplicates
     *
     * @param oldRooms
     * @param _newRooms
     */
    MatrixClientStore.prototype.mergeRooms = function (oldRooms, _newRooms) {
        if (!_newRooms) {
            return oldRooms;
        }
        var newRooms = Array.isArray(_newRooms) ? _newRooms : Object.values(_newRooms);
        var merged = Object.assign({}, oldRooms);
        newRooms.forEach(function (newRoom) {
            merged[newRoom.id] = MatrixRoom_1.MatrixRoom.merge(newRoom, oldRooms[newRoom.id]);
        });
        return merged;
    };
    /**
     * Notify listeners of state changes
     *
     * @param oldState
     * @param newState
     * @param stateChange
     */
    MatrixClientStore.prototype.notifyListeners = function (oldState, newState, stateChange) {
        var _this = this;
        var listenForAll = this.onStateChangedListeners.get('all');
        if (listenForAll) {
            listenForAll(oldState, newState, stateChange);
        }
        (0, beacon_utils_1.keys)(stateChange)
            .filter(function (key) { return stateChange[key] !== undefined; })
            .forEach(function (key) {
            var listener = _this.onStateChangedListeners.get(key);
            if (listener) {
                listener(oldState, newState, stateChange);
            }
        });
    };
    return MatrixClientStore;
}());
exports.MatrixClientStore = MatrixClientStore;

},{"./models/MatrixRoom":96,"@airgap/beacon-types":104,"@airgap/beacon-utils":136}],93:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MatrixHttpClient = void 0;
var axios_1 = require("axios");
var beacon_utils_1 = require("@airgap/beacon-utils");
var beacon_core_1 = require("@airgap/beacon-core");
var logger = new beacon_core_1.Logger('MatrixHttpClient');
var CLIENT_API_R0 = '/_matrix/client/r0';
/**
 * Handling the HTTP connection to the matrix synapse node
 */
var MatrixHttpClient = /** @class */ (function () {
    function MatrixHttpClient(baseUrl) {
        this.baseUrl = baseUrl;
        this.cancelTokenSource = axios_1.default.CancelToken.source();
    }
    /**
     * Get data from the synapse node
     *
     * @param endpoint
     * @param options
     */
    MatrixHttpClient.prototype.get = function (endpoint, params, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.send('GET', endpoint, options, params)];
            });
        });
    };
    /**
     * Post data to the synapse node
     *
     * @param endpoint
     * @param body
     * @param options
     * @param params
     */
    MatrixHttpClient.prototype.post = function (endpoint, body, options, params) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.send('POST', endpoint, options, params, body)];
            });
        });
    };
    /**
     * Put data to the synapse node
     *
     * @param endpoint
     * @param body
     * @param options
     * @param params
     */
    MatrixHttpClient.prototype.put = function (endpoint, body, options, params) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.send('PUT', endpoint, options, params, body)];
            });
        });
    };
    MatrixHttpClient.prototype.cancelAllRequests = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.cancelTokenSource.cancel('Manually cancelled')];
            });
        });
    };
    /**
     * Send a request to the synapse node
     *
     * @param method
     * @param endpoint
     * @param config
     * @param requestParams
     * @param data
     */
    MatrixHttpClient.prototype.send = function (method, endpoint, config, requestParams, data) {
        return __awaiter(this, void 0, void 0, function () {
            var headers, params, response, error_1, axiosError;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = config ? this.getHeaders(config) : undefined;
                        params = requestParams ? this.getParams(requestParams) : undefined;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, axios_1.default.request({
                                method: method,
                                url: endpoint,
                                baseURL: this.apiUrl(CLIENT_API_R0),
                                headers: headers,
                                data: data,
                                params: params,
                                cancelToken: this.cancelTokenSource.token
                            })];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        axiosError = error_1;
                        logger.error('send', axiosError.code, axiosError.message, axiosError.response.data);
                        throw error_1.response.data;
                    case 4: return [2 /*return*/, response.data];
                }
            });
        });
    };
    /**
     * Get the headers based on the options object
     *
     * @param options
     */
    MatrixHttpClient.prototype.getHeaders = function (options) {
        var headers = {};
        var entries = [];
        if (options.accessToken) {
            entries.push(['Authorization', "Bearer ".concat(options.accessToken)]);
        }
        if (entries.length === 0) {
            return undefined;
        }
        for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
            var _a = entries_1[_i], key = _a[0], value = _a[1];
            headers[key] = value;
        }
        return headers;
    };
    /**
     * Get parameters
     *
     * @param _params
     */
    MatrixHttpClient.prototype.getParams = function (_params) {
        if (!_params) {
            return undefined;
        }
        var params = Object.assign(_params, {});
        (0, beacon_utils_1.keys)(params).forEach(function (key) { return params[key] === undefined && delete params[key]; });
        return params;
    };
    /**
     * Construct API URL
     */
    MatrixHttpClient.prototype.apiUrl = function () {
        var parts = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            parts[_i] = arguments[_i];
        }
        var apiBase = this.baseUrl.endsWith('/')
            ? this.baseUrl.substr(0, this.baseUrl.length - 1)
            : this.baseUrl;
        var apiParts = parts.map(function (path) { return (path.startsWith('/') ? path.substr(1) : path); });
        return __spreadArray([apiBase], apiParts, true).join('/');
    };
    return MatrixHttpClient;
}());
exports.MatrixHttpClient = MatrixHttpClient;

},{"@airgap/beacon-core":58,"@airgap/beacon-utils":136,"axios":212}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MatrixClientEventType = void 0;
var MatrixClientEventType;
(function (MatrixClientEventType) {
    MatrixClientEventType["INVITE"] = "invite";
    MatrixClientEventType["MESSAGE"] = "message";
})(MatrixClientEventType = exports.MatrixClientEventType || (exports.MatrixClientEventType = {}));

},{}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MatrixMessage = exports.MatrixMessageType = void 0;
var events_1 = require("../utils/events");
var MatrixMessageType;
(function (MatrixMessageType) {
    MatrixMessageType["TEXT"] = "m.text";
})(MatrixMessageType = exports.MatrixMessageType || (exports.MatrixMessageType = {}));
var MatrixMessage = /** @class */ (function () {
    function MatrixMessage(type, sender, content, timestamp) {
        this.type = type;
        this.sender = sender;
        this.content = content;
        this.timestamp = timestamp;
    }
    /**
     * Construct a message from a message event
     *
     * @param event
     */
    MatrixMessage.from = function (event) {
        if ((0, events_1.isTextMessageEvent)(event)) {
            return new MatrixMessage(event.content.msgtype, event.sender, event.content.body, event.origin_server_ts);
        }
        // for now only text messages are supported
        return undefined;
    };
    return MatrixMessage;
}());
exports.MatrixMessage = MatrixMessage;

},{"../utils/events":100}],96:[function(require,module,exports){
"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MatrixRoom = exports.MatrixRoomStatus = void 0;
var events_1 = require("../utils/events");
var MatrixMessage_1 = require("./MatrixMessage");
var MatrixRoomStatus;
(function (MatrixRoomStatus) {
    MatrixRoomStatus[MatrixRoomStatus["UNKNOWN"] = 0] = "UNKNOWN";
    MatrixRoomStatus[MatrixRoomStatus["JOINED"] = 1] = "JOINED";
    MatrixRoomStatus[MatrixRoomStatus["INVITED"] = 2] = "INVITED";
    MatrixRoomStatus[MatrixRoomStatus["LEFT"] = 3] = "LEFT";
})(MatrixRoomStatus = exports.MatrixRoomStatus || (exports.MatrixRoomStatus = {}));
var MatrixRoom = /** @class */ (function () {
    function MatrixRoom(id, status, members, messages) {
        if (status === void 0) { status = MatrixRoomStatus.UNKNOWN; }
        if (members === void 0) { members = []; }
        if (messages === void 0) { messages = []; }
        this.id = id;
        this.status = status;
        this.members = members;
        this.messages = messages;
    }
    /**
     * Reconstruct rooms from a sync response
     *
     * @param roomSync
     */
    MatrixRoom.fromSync = function (roomSync) {
        var _a, _b, _c;
        if (!roomSync) {
            return [];
        }
        function create(rooms, creator) {
            return Object.entries(rooms).map(function (_a) {
                var id = _a[0], room = _a[1];
                return creator(id, room);
            });
        }
        return __spreadArray(__spreadArray(__spreadArray([], create((_a = roomSync.join) !== null && _a !== void 0 ? _a : {}, MatrixRoom.fromJoined), true), create((_b = roomSync.invite) !== null && _b !== void 0 ? _b : {}, MatrixRoom.fromInvited), true), create((_c = roomSync.leave) !== null && _c !== void 0 ? _c : {}, MatrixRoom.fromLeft), true);
    };
    /**
     * Reconstruct a room from an ID or object
     *
     * @param roomOrId
     * @param status
     */
    MatrixRoom.from = function (roomOrId, status) {
        return typeof roomOrId === 'string'
            ? new MatrixRoom(roomOrId, status || MatrixRoomStatus.UNKNOWN)
            : status !== undefined
                ? new MatrixRoom(roomOrId.id, status, roomOrId.members, roomOrId.messages)
                : roomOrId;
    };
    /**
     * Merge new and old state and remove duplicates
     *
     * @param newState
     * @param previousState
     */
    MatrixRoom.merge = function (newState, previousState) {
        if (!previousState || previousState.id !== newState.id) {
            return MatrixRoom.from(newState);
        }
        return new MatrixRoom(newState.id, newState.status, __spreadArray(__spreadArray([], previousState.members, true), newState.members, true).filter(function (member, index, array) { return array.indexOf(member) === index; }), __spreadArray(__spreadArray([], previousState.messages, true), newState.messages, true));
    };
    /**
     * Create a room from a join
     *
     * @param id
     * @param joined
     */
    MatrixRoom.fromJoined = function (id, joined) {
        var events = __spreadArray(__spreadArray([], joined.state.events, true), joined.timeline.events, true);
        var members = MatrixRoom.getMembersFromEvents(events);
        var messages = MatrixRoom.getMessagesFromEvents(events);
        return new MatrixRoom(id, MatrixRoomStatus.JOINED, members, messages);
    };
    /**
     * Create a room from an invite
     *
     * @param id
     * @param invited
     */
    MatrixRoom.fromInvited = function (id, invited) {
        var members = MatrixRoom.getMembersFromEvents(invited.invite_state.events);
        return new MatrixRoom(id, MatrixRoomStatus.INVITED, members);
    };
    /**
     * Create a room from a leave
     *
     * @param id
     * @param left
     */
    MatrixRoom.fromLeft = function (id, left) {
        var events = __spreadArray(__spreadArray([], left.state.events, true), left.timeline.events, true);
        var members = MatrixRoom.getMembersFromEvents(events);
        var messages = MatrixRoom.getMessagesFromEvents(events);
        return new MatrixRoom(id, MatrixRoomStatus.LEFT, members, messages);
    };
    /**
     * Extract members from an event
     *
     * @param events
     */
    MatrixRoom.getMembersFromEvents = function (events) {
        return MatrixRoom.getUniqueEvents(events.filter(function (event) { return (0, events_1.isCreateEvent)(event) || (0, events_1.isJoinEvent)(event); }))
            .map(function (event) { return event.sender; })
            .filter(function (member, index, array) { return array.indexOf(member) === index; });
    };
    /**
     * Extract messages from an event
     *
     * @param events
     */
    MatrixRoom.getMessagesFromEvents = function (events) {
        return MatrixRoom.getUniqueEvents(events.filter(events_1.isMessageEvent))
            .map(function (event) { return MatrixMessage_1.MatrixMessage.from(event); })
            .filter(Boolean);
    };
    /**
     * Get unique events and remove duplicates
     *
     * @param events
     */
    MatrixRoom.getUniqueEvents = function (events) {
        var eventIds = {};
        var uniqueEvents = [];
        events.forEach(function (event, index) {
            var eventId = event.event_id;
            if (eventId === undefined || !(eventId in eventIds)) {
                if (eventId !== undefined) {
                    eventIds[eventId] = index;
                }
                uniqueEvents.push(event);
            }
        });
        return uniqueEvents;
    };
    return MatrixRoom;
}());
exports.MatrixRoom = MatrixRoom;

},{"../utils/events":100,"./MatrixMessage":95}],97:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MatrixEventService = void 0;
/**
 * A service to help with matrix event management
 */
var MatrixEventService = /** @class */ (function () {
    function MatrixEventService(httpClient) {
        this.httpClient = httpClient;
        this.cachedPromises = new Map();
    }
    /**
     * Get the latest state from the matrix node
     *
     * @param accessToken
     * @param options
     */
    MatrixEventService.prototype.sync = function (accessToken, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.withCache('sync', function () {
                        return _this.httpClient.get('/sync', {
                            timeout: options ? options.pollingTimeout : undefined,
                            since: options ? options.syncToken : undefined
                        }, { accessToken: accessToken });
                    })];
            });
        });
    };
    /**
     * Send a message to a room
     *
     * @param accessToken
     * @param room
     * @param content
     * @param txnId
     */
    MatrixEventService.prototype.sendMessage = function (accessToken, roomId, content, txnId) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        return _this.scheduleEvent({
                            accessToken: accessToken,
                            roomId: roomId,
                            type: 'm.room.message',
                            content: content,
                            txnId: txnId,
                            onSuccess: resolve,
                            onError: reject
                        });
                    })];
            });
        });
    };
    /**
     * Schedules an event to be sent to the node
     *
     * @param event
     */
    MatrixEventService.prototype.scheduleEvent = function (event) {
        // TODO: actual scheduling
        this.sendEvent(event);
    };
    /**
     * Send an event to the matrix node
     *
     * @param scheduledEvent
     */
    MatrixEventService.prototype.sendEvent = function (scheduledEvent) {
        return __awaiter(this, void 0, void 0, function () {
            var roomId, type, txnId, content, accessToken, response, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        roomId = scheduledEvent.roomId, type = scheduledEvent.type, txnId = scheduledEvent.txnId, content = scheduledEvent.content, accessToken = scheduledEvent.accessToken;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.httpClient.put("/rooms/".concat(encodeURIComponent(roomId), "/send/").concat(type, "/").concat(encodeURIComponent(txnId)), content, { accessToken: accessToken })];
                    case 2:
                        response = _a.sent();
                        scheduledEvent.onSuccess(response);
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        scheduledEvent.onError(error_1);
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Check the cache when interacting with the Matrix node, if there is an already ongoing call for the specified key, return its promise instead of duplicating the call.
     *
     * @param key
     * @param promiseProvider
     */
    MatrixEventService.prototype.withCache = function (key, promiseProvider) {
        var _this = this;
        var promise = this.cachedPromises.get(key);
        if (!promise) {
            promise = promiseProvider().finally(function () {
                _this.cachedPromises.delete(key);
            });
            this.cachedPromises.set(key, promise);
        }
        return promise;
    };
    return MatrixEventService;
}());
exports.MatrixEventService = MatrixEventService;

},{}],98:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MatrixRoomService = void 0;
var MatrixRoom_1 = require("../models/MatrixRoom");
/**
 * A service to help with matrix room management
 */
var MatrixRoomService = /** @class */ (function () {
    function MatrixRoomService(httpClient) {
        this.httpClient = httpClient;
    }
    /**
     * Create a room
     *
     * @param accessToken
     * @param config
     */
    MatrixRoomService.prototype.createRoom = function (accessToken, config) {
        if (config === void 0) { config = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.httpClient.post('/createRoom', config, { accessToken: accessToken })];
            });
        });
    };
    /**
     * Invite a user to a room
     *
     * @param accessToken
     * @param user
     * @param room
     */
    MatrixRoomService.prototype.inviteToRoom = function (accessToken, user, room) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (room.status !== MatrixRoom_1.MatrixRoomStatus.JOINED && room.status !== MatrixRoom_1.MatrixRoomStatus.UNKNOWN) {
                    return [2 /*return*/, Promise.reject("User is not a member of room ".concat(room.id, "."))];
                }
                return [2 /*return*/, this.httpClient.post("/rooms/".concat(encodeURIComponent(room.id), "/invite"), { user_id: user }, { accessToken: accessToken })];
            });
        });
    };
    /**
     * Join a specific room
     *
     * @param accessToken
     * @param room
     */
    MatrixRoomService.prototype.joinRoom = function (accessToken, room) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (room.status === MatrixRoom_1.MatrixRoomStatus.JOINED) {
                    return [2 /*return*/, Promise.resolve({ room_id: room.id })];
                }
                return [2 /*return*/, this.httpClient.post("/rooms/".concat(encodeURIComponent(room.id), "/join"), {}, { accessToken: accessToken })];
            });
        });
    };
    /**
     * Get all joined rooms
     *
     * @param accessToken
     */
    MatrixRoomService.prototype.getJoinedRooms = function (accessToken) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.httpClient.get("/joined_rooms", undefined, { accessToken: accessToken })];
            });
        });
    };
    return MatrixRoomService;
}());
exports.MatrixRoomService = MatrixRoomService;

},{"../models/MatrixRoom":96}],99:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MatrixUserService = void 0;
var MatrixUserService = /** @class */ (function () {
    function MatrixUserService(httpClient) {
        this.httpClient = httpClient;
    }
    /**
     * Log in to the matrix node with username and password
     *
     * @param user
     * @param password
     * @param deviceId
     */
    MatrixUserService.prototype.login = function (user, password, deviceId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.httpClient.post('/login', {
                        type: 'm.login.password',
                        identifier: {
                            type: 'm.id.user',
                            user: user
                        },
                        password: password,
                        device_id: deviceId
                    })];
            });
        });
    };
    return MatrixUserService;
}());
exports.MatrixUserService = MatrixUserService;

},{}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTextMessageEvent = exports.isMessageEvent = exports.isJoinEvent = exports.isCreateEvent = void 0;
var MatrixMessage_1 = require("../models/MatrixMessage");
/**
 * Check if an event is a create event
 *
 * @param event MatrixStateEvent
 */
var isCreateEvent = function (event) {
    return event.type === 'm.room.create' && event.content instanceof Object && 'creator' in event.content;
};
exports.isCreateEvent = isCreateEvent;
/**
 * Check if an event is a join event
 *
 * @param event MatrixStateEvent
 */
var isJoinEvent = function (event) {
    return event.type === 'm.room.member' &&
        event.content instanceof Object &&
        'membership' in event.content &&
        // eslint-disable-next-line dot-notation
        event.content['membership'] === 'join';
};
exports.isJoinEvent = isJoinEvent;
/**
 * Check if an event is a message event
 *
 * @param event MatrixStateEvent
 */
var isMessageEvent = function (event) { return event.type === 'm.room.message'; };
exports.isMessageEvent = isMessageEvent;
/**
 * Check if an event is a text message event
 *
 * @param event MatrixStateEvent
 */
var isTextMessageEvent = function (event) {
    return (0, exports.isMessageEvent)(event) &&
        event.content instanceof Object &&
        'msgtype' in event.content &&
        // eslint-disable-next-line dot-notation
        event.content['msgtype'] === MatrixMessage_1.MatrixMessageType.TEXT;
};
exports.isTextMessageEvent = isTextMessageEvent;

},{"../models/MatrixMessage":95}],101:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PostMessageClient = void 0;
var beacon_core_1 = require("@airgap/beacon-core");
var beacon_utils_1 = require("@airgap/beacon-utils");
var beacon_types_1 = require("@airgap/beacon-types");
/**
 * @internalapi
 *
 *
 */
var PostMessageClient = /** @class */ (function (_super) {
    __extends(PostMessageClient, _super);
    function PostMessageClient() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.activeListeners = new Map();
        return _this;
    }
    PostMessageClient.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.subscribeToMessages().catch(console.error);
                return [2 /*return*/];
            });
        });
    };
    PostMessageClient.prototype.listenForEncryptedMessage = function (senderPublicKey, messageCallback) {
        return __awaiter(this, void 0, void 0, function () {
            var callbackFunction;
            var _this = this;
            return __generator(this, function (_a) {
                if (this.activeListeners.has(senderPublicKey)) {
                    return [2 /*return*/];
                }
                callbackFunction = function (message, context) { return __awaiter(_this, void 0, void 0, function () {
                    var decryptedMessage, decryptionError_1;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 2, , 3]);
                                return [4 /*yield*/, this.decryptMessage(senderPublicKey, message.encryptedPayload)
                                    // console.log('calculated sender ID', await getSenderId(senderPublicKey))
                                    // TODO: Add check for correct decryption key / sender ID
                                ];
                            case 1:
                                decryptedMessage = _a.sent();
                                // console.log('calculated sender ID', await getSenderId(senderPublicKey))
                                // TODO: Add check for correct decryption key / sender ID
                                messageCallback(decryptedMessage, context);
                                return [3 /*break*/, 3];
                            case 2:
                                decryptionError_1 = _a.sent();
                                return [3 /*break*/, 3];
                            case 3: return [2 /*return*/];
                        }
                    });
                }); };
                this.activeListeners.set(senderPublicKey, callbackFunction);
                return [2 /*return*/];
            });
        });
    };
    PostMessageClient.prototype.sendMessage = function (message, peer) {
        return __awaiter(this, void 0, void 0, function () {
            var payload, targetId, msg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.encryptMessage(peer.publicKey, message)];
                    case 1:
                        payload = _a.sent();
                        targetId = peer === null || peer === void 0 ? void 0 : peer.extensionId;
                        msg = {
                            target: beacon_types_1.ExtensionMessageTarget.EXTENSION,
                            encryptedPayload: payload,
                            targetId: targetId
                        };
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        beacon_core_1.windowRef.postMessage(msg, beacon_core_1.windowRef.location.origin);
                        return [2 /*return*/];
                }
            });
        });
    };
    PostMessageClient.prototype.listenForChannelOpening = function (messageCallback) {
        return __awaiter(this, void 0, void 0, function () {
            var fn;
            var _this = this;
            return __generator(this, function (_a) {
                fn = function (event) { return __awaiter(_this, void 0, void 0, function () {
                    var data, _a, payload, pairingResponse, _b, _c, _d, _e, decryptionError_2;
                    var _f;
                    var _g, _h;
                    return __generator(this, function (_j) {
                        switch (_j.label) {
                            case 0:
                                if (event.source !== beacon_core_1.windowRef || event.origin !== beacon_core_1.windowRef.location.origin) {
                                    // TODO: Add to error handler: console.debug('[Beacon]: Event received from untrusted origin')
                                    return [2 /*return*/];
                                }
                                data = (_g = event === null || event === void 0 ? void 0 : event.data) === null || _g === void 0 ? void 0 : _g.message;
                                _a = data &&
                                    data.target === beacon_types_1.ExtensionMessageTarget.PAGE;
                                if (!_a) return [3 /*break*/, 2];
                                return [4 /*yield*/, this.isChannelOpenMessage(data)];
                            case 1:
                                _a = (_j.sent());
                                _j.label = 2;
                            case 2:
                                if (!_a) return [3 /*break*/, 7];
                                payload = Buffer.from(data.payload, 'hex');
                                if (!(payload.length >= beacon_utils_1.secretbox_NONCEBYTES + beacon_utils_1.secretbox_MACBYTES)) return [3 /*break*/, 7];
                                _j.label = 3;
                            case 3:
                                _j.trys.push([3, 6, , 7]);
                                _c = (_b = JSON).parse;
                                return [4 /*yield*/, (0, beacon_utils_1.openCryptobox)(payload, this.keyPair.publicKey, this.keyPair.secretKey)];
                            case 4:
                                pairingResponse = _c.apply(_b, [_j.sent()]);
                                _d = messageCallback;
                                _e = [__assign({}, pairingResponse)];
                                _f = {};
                                return [4 /*yield*/, (0, beacon_core_1.getSenderId)(pairingResponse.publicKey)];
                            case 5:
                                _d.apply(void 0, [__assign.apply(void 0, _e.concat([(_f.senderId = _j.sent(), _f.extensionId = (_h = event === null || event === void 0 ? void 0 : event.data) === null || _h === void 0 ? void 0 : _h.sender.id, _f)]))]);
                                return [3 /*break*/, 7];
                            case 6:
                                decryptionError_2 = _j.sent();
                                return [3 /*break*/, 7];
                            case 7: return [2 /*return*/];
                        }
                    });
                }); };
                beacon_core_1.windowRef.addEventListener('message', fn);
                return [2 /*return*/];
            });
        });
    };
    PostMessageClient.prototype.sendPairingRequest = function (id) {
        return __awaiter(this, void 0, void 0, function () {
            var message, _a, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _c = {
                            target: beacon_types_1.ExtensionMessageTarget.EXTENSION
                        };
                        _b = (_a = new beacon_core_1.Serializer()).serialize;
                        return [4 /*yield*/, this.getPairingRequestInfo()];
                    case 1: return [4 /*yield*/, _b.apply(_a, [_d.sent()])];
                    case 2:
                        message = (_c.payload = _d.sent(),
                            _c.targetId = id,
                            _c);
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        beacon_core_1.windowRef.postMessage(message, beacon_core_1.windowRef.location.origin);
                        return [2 /*return*/];
                }
            });
        });
    };
    PostMessageClient.prototype.isChannelOpenMessage = function (message) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, typeof message === 'object' && message.hasOwnProperty('payload')];
            });
        });
    };
    PostMessageClient.prototype.subscribeToMessages = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                beacon_core_1.windowRef.addEventListener('message', function (message) {
                    if (message.source !== beacon_core_1.windowRef ||
                        message.origin !== beacon_core_1.windowRef.location.origin) {
                        // TODO: Add to error handler: console.debug('[Beacon]: Event received from untrusted origin')
                        return;
                    }
                    if (typeof message === 'object' && message) {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        var data_1 = message.data;
                        if (data_1.message && data_1.message.target === beacon_types_1.ExtensionMessageTarget.PAGE) {
                            _this.activeListeners.forEach(function (listener) {
                                listener(data_1.message, {
                                    origin: beacon_types_1.Origin.EXTENSION,
                                    id: data_1.sender.id || ''
                                });
                            });
                        }
                    }
                });
                return [2 /*return*/];
            });
        });
    };
    return PostMessageClient;
}(beacon_core_1.MessageBasedClient));
exports.PostMessageClient = PostMessageClient;

}).call(this)}).call(this,require("buffer").Buffer)
},{"@airgap/beacon-core":58,"@airgap/beacon-types":104,"@airgap/beacon-utils":136,"buffer":3}],102:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PostMessageTransport = void 0;
var beacon_types_1 = require("@airgap/beacon-types");
var beacon_core_1 = require("@airgap/beacon-core");
var PostMessageClient_1 = require("./PostMessageClient");
var logger = new beacon_core_1.Logger('PostMessageTransport');
var listeningForExtensions = false;
var extensionsPromise;
var extensions;
var addExtension = function (extension) {
    if (!extensions) {
        extensions = [];
    }
    if (!extensions.some(function (ext) { return ext.id === extension.id; })) {
        extensions.push(extension);
        beacon_core_1.windowRef.postMessage('extensionsUpdated', beacon_core_1.windowRef.location.origin);
    }
};
/**
 * @internalapi
 *
 *
 */
var PostMessageTransport = /** @class */ (function (_super) {
    __extends(PostMessageTransport, _super);
    function PostMessageTransport(name, keyPair, storage, storageKey) {
        var _this = _super.call(this, name, new PostMessageClient_1.PostMessageClient(name, keyPair), new beacon_core_1.PeerManager(storage, storageKey)) || this;
        _this.type = beacon_types_1.TransportType.POST_MESSAGE;
        return _this;
    }
    PostMessageTransport.isAvailable = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        var fn = function (event) {
                            var data = event.data;
                            if (data && data.payload === 'pong') {
                                resolve(true);
                                beacon_core_1.windowRef.removeEventListener('message', fn);
                            }
                        };
                        beacon_core_1.windowRef.addEventListener('message', fn);
                        var message = {
                            target: beacon_types_1.ExtensionMessageTarget.EXTENSION,
                            payload: 'ping'
                        };
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        beacon_core_1.windowRef.postMessage(message, beacon_core_1.windowRef.location.origin);
                    })];
            });
        });
    };
    PostMessageTransport.getAvailableExtensions = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (extensionsPromise) {
                    return [2 /*return*/, extensionsPromise];
                }
                if (extensions) {
                    return [2 /*return*/, extensions];
                }
                extensions = [];
                extensionsPromise = new Promise(function (resolve) {
                    PostMessageTransport.listenForExtensions();
                    setTimeout(function () {
                        resolve(extensions !== null && extensions !== void 0 ? extensions : []);
                    }, 1000);
                }).finally(function () {
                    extensionsPromise = undefined;
                });
                return [2 /*return*/, extensionsPromise];
            });
        });
    };
    PostMessageTransport.listenForExtensions = function () {
        if (listeningForExtensions) {
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var fn = function (event) {
            if (event.source !== beacon_core_1.windowRef || event.origin !== beacon_core_1.windowRef.location.origin) {
                // TODO: Add to error handler: console.debug('[Beacon]: Event received from untrusted origin')
                return;
            }
            var data = event.data;
            var sender = data.sender;
            if (data && data.payload === 'pong' && sender) {
                logger.log('getAvailableExtensions', "extension \"".concat(sender.name, "\" is available"), sender);
                addExtension(sender);
            }
        };
        beacon_core_1.windowRef.addEventListener('message', fn);
        var message = {
            target: beacon_types_1.ExtensionMessageTarget.EXTENSION,
            payload: 'ping'
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        beacon_core_1.windowRef.postMessage(message, beacon_core_1.windowRef.location.origin);
        listeningForExtensions = true;
    };
    PostMessageTransport.prototype.connect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var knownPeers, connectionPromises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        logger.log('connect');
                        if (this._isConnected !== beacon_types_1.TransportStatus.NOT_CONNECTED) {
                            return [2 /*return*/];
                        }
                        this._isConnected = beacon_types_1.TransportStatus.CONNECTING;
                        return [4 /*yield*/, this.getPeers()];
                    case 1:
                        knownPeers = _a.sent();
                        if (knownPeers.length > 0) {
                            logger.log('connect', "connecting to ".concat(knownPeers.length, " peers"));
                            connectionPromises = knownPeers.map(function (peer) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2 /*return*/, this.listen(peer.publicKey)];
                            }); }); });
                            Promise.all(connectionPromises).catch(function (error) { return logger.error('connect', error); });
                        }
                        return [4 /*yield*/, this.startOpenChannelListener()];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, _super.prototype.connect.call(this)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    PostMessageTransport.prototype.startOpenChannelListener = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/];
            });
        });
    };
    PostMessageTransport.prototype.getPairingRequestInfo = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.client.getPairingRequestInfo()];
            });
        });
    };
    PostMessageTransport.prototype.listen = function (publicKey) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        logger.log('listen', publicKey);
                        return [4 /*yield*/, this.client
                                .listenForEncryptedMessage(publicKey, function (message, context) {
                                var connectionContext = {
                                    origin: beacon_types_1.Origin.EXTENSION,
                                    id: context.id
                                };
                                _this.notifyListeners(message, connectionContext).catch(function (error) {
                                    throw error;
                                });
                            })
                                .catch(function (error) {
                                throw error;
                            })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return PostMessageTransport;
}(beacon_core_1.Transport));
exports.PostMessageTransport = PostMessageTransport;

},{"./PostMessageClient":101,"@airgap/beacon-core":58,"@airgap/beacon-types":104}],103:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PostMessageTransport = void 0;
var PostMessageTransport_1 = require("./PostMessageTransport");
Object.defineProperty(exports, "PostMessageTransport", { enumerable: true, get: function () { return PostMessageTransport_1.PostMessageTransport; } });

},{"./PostMessageTransport":102}],104:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColorMode = exports.defaultValues = exports.StorageKey = exports.Storage = exports.TransportType = exports.TransportStatus = exports.BeaconErrorType = exports.ExtensionMessageTarget = exports.SigningType = exports.Origin = exports.PermissionScope = exports.BeaconMessageType = exports.NetworkType = exports.TezosOperationType = void 0;
var BeaconMessageType_1 = require("./types/beacon/BeaconMessageType");
Object.defineProperty(exports, "BeaconMessageType", { enumerable: true, get: function () { return BeaconMessageType_1.BeaconMessageType; } });
var PermissionScope_1 = require("./types/beacon/PermissionScope");
Object.defineProperty(exports, "PermissionScope", { enumerable: true, get: function () { return PermissionScope_1.PermissionScope; } });
var NetworkType_1 = require("./types/beacon/NetworkType");
Object.defineProperty(exports, "NetworkType", { enumerable: true, get: function () { return NetworkType_1.NetworkType; } });
var OperationTypes_1 = require("./types/tezos/OperationTypes");
Object.defineProperty(exports, "TezosOperationType", { enumerable: true, get: function () { return OperationTypes_1.TezosOperationType; } });
var Origin_1 = require("./types/Origin");
Object.defineProperty(exports, "Origin", { enumerable: true, get: function () { return Origin_1.Origin; } });
var ExtensionMessageTarget_1 = require("./types/ExtensionMessageTarget");
Object.defineProperty(exports, "ExtensionMessageTarget", { enumerable: true, get: function () { return ExtensionMessageTarget_1.ExtensionMessageTarget; } });
var BeaconErrorType_1 = require("./types/BeaconErrorType");
Object.defineProperty(exports, "BeaconErrorType", { enumerable: true, get: function () { return BeaconErrorType_1.BeaconErrorType; } });
var TransportStatus_1 = require("./types/transport/TransportStatus");
Object.defineProperty(exports, "TransportStatus", { enumerable: true, get: function () { return TransportStatus_1.TransportStatus; } });
var TransportType_1 = require("./types/transport/TransportType");
Object.defineProperty(exports, "TransportType", { enumerable: true, get: function () { return TransportType_1.TransportType; } });
var Storage_1 = require("./types/storage/Storage");
Object.defineProperty(exports, "Storage", { enumerable: true, get: function () { return Storage_1.Storage; } });
var StorageKey_1 = require("./types/storage/StorageKey");
Object.defineProperty(exports, "StorageKey", { enumerable: true, get: function () { return StorageKey_1.StorageKey; } });
var StorageKeyReturnDefaults_1 = require("./types/storage/StorageKeyReturnDefaults");
Object.defineProperty(exports, "defaultValues", { enumerable: true, get: function () { return StorageKeyReturnDefaults_1.defaultValues; } });
var SigningType_1 = require("./types/beacon/SigningType");
Object.defineProperty(exports, "SigningType", { enumerable: true, get: function () { return SigningType_1.SigningType; } });
var ColorMode_1 = require("./types/ColorMode");
Object.defineProperty(exports, "ColorMode", { enumerable: true, get: function () { return ColorMode_1.ColorMode; } });
__exportStar(require("./types/beaconV3/PermissionRequest"), exports);
__exportStar(require("./types/ui"), exports);
__exportStar(require("./types/Regions"), exports);

},{"./types/BeaconErrorType":105,"./types/ColorMode":106,"./types/ExtensionMessageTarget":107,"./types/Origin":108,"./types/Regions":109,"./types/beacon/BeaconMessageType":110,"./types/beacon/NetworkType":111,"./types/beacon/PermissionScope":112,"./types/beacon/SigningType":113,"./types/beaconV3/PermissionRequest":114,"./types/storage/Storage":115,"./types/storage/StorageKey":116,"./types/storage/StorageKeyReturnDefaults":117,"./types/tezos/OperationTypes":118,"./types/transport/TransportStatus":119,"./types/transport/TransportType":120,"./types/ui":121}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BeaconErrorType = void 0;
var BeaconErrorType;
(function (BeaconErrorType) {
    /**
     * {@link BroadcastBeaconError}
     *
     * Will be returned if the user chooses that the transaction is broadcast but there is an error (eg. node not available).
     *
     * Returned by: Broadcast | Operation Request
     */
    BeaconErrorType["BROADCAST_ERROR"] = "BROADCAST_ERROR";
    /**
     * {@link NetworkNotSupportedBeaconError}
     *
     * Will be returned if the selected network is not supported by the wallet / extension.
     *
     * Returned by: Permission
     */
    BeaconErrorType["NETWORK_NOT_SUPPORTED"] = "NETWORK_NOT_SUPPORTED";
    /**
     * {@link NoAddressBeaconError}
     *
     * Will be returned if there is no address present for the protocol / network requested.
     *
     * Returned by: Permission
     */
    BeaconErrorType["NO_ADDRESS_ERROR"] = "NO_ADDRESS_ERROR";
    /**
     * {@link NoPrivateKeyBeaconError}
     *
     * Will be returned if the private key matching the sourceAddress could not be found.
     *
     * Returned by: Sign
     */
    BeaconErrorType["NO_PRIVATE_KEY_FOUND_ERROR"] = "NO_PRIVATE_KEY_FOUND_ERROR";
    /**
     * {@link NotGrantedBeaconError}
     *
     * Will be returned if the signature was blocked // (Not needed?) Permission: Will be returned if the permissions requested by the App were not granted.
     *
     * Returned by: Sign
     */
    BeaconErrorType["NOT_GRANTED_ERROR"] = "NOT_GRANTED_ERROR";
    /**
     * {@link ParametersInvalidBeaconError}
     *
     * Will be returned if any of the parameters are invalid.
     *
     * Returned by: Operation Request
     */
    BeaconErrorType["PARAMETERS_INVALID_ERROR"] = "PARAMETERS_INVALID_ERROR";
    /**
     * {@link TooManyOperationsBeaconError}
     *
     * Will be returned if too many operations were in the request and they were not able to fit into a single operation group.
     *
     * Returned by: Operation Request
     */
    BeaconErrorType["TOO_MANY_OPERATIONS"] = "TOO_MANY_OPERATIONS";
    /**
     * {@link TransactionInvalidBeaconError}
     *
     * Will be returned if the transaction is not parsable or is rejected by the node.
     *
     * Returned by: Broadcast
     */
    BeaconErrorType["TRANSACTION_INVALID_ERROR"] = "TRANSACTION_INVALID_ERROR";
    /**
     * {@link SignatureTypeNotSupportedBeaconError}
     *
     * Will be returned if the signing type is not supported.
     *
     * Returned by: Sign
     */
    BeaconErrorType["SIGNATURE_TYPE_NOT_SUPPORTED"] = "SIGNATURE_TYPE_NOT_SUPPORTED";
    // TODO: ENCRYPTION
    // /**
    //  * {@link EncryptionTypeNotSupportedBeaconError}
    //  *
    //  * Will be returned if the encryption type is not supported.
    //  *
    //  * Returned by: Encrypt
    //  */
    // ENCRYPTION_TYPE_NOT_SUPPORTED = 'ENCRYPTION_TYPE_NOT_SUPPORTED',
    /**
     * {@link AbortedBeaconError}
     *
     * Will be returned if the request was aborted by the user or the wallet.
     *
     * Returned by: Permission | Operation Request | Sign Request | Broadcast
     */
    BeaconErrorType["ABORTED_ERROR"] = "ABORTED_ERROR";
    /**
     * {@link UnknownBeaconError}
     *
     * Used as a wildcard if an unexpected error occured.
     *
     * Returned by: Permission | Operation Request | Sign Request | Broadcast
     */
    BeaconErrorType["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
})(BeaconErrorType = exports.BeaconErrorType || (exports.BeaconErrorType = {}));

},{}],106:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColorMode = void 0;
var ColorMode;
(function (ColorMode) {
    ColorMode["LIGHT"] = "light";
    ColorMode["DARK"] = "dark";
})(ColorMode = exports.ColorMode || (exports.ColorMode = {}));

},{}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtensionMessageTarget = void 0;
/**
 * @internalapi
 */
var ExtensionMessageTarget;
(function (ExtensionMessageTarget) {
    ExtensionMessageTarget["BACKGROUND"] = "toBackground";
    ExtensionMessageTarget["PAGE"] = "toPage";
    ExtensionMessageTarget["EXTENSION"] = "toExtension";
})(ExtensionMessageTarget = exports.ExtensionMessageTarget || (exports.ExtensionMessageTarget = {}));

},{}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Origin = void 0;
/**
 * @internalapi
 */
var Origin;
(function (Origin) {
    Origin["WEBSITE"] = "website";
    Origin["EXTENSION"] = "extension";
    Origin["P2P"] = "p2p";
})(Origin = exports.Origin || (exports.Origin = {}));

},{}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Regions = void 0;
/**
 * Geographic region where a beacon node is located. This list can be changed in the future to be more specific, but for now it should cover most general areas.
 */
var Regions;
(function (Regions) {
    Regions["EUROPE_EAST"] = "europe-east";
    Regions["EUROPE_WEST"] = "europe-west";
    Regions["NORTH_AMERICA_EAST"] = "north-america-east";
    Regions["NORTH_AMERICA_WEST"] = "north-america-west";
    Regions["CENTRAL_AMERICA"] = "central-america";
    Regions["SOUTH_AMERICA"] = "south-america";
    Regions["ASIA_EAST"] = "asia-east";
    Regions["ASIA_WEST"] = "asia-west";
    Regions["AFRICA"] = "africa";
    Regions["AUSTRALIA"] = "australia";
})(Regions = exports.Regions || (exports.Regions = {}));

},{}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BeaconMessageType = void 0;
var BeaconMessageType;
(function (BeaconMessageType) {
    BeaconMessageType["BlockchainRequest"] = "blockchain_request";
    BeaconMessageType["PermissionRequest"] = "permission_request";
    BeaconMessageType["SignPayloadRequest"] = "sign_payload_request";
    // EncryptPayloadRequest = 'encrypt_payload_request',
    BeaconMessageType["OperationRequest"] = "operation_request";
    BeaconMessageType["BroadcastRequest"] = "broadcast_request";
    BeaconMessageType["BlockchainResponse"] = "blockchain_response";
    BeaconMessageType["PermissionResponse"] = "permission_response";
    BeaconMessageType["SignPayloadResponse"] = "sign_payload_response";
    // EncryptPayloadResponse = 'encrypt_payload_response',
    BeaconMessageType["OperationResponse"] = "operation_response";
    BeaconMessageType["BroadcastResponse"] = "broadcast_response";
    BeaconMessageType["Acknowledge"] = "acknowledge";
    BeaconMessageType["Disconnect"] = "disconnect";
    BeaconMessageType["Error"] = "error";
})(BeaconMessageType = exports.BeaconMessageType || (exports.BeaconMessageType = {}));

},{}],111:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkType = void 0;
var NetworkType;
(function (NetworkType) {
    NetworkType["MAINNET"] = "mainnet";
    NetworkType["GHOSTNET"] = "ghostnet";
    NetworkType["MONDAYNET"] = "mondaynet";
    NetworkType["DAILYNET"] = "dailynet";
    NetworkType["DELPHINET"] = "delphinet";
    NetworkType["EDONET"] = "edonet";
    NetworkType["FLORENCENET"] = "florencenet";
    NetworkType["GRANADANET"] = "granadanet";
    NetworkType["HANGZHOUNET"] = "hangzhounet";
    NetworkType["ITHACANET"] = "ithacanet";
    NetworkType["JAKARTANET"] = "jakartanet";
    NetworkType["KATHMANDUNET"] = "kathmandunet";
    NetworkType["LIMANET"] = "limanet";
    NetworkType["MUMBAINET"] = "mumbainet";
    NetworkType["CUSTOM"] = "custom";
})(NetworkType = exports.NetworkType || (exports.NetworkType = {}));

},{}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionScope = void 0;
var PermissionScope;
(function (PermissionScope) {
    PermissionScope["SIGN"] = "sign";
    PermissionScope["OPERATION_REQUEST"] = "operation_request";
    PermissionScope["ENCRYPT"] = "encrypt";
    PermissionScope["NOTIFICATION"] = "notification";
    PermissionScope["THRESHOLD"] = "threshold"; // Allows the DApp to sign transactions below a certain threshold. This is currently not fully defined and unused
})(PermissionScope = exports.PermissionScope || (exports.PermissionScope = {}));

},{}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SigningType = void 0;
var SigningType;
(function (SigningType) {
    SigningType["RAW"] = "raw";
    SigningType["OPERATION"] = "operation";
    SigningType["MICHELINE"] = "micheline"; // "05" prefix
})(SigningType = exports.SigningType || (exports.SigningType = {}));

},{}],114:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],115:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Storage = void 0;
/**
 * @internalapi
 *
 * The storage used in the SDK
 */
var Storage = /** @class */ (function () {
    function Storage() {
    }
    /**
     * Returns a promise that resolves to true if the storage option is available on this platform.
     */
    Storage.isSupported = function () {
        return Promise.resolve(false);
    };
    return Storage;
}());
exports.Storage = Storage;

},{}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageKey = void 0;
/**
 * @internalapi
 */
var StorageKey;
(function (StorageKey) {
    StorageKey["TRANSPORT_P2P_PEERS_DAPP"] = "beacon:communication-peers-dapp";
    StorageKey["TRANSPORT_P2P_PEERS_WALLET"] = "beacon:communication-peers-wallet";
    StorageKey["TRANSPORT_POSTMESSAGE_PEERS_DAPP"] = "beacon:postmessage-peers-dapp";
    StorageKey["TRANSPORT_POSTMESSAGE_PEERS_WALLET"] = "beacon:postmessage-peers-wallet";
    StorageKey["ACCOUNTS"] = "beacon:accounts";
    StorageKey["ACTIVE_ACCOUNT"] = "beacon:active-account";
    StorageKey["PUSH_TOKENS"] = "beacon:push-tokens";
    StorageKey["BEACON_SDK_SECRET_SEED"] = "beacon:sdk-secret-seed";
    StorageKey["APP_METADATA_LIST"] = "beacon:app-metadata-list";
    StorageKey["PERMISSION_LIST"] = "beacon:permissions";
    StorageKey["BEACON_SDK_VERSION"] = "beacon:sdk_version";
    StorageKey["MATRIX_PRESERVED_STATE"] = "beacon:sdk-matrix-preserved-state";
    StorageKey["MATRIX_PEER_ROOM_IDS"] = "beacon:matrix-peer-rooms";
    StorageKey["MATRIX_SELECTED_NODE"] = "beacon:matrix-selected-node";
    StorageKey["MULTI_NODE_SETUP_DONE"] = "beacon:multi-node-setup";
})(StorageKey = exports.StorageKey || (exports.StorageKey = {}));

},{}],117:[function(require,module,exports){
"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultValues = void 0;
var __1 = require("../..");
/**
 * @internalapi
 */
exports.defaultValues = (_a = {},
    _a[__1.StorageKey.TRANSPORT_P2P_PEERS_DAPP] = [],
    _a[__1.StorageKey.TRANSPORT_P2P_PEERS_WALLET] = [],
    _a[__1.StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP] = [],
    _a[__1.StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET] = [],
    _a[__1.StorageKey.ACCOUNTS] = [],
    _a[__1.StorageKey.ACTIVE_ACCOUNT] = undefined,
    _a[__1.StorageKey.PUSH_TOKENS] = [],
    _a[__1.StorageKey.BEACON_SDK_SECRET_SEED] = undefined,
    _a[__1.StorageKey.APP_METADATA_LIST] = [],
    _a[__1.StorageKey.PERMISSION_LIST] = [],
    _a[__1.StorageKey.BEACON_SDK_VERSION] = undefined,
    _a[__1.StorageKey.MATRIX_PRESERVED_STATE] = {},
    _a[__1.StorageKey.MATRIX_PEER_ROOM_IDS] = {},
    _a[__1.StorageKey.MATRIX_SELECTED_NODE] = undefined,
    _a[__1.StorageKey.MULTI_NODE_SETUP_DONE] = undefined,
    _a);

},{"../..":104}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TezosOperationType = void 0;
/**
 * @publicapi
 * @category Tezos
 */
var TezosOperationType;
(function (TezosOperationType) {
    TezosOperationType["ENDORSEMENT"] = "endorsement";
    TezosOperationType["SEED_NONCE_REVELATION"] = "seed_nonce_revelation";
    TezosOperationType["DOUBLE_ENDORSEMENT_EVIDENCE"] = "double_endorsement_evidence";
    TezosOperationType["DOUBLE_BAKING_EVIDENCE"] = "double_baking_evidence";
    TezosOperationType["ACTIVATE_ACCOUNT"] = "activate_account";
    TezosOperationType["PROPOSALS"] = "proposals";
    TezosOperationType["BALLOT"] = "ballot";
    TezosOperationType["REVEAL"] = "reveal";
    TezosOperationType["TRANSACTION"] = "transaction";
    TezosOperationType["ORIGINATION"] = "origination";
    TezosOperationType["DELEGATION"] = "delegation";
})(TezosOperationType = exports.TezosOperationType || (exports.TezosOperationType = {}));

},{}],119:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransportStatus = void 0;
var TransportStatus;
(function (TransportStatus) {
    TransportStatus["NOT_CONNECTED"] = "NOT_CONNECTED";
    TransportStatus["CONNECTING"] = "CONNECTING";
    TransportStatus["CONNECTED"] = "CONNECTED";
})(TransportStatus = exports.TransportStatus || (exports.TransportStatus = {}));

},{}],120:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransportType = void 0;
/**
 * @internalapi
 */
var TransportType;
(function (TransportType) {
    TransportType["CHROME_MESSAGE"] = "chrome_message";
    TransportType["POST_MESSAGE"] = "post_message";
    TransportType["LEDGER"] = "ledger";
    TransportType["P2P"] = "p2p";
})(TransportType = exports.TransportType || (exports.TransportType = {}));

},{}],121:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var NetworkType_1 = require("./beacon/NetworkType");

},{"./beacon/NetworkType":111}],122:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setColorMode = exports.getColorMode = exports.getiOSList = exports.getWebList = exports.getExtensionList = exports.getDesktopList = exports.setiOSList = exports.setWebList = exports.setExtensionList = exports.setDesktopList = exports.Pairing = exports.isMobile = exports.openToast = exports.closeToast = exports.closeAlerts = exports.openAlert = void 0;
var Alert_1 = require("./ui/alert/Alert");
Object.defineProperty(exports, "openAlert", { enumerable: true, get: function () { return Alert_1.openAlert; } });
Object.defineProperty(exports, "closeAlerts", { enumerable: true, get: function () { return Alert_1.closeAlerts; } });
var Toast_1 = require("./ui/toast/Toast");
Object.defineProperty(exports, "closeToast", { enumerable: true, get: function () { return Toast_1.closeToast; } });
Object.defineProperty(exports, "openToast", { enumerable: true, get: function () { return Toast_1.openToast; } });
var platform_1 = require("./utils/platform");
Object.defineProperty(exports, "isMobile", { enumerable: true, get: function () { return platform_1.isMobile; } });
var Pairing_1 = require("./ui/alert/Pairing");
Object.defineProperty(exports, "Pairing", { enumerable: true, get: function () { return Pairing_1.Pairing; } });
Object.defineProperty(exports, "setDesktopList", { enumerable: true, get: function () { return Pairing_1.setDesktopList; } });
Object.defineProperty(exports, "setExtensionList", { enumerable: true, get: function () { return Pairing_1.setExtensionList; } });
Object.defineProperty(exports, "setWebList", { enumerable: true, get: function () { return Pairing_1.setWebList; } });
Object.defineProperty(exports, "setiOSList", { enumerable: true, get: function () { return Pairing_1.setiOSList; } });
Object.defineProperty(exports, "getDesktopList", { enumerable: true, get: function () { return Pairing_1.getDesktopList; } });
Object.defineProperty(exports, "getExtensionList", { enumerable: true, get: function () { return Pairing_1.getExtensionList; } });
Object.defineProperty(exports, "getWebList", { enumerable: true, get: function () { return Pairing_1.getWebList; } });
Object.defineProperty(exports, "getiOSList", { enumerable: true, get: function () { return Pairing_1.getiOSList; } });
var colorMode_1 = require("./utils/colorMode");
Object.defineProperty(exports, "getColorMode", { enumerable: true, get: function () { return colorMode_1.getColorMode; } });
Object.defineProperty(exports, "setColorMode", { enumerable: true, get: function () { return colorMode_1.setColorMode; } });

},{"./ui/alert/Alert":123,"./ui/alert/Pairing":124,"./ui/toast/Toast":128,"./utils/colorMode":130,"./utils/platform":133}],123:[function(require,module,exports){
"use strict";
// Taken from https://github.com/WalletConnect/walletconnect-monorepo/blob/master/packages/qrcode-modal/src/browser.ts
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.openAlert = exports.closeAlerts = exports.closeAlert = void 0;
var beacon_core_1 = require("@airgap/beacon-core");
var beacon_utils_1 = require("@airgap/beacon-utils");
var alert_templates_1 = require("./alert-templates");
var PairingAlert_1 = require("./PairingAlert");
var colorMode_1 = require("../../utils/colorMode");
var html_elements_1 = require("../../utils/html-elements");
var templates_1 = require("../../utils/templates");
var lastFocusedElement;
var document;
if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {
    document = window.document;
}
var timeout = {};
var addQR = function (dataString) {
    if (typeof dataString === 'string') {
        return (0, html_elements_1.createSanitizedElement)('div', [], [['id', 'beacon--qr__container']], [
            (0, html_elements_1.createSanitizedElement)('div', [], [['id', 'beacon--qr__copy__container']], [
                (0, html_elements_1.createSanitizedElement)('button', ['beacon-modal__button--outline'], [['id', 'beacon--qr__copy']], 'Copy')
            ])
        ]);
    }
    return (0, html_elements_1.createSanitizedElement)('span', [], [], '');
};
var formatAlert = function (id, body, title, buttons, hasPairingPayload) {
    var callToAction = title;
    var buttonsHtml = buttons.map(function (button, index) {
        return (0, html_elements_1.createSanitizedElement)('button', ["beacon-modal__button".concat(button.style === 'outline' ? '--outline' : '')], [['id', "beacon-alert-".concat(id, "-").concat(index)]], button.text);
    });
    var allStyles = alert_templates_1.alertTemplates.default.css;
    if (hasPairingPayload) {
        allStyles += alert_templates_1.alertTemplates.pair.css;
    }
    var callToActionEl = (0, html_elements_1.createSanitizedElement)('span', [], [], callToAction);
    var alertEl = hasPairingPayload
        ? (0, templates_1.constructPairAlert)(id, [callToActionEl], buttonsHtml, [body])
        : (0, templates_1.constructDefaultAlert)(id, [callToActionEl], buttonsHtml, [body]);
    return {
        style: allStyles,
        html: alertEl
    };
};
/**
 * Close an alert by ID
 *
 * @param id ID of alert
 */
var closeAlert = function (id) {
    beacon_core_1.windowRef.postMessage("closeAlert-".concat(id));
    return new Promise(function (resolve) {
        var _a;
        var wrapper = document.getElementById("beacon-alert-wrapper-".concat(id));
        if (!wrapper) {
            return resolve();
        }
        var elm = (_a = wrapper.shadowRoot) === null || _a === void 0 ? void 0 : _a.getElementById("beacon-alert-modal-".concat(id));
        if (elm) {
            var animationDuration = 300;
            var localTimeout = timeout[id];
            if (localTimeout) {
                clearTimeout(localTimeout);
                timeout[id] = undefined;
            }
            elm.className = elm.className.replace('fadeIn', 'fadeOut');
            window.setTimeout(function () {
                var parent = wrapper.parentNode;
                if (parent) {
                    parent.removeChild(wrapper);
                }
                if (lastFocusedElement) {
                    ;
                    lastFocusedElement.focus(); // set focus back to last focussed element
                }
                resolve();
            }, animationDuration);
        }
        else {
            resolve();
        }
    });
};
exports.closeAlert = closeAlert;
/**
 * Close all alerts
 */
var closeAlerts = function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, new Promise(function (resolve) { return __awaiter(void 0, void 0, void 0, function () {
                var openAlertElements, alertIds_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            openAlertElements = document.querySelectorAll('[id^="beacon-alert-wrapper-"]');
                            if (!(openAlertElements.length > 0)) return [3 /*break*/, 2];
                            alertIds_1 = [];
                            openAlertElements.forEach(function (element) { return __awaiter(void 0, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    alertIds_1.push(element.id.split('-')[3]);
                                    return [2 /*return*/];
                                });
                            }); });
                            return [4 /*yield*/, Promise.all(alertIds_1.map(closeAlert))];
                        case 1:
                            _a.sent();
                            resolve();
                            return [3 /*break*/, 3];
                        case 2:
                            resolve();
                            _a.label = 3;
                        case 3: return [2 /*return*/];
                    }
                });
            }); })
            /**
             * Show an alert
             *
             * @param alertConfig The configuration of the alert
             */
            // eslint-disable-next-line complexity
        ];
    });
}); };
exports.closeAlerts = closeAlerts;
/**
 * Show an alert
 *
 * @param alertConfig The configuration of the alert
 */
// eslint-disable-next-line complexity
var openAlert = function (alertConfig) { return __awaiter(void 0, void 0, void 0, function () {
    var body, data, title, timer, pairingPayload, disclaimer, closeButtonCallback, id, shadowRootEl, shadowRoot, wrapper, buttons, formattedBody, _a, style, html, styleEl, closeButton, closeButtonClick, disclaimerContainer, colorMode, elm, modal;
    var _b, _c;
    return __generator(this, function (_d) {
        switch (_d.label) {
            case 0:
                body = alertConfig.body;
                data = alertConfig.data;
                title = alertConfig.title;
                timer = alertConfig.timer;
                pairingPayload = alertConfig.pairingPayload;
                disclaimer = alertConfig.disclaimerText;
                closeButtonCallback = alertConfig.closeButtonCallback;
                return [4 /*yield*/, closeAlerts()];
            case 1:
                _d.sent();
                return [4 /*yield*/, (0, beacon_utils_1.generateGUID)()];
            case 2:
                id = (_d.sent()).split('-').join('');
                shadowRootEl = document.createElement('div');
                shadowRootEl.setAttribute('id', "beacon-alert-wrapper-".concat(id));
                shadowRoot = shadowRootEl.attachShadow({ mode: 'open' });
                wrapper = document.createElement('div');
                wrapper.setAttribute('tabindex', "0"); // Make modal focussable
                shadowRoot.appendChild(wrapper);
                buttons = __spreadArray([], ((_c = (_b = alertConfig.buttons) === null || _b === void 0 ? void 0 : _b.map(function (button) {
                    var _a, _b;
                    return ({
                        text: button.text,
                        // eslint-disable-next-line @typescript-eslint/unbound-method
                        actionCallback: (_a = button.actionCallback) !== null && _a !== void 0 ? _a : (function () { return Promise.resolve(); }),
                        style: (_b = button.style) !== null && _b !== void 0 ? _b : 'outline'
                    });
                })) !== null && _c !== void 0 ? _c : []), true);
                formattedBody = pairingPayload
                    ? addQR(body)
                    : (0, html_elements_1.createSanitizedElement)('span', [], [], body !== null && body !== void 0 ? body : '');
                if (data) {
                    formattedBody = (0, html_elements_1.createSanitizedElement)('span', [], [], [formattedBody, (0, html_elements_1.createSanitizedElement)('pre', [], [['style', 'text-align: left']], data)]);
                }
                _a = formatAlert(id, formattedBody, title, buttons, !!(pairingPayload === null || pairingPayload === void 0 ? void 0 : pairingPayload.p2pSyncCode)), style = _a.style, html = _a.html;
                wrapper.appendChild(html);
                styleEl = document.createElement('style');
                styleEl.textContent = style;
                shadowRoot.appendChild(styleEl);
                if (timer) {
                    timeout[id] = window.setTimeout(function () { return __awaiter(void 0, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, closeAlert(id)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); }, timer);
                }
                document.body.prepend(shadowRootEl);
                closeButton = shadowRoot.getElementById("beacon-alert-".concat(id, "-close"));
                closeButtonClick = function () { return __awaiter(void 0, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (closeButtonCallback) {
                                    closeButtonCallback();
                                }
                                return [4 /*yield*/, closeAlert(id)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); };
                if (disclaimer) {
                    disclaimerContainer = shadowRoot.getElementById("beacon--disclaimer");
                    if (disclaimerContainer) {
                        disclaimerContainer.innerText = disclaimer;
                    }
                }
                colorMode = (0, colorMode_1.getColorMode)();
                elm = shadowRoot.getElementById("beacon-alert-modal-".concat(id));
                if (elm) {
                    elm.classList.add("theme__".concat(colorMode));
                    elm.addEventListener('click', closeButtonClick); // Backdrop click dismisses alert
                }
                modal = shadowRoot.querySelectorAll('.beacon-modal__wrapper');
                if (modal.length > 0) {
                    modal[0].addEventListener('click', function (event) {
                        event.stopPropagation();
                    });
                }
                lastFocusedElement = document.activeElement; // Store which element has been focussed before the alert is shown
                wrapper.focus(); // Focus alert for accessibility
                buttons.forEach(function (button, index) {
                    var buttonElement = shadowRoot.getElementById("beacon-alert-".concat(id, "-").concat(index));
                    if (buttonElement) {
                        buttonElement.addEventListener('click', function () { return __awaiter(void 0, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, closeAlert(id)];
                                    case 1:
                                        _a.sent();
                                        if (!button.actionCallback) return [3 /*break*/, 3];
                                        return [4 /*yield*/, button.actionCallback()];
                                    case 2:
                                        _a.sent();
                                        _a.label = 3;
                                    case 3: return [2 /*return*/];
                                }
                            });
                        }); });
                    }
                });
                if (closeButton) {
                    closeButton.addEventListener('click', function () { return __awaiter(void 0, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, closeButtonClick()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                }
                window.addEventListener('keydown', function (event) { return __awaiter(void 0, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!(event.key === 'Escape')) return [3 /*break*/, 2];
                                return [4 /*yield*/, closeButtonClick()];
                            case 1:
                                _a.sent();
                                _a.label = 2;
                            case 2: return [2 /*return*/];
                        }
                    });
                }); });
                if (!pairingPayload) return [3 /*break*/, 4];
                return [4 /*yield*/, (0, PairingAlert_1.preparePairingAlert)(id, shadowRoot, pairingPayload)];
            case 3:
                _d.sent();
                _d.label = 4;
            case 4: return [2 /*return*/, id];
        }
    });
}); };
exports.openAlert = openAlert;

},{"../../utils/colorMode":130,"../../utils/html-elements":132,"../../utils/templates":135,"./PairingAlert":125,"./alert-templates":126,"@airgap/beacon-core":58,"@airgap/beacon-utils":136}],124:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pairing = exports.WalletType = exports.Platform = exports.setiOSList = exports.getiOSList = exports.setWebList = exports.getWebList = exports.setExtensionList = exports.getExtensionList = exports.setDesktopList = exports.getDesktopList = void 0;
var beacon_core_1 = require("@airgap/beacon-core");
var beacon_types_1 = require("@airgap/beacon-types");
var beacon_core_2 = require("@airgap/beacon-core");
var get_tzip10_link_1 = require("../../utils/get-tzip10-link");
var platform_1 = require("../../utils/platform");
var beacon_transport_postmessage_1 = require("@airgap/beacon-transport-postmessage");
var wallet_lists_1 = require("./wallet-lists");
/**
 * Initialize with tezos wallets for backwards compatibility
 */
var localDesktopList = wallet_lists_1.desktopList;
var localExtensionList = wallet_lists_1.extensionList;
var localWebList = wallet_lists_1.webList;
var localiOSList = wallet_lists_1.iOSList;
var getDesktopList = function () {
    return localDesktopList;
};
exports.getDesktopList = getDesktopList;
var setDesktopList = function (desktopList) {
    localDesktopList = desktopList;
};
exports.setDesktopList = setDesktopList;
var getExtensionList = function () {
    return localExtensionList;
};
exports.getExtensionList = getExtensionList;
var setExtensionList = function (extensionList) {
    localExtensionList = extensionList;
};
exports.setExtensionList = setExtensionList;
var getWebList = function () {
    return localWebList;
};
exports.getWebList = getWebList;
var setWebList = function (webList) {
    localWebList = webList;
};
exports.setWebList = setWebList;
var getiOSList = function () {
    return localiOSList;
};
exports.getiOSList = getiOSList;
var setiOSList = function (iosList) {
    localiOSList = iosList;
};
exports.setiOSList = setiOSList;
var serializer = new beacon_core_1.Serializer();
var defaultExtensions = [
    'ookjlbkiijinhpmnjffcofjonbfbgaoc',
    'gpfndedineagiepkpinficbcbbgjoenn' // Spire
];
var Platform;
(function (Platform) {
    Platform[Platform["DESKTOP"] = 0] = "DESKTOP";
    Platform[Platform["IOS"] = 1] = "IOS";
    Platform[Platform["ANDROID"] = 2] = "ANDROID";
})(Platform = exports.Platform || (exports.Platform = {}));
var WalletType;
(function (WalletType) {
    WalletType["IOS"] = "ios";
    WalletType["ANDROID"] = "android";
    WalletType["EXTENSION"] = "extension";
    WalletType["DESKTOP"] = "desktop";
    WalletType["WEB"] = "web";
})(WalletType = exports.WalletType || (exports.WalletType = {}));
/**
 * @internalapi
 *
 */
var Pairing = /** @class */ (function () {
    function Pairing() {
    }
    Pairing.getPlatfrom = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, platform_1.isAndroid)(window) ? Platform.ANDROID : (0, platform_1.isIOS)(window) ? Platform.IOS : Platform.DESKTOP];
            });
        });
    };
    Pairing.getPairingInfo = function (pairingPayload, statusUpdateHandler, mobileWalletHandler, platform) {
        return __awaiter(this, void 0, void 0, function () {
            var activePlatform, _a, pairingCode, postmessageSyncCode, preferredNetwork;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(platform !== null && platform !== void 0)) return [3 /*break*/, 1];
                        _a = platform;
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, Pairing.getPlatfrom()];
                    case 2:
                        _a = (_b.sent());
                        _b.label = 3;
                    case 3:
                        activePlatform = _a;
                        pairingCode = pairingPayload.p2pSyncCode;
                        postmessageSyncCode = pairingPayload.postmessageSyncCode;
                        preferredNetwork = pairingPayload.preferredNetwork;
                        switch (activePlatform) {
                            case Platform.DESKTOP:
                                return [2 /*return*/, Pairing.getDesktopPairingAlert(pairingCode, statusUpdateHandler, postmessageSyncCode, mobileWalletHandler, preferredNetwork)];
                            case Platform.IOS:
                                return [2 /*return*/, Pairing.getIOSPairingAlert(pairingCode, statusUpdateHandler, preferredNetwork)];
                            case Platform.ANDROID:
                                return [2 /*return*/, Pairing.getAndroidPairingAlert(pairingCode, statusUpdateHandler, preferredNetwork)];
                            default:
                                throw new Error('platform unknown');
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    Pairing.getDesktopPairingAlert = function (pairingCode, statusUpdateHandler, postmessageSyncCode, mobileWalletHandler, network) {
        return __awaiter(this, void 0, void 0, function () {
            var availableExtensions, walletLists, _a, _b, _c;
            var _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0: return [4 /*yield*/, beacon_transport_postmessage_1.PostMessageTransport.getAvailableExtensions()];
                    case 1:
                        availableExtensions = _e.sent();
                        availableExtensions.forEach(function (ext) {
                            var index = defaultExtensions.indexOf(ext.id);
                            if (index >= 0) {
                                defaultExtensions.splice(index, 1);
                            }
                        });
                        walletLists = [];
                        if ((0, exports.getExtensionList)().length > 0) {
                            walletLists.push({
                                title: 'Browser Extensions',
                                type: WalletType.EXTENSION,
                                wallets: __spreadArray(__spreadArray([], availableExtensions.map(function (app) {
                                    var _a, _b, _c, _d, _e;
                                    var ext = (0, exports.getExtensionList)().find(function (extEl) { return extEl.id === app.id; });
                                    return {
                                        key: (_a = ext === null || ext === void 0 ? void 0 : ext.key) !== null && _a !== void 0 ? _a : app.id,
                                        name: (_b = app.name) !== null && _b !== void 0 ? _b : ext === null || ext === void 0 ? void 0 : ext.name,
                                        logo: (_c = app.iconUrl) !== null && _c !== void 0 ? _c : ext === null || ext === void 0 ? void 0 : ext.logo,
                                        shortName: (_d = app.shortName) !== null && _d !== void 0 ? _d : ext === null || ext === void 0 ? void 0 : ext.shortName,
                                        color: (_e = app.color) !== null && _e !== void 0 ? _e : ext === null || ext === void 0 ? void 0 : ext.color,
                                        enabled: true,
                                        clicked: false,
                                        clickHandler: function () {
                                            return __awaiter(this, void 0, void 0, function () {
                                                var postmessageCode, _a, _b, message;
                                                return __generator(this, function (_c) {
                                                    switch (_c.label) {
                                                        case 0:
                                                            if (this.clicked) {
                                                                return [2 /*return*/];
                                                            }
                                                            this.clicked = true;
                                                            if (!postmessageSyncCode) return [3 /*break*/, 3];
                                                            _b = (_a = serializer).serialize;
                                                            return [4 /*yield*/, postmessageSyncCode()];
                                                        case 1: return [4 /*yield*/, _b.apply(_a, [_c.sent()])];
                                                        case 2:
                                                            postmessageCode = _c.sent();
                                                            message = {
                                                                target: beacon_types_1.ExtensionMessageTarget.EXTENSION,
                                                                payload: postmessageCode,
                                                                targetId: app.id
                                                            };
                                                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                                            beacon_core_2.windowRef.postMessage(message, beacon_core_2.windowRef.location.origin);
                                                            _c.label = 3;
                                                        case 3:
                                                            statusUpdateHandler(WalletType.EXTENSION, this);
                                                            return [2 /*return*/];
                                                    }
                                                });
                                            });
                                        }
                                    };
                                }), true), (0, exports.getExtensionList)()
                                    .filter(function (app) { return defaultExtensions.some(function (extId) { return extId === app.id; }); })
                                    .map(function (app) { return ({
                                    key: app.key,
                                    name: app.name,
                                    shortName: app.shortName,
                                    color: app.color,
                                    logo: app.logo,
                                    enabled: false,
                                    clickHandler: function () {
                                        // Open wallet page
                                        window.open(app.link, '_blank');
                                    }
                                }); }), true).sort(function (a, b) { return a.key.localeCompare(b.key); })
                            });
                        }
                        if (!((0, exports.getDesktopList)().length > 0)) return [3 /*break*/, 3];
                        _b = (_a = walletLists).push;
                        _d = {
                            title: 'Desktop & Web Wallets',
                            type: WalletType.DESKTOP
                        };
                        _c = [__spreadArray([], (0, exports.getDesktopList)().map(function (app) { return ({
                                key: app.key,
                                name: app.name,
                                shortName: app.shortName,
                                color: app.color,
                                logo: app.logo,
                                enabled: true,
                                clicked: false,
                                clickHandler: function () {
                                    return __awaiter(this, void 0, void 0, function () {
                                        var code, _a, _b, link;
                                        return __generator(this, function (_c) {
                                            switch (_c.label) {
                                                case 0:
                                                    if (this.clicked) {
                                                        return [2 /*return*/];
                                                    }
                                                    this.clicked = true;
                                                    _b = (_a = serializer).serialize;
                                                    return [4 /*yield*/, pairingCode()];
                                                case 1: return [4 /*yield*/, _b.apply(_a, [_c.sent()])];
                                                case 2:
                                                    code = _c.sent();
                                                    link = (0, get_tzip10_link_1.getTzip10Link)(app.deepLink, code);
                                                    window.open(link, '_blank');
                                                    statusUpdateHandler(WalletType.DESKTOP, this, true);
                                                    return [2 /*return*/];
                                            }
                                        });
                                    });
                                }
                            }); }), true)];
                        return [4 /*yield*/, Pairing.getWebList(pairingCode, statusUpdateHandler, network)];
                    case 2:
                        _b.apply(_a, [(_d.wallets = __spreadArray.apply(void 0, _c.concat([(_e.sent()), true])).sort(function (a, b) { return a.key.localeCompare(b.key); }),
                                _d)]);
                        _e.label = 3;
                    case 3:
                        if ((0, exports.getiOSList)().length > 0) {
                            walletLists.push({
                                title: 'Mobile Wallets',
                                type: WalletType.IOS,
                                wallets: __spreadArray([], (0, exports.getiOSList)().map(function (app) { return ({
                                    key: app.key,
                                    name: app.name,
                                    shortName: app.shortName,
                                    color: app.color,
                                    logo: app.logo,
                                    enabled: true,
                                    clicked: false,
                                    clickHandler: function () {
                                        return __awaiter(this, void 0, void 0, function () {
                                            var code, _a, _b;
                                            return __generator(this, function (_c) {
                                                switch (_c.label) {
                                                    case 0:
                                                        if (this.clicked) {
                                                            return [2 /*return*/];
                                                        }
                                                        this.clicked = true;
                                                        _b = (_a = serializer).serialize;
                                                        return [4 /*yield*/, pairingCode()];
                                                    case 1: return [4 /*yield*/, _b.apply(_a, [_c.sent()])];
                                                    case 2:
                                                        code = _c.sent();
                                                        mobileWalletHandler(code);
                                                        statusUpdateHandler(WalletType.IOS, this, true);
                                                        return [2 /*return*/];
                                                }
                                            });
                                        });
                                    }
                                }); }), true).sort(function (a, b) { return a.key.localeCompare(b.key); })
                            });
                        }
                        return [2 /*return*/, {
                                walletLists: walletLists,
                                buttons: []
                            }];
                }
            });
        });
    };
    Pairing.getIOSPairingAlert = function (pairingCode, statusUpdateHandler, network) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            var _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _c = {};
                        _a = [{
                                title: 'Mobile Wallets',
                                type: WalletType.IOS,
                                wallets: (0, exports.getiOSList)()
                                    .map(function (app) { return ({
                                    key: app.key,
                                    name: app.name,
                                    shortName: app.shortName,
                                    color: app.color,
                                    logo: app.logo,
                                    enabled: true,
                                    clicked: false,
                                    clickHandler: function () {
                                        var _a;
                                        return __awaiter(this, void 0, void 0, function () {
                                            var code, _b, _c, link, a;
                                            return __generator(this, function (_d) {
                                                switch (_d.label) {
                                                    case 0:
                                                        if (this.clicked) {
                                                            return [2 /*return*/];
                                                        }
                                                        this.clicked = true;
                                                        _c = (_b = serializer).serialize;
                                                        return [4 /*yield*/, pairingCode()];
                                                    case 1: return [4 /*yield*/, _c.apply(_b, [_d.sent()])];
                                                    case 2:
                                                        code = _d.sent();
                                                        link = (0, get_tzip10_link_1.getTzip10Link)((_a = app.deepLink) !== null && _a !== void 0 ? _a : app.universalLink, code);
                                                        a = document.createElement('a');
                                                        a.setAttribute('href', link);
                                                        a.dispatchEvent(new MouseEvent('click', { view: window, bubbles: true, cancelable: true }));
                                                        statusUpdateHandler(WalletType.IOS, this, true);
                                                        return [2 /*return*/];
                                                }
                                            });
                                        });
                                    }
                                }); })
                                    .sort(function (a, b) { return a.key.localeCompare(b.key); })
                            }];
                        _d = {
                            title: 'Web Wallets',
                            type: WalletType.WEB
                        };
                        _b = [[]];
                        return [4 /*yield*/, Pairing.getWebList(pairingCode, statusUpdateHandler, network)];
                    case 1: return [2 /*return*/, (_c.walletLists = _a.concat([
                            (_d.wallets = __spreadArray.apply(void 0, _b.concat([(_e.sent()), true])).sort(function (a, b) { return a.key.localeCompare(b.key); }),
                                _d)
                        ]),
                            _c.buttons = [],
                            _c)];
                }
            });
        });
    };
    Pairing.getAndroidPairingAlert = function (pairingCode, statusUpdateHandler, network) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            var _b, _c;
            var _this = this;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _b = {};
                        _c = {
                            title: 'Web Wallets',
                            type: WalletType.WEB
                        };
                        _a = [[]];
                        return [4 /*yield*/, Pairing.getWebList(pairingCode, statusUpdateHandler, network)];
                    case 1: return [2 /*return*/, (_b.walletLists = [
                            (_c.wallets = __spreadArray.apply(void 0, _a.concat([(_d.sent()), true])).sort(function (a, b) { return a.key.localeCompare(b.key); }),
                                _c)
                        ],
                            _b.buttons = [
                                {
                                    title: 'Mobile Wallets',
                                    text: 'Connect Wallet',
                                    clickHandler: function () { return __awaiter(_this, void 0, void 0, function () {
                                        var code, _a, _b, qrLink;
                                        return __generator(this, function (_c) {
                                            switch (_c.label) {
                                                case 0:
                                                    _b = (_a = serializer).serialize;
                                                    return [4 /*yield*/, pairingCode()];
                                                case 1: return [4 /*yield*/, _b.apply(_a, [_c.sent()])];
                                                case 2:
                                                    code = _c.sent();
                                                    qrLink = (0, get_tzip10_link_1.getTzip10Link)('tezos://', code);
                                                    window.open(qrLink, '_blank');
                                                    statusUpdateHandler(WalletType.ANDROID);
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); }
                                }
                            ],
                            _b)];
                }
            });
        });
    };
    Pairing.getWebList = function (pairingCode, statusUpdateHandler, network) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, exports.getWebList)()
                        .map(function (app) { return ({
                        key: app.key,
                        name: app.name,
                        shortName: app.shortName,
                        color: app.color,
                        logo: app.logo,
                        enabled: true,
                        clicked: false,
                        clickHandler: function () {
                            var _this = this;
                            if (this.clicked) {
                                return;
                            }
                            this.clicked = true;
                            var newTab = window.open('', '_blank');
                            pairingCode()
                                .then(function (code) { return serializer.serialize(code); })
                                .then(function (code) {
                                var _a;
                                var link = (0, get_tzip10_link_1.getTzip10Link)((_a = app.links[network]) !== null && _a !== void 0 ? _a : app.links[beacon_types_1.NetworkType.MAINNET], code);
                                if (newTab) {
                                    newTab.location.href = link;
                                }
                                else {
                                    window.open(link, '_blank');
                                }
                                statusUpdateHandler(WalletType.WEB, _this, true);
                            })
                                .catch(function (error) {
                                // eslint-disable-next-line no-console
                                console.error(error);
                            });
                        }
                    }); })
                        .sort(function (a, b) { return a.key.localeCompare(b.key); })];
            });
        });
    };
    return Pairing;
}());
exports.Pairing = Pairing;

},{"../../utils/get-tzip10-link":131,"../../utils/platform":133,"./wallet-lists":127,"@airgap/beacon-core":58,"@airgap/beacon-transport-postmessage":103,"@airgap/beacon-types":104}],125:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.preparePairingAlert = void 0;
var beacon_core_1 = require("@airgap/beacon-core");
var beacon_utils_1 = require("@airgap/beacon-utils");
var platform_1 = require("../../utils/platform");
var qr_1 = require("../../utils/qr");
var get_tzip10_link_1 = require("../../utils/get-tzip10-link");
var Alert_1 = require("./Alert");
var Pairing_1 = require("./Pairing");
var html_elements_1 = require("../../utils/html-elements");
var logger = new beacon_core_1.Logger('Alert');
var serializer = new beacon_core_1.Serializer();
var preparePairingAlert = function (id, shadowRoot, pairingPayload) { return __awaiter(void 0, void 0, void 0, function () {
    var getInfo, info, container, buttonListWrapper, showWallet, listContainer, showWalletLists, messageFn, closeFn, qr, copyButton, titleEl, platform, mainText, walletList, switchButton, clipboardFn, qrShown, showPlatform, showQr, switchPlatform, platformSwitch;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                getInfo = function () { return __awaiter(void 0, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        return [2 /*return*/, Pairing_1.Pairing.getPairingInfo(pairingPayload, function (_walletType, _wallet, keepOpen) { return __awaiter(void 0, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            if (keepOpen) {
                                                return [2 /*return*/];
                                            }
                                            return [4 /*yield*/, (0, Alert_1.closeAlerts)()];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }); }, function () { return __awaiter(void 0, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switchPlatform();
                                    return [2 /*return*/];
                                });
                            }); })];
                    });
                }); };
                return [4 /*yield*/, getInfo()];
            case 1:
                info = _a.sent();
                container = shadowRoot.getElementById("pairing-container");
                if (!container) {
                    throw new Error('container not found');
                }
                buttonListWrapper = document.createElement('span');
                container.appendChild(buttonListWrapper);
                info.buttons.forEach(function (button) { return __awaiter(void 0, void 0, void 0, function () {
                    var randomId, titleEl, buttonEl, linkEl, shadowButtonEl;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, (0, beacon_utils_1.generateGUID)()];
                            case 1:
                                randomId = _a.sent();
                                titleEl = (0, html_elements_1.createSanitizedElement)('div', ['beacon-list__title'], [], button.title);
                                buttonEl = (0, html_elements_1.createSanitizedElement)('button', ['beacon-modal__button', 'connect__btn'], [], button.text);
                                linkEl = document.createElement('a');
                                linkEl.id = "button_".concat(randomId);
                                linkEl.appendChild(titleEl);
                                linkEl.appendChild(buttonEl);
                                buttonListWrapper.appendChild(linkEl);
                                shadowButtonEl = shadowRoot.getElementById(linkEl.id);
                                if (shadowButtonEl) {
                                    shadowButtonEl.addEventListener('click', function () { return __awaiter(void 0, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            button.clickHandler();
                                            return [2 /*return*/];
                                        });
                                    }); });
                                }
                                return [2 /*return*/];
                        }
                    });
                }); });
                showWallet = function (listEl, type, wallet) {
                    var altTag = "Open in ".concat(wallet.name);
                    var walletKey = wallet.key;
                    var logoEl = wallet.logo
                        ? (0, html_elements_1.createSanitizedElement)('div', [], [], [(0, html_elements_1.createSanitizedElement)('img', ['beacon-selection__img'], [['src', wallet.logo]], '')])
                        : (0, html_elements_1.createSVGElement)(['beacon-selection__img', 'svg-inline--fa', 'fa-wallet', 'fa-w-16'], [
                            ['aria-hidden', 'true'],
                            ['focusable', 'false'],
                            ['data-prefix', 'fas'],
                            ['data-icon', 'wallet'],
                            ['role', 'img'],
                            ['xmlns', 'http://www.w3.org/2000/svg'],
                            ['viewBox', '0 0 512 512'],
                            ['style', 'enable-background:new 0 0 512 512;'],
                            ['xml:space', 'preserve']
                        ], [
                            (0, html_elements_1.createSVGPathElement)([
                                [
                                    'd',
                                    'M376.2,181H152.9c-5.2,0-9.4-4.2-9.4-9.4s4.2-9.4,9.4-9.4h225c5.2,0,9.4-4.2,9.4-9.4c0-15.5-12.6-28.1-28.1-28.1H143.5c-20.7,0-37.5,16.8-37.5,37.5v187.5c0,20.7,16.8,37.5,37.5,37.5h232.7c16.4,0,29.8-12.6,29.8-28.1v-150C406,193.6,392.7,181,376.2,181z M349.8,302.9c-10.4,0-18.8-8.4-18.8-18.8s8.4-18.8,18.8-18.8s18.8,8.4,18.8,18.8S360.1,302.9,349.8,302.9z'
                                ]
                            ])
                        ]);
                    var nameEl = (0, html_elements_1.createSanitizedElement)('div', ['beacon-selection__name'], [], [
                        (0, html_elements_1.createSanitizedElement)('span', [], [], wallet.name),
                        wallet.enabled ? undefined : (0, html_elements_1.createSanitizedElement)('p', [], [], 'Not installed')
                    ]);
                    var linkEl = (0, html_elements_1.createSanitizedElement)('a', ['beacon-selection__list', wallet.enabled ? '' : 'disabled'], [
                        ['tabindex', '0'],
                        ['id', "wallet_".concat(walletKey)],
                        ['alt', altTag],
                        ['target', '_blank']
                    ], [nameEl, logoEl]);
                    var el = document.createElement('span');
                    el.appendChild(linkEl);
                    listEl.appendChild(el);
                    var walletEl = shadowRoot.getElementById("wallet_".concat(walletKey));
                    var completeHandler = function (event) { return __awaiter(void 0, void 0, void 0, function () {
                        var modalEl;
                        return __generator(this, function (_a) {
                            if (event && event.key !== 'Enter') {
                                return [2 /*return*/];
                            }
                            wallet.clickHandler();
                            modalEl = shadowRoot.getElementById('beacon-modal__content');
                            if (modalEl && type !== Pairing_1.WalletType.EXTENSION && type !== Pairing_1.WalletType.IOS) {
                                (0, html_elements_1.removeAllChildren)(modalEl);
                                modalEl.appendChild((0, html_elements_1.createSanitizedElement)('p', ['beacon-alert__title'], [], 'Establishing Connection..'));
                                modalEl.appendChild((0, html_elements_1.createSanitizedElement)('div', ['progress-line'], [['id', 'beacon-toast-loader']], ''));
                                modalEl.appendChild((0, html_elements_1.createSanitizedElement)('div', ['beacon--selected__container'], [], __spreadArray([], (wallet.logo
                                    ? [
                                        (0, html_elements_1.createSanitizedElement)('img', ['beacon-selection__img'], [['src', wallet.logo]], ''),
                                        (0, html_elements_1.createSanitizedElement)('img', ['beacon--selection__name__lg'], [], wallet.name)
                                    ]
                                    : []), true)));
                            }
                            return [2 /*return*/];
                        });
                    }); };
                    if (walletEl) {
                        walletEl.addEventListener('click', function () { return completeHandler(); });
                        walletEl.addEventListener('keydown', completeHandler);
                    }
                };
                listContainer = document.createElement('span');
                container.appendChild(listContainer);
                showWalletLists = function (walletLists) {
                    (0, html_elements_1.removeAllChildren)(listContainer);
                    walletLists.forEach(function (list) {
                        var listWrapperEl = document.createElement('div');
                        listWrapperEl.classList.add('beacon-list__wrapper');
                        listContainer.appendChild(listWrapperEl);
                        listWrapperEl.appendChild((0, html_elements_1.createSanitizedElement)('div', ['beacon-list__title'], [], list.title));
                        var listEl = document.createElement('span');
                        listWrapperEl.appendChild(listEl);
                        list.wallets.forEach(function (wallet) { return __awaiter(void 0, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                showWallet(listEl, list.type, wallet);
                                return [2 /*return*/];
                            });
                        }); });
                    });
                };
                showWalletLists(info.walletLists);
                messageFn = function (event) { return __awaiter(void 0, void 0, void 0, function () {
                    var newInfo;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!(event.data === 'extensionsUpdated')) return [3 /*break*/, 2];
                                return [4 /*yield*/, getInfo()];
                            case 1:
                                newInfo = _a.sent();
                                showWalletLists(newInfo.walletLists);
                                _a.label = 2;
                            case 2: return [2 /*return*/];
                        }
                    });
                }); };
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                closeFn = function (event) {
                    if (event.data === "closeAlert-".concat(id)) {
                        beacon_core_1.windowRef.removeEventListener('message', messageFn);
                        beacon_core_1.windowRef.removeEventListener('message', closeFn);
                    }
                };
                beacon_core_1.windowRef.addEventListener('message', messageFn);
                beacon_core_1.windowRef.addEventListener('message', closeFn);
                qr = shadowRoot.getElementById("beacon--qr__container");
                copyButton = shadowRoot.getElementById("beacon--qr__copy");
                titleEl = shadowRoot.getElementById("beacon-title");
                platform = (0, platform_1.isAndroid)(window) ? 'android' : (0, platform_1.isIOS)(window) ? 'ios' : 'desktop';
                mainText = shadowRoot.getElementById("beacon-main-text");
                walletList = shadowRoot.getElementById("pairing-container");
                switchButton = shadowRoot.getElementById("beacon--switch__container");
                clipboardFn = function () { return __awaiter(void 0, void 0, void 0, function () {
                    var code, _a, _b, _c;
                    return __generator(this, function (_d) {
                        switch (_d.label) {
                            case 0:
                                if (!pairingPayload) return [3 /*break*/, 3];
                                _c = (_b = serializer).serialize;
                                return [4 /*yield*/, pairingPayload.p2pSyncCode()];
                            case 1: return [4 /*yield*/, _c.apply(_b, [_d.sent()])];
                            case 2:
                                _a = _d.sent();
                                return [3 /*break*/, 4];
                            case 3:
                                _a = '';
                                _d.label = 4;
                            case 4:
                                code = _a;
                                navigator.clipboard.writeText(code).then(function () {
                                    if (copyButton) {
                                        copyButton.innerText = 'Copied';
                                    }
                                    logger.log('Copying to clipboard was successful!');
                                }, function (err) {
                                    logger.error('Could not copy text to clipboard: ', err);
                                });
                                return [2 /*return*/];
                        }
                    });
                }); };
                qrShown = false;
                showPlatform = function (type) { return __awaiter(void 0, void 0, void 0, function () {
                    var platformSwitch, _a, code, _b, _c, uri, qrSVG, qrString;
                    return __generator(this, function (_d) {
                        switch (_d.label) {
                            case 0:
                                platformSwitch = shadowRoot.getElementById("beacon-switch");
                                if (platformSwitch) {
                                    platformSwitch.innerText =
                                        type === 'none' ? 'Pair wallet on same device' : 'Pair wallet on another device';
                                }
                                if (!(mainText && walletList && switchButton && copyButton && qr && titleEl)) return [3 /*break*/, 8];
                                mainText.style.display = 'none';
                                titleEl.style.textAlign = 'center';
                                walletList.style.display = 'none';
                                switchButton.style.display = 'initial';
                                _a = type;
                                switch (_a) {
                                    case 'ios': return [3 /*break*/, 1];
                                    case 'android': return [3 /*break*/, 2];
                                    case 'desktop': return [3 /*break*/, 3];
                                }
                                return [3 /*break*/, 4];
                            case 1:
                                walletList.style.display = 'initial';
                                return [3 /*break*/, 8];
                            case 2:
                                walletList.style.display = 'initial';
                                return [3 /*break*/, 8];
                            case 3:
                                walletList.style.display = 'initial';
                                titleEl.style.textAlign = 'left';
                                mainText.style.display = 'none';
                                switchButton.style.display = 'initial';
                                return [3 /*break*/, 8];
                            case 4:
                                if (!!qrShown) return [3 /*break*/, 7];
                                // If we have previously triggered the load, do not load it again (this can lead to multiple QRs being added if "pairingPayload.p2pSyncCode()" is slow)
                                qrShown = true;
                                _c = (_b = serializer).serialize;
                                return [4 /*yield*/, pairingPayload.p2pSyncCode()];
                            case 5: return [4 /*yield*/, _c.apply(_b, [_d.sent()])];
                            case 6:
                                code = _d.sent();
                                uri = (0, get_tzip10_link_1.getTzip10Link)('tezos://', code);
                                qrSVG = (0, qr_1.getQrData)(uri, 'svg');
                                qrString = qrSVG.replace('<svg', "<svg class=\"beacon-alert__image\"");
                                qr.insertAdjacentHTML('afterbegin', qrString);
                                if (copyButton) {
                                    copyButton.addEventListener('click', clipboardFn);
                                }
                                if (qr) {
                                    qr.addEventListener('click', clipboardFn);
                                }
                                _d.label = 7;
                            case 7:
                                // QR code
                                mainText.style.display = 'initial';
                                _d.label = 8;
                            case 8: return [2 /*return*/];
                        }
                    });
                }); };
                showQr = false;
                switchPlatform = function () {
                    showPlatform(showQr ? 'none' : platform);
                    showQr = !showQr;
                };
                switchPlatform();
                {
                    platformSwitch = shadowRoot.getElementById("beacon-switch");
                    if (platformSwitch) {
                        platformSwitch.addEventListener('click', switchPlatform);
                    }
                }
                return [2 /*return*/];
        }
    });
}); };
exports.preparePairingAlert = preparePairingAlert;

},{"../../utils/get-tzip10-link":131,"../../utils/html-elements":132,"../../utils/platform":133,"../../utils/qr":134,"./Alert":123,"./Pairing":124,"@airgap/beacon-core":58,"@airgap/beacon-utils":136}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.alertTemplates = void 0;
exports.alertTemplates = { "default": { "css": ":host {\n  --animation-duration: 300ms;\n  all: initial;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.animated {\n  animation-duration: var(--animation-duration);\n  animation-fill-mode: both;\n}\n\n.fadeIn {\n  animation-name: fadeIn;\n}\n\n.fadeOut {\n  animation-name: fadeOut;\n}\n\n.beacon-modal__wrapper {\n  position: relative;\n  top: 0;\n  display: inline-block;\n  z-index: 2147483000;\n  max-width: 500px;\n  width: 80%;\n  padding: 24px;\n}\n\n.theme__light .beacon-modal__base,\n.theme__light .beacon-modal__close__wrapper {\n  background: #fff;\n}\n\n.theme__dark .beacon-modal__base,\n.theme__dark .beacon-modal__close__wrapper {\n  background: #27334c;\n}\n\n.beacon-modal__base,\n.beacon-modal__close__wrapper {\n  box-shadow: 0 12px 24px 0 rgba(0, 0, 0, 0.1);\n}\n\n.beacon-modal__base {\n  margin: 0 auto;\n  border-radius: 32px;\n  overflow: hidden;\n}\n\n.beacon-modal__header {\n  padding: 16px 0;\n  width: 100%;\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.beacon-modal__headerLogo {\n  width: 100%;\n  max-width: 320px;\n  margin: 20px auto;\n  height: 100%;\n}\n\na,\nbutton {\n  cursor: pointer;\n}\n\n.beacon-modal__close__wrapper {\n  position: absolute;\n  top: 44px;\n  right: 24px;\n  z-index: 10000;\n  cursor: pointer;\n  border-radius: 100%;\n}\n\n.beacon-modal__close__icon {\n  width: 16px;\n  height: 16px;\n  position: relative;\n  top: 0;\n  right: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transform: rotate(45deg);\n  margin: 8px;\n}\n\n.beacon-modal__close__line1 {\n  position: absolute;\n  width: 90%;\n}\n\n.beacon-modal__close__line2 {\n  position: absolute;\n  width: 90%;\n  transform: rotate(90deg);\n}\n\n.theme__light .beacon-modal__close__line2,\n.theme__light .beacon-modal__close__line1 {\n  border: 1px solid #000;\n}\n\n.theme__dark .beacon-modal__close__line2,\n.theme__dark .beacon-modal__close__line1 {\n  border: 1px solid #fff;\n}\n\n.beacon-alert__base {\n  position: fixed;\n  overflow-y: scroll;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 2147482999;\n  background-color: rgb(17 17 17 / 0.84);\n  text-align: center;\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n  font-family: Roboto, Helvetica, sans-serif;\n}\n\n.beacon-alert__base::-webkit-scrollbar {\n  display: none;\n}\n\n.beacon-alert__title {\n  text-align: center;\n}\n\n.beacon-alert__text,\n.beacon-alert__title {\n  margin: 0 auto;\n  padding: 0 0 24px;\n}\n\n.margin__bottom {\n  margin-bottom: 16px;\n}\n\n.beacon-alert__title {\n  font-size: 18px;\n}\n\n.theme__light .beacon-alert__title {\n  color: #3b3d40;\n}\n\n.theme__dark .beacon-alert__title,\n.theme__dark .beacon-alert__text {\n  color: #7c99d6;\n}\n\n.beacon-alert__text {\n  color: #000;\n  font-size: 14px;\n}\n\n.beacon-modal__button,\n.beacon-modal__button--outline {\n  height: 36px;\n  font-size: 14px;\n  letter-spacing: 0.84px;\n  margin-bottom: 4px;\n  margin-inline-end: 2px;\n  margin-inline-start: 2px;\n  margin-left: 2px;\n  margin-right: 2px;\n  margin-top: 4px;\n  padding-inline-end: 15.4px;\n  padding-inline-start: 15.4px;\n  padding-left: 15.4px;\n  padding-right: 15.4px;\n  overflow-wrap: break-word;\n  pointer-events: auto;\n  text-align: center;\n  border-radius: 4px;\n  border: 2px solid #3880ff;\n}\n\n.beacon-modal__button {\n  background: #3880ff;\n  color: #fff;\n}\n\n.beacon-modal__button--outline {\n  background: #fff;\n  color: #444444;\n  border: 1px solid #444444;\n}\n\n.beacon-alert__image {\n  width: 200px;\n  height: 200px;\n  box-sizing: border-box;\n  box-shadow: 0 10px 20px 0 rgba(17, 17, 17, 0.12);\n  border: 1px solid rgba(17, 17, 17, 0.04);\n  border-radius: 16px;\n}\n.connect__btn {\n  margin: 24px 0;\n  width: 100%;\n}\n\n#beacon-modal__content {\n  padding: 24px;\n}\n\n#beacon-switch {\n  margin-top: 24px;\n}\n\n#beacon-title {\n  margin: 0 0 24px;\n}\n\na {\n  text-decoration: none;\n}\n\npre {\n  white-space: pre-wrap; /* css-3 */\n  white-space: -moz-pre-wrap; /* Mozilla, since 1999 */\n  white-space: -pre-wrap; /* Opera 4-6 */\n  white-space: -o-pre-wrap; /* Opera 7 */\n  word-wrap: break-word; /* Internet Explorer 5.5+ */\n  padding: 16px;\n  background: #ececec;\n  line-height: 1.25rem;\n}\n" }, "pair": { "css": "#beacon-main-text {\n  display: initial;\n}\n.beacon-selection__container {\n  padding: 16px 16px 0;\n}\n.beacon-selection__list {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  text-decoration: none;\n  padding-bottom: 12px;\n  align-items: center;\n}\n.beacon-list__title {\n  text-align: left;\n  font-size: 12px;\n}\n.beacon-list__wrapper:nth-child(-n + 3) {\n  padding: 0 0 1rem;\n}\n.theme__light .beacon-list__title {\n  color: #7c828b;\n}\n.theme__dark .beacon-list__title,\n.theme__dark #beacon--disclaimer {\n  color: #7c99d6;\n}\n\n.beacon-selection__name {\n  font-size: 1rem;\n  font-weight: 600;\n  text-align: left;\n}\n.theme__light .beacon-selection__name,\n.theme__light .beacon--selection__name__lg {\n  color: #3b3d40;\n}\n.theme__dark .beacon-selection__name,\n.theme__dark .beacon--selection__name__lg {\n  color: #6183ff;\n}\n.beacon-selection__img {\n  width: 48px;\n  height: 48px;\n  box-shadow: 0 4px 12px 0 rgba(17, 17, 17, 0.24);\n  border-radius: 16px;\n  background-color: #fff;\n}\n.beacon--selection__name__lg {\n  font-size: 1.5rem;\n  font-weight: 600;\n  text-align: center;\n  padding: 1rem 0;\n}\n.beacon--selected__container {\n  padding: 2rem 0 0;\n}\n#beacon--qr__copy__container {\n  height: 0;\n}\n#beacon--qr__copy {\n  display: none;\n  position: relative;\n  margin-top: auto;\n  margin-left: auto;\n  margin-right: auto;\n}\n#beacon--qr__container {\n  margin-left: auto;\n  margin-right: auto;\n}\n#beacon--qr__container:hover #beacon--qr__copy {\n  display: block;\n}\n\n.disabled p {\n  text-align: left;\n  margin: 0;\n  font-size: 10px;\n  font-weight: 300;\n  opacity: 0.48;\n}\n\n#beacon--disclaimer {\n  text-align: left;\n  padding-top: 24px;\n  font-size: 0.875rem;\n}\n.progress-line,\n.progress-line:before {\n  height: 3px;\n  width: -webkit-fill-available;\n  margin-left: -24px;\n  margin-right: -24px;\n}\n.progress-line {\n  background-color: #a7c4f7;\n  display: -webkit-flex;\n  display: flex;\n}\n.progress-line:before {\n  background-color: #3880ff;\n  content: '';\n  -webkit-animation: running-progress 2s cubic-bezier(0.4, 0, 0.2, 1) infinite;\n  animation: running-progress 2s cubic-bezier(0.4, 0, 0.2, 1) infinite;\n}\n@-webkit-keyframes running-progress {\n  0% {\n    margin-left: 0px;\n    margin-right: 100%;\n  }\n  50% {\n    margin-left: 25%;\n    margin-right: 0%;\n  }\n  100% {\n    margin-left: 100%;\n    margin-right: 0;\n  }\n}\n@keyframes running-progress {\n  0% {\n    margin-left: 0px;\n    margin-right: 100%;\n  }\n  50% {\n    margin-left: 25%;\n    margin-right: 0%;\n  }\n  100% {\n    margin-left: 100%;\n    margin-right: 0;\n  }\n}\n" } };

},{}],127:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39}],128:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.openToast = exports.closeToast = void 0;
var beacon_utils_1 = require("@airgap/beacon-utils");
var toast_templates_1 = require("./toast-templates");
var colorMode_1 = require("../../utils/colorMode");
var html_elements_1 = require("../../utils/html-elements");
var templates_1 = require("../../utils/templates");
var document;
if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {
    document = window.document;
}
var EXPAND_AFTER = 5 * 1000;
var timeout;
var expandTimeout;
var globalToastConfig;
var createActionItem = function (toastAction) { return __awaiter(void 0, void 0, void 0, function () {
    var text, isBold, actionText, actionLogo, actionCallback, id, wrapper, wrapBold, textEl, textEl, textEl;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                text = toastAction.text, isBold = toastAction.isBold, actionText = toastAction.actionText, actionLogo = toastAction.actionLogo, actionCallback = toastAction.actionCallback;
                return [4 /*yield*/, (0, beacon_utils_1.generateGUID)()];
            case 1:
                id = _a.sent();
                wrapper = document.createElement('div');
                wrapper.classList.add('beacon-toast__action__item');
                removeAllChildNodes(wrapper);
                wrapBold = function (element) {
                    return (0, html_elements_1.createSanitizedElement)('strong', [], [], element);
                };
                if (actionCallback) {
                    if (text.length > 0) {
                        wrapper.appendChild((0, html_elements_1.createSanitizedElement)('p', [], [], text));
                    }
                    textEl = (0, html_elements_1.createSanitizedElement)('span', [], [], [
                        (0, html_elements_1.createSanitizedElement)('span', [], [], actionText),
                        actionLogo && actionLogo === 'external' ? (0, html_elements_1.createIconSVGExternal)() : undefined
                    ]);
                    wrapper.appendChild((0, html_elements_1.createSanitizedElement)('p', [], [], [(0, html_elements_1.createSanitizedElement)('a', [], [['id', id]], [isBold ? wrapBold([textEl]) : textEl])]));
                }
                else if (actionText) {
                    if (text.length > 0) {
                        wrapper.appendChild((0, html_elements_1.createSanitizedElement)('p', ['beacon-toast__action__item__subtitle'], [], text));
                    }
                    textEl = (0, html_elements_1.createSanitizedElement)('span', [], [], actionText);
                    wrapper.appendChild((0, html_elements_1.createSanitizedElement)('p', [], [], [isBold ? wrapBold([textEl]) : textEl]));
                }
                else {
                    textEl = (0, html_elements_1.createSanitizedElement)('p', [], [], text);
                    wrapper.appendChild(isBold ? wrapBold([textEl]) : textEl);
                }
                if (actionCallback) {
                    wrapper.addEventListener('click', actionCallback);
                }
                return [2 /*return*/, wrapper];
        }
    });
}); };
var removeAllChildNodes = function (parent) {
    while (parent.firstChild) {
        parent.removeChild(parent.firstChild);
    }
};
var formatToastText = function (html) {
    var _a, _b;
    var walletIcon = (_a = globalToastConfig === null || globalToastConfig === void 0 ? void 0 : globalToastConfig.walletInfo) === null || _a === void 0 ? void 0 : _a.icon;
    var walletName = (_b = globalToastConfig === null || globalToastConfig === void 0 ? void 0 : globalToastConfig.walletInfo) === null || _b === void 0 ? void 0 : _b.name;
    var walletEl;
    var walletNameEl = (0, html_elements_1.createSanitizedElement)('strong', [], [], walletName !== null && walletName !== void 0 ? walletName : 'Wallet');
    if (walletIcon) {
        walletEl = (0, html_elements_1.createSanitizedElement)('span', ['beacon-toast__wallet__container'], [], [
            (0, html_elements_1.createSanitizedElement)('img', ['beacon-toast__content__img'], [['src', walletIcon]], ''),
            walletNameEl
        ]);
    }
    else {
        walletEl = walletNameEl;
    }
    var splits = html.split("{{wallet}}");
    if (splits.length === 1) {
        return [(0, html_elements_1.createSanitizedElement)('span', [], [], html)];
    }
    else {
        var out = [];
        for (var x = 0; x < splits.length; x++) {
            out.push((0, html_elements_1.createSanitizedElement)('span', [], [], splits[x]));
            if (x < splits.length - 1) {
                out.push(walletEl);
            }
        }
        return out;
    }
};
var getToastHTML = function (config) {
    var text = config.body;
    var elements = formatToastText(text);
    var outerEl = (0, html_elements_1.createSanitizedElement)('span', ['beacon-toast__wallet__outer'], [], elements);
    var toastContainerEl = (0, templates_1.constructToastContainer)([outerEl]);
    return {
        style: toast_templates_1.toastTemplates.default.css,
        html: toastContainerEl
    };
};
/**
 * Close a toast
 */
var closeToast = function () {
    return new Promise(function (resolve) {
        var _a;
        globalToastConfig = undefined;
        var wrapper = document.getElementById('beacon-toast-wrapper');
        if (!wrapper) {
            return resolve();
        }
        var elm = (_a = wrapper.shadowRoot) === null || _a === void 0 ? void 0 : _a.getElementById('beacon-toast');
        if (elm) {
            var animationDuration = 300;
            if (timeout) {
                clearTimeout(timeout);
                timeout = undefined;
            }
            elm.className = elm.className.replace('fadeIn', 'fadeOut');
            window.setTimeout(function () {
                var parent = wrapper.parentNode;
                if (parent) {
                    parent.removeChild(wrapper);
                }
                resolve();
            }, animationDuration);
        }
        else {
            resolve();
        }
    });
};
exports.closeToast = closeToast;
var registerClick = function (shadowRoot, id, callback) {
    var button = shadowRoot.getElementById(id);
    if (button) {
        button.addEventListener('click', function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, callback(button)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
    }
    return button;
};
var showElement = function (shadowRoot, id) {
    var el = shadowRoot.getElementById(id);
    if (el) {
        el.classList.remove('hide');
        el.classList.add('show');
    }
};
var hideElement = function (shadowRoot, id) {
    var el = shadowRoot.getElementById(id);
    if (el) {
        el.classList.add('hide');
        el.classList.remove('show');
    }
};
// const showLoader = (): void => {
//   showElement('beacon-toast-loader')
// }
var hideLoader = function (shadowRoot) {
    hideElement(shadowRoot, 'beacon-toast-loader');
    showElement(shadowRoot, 'beacon-toast-loader-placeholder');
};
var showExpand = function (shadowRoot) {
    showElement(shadowRoot, 'beacon-toast-button-expand');
    hideElement(shadowRoot, 'beacon-toast-button-close');
};
var showClose = function (shadowRoot) {
    showElement(shadowRoot, 'beacon-toast-button-close');
    hideElement(shadowRoot, 'beacon-toast-button-expand');
};
var collapseList = function (shadowRoot) {
    var expandButton = shadowRoot.getElementById('beacon-toast-button-expand');
    var list = shadowRoot.getElementById('beacon-toast-list');
    if (expandButton && list) {
        expandButton.classList.remove('beacon-toast__upside_down');
        list.classList.add('hide');
        list.classList.remove('show');
    }
};
var expandList = function (shadowRoot) {
    var expandButton = shadowRoot.getElementById('beacon-toast-button-expand');
    var list = shadowRoot.getElementById('beacon-toast-list');
    if (expandButton && list) {
        expandButton.classList.add('beacon-toast__upside_down');
        list.classList.remove('hide');
        list.classList.add('show');
    }
};
var expandOrCollapseList = function (shadowRoot) {
    var expandButton = shadowRoot.getElementById('beacon-toast-button-expand');
    var list = shadowRoot.getElementById('beacon-toast-list');
    if (expandButton && list) {
        if (expandButton.classList.contains('beacon-toast__upside_down')) {
            collapseList(shadowRoot);
        }
        else {
            expandList(shadowRoot);
        }
    }
};
var addActionsToToast = function (shadowRoot, toastConfig, list) { return __awaiter(void 0, void 0, void 0, function () {
    var actions, actionPromises, actionItems, poweredByBeacon;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                actions = toastConfig.actions;
                if (!(actions && actions.length > 0)) return [3 /*break*/, 2];
                actionPromises = actions.map(function (action) { return __awaiter(void 0, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        // eslint-disable-next-line @typescript-eslint/unbound-method
                        return [2 /*return*/, createActionItem(action)];
                    });
                }); });
                return [4 /*yield*/, Promise.all(actionPromises)];
            case 1:
                actionItems = _a.sent();
                actionItems.forEach(function (item) { return list.appendChild(item); });
                poweredByBeacon = document.createElement('small');
                poweredByBeacon.classList.add('beacon-toast__powered');
                poweredByBeacon.appendChild((0, templates_1.constructPoweredByBeacon)());
                list.appendChild(poweredByBeacon);
                showExpand(shadowRoot);
                return [3 /*break*/, 3];
            case 2:
                showClose(shadowRoot);
                collapseList(shadowRoot);
                _a.label = 3;
            case 3: return [2 /*return*/];
        }
    });
}); };
var createNewToast = function (toastConfig) { return __awaiter(void 0, void 0, void 0, function () {
    var timer, shadowRootEl, shadowRoot, wrapper, _a, style, html, styleEl, colorMode, elm, list, openWalletButtonEl, closeButton;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                globalToastConfig = toastConfig;
                timer = toastConfig.timer;
                shadowRootEl = document.createElement('div');
                shadowRootEl.setAttribute('id', 'beacon-toast-wrapper');
                shadowRoot = shadowRootEl.attachShadow({ mode: 'open' });
                wrapper = document.createElement('div');
                _a = getToastHTML(toastConfig), style = _a.style, html = _a.html;
                wrapper.appendChild(html);
                styleEl = document.createElement('style');
                styleEl.textContent = style;
                shadowRoot.appendChild(wrapper);
                shadowRoot.appendChild(styleEl);
                if (timer) {
                    timeout = window.setTimeout(function () { return __awaiter(void 0, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, closeToast()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); }, timer);
                }
                document.body.prepend(shadowRootEl);
                colorMode = (0, colorMode_1.getColorMode)();
                elm = shadowRoot.getElementById("beacon-toast");
                if (elm) {
                    elm.classList.add("theme__".concat(colorMode));
                }
                list = shadowRoot.getElementById('beacon-toast-list');
                if (!list) return [3 /*break*/, 2];
                return [4 /*yield*/, addActionsToToast(shadowRoot, toastConfig, list)];
            case 1:
                _b.sent();
                _b.label = 2;
            case 2:
                openWalletButtonEl = shadowRoot.getElementById('beacon-open-wallet');
                if (openWalletButtonEl) {
                    if (toastConfig.openWalletAction) {
                        openWalletButtonEl.addEventListener('click', function () {
                            if (toastConfig.openWalletAction) {
                                toastConfig.openWalletAction();
                            }
                        });
                    }
                    else {
                        openWalletButtonEl.classList.add('hide');
                    }
                }
                if (globalToastConfig.state === 'loading') {
                    expandTimeout = window.setTimeout(function () { return __awaiter(void 0, void 0, void 0, function () {
                        var expandButton;
                        return __generator(this, function (_a) {
                            expandButton = shadowRoot.getElementById('beacon-toast-button-expand');
                            if (expandButton && !expandButton.classList.contains('beacon-toast__upside_down')) {
                                expandOrCollapseList(shadowRoot);
                            }
                            return [2 /*return*/];
                        });
                    }); }, EXPAND_AFTER);
                }
                registerClick(shadowRoot, 'beacon-toast-button-done', function () { return __awaiter(void 0, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, closeToast()];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); });
                closeButton = registerClick(shadowRoot, 'beacon-toast-button-close', function () { return __awaiter(void 0, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, closeToast()];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); });
                if (closeButton && globalToastConfig.state === 'loading') {
                    closeButton.classList.add('hide');
                }
                registerClick(shadowRoot, 'beacon-toast-button-expand', function () { return __awaiter(void 0, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        expandOrCollapseList(shadowRoot);
                        return [2 /*return*/];
                    });
                }); });
                return [2 /*return*/];
        }
    });
}); };
var updateToast = function (toastConfig) { return __awaiter(void 0, void 0, void 0, function () {
    var timer, wrapper, shadowRoot, list, toastTextEl, openWalletButtonEl, doneButton;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                globalToastConfig = __assign(__assign({}, globalToastConfig), toastConfig);
                timer = toastConfig.timer;
                wrapper = document.getElementById('beacon-toast-wrapper');
                if (!wrapper) {
                    return [2 /*return*/];
                }
                shadowRoot = wrapper.shadowRoot;
                if (!shadowRoot) {
                    return [2 /*return*/];
                }
                list = shadowRoot.getElementById('beacon-toast-list');
                if (!list) return [3 /*break*/, 2];
                removeAllChildNodes(list);
                return [4 /*yield*/, addActionsToToast(shadowRoot, toastConfig, list)];
            case 1:
                _a.sent();
                _a.label = 2;
            case 2:
                if (globalToastConfig.state === 'loading') {
                    expandTimeout = window.setTimeout(function () { return __awaiter(void 0, void 0, void 0, function () {
                        var expandButton;
                        return __generator(this, function (_a) {
                            expandButton = shadowRoot.getElementById('beacon-toast-button-expand');
                            if (expandButton && !expandButton.classList.contains('beacon-toast__upside_down')) {
                                expandOrCollapseList(shadowRoot);
                            }
                            return [2 /*return*/];
                        });
                    }); }, EXPAND_AFTER);
                }
                toastTextEl = shadowRoot.getElementById('beacon-text-content');
                if (toastTextEl) {
                    removeAllChildNodes(toastTextEl);
                    toastTextEl.appendChild((0, html_elements_1.createSanitizedElement)('span', ['beacon-toast__wallet__outer'], [], formatToastText(toastConfig.body)));
                }
                openWalletButtonEl = shadowRoot.getElementById('beacon-open-wallet');
                if (openWalletButtonEl) {
                    if (toastConfig.openWalletAction) {
                        openWalletButtonEl.classList.remove('hide');
                        openWalletButtonEl.addEventListener('click', function () {
                            if (toastConfig.openWalletAction) {
                                toastConfig.openWalletAction();
                            }
                        });
                    }
                    else {
                        openWalletButtonEl.classList.add('hide');
                    }
                }
                if (timer) {
                    timeout = window.setTimeout(function () { return __awaiter(void 0, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, closeToast()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); }, timer);
                }
                doneButton = shadowRoot.getElementById('beacon-toast-button-done');
                if (doneButton) {
                    doneButton.addEventListener('click', function () { return __awaiter(void 0, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, closeToast()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                }
                return [2 /*return*/];
        }
    });
}); };
/**
 * Create a new toast
 *
 * @param toastConfig Configuration of the toast
 */
var openToast = function (toastConfig) { return __awaiter(void 0, void 0, void 0, function () {
    var wrapper, shadowRoot;
    var _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                if (expandTimeout) {
                    clearTimeout(expandTimeout);
                }
                wrapper = document.getElementById('beacon-toast-wrapper');
                if (!wrapper) return [3 /*break*/, 6];
                if (!toastConfig.forceNew) return [3 /*break*/, 3];
                return [4 /*yield*/, closeToast()];
            case 1:
                _b.sent();
                return [4 /*yield*/, createNewToast(toastConfig)];
            case 2:
                _b.sent();
                return [3 /*break*/, 5];
            case 3: return [4 /*yield*/, updateToast(toastConfig)];
            case 4:
                _b.sent();
                _b.label = 5;
            case 5: return [3 /*break*/, 8];
            case 6: return [4 /*yield*/, createNewToast(toastConfig)];
            case 7:
                _b.sent();
                _b.label = 8;
            case 8:
                if (globalToastConfig && globalToastConfig.state === 'finished') {
                    shadowRoot = (_a = document.getElementById('beacon-toast-wrapper')) === null || _a === void 0 ? void 0 : _a.shadowRoot;
                    if (shadowRoot) {
                        hideLoader(shadowRoot);
                        showClose(shadowRoot);
                        expandList(shadowRoot);
                    }
                }
                return [2 /*return*/];
        }
    });
}); };
exports.openToast = openToast;

},{"../../utils/colorMode":130,"../../utils/html-elements":132,"../../utils/templates":135,"./toast-templates":129,"@airgap/beacon-utils":136}],129:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toastTemplates = void 0;
exports.toastTemplates = { "default": { "css": ":host {\n  --animation-duration: 300ms;\n  all: initial;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.animated {\n  animation-duration: var(--animation-duration);\n  animation-fill-mode: both;\n}\n\n.fadeIn {\n  animation-name: fadeIn;\n}\n\n.fadeOut {\n  animation-name: fadeOut;\n}\n\n.beacon-toast__base {\n  position: fixed;\n  top: 16px;\n  right: 16px;\n  z-index: 2147483000;\n  margin: 0 auto;\n  border-radius: 8px;\n  overflow: hidden;\n  box-shadow: 0 12px 24px 0 rgba(0, 0, 0, 0.1);\n  flex-direction: column;\n}\n@media (max-width: 576px) {\n  .beacon-toast__base {\n    top: 8px;\n    right: 8px;\n    left: 8px;\n  }\n  .beacon-toast__wallet__outer {\n    flex-wrap: wrap;\n  }\n  .beacon-toast__wallet__link {\n    display: flex;\n    margin-left: 12px !important;\n  }\n}\n\n.theme__light.beacon-toast__base {\n  background: #fff;\n}\n\n.theme__dark.beacon-toast__base {\n  background: #27334c;\n}\n\n.theme__dark p {\n  color: #6183ff;\n}\n\na {\n  text-decoration: none;\n  color: #3880ff;\n}\n\na svg {\n  width: 12px;\n  margin-left: 2px;\n}\n\na:visited {\n  color: #3880ff;\n}\n\nhr {\n  height: 1px;\n  color: rgba(0, 0, 0, 0.12);\n  background-color: rgba(0, 0, 0, 0.12);\n  border: none;\n  width: 100%;\n  margin: 0;\n  display: none;\n}\n\n.show {\n  display: block !important;\n}\n\n.hide {\n  display: none !important;\n}\n\n#beacon-toast-list {\n  display: none;\n}\n\n.beacon-toast__upside_down {\n  transform: rotate(180deg);\n}\n\n.beacon-toast__content {\n  justify-content: space-between;\n  min-height: 56px;\n  height: 0;\n}\n\n.beacon-toast__action__item,\n.beacon-toast__powered a,\n.beacon-toast__wallet__container,\n#beacon-text,\n.beacon-toast__action__item p,\n.beacon-toast__wallet__outer {\n  align-items: center;\n}\n\n.beacon-toast__content,\n.beacon-toast__base,\n.beacon-toast__action__item,\n.beacon-toast__powered a,\n#beacon-text,\n.beacon-toast__wallet__container,\n.beacon-toast__wallet__outer {\n  display: flex;\n}\n\n.beacon-toast__content,\n.beacon-toast__action__item,\n.beacon-toast__powered a {\n  padding: 0 16px;\n  font-family: Roboto, Helvetica, sans-serif;\n}\n\n#beacon-text strong {\n  display: contents;\n}\n.beacon-toast__wallet__link {\n  margin-left: 8px;\n}\n.beacon-toast__wallet__link svg {\n  margin-left: 4px;\n}\n.beacon-toast__powered a {\n  margin: 4px 0 12px;\n  font-size: 12px;\n  opacity: 0.64;\n}\n\n.beacon-toast__powered svg {\n  width: 20px;\n  height: 20px;\n  margin: 0 2px 0 4px;\n}\n\n.beacon-toast__action__item {\n  font-size: 14px;\n  max-width: 40ch;\n}\n\n.beacon-toast__action__item p {\n  margin-right: 8px;\n}\n\n.beacon-toast__action__item__subtitle,\n.beacon-toast__powered a {\n  min-width: 88px;\n  color: rgba(0, 0, 0, 0.54);\n}\n\n.theme__dark .beacon-toast__powered a {\n  color: #7c99d6;\n}\n\n.beacon-toast__content__img {\n  width: 24px;\n  height: 24px;\n  margin-right: 4px;\n  image-rendering: -moz-crisp-edges; /* Firefox */\n  image-rendering: -o-crisp-edges; /* Opera */\n  image-rendering: -webkit-optimize-contrast; /* Webkit (non-standard naming) */\n  image-rendering: crisp-edges;\n  -ms-interpolation-mode: nearest-neighbor; /* IE (non-standard property) */\n}\n\n.beacon-toast__more {\n  width: 14px;\n  transition: transform 0.5s;\n}\n\na,\n.beacon-toast__more {\n  cursor: pointer;\n}\n\na:hover {\n  opacity: 0.64;\n}\n\n.theme__dark .beacon-toast__more {\n  color: #7c99d6;\n}\n\n.beacon-toast__more--action {\n  margin: 8px 0;\n}\n\n#beacon-text {\n  padding-right: 24px;\n}\n\n#beacon-text-content {\n  display: flex;\n  align-items: center;\n}\n\n.progress-line,\n.progress-line:before {\n  height: 3px;\n  width: 100%;\n  margin: 0;\n}\n.progress-line {\n  background-color: #a7c4f7;\n  display: -webkit-flex;\n  display: flex;\n}\n.progress-line:before {\n  background-color: #3880ff;\n  content: '';\n  -webkit-animation: running-progress 2s cubic-bezier(0.4, 0, 0.2, 1) infinite;\n  animation: running-progress 2s cubic-bezier(0.4, 0, 0.2, 1) infinite;\n}\n@-webkit-keyframes running-progress {\n  0% {\n    margin-left: 0px;\n    margin-right: 100%;\n  }\n  50% {\n    margin-left: 25%;\n    margin-right: 0%;\n  }\n  100% {\n    margin-left: 100%;\n    margin-right: 0;\n  }\n}\n@keyframes running-progress {\n  0% {\n    margin-left: 0px;\n    margin-right: 100%;\n  }\n  50% {\n    margin-left: 25%;\n    margin-right: 0%;\n  }\n  100% {\n    margin-left: 100%;\n    margin-right: 0;\n  }\n}\n" } };

},{}],130:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getColorMode = exports.setColorMode = void 0;
var beacon_types_1 = require("@airgap/beacon-types");
var colorMode = beacon_types_1.ColorMode.LIGHT;
var setColorMode = function (mode) {
    colorMode = mode;
};
exports.setColorMode = setColorMode;
var getColorMode = function () { return colorMode; };
exports.getColorMode = getColorMode;

},{"@airgap/beacon-types":104}],131:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTzip10Link = void 0;
var getTzip10Link = function (url, payload) {
    return "".concat(url, "?type=tzip10&data=").concat(payload);
};
exports.getTzip10Link = getTzip10Link;

},{}],132:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeAllChildren = exports.sanitizeText = exports.createIconSVGExternal = exports.createSVGGElement = exports.createSVGPathElement = exports.createSVGElement = exports.createSanitizedElement = void 0;
var createSanitizedElement = function (type, classes, attributes, element) {
    var _a;
    var el = document.createElement(type);
    if (classes.length > 0) {
        // Filter empty classnames and add all classes to element
        (_a = el.classList).add.apply(_a, classes.filter(function (clazz) { return !!clazz; }).map(function (clazz) { return (0, exports.sanitizeText)(clazz); }));
    }
    // Add all attributes to element
    attributes.forEach(function (attribute) {
        el.setAttribute((0, exports.sanitizeText)(attribute[0]), (0, exports.sanitizeText)(attribute[1]));
    });
    if (typeof element === 'object' && Array.isArray(element)) {
        // If we get a list of elements, add all of them as children
        element
            .filter(function (childEl) { return !!childEl; })
            .forEach(function (childEl) {
            el.appendChild(childEl);
        });
    }
    else if (typeof element === 'string') {
        // Use `innerText` to assign text to prevent malicious code from being rendered
        el.innerText = element;
    }
    else {
        // NOOP
    }
    return el;
};
exports.createSanitizedElement = createSanitizedElement;
var createSVGElement = function (classes, attributes, element) {
    var _a;
    var el = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    if (classes.length > 0) {
        (_a = el.classList).add.apply(_a, classes.filter(function (clazz) { return !!clazz; }));
    }
    attributes.forEach(function (attribute) {
        el.setAttribute((0, exports.sanitizeText)(attribute[0]), (0, exports.sanitizeText)(attribute[1]));
    });
    if (typeof element === 'object' && Array.isArray(element)) {
        element
            .filter(function (childEl) { return !!childEl; })
            .forEach(function (childEl) {
            el.appendChild(childEl);
        });
    }
    else {
        // NOOP
    }
    return el;
};
exports.createSVGElement = createSVGElement;
var createSVGPathElement = function (attributes) {
    var el = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    attributes.forEach(function (attribute) {
        el.setAttribute((0, exports.sanitizeText)(attribute[0]), (0, exports.sanitizeText)(attribute[1]));
    });
    return el;
};
exports.createSVGPathElement = createSVGPathElement;
var createSVGGElement = function (element) {
    var el = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    element
        .filter(function (childEl) { return !!childEl; })
        .forEach(function (childEl) {
        el.appendChild(childEl);
    });
    return el;
};
exports.createSVGGElement = createSVGGElement;
var createIconSVGExternal = function () {
    return (0, exports.createSVGElement)(['svg-inline--fa', 'fa-external-link-alt', 'fa-w-16'], [
        ['aria-hidden', 'true'],
        ['focusable', 'false'],
        ['data-prefix', 'fas'],
        ['data-icon', 'external-link-alt'],
        ['role', 'img'],
        ['xmlns', 'http://www.w3.org/2000/svg'],
        ['viewBox', '0 0 512 512']
    ], [
        (0, exports.createSVGPathElement)([
            ['fill', 'currentColor'],
            [
                'd',
                'M432,320H400a16,16,0,0,0-16,16V448H64V128H208a16,16,0,0,0,16-16V80a16,16,0,0,0-16-16H48A48,48,0,0,0,0,112V464a48,48,0,0,0,48,48H400a48,48,0,0,0,48-48V336A16,16,0,0,0,432,320ZM488,0h-128c-21.37,0-32.05,25.91-17,41l35.73,35.73L135,320.37a24,24,0,0,0,0,34L157.67,377a24,24,0,0,0,34,0L435.28,133.32,471,169c15,15,41,4.5,41-17V24A24,24,0,0,0,488,0Z'
            ]
        ])
    ]);
};
exports.createIconSVGExternal = createIconSVGExternal;
var sanitizeText = function (text) {
    var div = document.createElement('div');
    div.innerText = text;
    return div.innerHTML;
};
exports.sanitizeText = sanitizeText;
var removeAllChildren = function (el) {
    el.innerHTML = '';
};
exports.removeAllChildren = removeAllChildren;

},{}],133:[function(require,module,exports){
"use strict";
// Helper functions from https://github.com/ionic-team/ionic-framework/blob/master/core/src/utils/platform.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDesktop = exports.isAndroid = exports.isIOS = exports.isMobile = exports.testUserAgent = void 0;
var testUserAgent = function (win, expr) {
    return expr.test(win.navigator.userAgent);
};
exports.testUserAgent = testUserAgent;
var matchMedia = function (win, query) { return win.matchMedia(query).matches; };
var isMobile = function (win) { return matchMedia(win, '(any-pointer:coarse)'); };
exports.isMobile = isMobile;
// const isCordova = (win: any): boolean => Boolean(win.cordova || win.phonegap || win.PhoneGap)
// const isCapacitorNative = (win: any): boolean => {
//   const capacitor = win.Capacitor
//   return Boolean(capacitor && capacitor.isNative)
// }
// const isHybrid = (win: Window): boolean => isCordova(win) || isCapacitorNative(win)
// const isMobileWeb = (win: Window): boolean => isMobile(win) && !isHybrid(win)
var isIpad = function (win) {
    // iOS 12 and below
    if ((0, exports.testUserAgent)(win, /iPad/i)) {
        return true;
    }
    // iOS 13+
    if ((0, exports.testUserAgent)(win, /Macintosh/i) && (0, exports.isMobile)(win)) {
        return true;
    }
    return false;
};
var isIOS = function (win) { return (0, exports.testUserAgent)(win, /iPhone|iPod/i) || isIpad(win); };
exports.isIOS = isIOS;
var isAndroid = function (win) { return (0, exports.testUserAgent)(win, /android|sink/i); };
exports.isAndroid = isAndroid;
var isDesktop = function (win) { return !(0, exports.isMobile)(win); };
exports.isDesktop = isDesktop;

},{}],134:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getQrData = void 0;
var qrcode = require("qrcode-generator");
var beacon_core_1 = require("@airgap/beacon-core");
var logger = new beacon_core_1.Logger('QR');
/**
 * Convert data to a QR code
 *
 * @param payload The data to be encoded as a QR code
 * @param type How the QR code will be encoded
 */
var getQrData = function (payload, type) {
    var typeNumber = 0;
    var errorCorrectionLevel = 'L';
    var qr = qrcode(typeNumber, errorCorrectionLevel);
    if (payload.length > 500) {
        logger.warn('getQrData', 'The size of the payload in the QR code is quite long and some devices might not be able to scan it anymore. To reduce the QR size, try using a shorter "name", "appUrl" and "iconUrl"');
    }
    try {
        qr.addData(payload);
        qr.make();
        if (type === 'svg') {
            return qr.createSvgTag();
        }
        else if (type === 'ascii') {
            var length_1 = qr.getModuleCount();
            var black = '\x1B[40m  \x1B[0m';
            var white = '\x1B[47m  \x1B[0m';
            var whiteLine = new Array(length_1 + 3).join(white);
            var blackLine = new Array(length_1 + 3).join(black);
            var ascii = '';
            ascii += "".concat(blackLine, "\n");
            ascii += "".concat(whiteLine, "\n");
            for (var x = 0; x < length_1; x++) {
                ascii += white;
                for (var y = 0; y < length_1; y++) {
                    ascii += qr.isDark(x, y) ? black : white;
                }
                ascii += "".concat(white, "\n");
            }
            ascii += whiteLine;
            ascii += blackLine;
            return ascii;
        }
        else {
            return qr.createDataURL();
        }
    }
    catch (qrError) {
        console.error('error', qrError);
        throw qrError;
    }
};
exports.getQrData = getQrData;

},{"@airgap/beacon-core":58,"qrcode-generator":289}],135:[function(require,module,exports){
"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.constructPairAlert = exports.constructDefaultAlert = exports.constructAlertContainer = exports.constructPoweredByBeacon = exports.constructToastContainer = void 0;
var html_elements_1 = require("./html-elements");
var constructToastContainer = function (elements) {
    return (0, html_elements_1.createSanitizedElement)('div', ['beacon-toast__base', 'animated', 'fadeIn'], [['id', 'beacon-toast']], [
        (0, html_elements_1.createSanitizedElement)('div', ['beacon-toast__content'], [], [
            (0, html_elements_1.createSanitizedElement)('span', [], [['id', 'beacon-text']], [
                (0, html_elements_1.createSanitizedElement)('p', [], [['id', 'beacon-text-content']], elements),
                (0, html_elements_1.createSanitizedElement)('a', ['beacon-toast__wallet__link'], [['id', 'beacon-open-wallet']], [
                    (0, html_elements_1.createSanitizedElement)('span', [], [], 'Open'),
                    (0, html_elements_1.createSVGElement)(['svg-inline--fa', 'fa-external-link-alt', 'fa-w-16'], [
                        ['aria-hidden', 'true'],
                        ['focusable', 'false'],
                        ['data-prefix', 'fas'],
                        ['data-icon', 'external-link-alt'],
                        ['role', 'img'],
                        ['xmlns', 'http://www.w3.org/2000/svg'],
                        ['viewBox', '0 0 512 512']
                    ], [
                        (0, html_elements_1.createSVGPathElement)([
                            ['fill', 'currentColor'],
                            [
                                'd',
                                'M432,320H400a16,16,0,0,0-16,16V448H64V128H208a16,16,0,0,0,16-16V80a16,16,0,0,0-16-16H48A48,48,0,0,0,0,112V464a48,48,0,0,0,48,48H400a48,48,0,0,0,48-48V336A16,16,0,0,0,432,320ZM488,0h-128c-21.37,0-32.05,25.91-17,41l35.73,35.73L135,320.37a24,24,0,0,0,0,34L157.67,377a24,24,0,0,0,34,0L435.28,133.32,471,169c15,15,41,4.5,41-17V24A24,24,0,0,0,488,0Z'
                            ]
                        ])
                    ])
                ])
            ]),
            (0, html_elements_1.createSVGElement)(['beacon-toast__more', 'svg-inline--fa', 'fa-angle-down', 'fa-w-10'], [
                ['id', 'beacon-toast-button-expand'],
                ['aria-hidden', 'true'],
                ['focusable', 'false'],
                ['data-prefix', 'fas'],
                ['data-icon', 'angle-down'],
                ['role', 'img'],
                ['xmlns', 'http://www.w3.org/2000/svg'],
                ['viewBox', '0 0 320 512']
            ], [
                (0, html_elements_1.createSVGPathElement)([
                    ['fill', 'currentColor'],
                    [
                        'd',
                        'M143 352.3L7 216.3c-9.4-9.4-9.4-24.6 0-33.9l22.6-22.6c9.4-9.4 24.6-9.4 33.9 0l96.4 96.4 96.4-96.4c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9l-136 136c-9.2 9.4-24.4 9.4-33.8 0z'
                    ]
                ])
            ]),
            (0, html_elements_1.createSVGElement)(['beacon-toast__more', 'svg-inline--fa', 'fa-times', 'fa-w-10'], [
                ['id', 'beacon-toast-button-close'],
                ['aria-hidden', 'true'],
                ['focusable', 'false'],
                ['data-prefix', 'fal'],
                ['data-icon', 'times'],
                ['role', 'img'],
                ['xmlns', 'http://www.w3.org/2000/svg'],
                ['viewBox', '0 0 320 512']
            ], [
                (0, html_elements_1.createSVGPathElement)([
                    ['fill', 'currentColor'],
                    [
                        'd',
                        'M193.94 256L296.5 153.44l21.15-21.15c3.12-3.12 3.12-8.19 0-11.31l-22.63-22.63c-3.12-3.12-8.19-3.12-11.31 0L160 222.06 36.29 98.34c-3.12-3.12-8.19-3.12-11.31 0L2.34 120.97c-3.12 3.12-3.12 8.19 0 11.31L126.06 256 2.34 379.71c-3.12 3.12-3.12 8.19 0 11.31l22.63 22.63c3.12 3.12 8.19 3.12 11.31 0L160 289.94 262.56 392.5l21.15 21.15c3.12 3.12 8.19 3.12 11.31 0l22.63-22.63c3.12-3.12 3.12-8.19 0-11.31L193.94 256z'
                    ]
                ])
            ])
        ]),
        (0, html_elements_1.createSanitizedElement)('div', ['progress-line'], [['id', 'beacon-toast-loader']], ''),
        (0, html_elements_1.createSanitizedElement)('hr', ['hide'], [['id', 'beacon-toast-loader-placeholder']], ''),
        (0, html_elements_1.createSanitizedElement)('div', ['beacon-toast__more--action'], [['id', 'beacon-toast-list']], '')
    ]);
};
exports.constructToastContainer = constructToastContainer;
var constructPoweredByBeacon = function () {
    return (0, html_elements_1.createSanitizedElement)('a', [], [
        ['href', 'https://walletbeacon.io'],
        ['target', '_blank']
    ], [
        document.createTextNode('powered by'),
        (0, html_elements_1.createSVGElement)([], [
            ['id', 'f63e95a9-fd19-4487-bc1a-09eb2f066704'],
            ['data-name', 'Guides'],
            ['xmlns', 'http://www.w3.org/2000/svg'],
            ['width', '65'],
            ['height', '65'],
            ['viewBox', '0 0 65 65']
        ], [
            (0, html_elements_1.createSanitizedElement)('title', [], [], 'beacon_logo'),
            (0, html_elements_1.createSVGPathElement)([
                ['fill', 'currentColor'],
                [
                    'd',
                    'M59.66,29.52v1.06c0,.37-.18,9.07-4.11,15.88S44.16,57.75,43.84,57.93l-.91.54-1.61-.93-9.19-5.3a14.68,14.68,0,0,1-1.63-1.06h0a14.09,14.09,0,0,1-1.29-1,17.63,17.63,0,0,1-2.56-2.7,18.58,18.58,0,0,1-2.56-4.51,21.53,21.53,0,0,1-1.5-9,6.21,6.21,0,0,1,2.93-.73c.25,0,.49,0,.74,0a18.29,18.29,0,0,0,1,7.93,15.06,15.06,0,0,0,6.67,8l8.93,5.16c.2-.13.43-.3.68-.48,2.26-1.6,6.42-4.92,8.86-9.13C55.12,39.94,55.8,34,56,31.57l-3.79-2.19a23,23,0,0,0,.6-3.83Z'
                ]
            ]),
            (0, html_elements_1.createSVGPathElement)([
                ['fill', 'currentColor'],
                [
                    'd',
                    'M49.22,11.43V23.89c0,.65,0,1.3-.1,1.94v0c-.06.55-.13,1.1-.24,1.63A18,18,0,0,1,47.82,31a19.11,19.11,0,0,1-2.62,4.49,21.37,21.37,0,0,1-7.07,5.8,6.08,6.08,0,0,1-2.42-2.84A18.1,18.1,0,0,0,42,33.7h0a15.12,15.12,0,0,0,3.58-9.81V13.6c-.21-.11-.47-.21-.74-.35-2.52-1.16-7.47-3.1-12.36-3.1-5.42,0-11,2.4-13.08,3.45V18a22.54,22.54,0,0,0-3.63,1.38V11.43l.92-.52c.33-.18,8-4.38,15.79-4.38s15.48,4.2,15.8,4.38Z'
                ]
            ]),
            (0, html_elements_1.createSVGPathElement)([
                ['fill', 'currentColor'],
                [
                    'd',
                    'M18,26.4,9,31.55q0,.35.06.78a31.63,31.63,0,0,0,3.49,12.28c2.71,4.71,7.55,8.3,9.53,9.64l3.79-2.19a23.33,23.33,0,0,0,3,2.44l-6.88,4-.92-.54c-.31-.18-7.75-4.69-11.68-11.5S5.36,30.92,5.35,30.56V29.49L7,28.55l9.17-5.29c.57-.32,1.14-.61,1.72-.87a13.46,13.46,0,0,1,1.55-.61A17.52,17.52,0,0,1,23,20.91a19.2,19.2,0,0,1,5.19,0,21.49,21.49,0,0,1,8.55,3.24,6.29,6.29,0,0,1-1.25,3.51,17.9,17.9,0,0,0-7.3-3.06A15.14,15.14,0,0,0,18,26.4Z'
                ]
            ])
        ]),
        document.createTextNode('Beacon')
    ]);
};
exports.constructPoweredByBeacon = constructPoweredByBeacon;
var constructAlertContainer = function (id, callToAction, buttons, main) {
    return (0, html_elements_1.createSanitizedElement)('div', ['beacon-alert__base', 'animated', 'fadeIn'], [['id', "beacon-alert-modal-".concat(id)]], [
        (0, html_elements_1.createSanitizedElement)('div', ['beacon-modal__wrapper'], [], [
            (0, html_elements_1.createSanitizedElement)('div', ['beacon-modal__header'], [], [
                (0, html_elements_1.createSVGElement)([], [
                    ['xmlns', 'http://www.w3.org/2000/svg'],
                    ['id', 'Guides'],
                    ['x', '0'],
                    ['y', '0'],
                    ['version', '1.1'],
                    ['viewBox', '0 0 179.2 43'],
                    ['xml:space', 'preserve'],
                    ['width', '140'],
                    ['height', '40']
                ], [
                    (0, html_elements_1.createSanitizedElement)('style', [], [], ".st0 {\n                    fill: #3880ff;\n                  }\n                  .st1 {\n                    fill: #fff;\n                  }"),
                    (0, html_elements_1.createSVGPathElement)([
                        [
                            'd',
                            'M45 19v.9c0 .3-.2 7.5-3.4 13.2-3.3 5.6-9.4 9.3-9.7 9.5l-.8.4-1.3-.8-7.6-4.4c-.5-.3-.9-.6-1.4-.9-.4-.3-.7-.5-1.1-.8-.8-.7-1.5-1.4-2.1-2.2-.9-1.1-1.6-2.4-2.1-3.7-.9-2.3-1.3-4.8-1.2-7.5.8-.4 1.6-.6 2.4-.6h.6c-.2 2.4.1 4.6.8 6.6 1 2.8 2.9 5.1 5.5 6.6l7.4 4.3c.2-.1.4-.2.6-.4 1.9-1.3 5.3-4.1 7.3-7.6 2.2-3.9 2.8-8.9 3-10.8L38.8 19c.3-1 .4-2.1.5-3.2L45 19z'
                        ],
                        ['class', 'st0']
                    ]),
                    (0, html_elements_1.createSVGPathElement)([
                        [
                            'd',
                            'M36.3 4.1v10.3c0 .5 0 1.1-.1 1.6s-.1.9-.2 1.3c-.2 1-.5 2-.9 3-.5 1.3-1.3 2.6-2.2 3.7-1.5 1.9-3.5 3.6-5.9 4.8-.9-.6-1.6-1.3-2-2.4 2.1-1 3.9-2.3 5.2-4 1.9-2.3 3-5.1 3-8.1V5.9l-.6-.3c-2-1-6.1-2.6-10.1-2.6-4.5 0-9.1 2-10.9 2.9v3.6c-1 .3-2 .7-3 1.1V4.1l.8-.4C9.7 3.5 16 0 22.5 0s12.8 3.5 13.1 3.6l.7.5z'
                        ],
                        ['class', 'st0']
                    ]),
                    (0, html_elements_1.createSVGPathElement)([
                        [
                            'd',
                            'M10.5 16.5l-7.4 4.3v.7c.2 2.1.9 6.5 2.9 10 2.2 3.9 6.2 6.9 7.9 8l3.1-1.8c.8.7 1.6 1.4 2.5 2L13.8 43l-.8-.5c-.3-.2-6.4-3.9-9.7-9.5C.1 27.4 0 20.2 0 19.9V19l1.3-.8L9 13.9c.5-.3.9-.5 1.4-.7.4-.2.8-.4 1.3-.5 1-.4 2-.6 3-.7 1.4-.2 2.9-.2 4.3 0 2.4.3 4.8 1.2 7.1 2.7 0 1-.4 2-1 2.9-1.9-1.3-4-2.2-6-2.5-3.1-.6-6-.1-8.6 1.4z'
                        ],
                        ['class', 'st0']
                    ]),
                    (0, html_elements_1.createSVGGElement)([
                        (0, html_elements_1.createSVGPathElement)([
                            [
                                'd',
                                'M73.9 23c.9 1 1.3 2.3 1.3 3.7 0 1.9-.6 3.4-1.9 4.5-1.3 1.1-3.1 1.7-5.5 1.7h-8.6v-23h8.4c2.3 0 4.1.5 5.3 1.5 1.2 1 1.8 2.4 1.8 4.2 0 1.5-.4 2.7-1.2 3.6-.8.9-1.8 1.5-3.1 1.8 1.5.3 2.6 1 3.5 2zm-11.7-3h5c1.5 0 2.6-.3 3.4-1 .8-.7 1.2-1.6 1.2-2.8 0-1.2-.4-2.1-1.1-2.8-.8-.7-1.9-1-3.5-1h-4.8V20zm8.7 9.4c.9-.7 1.3-1.7 1.3-3s-.4-2.3-1.3-3c-.9-.7-2.1-1.1-3.7-1.1h-5v8.2h5c1.6-.1 2.8-.4 3.7-1.1zM95.3 24.6H81c.1 2.1.6 3.6 1.7 4.6s2.4 1.5 4 1.5c1.4 0 2.6-.4 3.6-1.1 1-.7 1.6-1.7 1.8-2.9h3.2c-.2 1.2-.7 2.4-1.5 3.3-.8 1-1.7 1.7-2.9 2.3-1.2.5-2.6.8-4.1.8-1.7 0-3.2-.4-4.6-1.1-1.3-.7-2.4-1.8-3.1-3.2-.8-1.4-1.1-3-1.1-4.9 0-1.9.4-3.5 1.1-4.9.8-1.4 1.8-2.5 3.1-3.2 1.3-.7 2.9-1.1 4.6-1.1 1.7 0 3.3.4 4.6 1.1 1.3.7 2.3 1.7 3 3 .7 1.2 1 2.6 1 4.1.1.7 0 1.2-.1 1.7zm-3.5-4.8c-.5-.9-1.2-1.6-2.1-2-.9-.4-1.8-.7-2.8-.7-1.6 0-3 .5-4.1 1.5-1.1 1-1.7 2.5-1.8 4.5h11.5c0-1.3-.2-2.4-.7-3.3zM111.2 16c1.2.9 2.1 2 2.5 3.5V15h3v18h-3v-4.6c-.5 1.5-1.3 2.6-2.5 3.5-1.2.9-2.7 1.3-4.4 1.3-1.6 0-3-.4-4.3-1.1-1.2-.7-2.2-1.8-2.9-3.2-.7-1.4-1.1-3-1.1-4.9 0-1.9.4-3.5 1.1-4.9.7-1.4 1.7-2.5 2.9-3.2 1.2-.7 2.7-1.1 4.3-1.1 1.7-.1 3.1.4 4.4 1.2zm-8 3.1c-1.1 1.2-1.7 2.8-1.7 4.8 0 2.1.5 3.7 1.7 4.8 1.1 1.2 2.6 1.8 4.4 1.8 1.2 0 2.2-.3 3.2-.8.9-.5 1.7-1.3 2.2-2.3.5-1 .8-2.1.8-3.5 0-1.3-.3-2.5-.8-3.5s-1.2-1.8-2.2-2.3c-.9-.5-2-.8-3.2-.8-1.9.1-3.3.7-4.4 1.8zM135 16.6c1.5 1.2 2.4 2.9 2.8 4.9h-3.1c-.2-1.3-.8-2.3-1.8-3-1-.7-2.2-1.1-3.6-1.1-1 0-2 .2-2.9.7-.9.5-1.6 1.2-2.1 2.2-.5 1-.8 2.2-.8 3.7s.3 2.7.8 3.7 1.2 1.7 2.1 2.2c.9.5 1.8.7 2.9.7 1.4 0 2.6-.4 3.6-1.1 1-.7 1.6-1.8 1.8-3h3.1c-.3 2.1-1.3 3.7-2.8 4.9-1.5 1.2-3.4 1.8-5.7 1.8-1.7 0-3.2-.4-4.6-1.1-1.3-.7-2.4-1.8-3.1-3.2-.8-1.4-1.1-3-1.1-4.9 0-1.9.4-3.5 1.1-4.9.8-1.4 1.8-2.5 3.1-3.2 1.3-.7 2.9-1.1 4.6-1.1 2.3-.1 4.2.6 5.7 1.8zM154.5 15.9c1.4.7 2.4 1.8 3.2 3.2.8 1.4 1.2 3 1.2 4.9 0 1.9-.4 3.5-1.2 4.9-.8 1.4-1.8 2.4-3.2 3.2-1.4.7-2.9 1.1-4.6 1.1-1.7 0-3.3-.4-4.6-1.1-1.4-.7-2.4-1.8-3.2-3.2-.8-1.4-1.2-3-1.2-4.9 0-1.9.4-3.5 1.2-4.9.8-1.4 1.9-2.5 3.2-3.2 1.4-.7 2.9-1.1 4.6-1.1 1.7-.1 3.2.3 4.6 1.1zm-7.6 2.2c-.9.5-1.6 1.2-2.2 2.2-.6 1-.8 2.2-.8 3.7 0 1.4.3 2.7.8 3.6.6 1 1.3 1.7 2.2 2.2.9.5 1.9.7 3 .7s2.1-.2 3-.7c.9-.5 1.6-1.2 2.2-2.2.6-1 .8-2.2.8-3.6 0-1.5-.3-2.7-.8-3.7-.6-1-1.3-1.7-2.2-2.2-.9-.5-1.9-.7-3-.7s-2.1.2-3 .7zM177.3 16.7c1.3 1.3 1.9 3.3 1.9 5.8v10.4h-3V22.8c0-1.8-.5-3.2-1.4-4.1-.9-1-2.2-1.4-3.7-1.4-1.6 0-2.9.5-3.9 1.6s-1.5 2.6-1.5 4.6V33h-3V15h3v4.3c.5-1.5 1.3-2.6 2.4-3.4 1.2-.8 2.5-1.2 4-1.2 2.2 0 3.9.6 5.2 2z'
                            ],
                            ['class', 'st1']
                        ])
                    ])
                ]),
                (0, html_elements_1.createSanitizedElement)('div', ['beacon-modal__close__wrapper'], [['id', "beacon-alert-".concat(id, "-close")]], [
                    (0, html_elements_1.createSanitizedElement)('div', ['beacon-modal__close__icon'], [], [
                        (0, html_elements_1.createSanitizedElement)('div', ['beacon-modal__close__line1'], [], []),
                        (0, html_elements_1.createSanitizedElement)('div', ['beacon-modal__close__line2'], [], [])
                    ])
                ])
            ]),
            (0, html_elements_1.createSanitizedElement)('div', ['beacon-modal__base'], [], [
                (0, html_elements_1.createSanitizedElement)('div', [], [['id', 'beacon-modal__content']], [
                    (0, html_elements_1.createSanitizedElement)('div', [], [], __spreadArray(__spreadArray([
                        (0, html_elements_1.createSanitizedElement)('p', ['beacon-alert__title'], [], callToAction)
                    ], main, true), [
                        (0, html_elements_1.createSanitizedElement)('div', ['beacon-action__container'], [], buttons)
                    ], false))
                ])
            ])
        ])
    ]);
};
exports.constructAlertContainer = constructAlertContainer;
var constructDefaultAlert = function (id, callToAction, buttons, main) {
    return (0, exports.constructAlertContainer)(id, callToAction, buttons, [
        (0, html_elements_1.createSanitizedElement)('div', ['beacon-alert__text'], [['id', 'beacon-main-text']], main)
    ]);
};
exports.constructDefaultAlert = constructDefaultAlert;
var constructPairAlert = function (id, callToAction, buttons, main) {
    return (0, exports.constructAlertContainer)(id, callToAction, buttons, [
        (0, html_elements_1.createSanitizedElement)('span', [], [['id', 'pairing-container']], ''),
        (0, html_elements_1.createSanitizedElement)('div', ['beacon-alert__text'], [['id', 'beacon-main-text']], [
            (0, html_elements_1.createSanitizedElement)('p', ['beacon-list__title'], [['id', 'beacon-title']], __spreadArray([
                document.createTextNode('Scan QR code with a Beacon-compatible wallet.\u00A0'),
                (0, html_elements_1.createSanitizedElement)('a', [], [
                    ['href', 'https://docs.walletbeacon.io/supported-wallets'],
                    ['target', '_blank']
                ], 'Learn more')
            ], main, true))
        ]),
        (0, html_elements_1.createSanitizedElement)('div', [], [['id', 'beacon--switch__container']], [
            (0, html_elements_1.createSanitizedElement)('button', ['beacon-modal__button--outline'], [['id', 'beacon-switch']], '')
        ]),
        (0, html_elements_1.createSanitizedElement)('div', [], [['id', 'beacon--disclaimer']], '')
    ]);
};
exports.constructPairAlert = constructPairAlert;

},{"./html-elements":132}],136:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.secretbox_MACBYTES = exports.secretbox_NONCEBYTES = exports.generateGUID = exports.signMessage = exports.recipientString = exports.openCryptobox = exports.sealCryptobox = exports.getHexHash = exports.encryptCryptoboxPayload = exports.decryptCryptoboxPayload = exports.getAddressFromPublicKey = exports.toHex = exports.getKeypairFromSeed = exports.ExposedPromiseStatus = exports.ExposedPromise = exports.keys = void 0;
var keys_1 = require("./utils/keys");
Object.defineProperty(exports, "keys", { enumerable: true, get: function () { return keys_1.keys; } });
var exposed_promise_1 = require("./utils/exposed-promise");
Object.defineProperty(exports, "ExposedPromise", { enumerable: true, get: function () { return exposed_promise_1.ExposedPromise; } });
Object.defineProperty(exports, "ExposedPromiseStatus", { enumerable: true, get: function () { return exposed_promise_1.ExposedPromiseStatus; } });
var crypto_1 = require("./utils/crypto");
Object.defineProperty(exports, "getKeypairFromSeed", { enumerable: true, get: function () { return crypto_1.getKeypairFromSeed; } });
Object.defineProperty(exports, "toHex", { enumerable: true, get: function () { return crypto_1.toHex; } });
Object.defineProperty(exports, "getAddressFromPublicKey", { enumerable: true, get: function () { return crypto_1.getAddressFromPublicKey; } });
Object.defineProperty(exports, "decryptCryptoboxPayload", { enumerable: true, get: function () { return crypto_1.decryptCryptoboxPayload; } });
Object.defineProperty(exports, "encryptCryptoboxPayload", { enumerable: true, get: function () { return crypto_1.encryptCryptoboxPayload; } });
Object.defineProperty(exports, "getHexHash", { enumerable: true, get: function () { return crypto_1.getHexHash; } });
Object.defineProperty(exports, "sealCryptobox", { enumerable: true, get: function () { return crypto_1.sealCryptobox; } });
Object.defineProperty(exports, "openCryptobox", { enumerable: true, get: function () { return crypto_1.openCryptobox; } });
Object.defineProperty(exports, "recipientString", { enumerable: true, get: function () { return crypto_1.recipientString; } });
Object.defineProperty(exports, "signMessage", { enumerable: true, get: function () { return crypto_1.signMessage; } });
var generate_uuid_1 = require("./utils/generate-uuid");
Object.defineProperty(exports, "generateGUID", { enumerable: true, get: function () { return generate_uuid_1.generateGUID; } });
exports.secretbox_NONCEBYTES = 24; // crypto_secretbox_NONCEBYTES
exports.secretbox_MACBYTES = 16; // crypto_secretbox_MACBYTES

},{"./utils/crypto":137,"./utils/exposed-promise":138,"./utils/generate-uuid":139,"./utils/keys":140}],137:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.signMessage = exports.recipientString = exports.getAddressFromPublicKey = exports.openCryptobox = exports.sealCryptobox = exports.decryptCryptoboxPayload = exports.encryptCryptoboxPayload = exports.getKeypairFromSeed = exports.getHexHash = exports.toHex = exports.secretbox_MACBYTES = exports.secretbox_NONCEBYTES = void 0;
var bs58check = require("bs58check");
var nacl_1 = require("@stablelib/nacl");
var random_1 = require("@stablelib/random");
var utf8_1 = require("@stablelib/utf8");
var blake2b_1 = require("@stablelib/blake2b");
var ed25519_1 = require("@stablelib/ed25519");
var ed25519_2 = require("@stablelib/ed25519");
var blake2b_2 = require("@stablelib/blake2b");
var bytes_1 = require("@stablelib/bytes");
var ed25519_3 = require("@stablelib/ed25519");
exports.secretbox_NONCEBYTES = 24; // crypto_secretbox_NONCEBYTES
exports.secretbox_MACBYTES = 16; // crypto_secretbox_MACBYTES
/* eslint-disable prefer-arrow/prefer-arrow-functions */
/**
 * Convert a value to hex
 *
 * @param value
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function toHex(value) {
    return Buffer.from(value).toString('hex');
}
exports.toHex = toHex;
/**
 * Get the hex hash of a value
 *
 * @param key
 */
function getHexHash(key) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (typeof key === 'string') {
                return [2 /*return*/, toHex((0, blake2b_1.hash)((0, utf8_1.encode)(key), 32))];
            }
            return [2 /*return*/, toHex((0, blake2b_1.hash)(key, 32))];
        });
    });
}
exports.getHexHash = getHexHash;
/**
 * Get a keypair from a seed
 *
 * @param seed
 */
function getKeypairFromSeed(seed) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, (0, ed25519_1.generateKeyPairFromSeed)((0, blake2b_1.hash)((0, utf8_1.encode)(seed), 32))];
        });
    });
}
exports.getKeypairFromSeed = getKeypairFromSeed;
/**
 * Encrypt a message with a shared key
 *
 * @param message
 * @param sharedKey
 */
function encryptCryptoboxPayload(message, sharedKey) {
    return __awaiter(this, void 0, void 0, function () {
        var nonce, combinedPayload;
        return __generator(this, function (_a) {
            nonce = Buffer.from((0, random_1.randomBytes)(exports.secretbox_NONCEBYTES));
            combinedPayload = Buffer.concat([
                nonce,
                Buffer.from((0, nacl_1.secretBox)(sharedKey, nonce, Buffer.from(message, 'utf8')))
            ]);
            return [2 /*return*/, toHex(combinedPayload)];
        });
    });
}
exports.encryptCryptoboxPayload = encryptCryptoboxPayload;
/**
 * Decrypt a message with a shared key
 *
 * @param payload
 * @param sharedKey
 */
function decryptCryptoboxPayload(payload, sharedKey) {
    return __awaiter(this, void 0, void 0, function () {
        var nonce, ciphertext, openBox;
        return __generator(this, function (_a) {
            nonce = payload.slice(0, exports.secretbox_NONCEBYTES);
            ciphertext = payload.slice(exports.secretbox_NONCEBYTES);
            openBox = (0, nacl_1.openSecretBox)(sharedKey, nonce, ciphertext);
            if (!openBox) {
                throw new Error('Decryption failed');
            }
            return [2 /*return*/, Buffer.from(openBox).toString('utf8')];
        });
    });
}
exports.decryptCryptoboxPayload = decryptCryptoboxPayload;
/**
 * Encrypt a message with a public key
 *
 * @param payload
 * @param publicKey
 */
function sealCryptobox(payload, otherPublicKey) {
    return __awaiter(this, void 0, void 0, function () {
        var kxOtherPublicKey, keypair, state, nonce, bytesPayload, encryptedMessage;
        return __generator(this, function (_a) {
            kxOtherPublicKey = (0, ed25519_2.convertPublicKeyToX25519)(Buffer.from(otherPublicKey)) // Secret bytes to scalar bytes
            ;
            keypair = (0, nacl_1.generateKeyPair)();
            state = new blake2b_2.BLAKE2b(24);
            nonce = state.update(keypair.publicKey, 32).update(kxOtherPublicKey, 32).digest();
            bytesPayload = typeof payload === 'string' ? (0, utf8_1.encode)(payload) : payload;
            encryptedMessage = (0, nacl_1.box)(kxOtherPublicKey, keypair.secretKey, nonce, bytesPayload);
            return [2 /*return*/, toHex((0, bytes_1.concat)(keypair.publicKey, encryptedMessage))];
        });
    });
}
exports.sealCryptobox = sealCryptobox;
/**
 * Decrypt a message with public + private key
 *
 * @param encryptedPayload
 * @param publicKey
 * @param privateKey
 */
function openCryptobox(encryptedPayload, publicKey, privateKey) {
    return __awaiter(this, void 0, void 0, function () {
        var kxSelfPrivateKey, kxSelfPublicKey, bytesPayload, epk, ciphertext, state, nonce, decryptedMessage2;
        return __generator(this, function (_a) {
            kxSelfPrivateKey = (0, ed25519_2.convertSecretKeyToX25519)(Buffer.from(privateKey)) // Secret bytes to scalar bytes
            ;
            kxSelfPublicKey = (0, ed25519_2.convertPublicKeyToX25519)(Buffer.from(publicKey)) // Secret bytes to scalar bytes
            ;
            bytesPayload = typeof encryptedPayload === 'string' ? (0, utf8_1.encode)(encryptedPayload) : encryptedPayload;
            epk = bytesPayload.slice(0, 32);
            ciphertext = bytesPayload.slice(32);
            state = new blake2b_2.BLAKE2b(24);
            nonce = state.update(epk, 32).update(kxSelfPublicKey, 32).digest();
            decryptedMessage2 = (0, nacl_1.openBox)(epk, kxSelfPrivateKey, nonce, ciphertext);
            if (!decryptedMessage2) {
                throw new Error('Decryption failed');
            }
            return [2 /*return*/, Buffer.from(decryptedMessage2).toString()];
        });
    });
}
exports.openCryptobox = openCryptobox;
/**
 * Get an address from the public key
 *
 * @param publicKey
 */
function getAddressFromPublicKey(publicKey) {
    return __awaiter(this, void 0, void 0, function () {
        var prefixes, prefix, plainPublicKey, entries, index, _a, key, value, decoded, payload;
        return __generator(this, function (_b) {
            prefixes = {
                // tz1...
                edpk: {
                    length: 54,
                    prefix: Buffer.from(new Uint8Array([6, 161, 159]))
                },
                // tz2...
                sppk: {
                    length: 55,
                    prefix: Buffer.from(new Uint8Array([6, 161, 161]))
                },
                // tz3...
                p2pk: {
                    length: 55,
                    prefix: Buffer.from(new Uint8Array([6, 161, 164]))
                }
            };
            if (publicKey.length === 64) {
                prefix = prefixes.edpk.prefix;
                plainPublicKey = publicKey;
            }
            else {
                entries = Object.entries(prefixes);
                for (index = 0; index < entries.length; index++) {
                    _a = entries[index], key = _a[0], value = _a[1];
                    if (publicKey.startsWith(key) && publicKey.length === value.length) {
                        prefix = value.prefix;
                        decoded = bs58check.decode(publicKey);
                        plainPublicKey = decoded.slice(key.length, decoded.length).toString('hex');
                        break;
                    }
                }
            }
            if (!prefix || !plainPublicKey) {
                throw new Error("invalid publicKey: ".concat(publicKey));
            }
            payload = (0, blake2b_1.hash)(Buffer.from(plainPublicKey, 'hex'), 20);
            return [2 /*return*/, bs58check.encode(Buffer.concat([prefix, Buffer.from(payload)]))];
        });
    });
}
exports.getAddressFromPublicKey = getAddressFromPublicKey;
/**
 * Get the recipient string used in the matrix message
 *
 * @param recipientHash
 * @param relayServer
 */
function recipientString(recipientHash, relayServer) {
    return "@".concat(recipientHash, ":").concat(relayServer);
}
exports.recipientString = recipientString;
var toBuffer = function (message) { return __awaiter(void 0, void 0, void 0, function () {
    var adjustedMessage, buffer;
    return __generator(this, function (_a) {
        if (message.length % 2 !== 0) {
            return [2 /*return*/, (0, utf8_1.encode)(message)];
        }
        adjustedMessage = message;
        if (message.startsWith('0x')) {
            adjustedMessage = message.slice(2);
        }
        buffer = Buffer.from(adjustedMessage, 'hex');
        if (buffer.length === adjustedMessage.length / 2) {
            return [2 /*return*/, buffer];
        }
        return [2 /*return*/, (0, utf8_1.encode)(message)];
    });
}); };
var coinlibhash = function (message, size) {
    if (size === void 0) { size = 32; }
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, (0, blake2b_1.hash)(message, size)];
        });
    });
};
var signMessage = function (message, keypair) { return __awaiter(void 0, void 0, void 0, function () {
    var bufferMessage, edsigPrefix, hash, rawSignature, signature;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, toBuffer(message)];
            case 1:
                bufferMessage = _a.sent();
                edsigPrefix = new Uint8Array([9, 245, 205, 134, 18]);
                return [4 /*yield*/, coinlibhash(bufferMessage)];
            case 2:
                hash = _a.sent();
                rawSignature = (0, ed25519_3.sign)(keypair.secretKey, hash);
                signature = bs58check.encode(Buffer.concat([Buffer.from(edsigPrefix), Buffer.from(rawSignature)]));
                return [2 /*return*/, signature];
        }
    });
}); };
exports.signMessage = signMessage;
/* eslint-enable prefer-arrow/prefer-arrow-functions */

}).call(this)}).call(this,require("buffer").Buffer)
},{"@stablelib/blake2b":147,"@stablelib/bytes":148,"@stablelib/ed25519":150,"@stablelib/nacl":153,"@stablelib/random":156,"@stablelib/utf8":162,"bs58check":251,"buffer":3}],138:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExposedPromise = exports.ExposedPromiseStatus = void 0;
var ExposedPromiseStatus;
(function (ExposedPromiseStatus) {
    ExposedPromiseStatus["PENDING"] = "pending";
    ExposedPromiseStatus["RESOLVED"] = "resolved";
    ExposedPromiseStatus["REJECTED"] = "rejected";
})(ExposedPromiseStatus = exports.ExposedPromiseStatus || (exports.ExposedPromiseStatus = {}));
var notInitialized = function () {
    throw new Error('ExposedPromise not initialized yet.');
};
/**
 * Exposed promise allow you to create a promise and then resolve it later, from the outside
 */
var ExposedPromise = /** @class */ (function () {
    function ExposedPromise() {
        var _this = this;
        this._resolve = notInitialized;
        this._reject = notInitialized;
        this._status = ExposedPromiseStatus.PENDING;
        this._promise = new Promise(function (innerResolve, innerReject) {
            _this._resolve = function (value) {
                if (_this.isSettled()) {
                    return;
                }
                _this._promiseResult = value;
                innerResolve(value);
                _this._status = ExposedPromiseStatus.RESOLVED;
                return;
            };
            _this._reject = function (reason) {
                if (_this.isSettled()) {
                    return;
                }
                _this._promiseError = reason;
                innerReject(reason);
                _this._status = ExposedPromiseStatus.REJECTED;
                return;
            };
        });
    }
    Object.defineProperty(ExposedPromise.prototype, "promise", {
        get: function () {
            return this._promise;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ExposedPromise.prototype, "resolve", {
        get: function () {
            return this._resolve;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ExposedPromise.prototype, "reject", {
        get: function () {
            return this._reject;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ExposedPromise.prototype, "status", {
        get: function () {
            return this._status;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ExposedPromise.prototype, "promiseResult", {
        get: function () {
            return this._promiseResult;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ExposedPromise.prototype, "promiseError", {
        get: function () {
            return this._promiseError;
        },
        enumerable: false,
        configurable: true
    });
    ExposedPromise.resolve = function (value) {
        var promise = new ExposedPromise();
        promise.resolve(value);
        return promise;
    };
    ExposedPromise.reject = function (reason) {
        var promise = new ExposedPromise();
        promise.reject(reason);
        return promise;
    };
    ExposedPromise.prototype.isPending = function () {
        return this.status === ExposedPromiseStatus.PENDING;
    };
    ExposedPromise.prototype.isResolved = function () {
        return this.status === ExposedPromiseStatus.RESOLVED;
    };
    ExposedPromise.prototype.isRejected = function () {
        return this.status === ExposedPromiseStatus.REJECTED;
    };
    ExposedPromise.prototype.isSettled = function () {
        return this.isResolved() || this.isRejected();
    };
    return ExposedPromise;
}());
exports.ExposedPromise = ExposedPromise;

},{}],139:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateGUID = void 0;
/* eslint-disable prefer-arrow/prefer-arrow-functions */
var random_1 = require("@stablelib/random");
/**
 * Generate a random GUID
 */
function generateGUID() {
    return __awaiter(this, void 0, void 0, function () {
        var buf;
        return __generator(this, function (_a) {
            buf = (0, random_1.randomBytes)(16);
            return [2 /*return*/, [buf.slice(0, 4), buf.slice(4, 6), buf.slice(6, 8), buf.slice(8, 10), buf.slice(10, 16)]
                    .map(function (subbuf) {
                    return Buffer.from(subbuf).toString('hex');
                })
                    .join('-')];
        });
    });
}
exports.generateGUID = generateGUID;
/* eslint-enable prefer-arrow/prefer-arrow-functions */

}).call(this)}).call(this,require("buffer").Buffer)
},{"@stablelib/random":156,"buffer":3}],140:[function(require,module,exports){
"use strict";
/* eslint-disable prefer-arrow/prefer-arrow-functions */
Object.defineProperty(exports, "__esModule", { value: true });
exports.keys = void 0;
/**
 * A helper function to improve typings of object keys
 *
 * @param obj Object
 */
function keys(obj) {
    return Object.keys(obj);
}
exports.keys = keys;

},{}],141:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletClient = void 0;
var axios_1 = require("axios");
var beacon_core_1 = require("@airgap/beacon-core");
var beacon_utils_1 = require("@airgap/beacon-utils");
var beacon_types_1 = require("@airgap/beacon-types");
var WalletP2PTransport_1 = require("../transports/WalletP2PTransport");
var IncomingRequestInterceptor_1 = require("../interceptors/IncomingRequestInterceptor");
var OutgoingResponseInterceptor_1 = require("../interceptors/OutgoingResponseInterceptor");
var logger = new beacon_core_1.Logger('WalletClient');
/**
 * @publicapi
 *
 * The WalletClient has to be used in the wallet. It handles all the logic related to connecting to beacon-compatible
 * dapps and handling/responding to requests.
 *
 * @category Wallet
 */
var WalletClient = /** @class */ (function (_super) {
    __extends(WalletClient, _super);
    function WalletClient(config) {
        var _this = _super.call(this, __assign({ storage: config && config.storage ? config.storage : new beacon_core_1.LocalStorage() }, config)) || this;
        /**
         * Returns whether or not the transport is connected
         */
        _this._isConnected = new beacon_utils_1.ExposedPromise();
        /**
         * This array stores pending requests, meaning requests we received and have not yet handled / sent a response.
         */
        _this.pendingRequests = [];
        _this.permissionManager = new beacon_core_1.PermissionManager(_this.storage);
        _this.appMetadataManager = new beacon_core_1.AppMetadataManager(_this.storage);
        return _this;
    }
    Object.defineProperty(WalletClient.prototype, "isConnected", {
        get: function () {
            return this._isConnected.promise;
        },
        enumerable: false,
        configurable: true
    });
    WalletClient.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyPair, p2pTransport;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.keyPair]; // We wait for keypair here so the P2P Transport creation is not delayed and causing issues
                    case 1:
                        keyPair = _a.sent() // We wait for keypair here so the P2P Transport creation is not delayed and causing issues
                        ;
                        p2pTransport = new WalletP2PTransport_1.WalletP2PTransport(this.name, keyPair, this.storage, this.matrixNodes, this.iconUrl, this.appUrl);
                        return [2 /*return*/, _super.prototype.init.call(this, p2pTransport)];
                }
            });
        });
    };
    /**
     * This method initiates a connection to the P2P network and registers a callback that will be called
     * whenever a message is received.
     *
     * @param newMessageCallback The callback that will be invoked for every message the transport receives.
     */
    WalletClient.prototype.connect = function (newMessageCallback) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                this.handleResponse = function (message, connectionContext) { return __awaiter(_this, void 0, void 0, function () {
                    var typedMessage, typedMessage;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!(message.version === '3')) return [3 /*break*/, 4];
                                typedMessage = message;
                                if (typedMessage.message.type === beacon_types_1.BeaconMessageType.Disconnect) {
                                    return [2 /*return*/, this.disconnect(typedMessage.senderId)];
                                }
                                if (!!this.pendingRequests.some(function (request) { return request[0].id === message.id; })) return [3 /*break*/, 3];
                                this.pendingRequests.push([typedMessage, connectionContext]);
                                return [4 /*yield*/, this.sendAcknowledgeResponse(typedMessage, connectionContext)];
                            case 1:
                                _a.sent();
                                return [4 /*yield*/, IncomingRequestInterceptor_1.IncomingRequestInterceptor.intercept({
                                        message: typedMessage,
                                        connectionInfo: connectionContext,
                                        appMetadataManager: this.appMetadataManager,
                                        interceptorCallback: newMessageCallback
                                    })];
                            case 2:
                                _a.sent();
                                _a.label = 3;
                            case 3: return [3 /*break*/, 8];
                            case 4:
                                typedMessage = message;
                                if (typedMessage.type === beacon_types_1.BeaconMessageType.Disconnect) {
                                    return [2 /*return*/, this.disconnect(typedMessage.senderId)];
                                }
                                if (!!this.pendingRequests.some(function (request) { return request[0].id === message.id; })) return [3 /*break*/, 8];
                                this.pendingRequests.push([typedMessage, connectionContext]);
                                if (!(typedMessage.version !== '1')) return [3 /*break*/, 6];
                                return [4 /*yield*/, this.sendAcknowledgeResponse(typedMessage, connectionContext)];
                            case 5:
                                _a.sent();
                                _a.label = 6;
                            case 6: return [4 /*yield*/, IncomingRequestInterceptor_1.IncomingRequestInterceptor.intercept({
                                    message: typedMessage,
                                    connectionInfo: connectionContext,
                                    appMetadataManager: this.appMetadataManager,
                                    interceptorCallback: newMessageCallback
                                })];
                            case 7:
                                _a.sent();
                                _a.label = 8;
                            case 8: return [2 /*return*/];
                        }
                    });
                }); };
                return [2 /*return*/, this._connect()];
            });
        });
    };
    WalletClient.prototype.getRegisterPushChallenge = function (backendUrl, accountPublicKey, oracleUrl) {
        if (oracleUrl === void 0) { oracleUrl = beacon_core_1.NOTIFICATION_ORACLE_URL; }
        return __awaiter(this, void 0, void 0, function () {
            var challenge, constructedString, bytes, payloadBytes;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, axios_1.default.get("".concat(oracleUrl, "/challenge"))];
                    case 1:
                        challenge = (_a.sent())
                            .data;
                        constructedString = [
                            'Tezos Signed Message: ',
                            challenge.id,
                            challenge.timestamp,
                            accountPublicKey,
                            backendUrl
                        ].join(' ');
                        bytes = (0, beacon_utils_1.toHex)(constructedString);
                        payloadBytes = '05' + '01' + bytes.length.toString(16).padStart(8, '0') + bytes;
                        return [2 /*return*/, {
                                challenge: challenge,
                                payloadToSign: payloadBytes
                            }];
                }
            });
        });
    };
    WalletClient.prototype.registerPush = function (challenge, signature, backendUrl, accountPublicKey, protocolIdentifier, deviceId, oracleUrl) {
        if (oracleUrl === void 0) { oracleUrl = beacon_core_1.NOTIFICATION_ORACLE_URL; }
        return __awaiter(this, void 0, void 0, function () {
            var tokens, token, register, newToken;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.storage.get(beacon_types_1.StorageKey.PUSH_TOKENS)];
                    case 1:
                        tokens = _a.sent();
                        token = tokens.find(function (el) { return el.publicKey === accountPublicKey && el.backendUrl === backendUrl; });
                        if (token) {
                            return [2 /*return*/, token];
                        }
                        return [4 /*yield*/, axios_1.default.post("".concat(oracleUrl, "/register"), {
                                name: this.name,
                                challenge: challenge,
                                accountPublicKey: accountPublicKey,
                                signature: signature,
                                backendUrl: backendUrl,
                                protocolIdentifier: protocolIdentifier,
                                deviceId: deviceId
                            })];
                    case 2:
                        register = (_a.sent()).data;
                        newToken = {
                            publicKey: accountPublicKey,
                            backendUrl: backendUrl,
                            accessToken: register.accessToken,
                            managementToken: register.managementToken
                        };
                        tokens.push(newToken);
                        return [4 /*yield*/, this.storage.set(beacon_types_1.StorageKey.PUSH_TOKENS, tokens)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, newToken];
                }
            });
        });
    };
    /**
     * The method will attempt to initiate a connection using the active transport.
     */
    WalletClient.prototype._connect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var transport;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.transport];
                    case 1:
                        transport = (_a.sent());
                        if (!(transport.connectionStatus === beacon_types_1.TransportStatus.NOT_CONNECTED)) return [3 /*break*/, 3];
                        return [4 /*yield*/, transport.connect()];
                    case 2:
                        _a.sent();
                        transport
                            .addListener(function (message, connectionInfo) { return __awaiter(_this, void 0, void 0, function () {
                            var deserializedMessage;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (!(typeof message === 'string')) return [3 /*break*/, 2];
                                        return [4 /*yield*/, new beacon_core_1.Serializer().deserialize(message)];
                                    case 1:
                                        deserializedMessage = (_a.sent());
                                        this.handleResponse(deserializedMessage, connectionInfo);
                                        _a.label = 2;
                                    case 2: return [2 /*return*/];
                                }
                            });
                        }); })
                            .catch(function (error) { return logger.log('_connect', error); });
                        this._isConnected.resolve(true);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * This method sends a response for a specific request back to the DApp
     *
     * @param message The BeaconResponseMessage that will be sent back to the DApp
     */
    WalletClient.prototype.respond = function (message) {
        return __awaiter(this, void 0, void 0, function () {
            var request, _a, _b, _c;
            var _d;
            var _this = this;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        console.log('RESPONSE', message);
                        request = this.pendingRequests.find(function (pendingRequest) { return pendingRequest[0].id === message.id; });
                        if (!request) {
                            throw new Error('No matching request found!');
                        }
                        this.pendingRequests = this.pendingRequests.filter(function (pendingRequest) { return pendingRequest[0].id !== message.id; });
                        _b = (_a = OutgoingResponseInterceptor_1.OutgoingResponseInterceptor).intercept;
                        _d = {};
                        _c = beacon_core_1.getSenderId;
                        return [4 /*yield*/, this.beaconId];
                    case 1: return [4 /*yield*/, _c.apply(void 0, [_e.sent()])];
                    case 2:
                        _d.senderId = _e.sent(),
                            _d.request = request[0],
                            _d.message = message;
                        return [4 /*yield*/, this.getOwnAppMetadata()];
                    case 3: return [4 /*yield*/, _b.apply(_a, [(_d.ownAppMetadata = _e.sent(),
                                _d.permissionManager = this.permissionManager,
                                _d.appMetadataManager = this.appMetadataManager,
                                _d.interceptorCallback = function (response) { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, this.respondToMessage(response, request[1])];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); },
                                _d)])];
                    case 4:
                        _e.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    WalletClient.prototype.getAppMetadataList = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.appMetadataManager.getAppMetadataList()];
            });
        });
    };
    WalletClient.prototype.getAppMetadata = function (senderId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.appMetadataManager.getAppMetadata(senderId)];
            });
        });
    };
    WalletClient.prototype.removeAppMetadata = function (senderId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.appMetadataManager.removeAppMetadata(senderId)];
            });
        });
    };
    WalletClient.prototype.removeAllAppMetadata = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.appMetadataManager.removeAllAppMetadata()];
            });
        });
    };
    WalletClient.prototype.getPermissions = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.permissionManager.getPermissions()];
            });
        });
    };
    WalletClient.prototype.getPermission = function (accountIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.permissionManager.getPermission(accountIdentifier)];
            });
        });
    };
    WalletClient.prototype.removePermission = function (accountIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.permissionManager.removePermission(accountIdentifier)];
            });
        });
    };
    WalletClient.prototype.removeAllPermissions = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.permissionManager.removeAllPermissions()];
            });
        });
    };
    /**
     * Add a new peer to the known peers
     * @param peer The new peer to add
     */
    WalletClient.prototype.addPeer = function (peer, sendPairingResponse) {
        if (sendPairingResponse === void 0) { sendPairingResponse = true; }
        return __awaiter(this, void 0, void 0, function () {
            var extendedPeer, _a;
            var _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = [__assign({}, peer)];
                        _b = {};
                        return [4 /*yield*/, (0, beacon_core_1.getSenderId)(peer.publicKey)];
                    case 1:
                        extendedPeer = __assign.apply(void 0, _a.concat([(_b.senderId = _c.sent(), _b)]));
                        return [4 /*yield*/, this.transport];
                    case 2: return [2 /*return*/, (_c.sent()).addPeer(extendedPeer, sendPairingResponse)];
                }
            });
        });
    };
    WalletClient.prototype.removePeer = function (peer, sendDisconnectToPeer) {
        if (sendDisconnectToPeer === void 0) { sendDisconnectToPeer = false; }
        return __awaiter(this, void 0, void 0, function () {
            var removePeerResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.transport];
                    case 1:
                        removePeerResult = (_a.sent()).removePeer(peer);
                        return [4 /*yield*/, this.removePermissionsForPeers([peer])];
                    case 2:
                        _a.sent();
                        if (!sendDisconnectToPeer) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.sendDisconnectToPeer(peer)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [2 /*return*/, removePeerResult];
                }
            });
        });
    };
    WalletClient.prototype.removeAllPeers = function (sendDisconnectToPeers) {
        if (sendDisconnectToPeers === void 0) { sendDisconnectToPeers = false; }
        return __awaiter(this, void 0, void 0, function () {
            var peers, removePeerResult, disconnectPromises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.transport];
                    case 1: return [4 /*yield*/, (_a.sent()).getPeers()];
                    case 2:
                        peers = _a.sent();
                        return [4 /*yield*/, this.transport];
                    case 3:
                        removePeerResult = (_a.sent()).removeAllPeers();
                        return [4 /*yield*/, this.removePermissionsForPeers(peers)];
                    case 4:
                        _a.sent();
                        if (!sendDisconnectToPeers) return [3 /*break*/, 6];
                        disconnectPromises = peers.map(function (peer) { return _this.sendDisconnectToPeer(peer); });
                        return [4 /*yield*/, Promise.all(disconnectPromises)];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6: return [2 /*return*/, removePeerResult];
                }
            });
        });
    };
    WalletClient.prototype.removePermissionsForPeers = function (peersToRemove) {
        return __awaiter(this, void 0, void 0, function () {
            var permissions, peerIdsToRemove, permissionsToRemove, permissionIdentifiersToRemove;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.permissionManager.getPermissions()];
                    case 1:
                        permissions = _a.sent();
                        peerIdsToRemove = peersToRemove.map(function (peer) { return peer.senderId; });
                        permissionsToRemove = permissions.filter(function (permission) {
                            return peerIdsToRemove.includes(permission.appMetadata.senderId);
                        });
                        permissionIdentifiersToRemove = permissionsToRemove.map(function (permissionInfo) { return permissionInfo.accountIdentifier; });
                        return [4 /*yield*/, this.permissionManager.removePermissions(permissionIdentifiersToRemove)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Send an acknowledge message back to the sender
     *
     * @param message The message that was received
     */
    WalletClient.prototype.sendAcknowledgeResponse = function (request, connectionContext) {
        return __awaiter(this, void 0, void 0, function () {
            var acknowledgeResponse, _a, _b, _c;
            var _d;
            var _this = this;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        acknowledgeResponse = {
                            id: request.id,
                            type: beacon_types_1.BeaconMessageType.Acknowledge
                        };
                        _b = (_a = OutgoingResponseInterceptor_1.OutgoingResponseInterceptor).intercept;
                        _d = {};
                        _c = beacon_core_1.getSenderId;
                        return [4 /*yield*/, this.beaconId];
                    case 1: return [4 /*yield*/, _c.apply(void 0, [_e.sent()])];
                    case 2:
                        _d.senderId = _e.sent(),
                            _d.request = request,
                            _d.message = acknowledgeResponse;
                        return [4 /*yield*/, this.getOwnAppMetadata()];
                    case 3: return [4 /*yield*/, _b.apply(_a, [(_d.ownAppMetadata = _e.sent(),
                                _d.permissionManager = this.permissionManager,
                                _d.appMetadataManager = this.appMetadataManager,
                                _d.interceptorCallback = function (response) { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, this.respondToMessage(response, connectionContext)];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); },
                                _d)])];
                    case 4:
                        _e.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * An internal method to send a BeaconMessage to the DApp
     *
     * @param response Send a message back to the DApp
     */
    WalletClient.prototype.respondToMessage = function (response, connectionContext) {
        return __awaiter(this, void 0, void 0, function () {
            var serializedMessage, peerInfos, peer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new beacon_core_1.Serializer().serialize(response)];
                    case 1:
                        serializedMessage = _a.sent();
                        if (!connectionContext) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.getPeers()];
                    case 2:
                        peerInfos = _a.sent();
                        peer = peerInfos.find(function (peerInfo) { return peerInfo.publicKey === connectionContext.id; });
                        return [4 /*yield*/, this.transport];
                    case 3: return [4 /*yield*/, (_a.sent()).send(serializedMessage, peer)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 8];
                    case 5: return [4 /*yield*/, this.transport];
                    case 6: return [4 /*yield*/, (_a.sent()).send(serializedMessage)];
                    case 7:
                        _a.sent();
                        _a.label = 8;
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    WalletClient.prototype.disconnect = function (senderId) {
        return __awaiter(this, void 0, void 0, function () {
            var transport, peers, peer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.transport];
                    case 1:
                        transport = _a.sent();
                        return [4 /*yield*/, transport.getPeers()];
                    case 2:
                        peers = _a.sent();
                        peer = peers.find(function (peerEl) { return peerEl.senderId === senderId; });
                        if (!peer) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.removePeer(peer)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    return WalletClient;
}(beacon_core_1.Client));
exports.WalletClient = WalletClient;

},{"../interceptors/IncomingRequestInterceptor":143,"../interceptors/OutgoingResponseInterceptor":144,"../transports/WalletP2PTransport":145,"@airgap/beacon-core":58,"@airgap/beacon-types":104,"@airgap/beacon-utils":136,"axios":212}],142:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletClient = void 0;
__exportStar(require("@airgap/beacon-core"), exports);
__exportStar(require("@airgap/beacon-transport-matrix"), exports);
__exportStar(require("@airgap/beacon-types"), exports);
__exportStar(require("@airgap/beacon-utils"), exports);
var WalletClient_1 = require("./client/WalletClient");
Object.defineProperty(exports, "WalletClient", { enumerable: true, get: function () { return WalletClient_1.WalletClient; } });

},{"./client/WalletClient":141,"@airgap/beacon-core":58,"@airgap/beacon-transport-matrix":88,"@airgap/beacon-types":104,"@airgap/beacon-utils":136}],143:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IncomingRequestInterceptor = void 0;
var beacon_types_1 = require("@airgap/beacon-types");
var beacon_core_1 = require("@airgap/beacon-core");
var logger = new beacon_core_1.Logger('IncomingRequestInterceptor');
/**
 * @internalapi
 *
 * The IncomingRequestInterceptor is used in the WalletClient to intercept an incoming request and enrich it with data, like app metadata.
 */
var IncomingRequestInterceptor = /** @class */ (function () {
    function IncomingRequestInterceptor() {
    }
    /**
     * The method that is called during the interception
     *
     * @param config
     */
    IncomingRequestInterceptor.intercept = function (config) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                console.log('INTERCEPTING REQUEST', config.message);
                if (config.message.version === '2') {
                    IncomingRequestInterceptor.handleV2Message(config);
                }
                else if (config.message.version === '3') {
                    IncomingRequestInterceptor.handleV3Message(config);
                }
                return [2 /*return*/];
            });
        });
    };
    IncomingRequestInterceptor.getAppMetadata = function (appMetadataManager, senderId) {
        return __awaiter(this, void 0, void 0, function () {
            var appMetadata;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, appMetadataManager.getAppMetadata(senderId)];
                    case 1:
                        appMetadata = _a.sent();
                        if (!appMetadata) {
                            throw new Error('AppMetadata not found');
                        }
                        return [2 /*return*/, appMetadata];
                }
            });
        });
    };
    IncomingRequestInterceptor.handleV2Message = function (config) {
        return __awaiter(this, void 0, void 0, function () {
            var message, connectionInfo, appMetadataManager, interceptorCallback, _a, request, appMetadata, request, appMetadata, request, appMetadata, request;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        message = config.message, connectionInfo = config.connectionInfo, appMetadataManager = config.appMetadataManager, interceptorCallback = config.interceptorCallback;
                        _a = message.type;
                        switch (_a) {
                            case beacon_types_1.BeaconMessageType.PermissionRequest: return [3 /*break*/, 1];
                            case beacon_types_1.BeaconMessageType.OperationRequest: return [3 /*break*/, 3];
                            case beacon_types_1.BeaconMessageType.SignPayloadRequest: return [3 /*break*/, 5];
                            case beacon_types_1.BeaconMessageType.BroadcastRequest: return [3 /*break*/, 7];
                        }
                        return [3 /*break*/, 9];
                    case 1:
                        console.log('PERMISSION REQUEST V*', message);
                        // TODO: Remove v1 compatibility in later version
                        if (message.appMetadata.beaconId && !message.appMetadata.senderId) {
                            message.appMetadata.senderId = message.appMetadata.beaconId;
                            delete message.appMetadata.beaconId;
                        }
                        return [4 /*yield*/, appMetadataManager.addAppMetadata(message.appMetadata)];
                    case 2:
                        _b.sent();
                        request = message;
                        interceptorCallback(request, connectionInfo);
                        return [3 /*break*/, 10];
                    case 3: return [4 /*yield*/, IncomingRequestInterceptor.getAppMetadata(appMetadataManager, message.senderId)];
                    case 4:
                        appMetadata = _b.sent();
                        request = __assign({ appMetadata: appMetadata }, message);
                        interceptorCallback(request, connectionInfo);
                        return [3 /*break*/, 10];
                    case 5: return [4 /*yield*/, IncomingRequestInterceptor.getAppMetadata(appMetadataManager, message.senderId)];
                    case 6:
                        appMetadata = _b.sent();
                        request = __assign({ appMetadata: appMetadata }, message);
                        interceptorCallback(request, connectionInfo);
                        return [3 /*break*/, 10];
                    case 7: return [4 /*yield*/, IncomingRequestInterceptor.getAppMetadata(appMetadataManager, message.senderId)];
                    case 8:
                        appMetadata = _b.sent();
                        request = __assign({ appMetadata: appMetadata }, message);
                        interceptorCallback(request, connectionInfo);
                        return [3 /*break*/, 10];
                    case 9:
                        logger.log('intercept', 'Message not handled');
                        assertNever(message);
                        _b.label = 10;
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    IncomingRequestInterceptor.handleV3Message = function (config) {
        return __awaiter(this, void 0, void 0, function () {
            var msg, connectionInfo, appMetadataManager, interceptorCallback, wrappedMessage, v3Message, _a, request /* PermissionRequestOutput */, request /* BeaconMessageWrapper<BlockchainRequestV3<string>> */;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        msg = config.message, connectionInfo = config.connectionInfo, appMetadataManager = config.appMetadataManager, interceptorCallback = config.interceptorCallback;
                        wrappedMessage = msg /* TODO: Remove any */;
                        v3Message = wrappedMessage.message;
                        _a = v3Message.type;
                        switch (_a) {
                            case beacon_types_1.BeaconMessageType.PermissionRequest: return [3 /*break*/, 1];
                            case beacon_types_1.BeaconMessageType.BlockchainRequest: return [3 /*break*/, 3];
                        }
                        return [3 /*break*/, 4];
                    case 1: return [4 /*yield*/, appMetadataManager.addAppMetadata(__assign(__assign({}, v3Message.blockchainData.appMetadata), { senderId: msg.senderId }))]; // Make sure we use the actual senderId, not what the dApp told us
                    case 2:
                        _b.sent(); // Make sure we use the actual senderId, not what the dApp told us
                        request = wrappedMessage;
                        interceptorCallback(request, connectionInfo);
                        return [3 /*break*/, 5];
                    case 3:
                        {
                            request = __assign({}, wrappedMessage);
                            interceptorCallback(request, connectionInfo);
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        logger.log('intercept', 'Message not handled');
                        assertNever(v3Message);
                        _b.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return IncomingRequestInterceptor;
}());
exports.IncomingRequestInterceptor = IncomingRequestInterceptor;
function assertNever(_message) {
    throw new Error('Function not implemented.');
}

},{"@airgap/beacon-core":58,"@airgap/beacon-types":104}],144:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OutgoingResponseInterceptor = void 0;
var beacon_core_1 = require("@airgap/beacon-core");
var beacon_types_1 = require("@airgap/beacon-types");
var beacon_utils_1 = require("@airgap/beacon-utils");
var logger = new beacon_core_1.Logger('OutgoingResponseInterceptor');
/**
 * @internalapi
 *
 * The OutgoingResponseInterceptor is used in the WalletClient to intercept an outgoing response and enrich it with data.
 */
var OutgoingResponseInterceptor = /** @class */ (function () {
    function OutgoingResponseInterceptor() {
    }
    OutgoingResponseInterceptor.intercept = function (config) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (config.request.version === '2') {
                    OutgoingResponseInterceptor.handleV2Message(config);
                }
                else if (config.request.version === '3') {
                    OutgoingResponseInterceptor.handleV3Message(config);
                }
                return [2 /*return*/];
            });
        });
    };
    OutgoingResponseInterceptor.handleV3Message = function (config) {
        return __awaiter(this, void 0, void 0, function () {
            var msg, 
            // ownAppMetadata,
            // permissionManager,
            appMetadataManager, interceptorCallback, wrappedMessage, v3Message;
            return __generator(this, function (_a) {
                msg = config.message, appMetadataManager = config.appMetadataManager, interceptorCallback = config.interceptorCallback;
                wrappedMessage = msg;
                v3Message = wrappedMessage.message;
                console.log('LOGGING OUTGOING V3', v3Message, appMetadataManager);
                interceptorCallback(msg);
                return [2 /*return*/];
            });
        });
    };
    OutgoingResponseInterceptor.handleV2Message = function (config) {
        return __awaiter(this, void 0, void 0, function () {
            var senderId, request, message, ownAppMetadata, permissionManager, appMetadataManager, interceptorCallback, _a, response, errorData, response, response, publicKey, address, appMetadata, permission, response, response, response;
            var _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        senderId = config.senderId, request = config.request, message = config.message, ownAppMetadata = config.ownAppMetadata, permissionManager = config.permissionManager, appMetadataManager = config.appMetadataManager, interceptorCallback = config.interceptorCallback;
                        _a = message.type;
                        switch (_a) {
                            case beacon_types_1.BeaconMessageType.Error: return [3 /*break*/, 1];
                            case beacon_types_1.BeaconMessageType.Acknowledge: return [3 /*break*/, 2];
                            case beacon_types_1.BeaconMessageType.PermissionResponse: return [3 /*break*/, 3];
                            case beacon_types_1.BeaconMessageType.OperationResponse: return [3 /*break*/, 7];
                            case beacon_types_1.BeaconMessageType.SignPayloadResponse: return [3 /*break*/, 8];
                            case beacon_types_1.BeaconMessageType.BroadcastResponse: return [3 /*break*/, 9];
                        }
                        return [3 /*break*/, 10];
                    case 1:
                        {
                            response = {
                                type: message.type,
                                version: '2',
                                senderId: senderId,
                                id: message.id,
                                errorType: message.errorType
                            };
                            if (message.errorType === beacon_types_1.BeaconErrorType.TRANSACTION_INVALID_ERROR && message.errorData) {
                                errorData = message.errorData;
                                // Check if error data is in correct format
                                if (Array.isArray(errorData) &&
                                    errorData.every(function (item) { return Boolean(item.kind) && Boolean(item.id); })) {
                                    response.errorData = message.errorData;
                                }
                                else {
                                    logger.warn('ErrorData provided is not in correct format. It needs to be an array of RPC errors. It will not be included in the message sent to the dApp');
                                }
                            }
                            interceptorCallback(response);
                            return [3 /*break*/, 11];
                        }
                        _c.label = 2;
                    case 2:
                        {
                            response = {
                                type: message.type,
                                version: '2',
                                senderId: senderId,
                                id: message.id
                            };
                            interceptorCallback(response);
                            return [3 /*break*/, 11];
                        }
                        _c.label = 3;
                    case 3:
                        response = __assign({ senderId: senderId, version: '2', appMetadata: ownAppMetadata }, message);
                        publicKey = response.publicKey;
                        return [4 /*yield*/, (0, beacon_utils_1.getAddressFromPublicKey)(publicKey)];
                    case 4:
                        address = _c.sent();
                        return [4 /*yield*/, appMetadataManager.getAppMetadata(request.senderId)];
                    case 5:
                        appMetadata = _c.sent();
                        if (!appMetadata) {
                            throw new Error('AppMetadata not found');
                        }
                        _b = {};
                        return [4 /*yield*/, (0, beacon_core_1.getAccountIdentifier)(address, response.network)];
                    case 6:
                        permission = (_b.accountIdentifier = _c.sent(),
                            _b.senderId = request.senderId,
                            _b.appMetadata = appMetadata,
                            _b.website = '',
                            _b.address = address,
                            _b.publicKey = publicKey,
                            _b.network = response.network,
                            _b.scopes = response.scopes,
                            _b.connectedAt = new Date().getTime(),
                            _b);
                        permissionManager.addPermission(permission).catch(console.error);
                        interceptorCallback(response);
                        return [3 /*break*/, 11];
                    case 7:
                        {
                            response = __assign({ senderId: senderId, version: '2' }, message);
                            interceptorCallback(response);
                        }
                        return [3 /*break*/, 11];
                    case 8:
                        {
                            response = __assign({ senderId: senderId, version: '2' }, message);
                            interceptorCallback(response);
                        }
                        return [3 /*break*/, 11];
                    case 9:
                        {
                            response = __assign({ senderId: senderId, version: '2' }, message);
                            interceptorCallback(response);
                        }
                        return [3 /*break*/, 11];
                    case 10:
                        logger.log('intercept', 'Message not handled');
                        assertNever(message);
                        _c.label = 11;
                    case 11: return [2 /*return*/];
                }
            });
        });
    };
    return OutgoingResponseInterceptor;
}());
exports.OutgoingResponseInterceptor = OutgoingResponseInterceptor;
function assertNever(_message) {
    throw new Error('Function not implemented.');
}

},{"@airgap/beacon-core":58,"@airgap/beacon-types":104,"@airgap/beacon-utils":136}],145:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletP2PTransport = void 0;
var beacon_types_1 = require("@airgap/beacon-types");
var beacon_transport_matrix_1 = require("@airgap/beacon-transport-matrix");
// const logger = new Logger('DappP2PTransport')
/**
 * @internalapi
 *
 *
 */
var WalletP2PTransport = /** @class */ (function (_super) {
    __extends(WalletP2PTransport, _super);
    function WalletP2PTransport(name, keyPair, storage, matrixNodes, iconUrl, appUrl) {
        return _super.call(this, name, keyPair, storage, matrixNodes, beacon_types_1.StorageKey.TRANSPORT_P2P_PEERS_WALLET, iconUrl, appUrl) || this;
    }
    WalletP2PTransport.prototype.addPeer = function (newPeer, sendPairingResponse) {
        if (sendPairingResponse === void 0) { sendPairingResponse = true; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, _super.prototype.addPeer.call(this, newPeer)];
                    case 1:
                        _a.sent();
                        if (!sendPairingResponse) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.client.sendPairingResponse(newPeer)]; // TODO: Should we have a confirmation here?
                    case 2:
                        _a.sent(); // TODO: Should we have a confirmation here?
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    return WalletP2PTransport;
}(beacon_transport_matrix_1.P2PTransport));
exports.WalletP2PTransport = WalletP2PTransport;

},{"@airgap/beacon-transport-matrix":88,"@airgap/beacon-types":104}],146:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package binary provides functions for encoding and decoding numbers in byte arrays.
 */
var int_1 = require("@stablelib/int");
// TODO(dchest): add asserts for correct value ranges and array offsets.
/**
 * Reads 2 bytes from array starting at offset as big-endian
 * signed 16-bit integer and returns it.
 */
function readInt16BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (((array[offset + 0] << 8) | array[offset + 1]) << 16) >> 16;
}
exports.readInt16BE = readInt16BE;
/**
 * Reads 2 bytes from array starting at offset as big-endian
 * unsigned 16-bit integer and returns it.
 */
function readUint16BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset + 0] << 8) | array[offset + 1]) >>> 0;
}
exports.readUint16BE = readUint16BE;
/**
 * Reads 2 bytes from array starting at offset as little-endian
 * signed 16-bit integer and returns it.
 */
function readInt16LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (((array[offset + 1] << 8) | array[offset]) << 16) >> 16;
}
exports.readInt16LE = readInt16LE;
/**
 * Reads 2 bytes from array starting at offset as little-endian
 * unsigned 16-bit integer and returns it.
 */
function readUint16LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset + 1] << 8) | array[offset]) >>> 0;
}
exports.readUint16LE = readUint16LE;
/**
 * Writes 2-byte big-endian representation of 16-bit unsigned
 * value to byte array starting at offset.
 *
 * If byte array is not given, creates a new 2-byte one.
 *
 * Returns the output byte array.
 */
function writeUint16BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(2); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 8;
    out[offset + 1] = value >>> 0;
    return out;
}
exports.writeUint16BE = writeUint16BE;
exports.writeInt16BE = writeUint16BE;
/**
 * Writes 2-byte little-endian representation of 16-bit unsigned
 * value to array starting at offset.
 *
 * If byte array is not given, creates a new 2-byte one.
 *
 * Returns the output byte array.
 */
function writeUint16LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(2); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 0;
    out[offset + 1] = value >>> 8;
    return out;
}
exports.writeUint16LE = writeUint16LE;
exports.writeInt16LE = writeUint16LE;
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * signed 32-bit integer and returns it.
 */
function readInt32BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (array[offset] << 24) |
        (array[offset + 1] << 16) |
        (array[offset + 2] << 8) |
        array[offset + 3];
}
exports.readInt32BE = readInt32BE;
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * unsigned 32-bit integer and returns it.
 */
function readUint32BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset] << 24) |
        (array[offset + 1] << 16) |
        (array[offset + 2] << 8) |
        array[offset + 3]) >>> 0;
}
exports.readUint32BE = readUint32BE;
/**
 * Reads 4 bytes from array starting at offset as little-endian
 * signed 32-bit integer and returns it.
 */
function readInt32LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (array[offset + 3] << 24) |
        (array[offset + 2] << 16) |
        (array[offset + 1] << 8) |
        array[offset];
}
exports.readInt32LE = readInt32LE;
/**
 * Reads 4 bytes from array starting at offset as little-endian
 * unsigned 32-bit integer and returns it.
 */
function readUint32LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset + 3] << 24) |
        (array[offset + 2] << 16) |
        (array[offset + 1] << 8) |
        array[offset]) >>> 0;
}
exports.readUint32LE = readUint32LE;
/**
 * Writes 4-byte big-endian representation of 32-bit unsigned
 * value to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeUint32BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 24;
    out[offset + 1] = value >>> 16;
    out[offset + 2] = value >>> 8;
    out[offset + 3] = value >>> 0;
    return out;
}
exports.writeUint32BE = writeUint32BE;
exports.writeInt32BE = writeUint32BE;
/**
 * Writes 4-byte little-endian representation of 32-bit unsigned
 * value to array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeUint32LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 0;
    out[offset + 1] = value >>> 8;
    out[offset + 2] = value >>> 16;
    out[offset + 3] = value >>> 24;
    return out;
}
exports.writeUint32LE = writeUint32LE;
exports.writeInt32LE = writeUint32LE;
/**
 * Reads 8 bytes from array starting at offset as big-endian
 * signed 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports exact
 * numbers in range -9007199254740991 to 9007199254740991.
 * If the number stored in the byte array is outside this range,
 * the result is not exact.
 */
function readInt64BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var hi = readInt32BE(array, offset);
    var lo = readInt32BE(array, offset + 4);
    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);
}
exports.readInt64BE = readInt64BE;
/**
 * Reads 8 bytes from array starting at offset as big-endian
 * unsigned 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.
 */
function readUint64BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var hi = readUint32BE(array, offset);
    var lo = readUint32BE(array, offset + 4);
    return hi * 0x100000000 + lo;
}
exports.readUint64BE = readUint64BE;
/**
 * Reads 8 bytes from array starting at offset as little-endian
 * signed 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports exact
 * numbers in range -9007199254740991 to 9007199254740991.
 * If the number stored in the byte array is outside this range,
 * the result is not exact.
 */
function readInt64LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var lo = readInt32LE(array, offset);
    var hi = readInt32LE(array, offset + 4);
    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);
}
exports.readInt64LE = readInt64LE;
/**
 * Reads 8 bytes from array starting at offset as little-endian
 * unsigned 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.
 */
function readUint64LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var lo = readUint32LE(array, offset);
    var hi = readUint32LE(array, offset + 4);
    return hi * 0x100000000 + lo;
}
exports.readUint64LE = readUint64LE;
/**
 * Writes 8-byte big-endian representation of 64-bit unsigned
 * value to byte array starting at offset.
 *
 * Due to JavaScript limitation, supports values up to 2^53-1.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeUint64BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    writeUint32BE(value / 0x100000000 >>> 0, out, offset);
    writeUint32BE(value >>> 0, out, offset + 4);
    return out;
}
exports.writeUint64BE = writeUint64BE;
exports.writeInt64BE = writeUint64BE;
/**
 * Writes 8-byte little-endian representation of 64-bit unsigned
 * value to byte array starting at offset.
 *
 * Due to JavaScript limitation, supports values up to 2^53-1.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeUint64LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    writeUint32LE(value >>> 0, out, offset);
    writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);
    return out;
}
exports.writeUint64LE = writeUint64LE;
exports.writeInt64LE = writeUint64LE;
/**
 * Reads bytes from array starting at offset as big-endian
 * unsigned bitLen-bit integer and returns it.
 *
 * Supports bit lengths divisible by 8, up to 48.
 */
function readUintBE(bitLength, array, offset) {
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
    }
    if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
    }
    var result = 0;
    var mul = 1;
    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        result += array[i] * mul;
        mul *= 256;
    }
    return result;
}
exports.readUintBE = readUintBE;
/**
 * Reads bytes from array starting at offset as little-endian
 * unsigned bitLen-bit integer and returns it.
 *
 * Supports bit lengths divisible by 8, up to 48.
 */
function readUintLE(bitLength, array, offset) {
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
    }
    if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
    }
    var result = 0;
    var mul = 1;
    for (var i = offset; i < offset + bitLength / 8; i++) {
        result += array[i] * mul;
        mul *= 256;
    }
    return result;
}
exports.readUintLE = readUintLE;
/**
 * Writes a big-endian representation of bitLen-bit unsigned
 * value to array starting at offset.
 *
 * Supports bit lengths divisible by 8, up to 48.
 *
 * If byte array is not given, creates a new one.
 *
 * Returns the output byte array.
 */
function writeUintBE(bitLength, value, out, offset) {
    if (out === void 0) { out = new Uint8Array(bitLength / 8); }
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
    }
    if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
    }
    var div = 1;
    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        out[i] = (value / div) & 0xff;
        div *= 256;
    }
    return out;
}
exports.writeUintBE = writeUintBE;
/**
 * Writes a little-endian representation of bitLen-bit unsigned
 * value to array starting at offset.
 *
 * Supports bit lengths divisible by 8, up to 48.
 *
 * If byte array is not given, creates a new one.
 *
 * Returns the output byte array.
 */
function writeUintLE(bitLength, value, out, offset) {
    if (out === void 0) { out = new Uint8Array(bitLength / 8); }
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
    }
    if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
    }
    var div = 1;
    for (var i = offset; i < offset + bitLength / 8; i++) {
        out[i] = (value / div) & 0xff;
        div *= 256;
    }
    return out;
}
exports.writeUintLE = writeUintLE;
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * 32-bit floating-point number and returns it.
 */
function readFloat32BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat32(offset);
}
exports.readFloat32BE = readFloat32BE;
/**
 * Reads 4 bytes from array starting at offset as little-endian
 * 32-bit floating-point number and returns it.
 */
function readFloat32LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat32(offset, true);
}
exports.readFloat32LE = readFloat32LE;
/**
 * Reads 8 bytes from array starting at offset as big-endian
 * 64-bit floating-point number ("double") and returns it.
 */
function readFloat64BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat64(offset);
}
exports.readFloat64BE = readFloat64BE;
/**
 * Reads 8 bytes from array starting at offset as little-endian
 * 64-bit floating-point number ("double") and returns it.
 */
function readFloat64LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat64(offset, true);
}
exports.readFloat64LE = readFloat64LE;
/**
 * Writes 4-byte big-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat32BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat32(offset, value);
    return out;
}
exports.writeFloat32BE = writeFloat32BE;
/**
 * Writes 4-byte little-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat32LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat32(offset, value, true);
    return out;
}
exports.writeFloat32LE = writeFloat32LE;
/**
 * Writes 8-byte big-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat64BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat64(offset, value);
    return out;
}
exports.writeFloat64BE = writeFloat64BE;
/**
 * Writes 8-byte little-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat64LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat64(offset, value, true);
    return out;
}
exports.writeFloat64LE = writeFloat64LE;

},{"@stablelib/int":151}],147:[function(require,module,exports){
"use strict";
// Copyright (C) 2017 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
var binary_1 = require("@stablelib/binary");
var wipe_1 = require("@stablelib/wipe");
exports.BLOCK_SIZE = 128;
exports.DIGEST_LENGTH = 64;
exports.KEY_LENGTH = 64;
exports.PERSONALIZATION_LENGTH = 16;
exports.SALT_LENGTH = 16;
exports.MAX_LEAF_SIZE = Math.pow(2, 32) - 1;
exports.MAX_FANOUT = 255;
exports.MAX_MAX_DEPTH = 255; // not a typo
var IV = new Uint32Array([
    // low bits // high bits
    0xf3bcc908, 0x6a09e667,
    0x84caa73b, 0xbb67ae85,
    0xfe94f82b, 0x3c6ef372,
    0x5f1d36f1, 0xa54ff53a,
    0xade682d1, 0x510e527f,
    0x2b3e6c1f, 0x9b05688c,
    0xfb41bd6b, 0x1f83d9ab,
    0x137e2179, 0x5be0cd19,
]);
// Note: sigma values are doubled since we store
// 64-bit ints as two 32-bit ints in arrays.
var SIGMA = [
    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30],
    [28, 20, 8, 16, 18, 30, 26, 12, 2, 24, 0, 4, 22, 14, 10, 6],
    [22, 16, 24, 0, 10, 4, 30, 26, 20, 28, 6, 12, 14, 2, 18, 8],
    [14, 18, 6, 2, 26, 24, 22, 28, 4, 12, 10, 20, 8, 0, 30, 16],
    [18, 0, 10, 14, 4, 8, 20, 30, 28, 2, 22, 24, 12, 16, 6, 26],
    [4, 24, 12, 20, 0, 22, 16, 6, 8, 26, 14, 10, 30, 28, 2, 18],
    [24, 10, 2, 30, 28, 26, 8, 20, 0, 14, 12, 6, 18, 4, 16, 22],
    [26, 22, 14, 28, 24, 2, 6, 18, 10, 0, 30, 8, 16, 12, 4, 20],
    [12, 30, 28, 18, 22, 6, 0, 16, 24, 4, 26, 14, 2, 8, 20, 10],
    [20, 4, 16, 8, 14, 12, 2, 10, 30, 22, 18, 28, 6, 24, 26, 0],
    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30],
    [28, 20, 8, 16, 18, 30, 26, 12, 2, 24, 0, 4, 22, 14, 10, 6]
];
/**
 * BLAKE2b hash function.
 */
var BLAKE2b = /** @class */ (function () {
    function BLAKE2b(digestLength, config) {
        if (digestLength === void 0) { digestLength = 64; }
        this.digestLength = digestLength;
        this.blockSize = exports.BLOCK_SIZE;
        // Note: Int32Arrays for state and message are used for performance reasons.
        this._state = new Int32Array(IV); // hash state, initialized with IV
        this._buffer = new Uint8Array(exports.BLOCK_SIZE); // buffer for data
        this._bufferLength = 0; // number of bytes in buffer
        this._ctr = new Uint32Array(4);
        this._flag = new Uint32Array(4);
        this._lastNode = false;
        this._finished = false;
        this._vtmp = new Uint32Array(32);
        this._mtmp = new Uint32Array(32);
        // Validate digest length.
        if (digestLength < 1 || digestLength > exports.DIGEST_LENGTH) {
            throw new Error("blake2b: wrong digest length");
        }
        // Validate config, if present.
        if (config) {
            this.validateConfig(config);
        }
        // Get key length from config.
        var keyLength = 0;
        if (config && config.key) {
            keyLength = config.key.length;
        }
        // Get tree fanout and maxDepth from config.
        var fanout = 1;
        var maxDepth = 1;
        if (config && config.tree) {
            fanout = config.tree.fanout;
            maxDepth = config.tree.maxDepth;
        }
        // Xor common parameters into state.
        this._state[0] ^= digestLength | (keyLength << 8) | (fanout << 16) | (maxDepth << 24);
        // Xor tree parameters into state.
        if (config && config.tree) {
            this._state[1] ^= config.tree.leafSize;
            this._state[2] ^= config.tree.nodeOffsetLowBits;
            this._state[3] ^= config.tree.nodeOffsetHighBits;
            this._state[4] ^= config.tree.nodeDepth | (config.tree.innerDigestLength << 8);
            this._lastNode = config.tree.lastNode;
        }
        // Xor salt into state.
        if (config && config.salt) {
            this._state[8] ^= binary_1.readUint32LE(config.salt, 0);
            this._state[9] ^= binary_1.readUint32LE(config.salt, 4);
            this._state[10] ^= binary_1.readUint32LE(config.salt, 8);
            this._state[11] ^= binary_1.readUint32LE(config.salt, 12);
        }
        // Xor personalization into state.
        if (config && config.personalization) {
            this._state[12] ^= binary_1.readUint32LE(config.personalization, 0);
            this._state[13] ^= binary_1.readUint32LE(config.personalization, 4);
            this._state[14] ^= binary_1.readUint32LE(config.personalization, 8);
            this._state[15] ^= binary_1.readUint32LE(config.personalization, 12);
        }
        // Save a copy of initialized state for reset.
        this._initialState = new Uint32Array(this._state);
        // Process key.
        if (config && config.key && keyLength > 0) {
            this._paddedKey = new Uint8Array(exports.BLOCK_SIZE);
            this._paddedKey.set(config.key);
            // Put padded key into buffer.
            this._buffer.set(this._paddedKey);
            this._bufferLength = exports.BLOCK_SIZE;
        }
    }
    BLAKE2b.prototype.reset = function () {
        // Restore initial state.
        this._state.set(this._initialState);
        if (this._paddedKey) {
            // Put padded key into buffer.
            this._buffer.set(this._paddedKey);
            this._bufferLength = exports.BLOCK_SIZE;
        }
        else {
            this._bufferLength = 0;
        }
        // Clear counters and flags.
        wipe_1.wipe(this._ctr);
        wipe_1.wipe(this._flag);
        this._finished = false;
        return this;
    };
    BLAKE2b.prototype.validateConfig = function (config) {
        if (config.key && config.key.length > exports.KEY_LENGTH) {
            throw new Error("blake2b: wrong key length");
        }
        if (config.salt && config.salt.length !== exports.SALT_LENGTH) {
            throw new Error("blake2b: wrong salt length");
        }
        if (config.personalization &&
            config.personalization.length !== exports.PERSONALIZATION_LENGTH) {
            throw new Error("blake2b: wrong personalization length");
        }
        if (config.tree) {
            if (config.tree.fanout < 0 || config.tree.fanout > exports.MAX_FANOUT) {
                throw new Error("blake2b: wrong tree fanout");
            }
            if (config.tree.maxDepth < 0 || config.tree.maxDepth > exports.MAX_MAX_DEPTH) {
                throw new Error("blake2b: wrong tree depth");
            }
            if (config.tree.leafSize < 0 || config.tree.leafSize > exports.MAX_LEAF_SIZE) {
                throw new Error("blake2b: wrong leaf size");
            }
            if (config.tree.innerDigestLength < 0 ||
                config.tree.innerDigestLength > exports.DIGEST_LENGTH) {
                throw new Error("blake2b: wrong tree inner digest length");
            }
        }
    };
    BLAKE2b.prototype.update = function (data, dataLength) {
        if (dataLength === void 0) { dataLength = data.length; }
        if (this._finished) {
            throw new Error("blake2b: can't update because hash was finished.");
        }
        var left = exports.BLOCK_SIZE - this._bufferLength;
        var dataPos = 0;
        if (dataLength === 0) {
            return this;
        }
        // Finish buffer.
        if (dataLength > left) {
            for (var i = 0; i < left; i++) {
                this._buffer[this._bufferLength + i] = data[dataPos + i];
            }
            this._processBlock(exports.BLOCK_SIZE);
            dataPos += left;
            dataLength -= left;
            this._bufferLength = 0;
        }
        // Process data blocks.
        while (dataLength > exports.BLOCK_SIZE) {
            for (var i = 0; i < exports.BLOCK_SIZE; i++) {
                this._buffer[i] = data[dataPos + i];
            }
            this._processBlock(exports.BLOCK_SIZE);
            dataPos += exports.BLOCK_SIZE;
            dataLength -= exports.BLOCK_SIZE;
            this._bufferLength = 0;
        }
        // Copy leftovers to buffer.
        for (var i = 0; i < dataLength; i++) {
            this._buffer[this._bufferLength + i] = data[dataPos + i];
        }
        this._bufferLength += dataLength;
        return this;
    };
    BLAKE2b.prototype.finish = function (out) {
        if (!this._finished) {
            for (var i = this._bufferLength; i < exports.BLOCK_SIZE; i++) {
                this._buffer[i] = 0;
            }
            // Set last block flag.
            this._flag[0] = 0xffffffff;
            this._flag[1] = 0xffffffff;
            // Set last node flag if last node in tree.
            if (this._lastNode) {
                this._flag[2] = 0xffffffff;
                this._flag[3] = 0xffffffff;
            }
            this._processBlock(this._bufferLength);
            this._finished = true;
        }
        // Reuse buffer as temporary space for digest.
        var tmp = this._buffer.subarray(0, 64);
        for (var i = 0; i < 16; i++) {
            binary_1.writeUint32LE(this._state[i], tmp, i * 4);
        }
        out.set(tmp.subarray(0, out.length));
        return this;
    };
    BLAKE2b.prototype.digest = function () {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
    };
    BLAKE2b.prototype.clean = function () {
        wipe_1.wipe(this._vtmp);
        wipe_1.wipe(this._mtmp);
        wipe_1.wipe(this._state);
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._initialState);
        if (this._paddedKey) {
            wipe_1.wipe(this._paddedKey);
        }
        this._bufferLength = 0;
        wipe_1.wipe(this._ctr);
        wipe_1.wipe(this._flag);
        this._lastNode = false;
        this._finished = false;
    };
    BLAKE2b.prototype.saveState = function () {
        if (this._finished) {
            throw new Error("blake2b: cannot save finished state");
        }
        return {
            state: new Uint32Array(this._state),
            buffer: new Uint8Array(this._buffer),
            bufferLength: this._bufferLength,
            ctr: new Uint32Array(this._ctr),
            flag: new Uint32Array(this._flag),
            lastNode: this._lastNode,
            paddedKey: this._paddedKey ? new Uint8Array(this._paddedKey) : undefined,
            initialState: new Uint32Array(this._initialState)
        };
    };
    BLAKE2b.prototype.restoreState = function (savedState) {
        this._state.set(savedState.state);
        this._buffer.set(savedState.buffer);
        this._bufferLength = savedState.bufferLength;
        this._ctr.set(savedState.ctr);
        this._flag.set(savedState.flag);
        this._lastNode = savedState.lastNode;
        if (this._paddedKey) {
            wipe_1.wipe(this._paddedKey);
        }
        this._paddedKey = savedState.paddedKey ? new Uint8Array(savedState.paddedKey) : undefined;
        this._initialState.set(savedState.initialState);
        return this;
    };
    BLAKE2b.prototype.cleanSavedState = function (savedState) {
        wipe_1.wipe(savedState.state);
        wipe_1.wipe(savedState.buffer);
        wipe_1.wipe(savedState.initialState);
        if (savedState.paddedKey) {
            wipe_1.wipe(savedState.paddedKey);
        }
        savedState.bufferLength = 0;
        wipe_1.wipe(savedState.ctr);
        wipe_1.wipe(savedState.flag);
        savedState.lastNode = false;
    };
    BLAKE2b.prototype._G = function (v, al, bl, cl, dl, ah, bh, ch, dh, ml0, mh0, ml1, mh1) {
        var vla = v[al], vha = v[ah], vlb = v[bl], vhb = v[bh], vlc = v[cl], vhc = v[ch], vld = v[dl], vhd = v[dh];
        // 64-bit: va += vb
        var w = vla & 0xffff, x = vla >>> 16, y = vha & 0xffff, z = vha >>> 16;
        w += vlb & 0xffff;
        x += vlb >>> 16;
        y += vhb & 0xffff;
        z += vhb >>> 16;
        x += w >>> 16;
        y += x >>> 16;
        z += y >>> 16;
        vha = (y & 0xffff) | (z << 16);
        vla = (w & 0xffff) | (x << 16);
        // 64-bit: va += m[sigma[r][2 * i + 0]]
        w = vla & 0xffff;
        x = vla >>> 16;
        y = vha & 0xffff;
        z = vha >>> 16;
        w += ml0 & 0xffff;
        x += ml0 >>> 16;
        y += mh0 & 0xffff;
        z += mh0 >>> 16;
        x += w >>> 16;
        y += x >>> 16;
        z += y >>> 16;
        vha = (y & 0xffff) | (z << 16);
        vla = (w & 0xffff) | (x << 16);
        // 64-bit: vd ^= va
        vld ^= vla;
        vhd ^= vha;
        // 64-bit: rot(vd, 32)
        w = vhd;
        vhd = vld;
        vld = w;
        // 64-bit: vc += vd
        w = vlc & 0xffff;
        x = vlc >>> 16;
        y = vhc & 0xffff;
        z = vhc >>> 16;
        w += vld & 0xffff;
        x += vld >>> 16;
        y += vhd & 0xffff;
        z += vhd >>> 16;
        x += w >>> 16;
        y += x >>> 16;
        z += y >>> 16;
        vhc = (y & 0xffff) | (z << 16);
        vlc = (w & 0xffff) | (x << 16);
        // 64-bit: vb ^= vc
        vlb ^= vlc;
        vhb ^= vhc;
        // 64-bit: rot(vb, 24)
        w = vlb << 8 | vhb >>> 24;
        vlb = vhb << 8 | vlb >>> 24;
        vhb = w;
        // 64-bit: va += vb
        w = vla & 0xffff;
        x = vla >>> 16;
        y = vha & 0xffff;
        z = vha >>> 16;
        w += vlb & 0xffff;
        x += vlb >>> 16;
        y += vhb & 0xffff;
        z += vhb >>> 16;
        x += w >>> 16;
        y += x >>> 16;
        z += y >>> 16;
        vha = (y & 0xffff) | (z << 16);
        vla = (w & 0xffff) | (x << 16);
        // 64-bit: va += m[sigma[r][2 * i + 1]
        w = vla & 0xffff;
        x = vla >>> 16;
        y = vha & 0xffff;
        z = vha >>> 16;
        w += ml1 & 0xffff;
        x += ml1 >>> 16;
        y += mh1 & 0xffff;
        z += mh1 >>> 16;
        x += w >>> 16;
        y += x >>> 16;
        z += y >>> 16;
        vha = (y & 0xffff) | (z << 16);
        vla = (w & 0xffff) | (x << 16);
        // 64-bit: vd ^= va
        vld ^= vla;
        vhd ^= vha;
        // 64-bit: rot(vd, 16)
        w = vld << 16 | vhd >>> 16;
        vld = vhd << 16 | vld >>> 16;
        vhd = w;
        // 64-bit: vc += vd
        w = vlc & 0xffff;
        x = vlc >>> 16;
        y = vhc & 0xffff;
        z = vhc >>> 16;
        w += vld & 0xffff;
        x += vld >>> 16;
        y += vhd & 0xffff;
        z += vhd >>> 16;
        x += w >>> 16;
        y += x >>> 16;
        z += y >>> 16;
        vhc = (y & 0xffff) | (z << 16);
        vlc = (w & 0xffff) | (x << 16);
        // 64-bit: vb ^= vc
        vlb ^= vlc;
        vhb ^= vhc;
        // 64-bit: rot(vb, 63)
        w = vhb << 1 | vlb >>> 31;
        vlb = vlb << 1 | vhb >>> 31;
        vhb = w;
        v[al] = vla;
        v[ah] = vha;
        v[bl] = vlb;
        v[bh] = vhb;
        v[cl] = vlc;
        v[ch] = vhc;
        v[dl] = vld;
        v[dh] = vhd;
    };
    BLAKE2b.prototype._incrementCounter = function (n) {
        for (var i = 0; i < 3; i++) {
            var a = this._ctr[i] + n;
            this._ctr[i] = a >>> 0;
            if (this._ctr[i] === a) {
                return;
            }
            n = 1;
        }
    };
    BLAKE2b.prototype._processBlock = function (length) {
        this._incrementCounter(length);
        var v = this._vtmp;
        v.set(this._state);
        v.set(IV, 16);
        v[12 * 2 + 0] ^= this._ctr[0];
        v[12 * 2 + 1] ^= this._ctr[1];
        v[13 * 2 + 0] ^= this._ctr[2];
        v[13 * 2 + 1] ^= this._ctr[3];
        v[14 * 2 + 0] ^= this._flag[0];
        v[14 * 2 + 1] ^= this._flag[1];
        v[15 * 2 + 0] ^= this._flag[2];
        v[15 * 2 + 1] ^= this._flag[3];
        var m = this._mtmp;
        for (var i = 0; i < 32; i++) {
            m[i] = binary_1.readUint32LE(this._buffer, i * 4);
        }
        for (var r = 0; r < 12; r++) {
            this._G(v, 0, 8, 16, 24, 1, 9, 17, 25, m[SIGMA[r][0]], m[SIGMA[r][0] + 1], m[SIGMA[r][1]], m[SIGMA[r][1] + 1]);
            this._G(v, 2, 10, 18, 26, 3, 11, 19, 27, m[SIGMA[r][2]], m[SIGMA[r][2] + 1], m[SIGMA[r][3]], m[SIGMA[r][3] + 1]);
            this._G(v, 4, 12, 20, 28, 5, 13, 21, 29, m[SIGMA[r][4]], m[SIGMA[r][4] + 1], m[SIGMA[r][5]], m[SIGMA[r][5] + 1]);
            this._G(v, 6, 14, 22, 30, 7, 15, 23, 31, m[SIGMA[r][6]], m[SIGMA[r][6] + 1], m[SIGMA[r][7]], m[SIGMA[r][7] + 1]);
            this._G(v, 0, 10, 20, 30, 1, 11, 21, 31, m[SIGMA[r][8]], m[SIGMA[r][8] + 1], m[SIGMA[r][9]], m[SIGMA[r][9] + 1]);
            this._G(v, 2, 12, 22, 24, 3, 13, 23, 25, m[SIGMA[r][10]], m[SIGMA[r][10] + 1], m[SIGMA[r][11]], m[SIGMA[r][11] + 1]);
            this._G(v, 4, 14, 16, 26, 5, 15, 17, 27, m[SIGMA[r][12]], m[SIGMA[r][12] + 1], m[SIGMA[r][13]], m[SIGMA[r][13] + 1]);
            this._G(v, 6, 8, 18, 28, 7, 9, 19, 29, m[SIGMA[r][14]], m[SIGMA[r][14] + 1], m[SIGMA[r][15]], m[SIGMA[r][15] + 1]);
        }
        for (var i = 0; i < 16; i++) {
            this._state[i] ^= v[i] ^ v[i + 16];
        }
    };
    return BLAKE2b;
}());
exports.BLAKE2b = BLAKE2b;
function hash(data, digestLength, config) {
    if (digestLength === void 0) { digestLength = exports.DIGEST_LENGTH; }
    var h = new BLAKE2b(digestLength, config);
    h.update(data);
    var digest = h.digest();
    h.clean();
    return digest;
}
exports.hash = hash;

},{"@stablelib/binary":146,"@stablelib/wipe":163}],148:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
function concat() {
    // Calculate sum of lengths of all arrays.
    var totalLength = 0;
    for (var i = 0; i < arguments.length; i++) {
        totalLength += arguments[i].length;
    }
    // Allocate new array of calculated length.
    var result = new Uint8Array(totalLength);
    // Copy all arrays into result.
    var offset = 0;
    for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        result.set(arg, offset);
        offset += arg.length;
    }
    return result;
}
exports.concat = concat;

},{}],149:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package constant-time provides functions for performing algorithmically constant-time operations.
 */
/**
 * NOTE! Due to the inability to guarantee real constant time evaluation of
 * anything in JavaScript VM, this is module is the best effort.
 */
/**
 * Returns resultIfOne if subject is 1, or resultIfZero if subject is 0.
 *
 * Supports only 32-bit integers, so resultIfOne or resultIfZero are not
 * integers, they'll be converted to them with bitwise operations.
 */
function select(subject, resultIfOne, resultIfZero) {
    return (~(subject - 1) & resultIfOne) | ((subject - 1) & resultIfZero);
}
exports.select = select;
/**
 * Returns 1 if a <= b, or 0 if not.
 * Arguments must be positive 32-bit integers less than or equal to 2^31 - 1.
 */
function lessOrEqual(a, b) {
    return (((a | 0) - (b | 0) - 1) >>> 31) & 1;
}
exports.lessOrEqual = lessOrEqual;
/**
 * Returns 1 if a and b are of equal length and their contents
 * are equal, or 0 otherwise.
 *
 * Note that unlike in equal(), zero-length inputs are considered
 * the same, so this function will return 1.
 */
function compare(a, b) {
    if (a.length !== b.length) {
        return 0;
    }
    var result = 0;
    for (var i = 0; i < a.length; i++) {
        result |= a[i] ^ b[i];
    }
    return (1 & ((result - 1) >>> 8));
}
exports.compare = compare;
/**
 * Returns true if a and b are of equal non-zero length,
 * and their contents are equal, or false otherwise.
 *
 * Note that unlike in compare() zero-length inputs are considered
 * _not_ equal, so this function will return false.
 */
function equal(a, b) {
    if (a.length === 0 || b.length === 0) {
        return false;
    }
    return compare(a, b) !== 0;
}
exports.equal = equal;

},{}],150:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertSecretKeyToX25519 = exports.convertPublicKeyToX25519 = exports.verify = exports.sign = exports.extractPublicKeyFromSecretKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.SEED_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = exports.SIGNATURE_LENGTH = void 0;
/**
 * Package ed25519 implements Ed25519 public-key signature algorithm.
 */
const random_1 = require("@stablelib/random");
const sha512_1 = require("@stablelib/sha512");
const wipe_1 = require("@stablelib/wipe");
exports.SIGNATURE_LENGTH = 64;
exports.PUBLIC_KEY_LENGTH = 32;
exports.SECRET_KEY_LENGTH = 64;
exports.SEED_LENGTH = 32;
// Returns new zero-filled 16-element GF (Float64Array).
// If passed an array of numbers, prefills the returned
// array with them.
//
// We use Float64Array, because we need 48-bit numbers
// for this implementation.
function gf(init) {
    const r = new Float64Array(16);
    if (init) {
        for (let i = 0; i < init.length; i++) {
            r[i] = init[i];
        }
    }
    return r;
}
// Base point.
const _9 = new Uint8Array(32);
_9[0] = 9;
const gf0 = gf();
const gf1 = gf([1]);
const D = gf([
    0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070,
    0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203
]);
const D2 = gf([
    0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0,
    0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406
]);
const X = gf([
    0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c,
    0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169
]);
const Y = gf([
    0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666,
    0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666
]);
const I = gf([
    0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43,
    0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83
]);
function set25519(r, a) {
    for (let i = 0; i < 16; i++) {
        r[i] = a[i] | 0;
    }
}
function car25519(o) {
    let c = 1;
    for (let i = 0; i < 16; i++) {
        let v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
    }
    o[0] += c - 1 + 37 * (c - 1);
}
function sel25519(p, q, b) {
    const c = ~(b - 1);
    for (let i = 0; i < 16; i++) {
        const t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
    }
}
function pack25519(o, n) {
    const m = gf();
    const t = gf();
    for (let i = 0; i < 16; i++) {
        t[i] = n[i];
    }
    car25519(t);
    car25519(t);
    car25519(t);
    for (let j = 0; j < 2; j++) {
        m[0] = t[0] - 0xffed;
        for (let i = 1; i < 15; i++) {
            m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
            m[i - 1] &= 0xffff;
        }
        m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
        const b = (m[15] >> 16) & 1;
        m[14] &= 0xffff;
        sel25519(t, m, 1 - b);
    }
    for (let i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 0xff;
        o[2 * i + 1] = t[i] >> 8;
    }
}
function verify32(x, y) {
    let d = 0;
    for (let i = 0; i < 32; i++) {
        d |= x[i] ^ y[i];
    }
    return (1 & ((d - 1) >>> 8)) - 1;
}
function neq25519(a, b) {
    const c = new Uint8Array(32);
    const d = new Uint8Array(32);
    pack25519(c, a);
    pack25519(d, b);
    return verify32(c, d);
}
function par25519(a) {
    const d = new Uint8Array(32);
    pack25519(d, a);
    return d[0] & 1;
}
function unpack25519(o, n) {
    for (let i = 0; i < 16; i++) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
    }
    o[15] &= 0x7fff;
}
function add(o, a, b) {
    for (let i = 0; i < 16; i++) {
        o[i] = a[i] + b[i];
    }
}
function sub(o, a, b) {
    for (let i = 0; i < 16; i++) {
        o[i] = a[i] - b[i];
    }
}
function mul(o, a, b) {
    let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    v = a[0];
    t0 += v * b0;
    t1 += v * b1;
    t2 += v * b2;
    t3 += v * b3;
    t4 += v * b4;
    t5 += v * b5;
    t6 += v * b6;
    t7 += v * b7;
    t8 += v * b8;
    t9 += v * b9;
    t10 += v * b10;
    t11 += v * b11;
    t12 += v * b12;
    t13 += v * b13;
    t14 += v * b14;
    t15 += v * b15;
    v = a[1];
    t1 += v * b0;
    t2 += v * b1;
    t3 += v * b2;
    t4 += v * b3;
    t5 += v * b4;
    t6 += v * b5;
    t7 += v * b6;
    t8 += v * b7;
    t9 += v * b8;
    t10 += v * b9;
    t11 += v * b10;
    t12 += v * b11;
    t13 += v * b12;
    t14 += v * b13;
    t15 += v * b14;
    t16 += v * b15;
    v = a[2];
    t2 += v * b0;
    t3 += v * b1;
    t4 += v * b2;
    t5 += v * b3;
    t6 += v * b4;
    t7 += v * b5;
    t8 += v * b6;
    t9 += v * b7;
    t10 += v * b8;
    t11 += v * b9;
    t12 += v * b10;
    t13 += v * b11;
    t14 += v * b12;
    t15 += v * b13;
    t16 += v * b14;
    t17 += v * b15;
    v = a[3];
    t3 += v * b0;
    t4 += v * b1;
    t5 += v * b2;
    t6 += v * b3;
    t7 += v * b4;
    t8 += v * b5;
    t9 += v * b6;
    t10 += v * b7;
    t11 += v * b8;
    t12 += v * b9;
    t13 += v * b10;
    t14 += v * b11;
    t15 += v * b12;
    t16 += v * b13;
    t17 += v * b14;
    t18 += v * b15;
    v = a[4];
    t4 += v * b0;
    t5 += v * b1;
    t6 += v * b2;
    t7 += v * b3;
    t8 += v * b4;
    t9 += v * b5;
    t10 += v * b6;
    t11 += v * b7;
    t12 += v * b8;
    t13 += v * b9;
    t14 += v * b10;
    t15 += v * b11;
    t16 += v * b12;
    t17 += v * b13;
    t18 += v * b14;
    t19 += v * b15;
    v = a[5];
    t5 += v * b0;
    t6 += v * b1;
    t7 += v * b2;
    t8 += v * b3;
    t9 += v * b4;
    t10 += v * b5;
    t11 += v * b6;
    t12 += v * b7;
    t13 += v * b8;
    t14 += v * b9;
    t15 += v * b10;
    t16 += v * b11;
    t17 += v * b12;
    t18 += v * b13;
    t19 += v * b14;
    t20 += v * b15;
    v = a[6];
    t6 += v * b0;
    t7 += v * b1;
    t8 += v * b2;
    t9 += v * b3;
    t10 += v * b4;
    t11 += v * b5;
    t12 += v * b6;
    t13 += v * b7;
    t14 += v * b8;
    t15 += v * b9;
    t16 += v * b10;
    t17 += v * b11;
    t18 += v * b12;
    t19 += v * b13;
    t20 += v * b14;
    t21 += v * b15;
    v = a[7];
    t7 += v * b0;
    t8 += v * b1;
    t9 += v * b2;
    t10 += v * b3;
    t11 += v * b4;
    t12 += v * b5;
    t13 += v * b6;
    t14 += v * b7;
    t15 += v * b8;
    t16 += v * b9;
    t17 += v * b10;
    t18 += v * b11;
    t19 += v * b12;
    t20 += v * b13;
    t21 += v * b14;
    t22 += v * b15;
    v = a[8];
    t8 += v * b0;
    t9 += v * b1;
    t10 += v * b2;
    t11 += v * b3;
    t12 += v * b4;
    t13 += v * b5;
    t14 += v * b6;
    t15 += v * b7;
    t16 += v * b8;
    t17 += v * b9;
    t18 += v * b10;
    t19 += v * b11;
    t20 += v * b12;
    t21 += v * b13;
    t22 += v * b14;
    t23 += v * b15;
    v = a[9];
    t9 += v * b0;
    t10 += v * b1;
    t11 += v * b2;
    t12 += v * b3;
    t13 += v * b4;
    t14 += v * b5;
    t15 += v * b6;
    t16 += v * b7;
    t17 += v * b8;
    t18 += v * b9;
    t19 += v * b10;
    t20 += v * b11;
    t21 += v * b12;
    t22 += v * b13;
    t23 += v * b14;
    t24 += v * b15;
    v = a[10];
    t10 += v * b0;
    t11 += v * b1;
    t12 += v * b2;
    t13 += v * b3;
    t14 += v * b4;
    t15 += v * b5;
    t16 += v * b6;
    t17 += v * b7;
    t18 += v * b8;
    t19 += v * b9;
    t20 += v * b10;
    t21 += v * b11;
    t22 += v * b12;
    t23 += v * b13;
    t24 += v * b14;
    t25 += v * b15;
    v = a[11];
    t11 += v * b0;
    t12 += v * b1;
    t13 += v * b2;
    t14 += v * b3;
    t15 += v * b4;
    t16 += v * b5;
    t17 += v * b6;
    t18 += v * b7;
    t19 += v * b8;
    t20 += v * b9;
    t21 += v * b10;
    t22 += v * b11;
    t23 += v * b12;
    t24 += v * b13;
    t25 += v * b14;
    t26 += v * b15;
    v = a[12];
    t12 += v * b0;
    t13 += v * b1;
    t14 += v * b2;
    t15 += v * b3;
    t16 += v * b4;
    t17 += v * b5;
    t18 += v * b6;
    t19 += v * b7;
    t20 += v * b8;
    t21 += v * b9;
    t22 += v * b10;
    t23 += v * b11;
    t24 += v * b12;
    t25 += v * b13;
    t26 += v * b14;
    t27 += v * b15;
    v = a[13];
    t13 += v * b0;
    t14 += v * b1;
    t15 += v * b2;
    t16 += v * b3;
    t17 += v * b4;
    t18 += v * b5;
    t19 += v * b6;
    t20 += v * b7;
    t21 += v * b8;
    t22 += v * b9;
    t23 += v * b10;
    t24 += v * b11;
    t25 += v * b12;
    t26 += v * b13;
    t27 += v * b14;
    t28 += v * b15;
    v = a[14];
    t14 += v * b0;
    t15 += v * b1;
    t16 += v * b2;
    t17 += v * b3;
    t18 += v * b4;
    t19 += v * b5;
    t20 += v * b6;
    t21 += v * b7;
    t22 += v * b8;
    t23 += v * b9;
    t24 += v * b10;
    t25 += v * b11;
    t26 += v * b12;
    t27 += v * b13;
    t28 += v * b14;
    t29 += v * b15;
    v = a[15];
    t15 += v * b0;
    t16 += v * b1;
    t17 += v * b2;
    t18 += v * b3;
    t19 += v * b4;
    t20 += v * b5;
    t21 += v * b6;
    t22 += v * b7;
    t23 += v * b8;
    t24 += v * b9;
    t25 += v * b10;
    t26 += v * b11;
    t27 += v * b12;
    t28 += v * b13;
    t29 += v * b14;
    t30 += v * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    // t15 left as is
    // first car
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    // second car
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
}
function square(o, a) {
    mul(o, a, a);
}
function inv25519(o, i) {
    const c = gf();
    let a;
    for (a = 0; a < 16; a++) {
        c[a] = i[a];
    }
    for (a = 253; a >= 0; a--) {
        square(c, c);
        if (a !== 2 && a !== 4) {
            mul(c, c, i);
        }
    }
    for (a = 0; a < 16; a++) {
        o[a] = c[a];
    }
}
function pow2523(o, i) {
    const c = gf();
    let a;
    for (a = 0; a < 16; a++) {
        c[a] = i[a];
    }
    for (a = 250; a >= 0; a--) {
        square(c, c);
        if (a !== 1) {
            mul(c, c, i);
        }
    }
    for (a = 0; a < 16; a++) {
        o[a] = c[a];
    }
}
function edadd(p, q) {
    const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
    sub(a, p[1], p[0]);
    sub(t, q[1], q[0]);
    mul(a, a, t);
    add(b, p[0], p[1]);
    add(t, q[0], q[1]);
    mul(b, b, t);
    mul(c, p[3], q[3]);
    mul(c, c, D2);
    mul(d, p[2], q[2]);
    add(d, d, d);
    sub(e, b, a);
    sub(f, d, c);
    add(g, d, c);
    add(h, b, a);
    mul(p[0], e, f);
    mul(p[1], h, g);
    mul(p[2], g, f);
    mul(p[3], e, h);
}
function cswap(p, q, b) {
    for (let i = 0; i < 4; i++) {
        sel25519(p[i], q[i], b);
    }
}
function pack(r, p) {
    const tx = gf(), ty = gf(), zi = gf();
    inv25519(zi, p[2]);
    mul(tx, p[0], zi);
    mul(ty, p[1], zi);
    pack25519(r, ty);
    r[31] ^= par25519(tx) << 7;
}
function scalarmult(p, q, s) {
    set25519(p[0], gf0);
    set25519(p[1], gf1);
    set25519(p[2], gf1);
    set25519(p[3], gf0);
    for (let i = 255; i >= 0; --i) {
        const b = (s[(i / 8) | 0] >> (i & 7)) & 1;
        cswap(p, q, b);
        edadd(q, p);
        edadd(p, p);
        cswap(p, q, b);
    }
}
function scalarbase(p, s) {
    const q = [gf(), gf(), gf(), gf()];
    set25519(q[0], X);
    set25519(q[1], Y);
    set25519(q[2], gf1);
    mul(q[3], X, Y);
    scalarmult(p, q, s);
}
// Generates key pair from secret 32-byte seed.
function generateKeyPairFromSeed(seed) {
    if (seed.length !== exports.SEED_LENGTH) {
        throw new Error(`ed25519: seed must be ${exports.SEED_LENGTH} bytes`);
    }
    const d = (0, sha512_1.hash)(seed);
    d[0] &= 248;
    d[31] &= 127;
    d[31] |= 64;
    const publicKey = new Uint8Array(32);
    const p = [gf(), gf(), gf(), gf()];
    scalarbase(p, d);
    pack(publicKey, p);
    const secretKey = new Uint8Array(64);
    secretKey.set(seed);
    secretKey.set(publicKey, 32);
    return {
        publicKey,
        secretKey
    };
}
exports.generateKeyPairFromSeed = generateKeyPairFromSeed;
function generateKeyPair(prng) {
    const seed = (0, random_1.randomBytes)(32, prng);
    const result = generateKeyPairFromSeed(seed);
    (0, wipe_1.wipe)(seed);
    return result;
}
exports.generateKeyPair = generateKeyPair;
function extractPublicKeyFromSecretKey(secretKey) {
    if (secretKey.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`ed25519: secret key must be ${exports.SECRET_KEY_LENGTH} bytes`);
    }
    return new Uint8Array(secretKey.subarray(32));
}
exports.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
const L = new Float64Array([
    0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2,
    0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10
]);
function modL(r, x) {
    let carry;
    let i;
    let j;
    let k;
    for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
    }
    carry = 0;
    for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
    }
    for (j = 0; j < 32; j++) {
        x[j] -= carry * L[j];
    }
    for (i = 0; i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
    }
}
function reduce(r) {
    const x = new Float64Array(64);
    for (let i = 0; i < 64; i++) {
        x[i] = r[i];
    }
    for (let i = 0; i < 64; i++) {
        r[i] = 0;
    }
    modL(r, x);
}
// Returns 64-byte signature of the message under the 64-byte secret key.
function sign(secretKey, message) {
    const x = new Float64Array(64);
    const p = [gf(), gf(), gf(), gf()];
    const d = (0, sha512_1.hash)(secretKey.subarray(0, 32));
    d[0] &= 248;
    d[31] &= 127;
    d[31] |= 64;
    const signature = new Uint8Array(64);
    signature.set(d.subarray(32), 32);
    const hs = new sha512_1.SHA512();
    hs.update(signature.subarray(32));
    hs.update(message);
    const r = hs.digest();
    hs.clean();
    reduce(r);
    scalarbase(p, r);
    pack(signature, p);
    hs.reset();
    hs.update(signature.subarray(0, 32));
    hs.update(secretKey.subarray(32));
    hs.update(message);
    const h = hs.digest();
    reduce(h);
    for (let i = 0; i < 32; i++) {
        x[i] = r[i];
    }
    for (let i = 0; i < 32; i++) {
        for (let j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
        }
    }
    modL(signature.subarray(32), x);
    return signature;
}
exports.sign = sign;
function unpackneg(r, p) {
    const t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
    set25519(r[2], gf1);
    unpack25519(r[1], p);
    square(num, r[1]);
    mul(den, num, D);
    sub(num, num, r[2]);
    add(den, r[2], den);
    square(den2, den);
    square(den4, den2);
    mul(den6, den4, den2);
    mul(t, den6, num);
    mul(t, t, den);
    pow2523(t, t);
    mul(t, t, num);
    mul(t, t, den);
    mul(t, t, den);
    mul(r[0], t, den);
    square(chk, r[0]);
    mul(chk, chk, den);
    if (neq25519(chk, num)) {
        mul(r[0], r[0], I);
    }
    square(chk, r[0]);
    mul(chk, chk, den);
    if (neq25519(chk, num)) {
        return -1;
    }
    if (par25519(r[0]) === (p[31] >> 7)) {
        sub(r[0], gf0, r[0]);
    }
    mul(r[3], r[0], r[1]);
    return 0;
}
function verify(publicKey, message, signature) {
    const t = new Uint8Array(32);
    const p = [gf(), gf(), gf(), gf()];
    const q = [gf(), gf(), gf(), gf()];
    if (signature.length !== exports.SIGNATURE_LENGTH) {
        throw new Error(`ed25519: signature must be ${exports.SIGNATURE_LENGTH} bytes`);
    }
    if (unpackneg(q, publicKey)) {
        return false;
    }
    const hs = new sha512_1.SHA512();
    hs.update(signature.subarray(0, 32));
    hs.update(publicKey);
    hs.update(message);
    const h = hs.digest();
    reduce(h);
    scalarmult(p, q, h);
    scalarbase(q, signature.subarray(32));
    edadd(p, q);
    pack(t, p);
    if (verify32(signature, t)) {
        return false;
    }
    return true;
}
exports.verify = verify;
/**
 * Convert Ed25519 public key to X25519 public key.
 *
 * Throws if given an invalid public key.
 */
function convertPublicKeyToX25519(publicKey) {
    let q = [gf(), gf(), gf(), gf()];
    if (unpackneg(q, publicKey)) {
        throw new Error("Ed25519: invalid public key");
    }
    // Formula: montgomeryX = (edwardsY + 1)*inverse(1 - edwardsY) mod p
    let a = gf();
    let b = gf();
    let y = q[1];
    add(a, gf1, y);
    sub(b, gf1, y);
    inv25519(b, b);
    mul(a, a, b);
    let z = new Uint8Array(32);
    pack25519(z, a);
    return z;
}
exports.convertPublicKeyToX25519 = convertPublicKeyToX25519;
/**
 *  Convert Ed25519 secret (private) key to X25519 secret key.
 */
function convertSecretKeyToX25519(secretKey) {
    const d = (0, sha512_1.hash)(secretKey.subarray(0, 32));
    d[0] &= 248;
    d[31] &= 127;
    d[31] |= 64;
    const o = new Uint8Array(d.subarray(0, 32));
    (0, wipe_1.wipe)(d);
    return o;
}
exports.convertSecretKeyToX25519 = convertSecretKeyToX25519;

},{"@stablelib/random":156,"@stablelib/sha512":161,"@stablelib/wipe":163}],151:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package int provides helper functions for integerss.
 */
// Shim using 16-bit pieces.
function imulShim(a, b) {
    var ah = (a >>> 16) & 0xffff, al = a & 0xffff;
    var bh = (b >>> 16) & 0xffff, bl = b & 0xffff;
    return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
}
/** 32-bit integer multiplication.  */
// Use system Math.imul if available, otherwise use our shim.
exports.mul = Math.imul || imulShim;
/** 32-bit integer addition.  */
function add(a, b) {
    return (a + b) | 0;
}
exports.add = add;
/**  32-bit integer subtraction.  */
function sub(a, b) {
    return (a - b) | 0;
}
exports.sub = sub;
/** 32-bit integer left rotation */
function rotl(x, n) {
    return x << n | x >>> (32 - n);
}
exports.rotl = rotl;
/** 32-bit integer left rotation */
function rotr(x, n) {
    return x << (32 - n) | x >>> n;
}
exports.rotr = rotr;
function isIntegerShim(n) {
    return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
}
/**
 * Returns true if the argument is an integer number.
 *
 * In ES2015, Number.isInteger.
 */
exports.isInteger = Number.isInteger || isIntegerShim;
/**
 *  Math.pow(2, 53) - 1
 *
 *  In ES2015 Number.MAX_SAFE_INTEGER.
 */
exports.MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Returns true if the argument is a safe integer number
 * (-MIN_SAFE_INTEGER < number <= MAX_SAFE_INTEGER)
 *
 * In ES2015, Number.isSafeInteger.
 */
exports.isSafeInteger = function (n) {
    return exports.isInteger(n) && (n >= -exports.MAX_SAFE_INTEGER && n <= exports.MAX_SAFE_INTEGER);
};

},{}],152:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
exports.openBox = exports.box = exports.precomputeSharedKey = exports.generateKeyPair = void 0;
const x25519_1 = require("@stablelib/x25519");
const xsalsa20_1 = require("@stablelib/xsalsa20");
const secretbox_1 = require("./secretbox");
const wipe_1 = require("@stablelib/wipe");
var x25519_2 = require("@stablelib/x25519");
Object.defineProperty(exports, "generateKeyPair", { enumerable: true, get: function () { return x25519_2.generateKeyPair; } });
const zeros16 = new Uint8Array(16);
function precomputeSharedKey(theirPublicKey, mySecretKey) {
    // Compute scalar multiplication result.
    const key = (0, x25519_1.scalarMult)(mySecretKey, theirPublicKey);
    // Hash key with HSalsa function.
    (0, xsalsa20_1.hsalsa)(key, zeros16, key);
    return key;
}
exports.precomputeSharedKey = precomputeSharedKey;
function box(theirPublicKey, mySecretKey, nonce, data) {
    const sharedKey = precomputeSharedKey(theirPublicKey, mySecretKey);
    const result = (0, secretbox_1.secretBox)(sharedKey, nonce, data);
    (0, wipe_1.wipe)(sharedKey);
    return result;
}
exports.box = box;
function openBox(theirPublicKey, mySecretKey, nonce, data) {
    const sharedKey = precomputeSharedKey(theirPublicKey, mySecretKey);
    const result = (0, secretbox_1.openSecretBox)(sharedKey, nonce, data);
    (0, wipe_1.wipe)(sharedKey);
    return result;
}
exports.openBox = openBox;

},{"./secretbox":154,"@stablelib/wipe":163,"@stablelib/x25519":166,"@stablelib/xsalsa20":167}],153:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package nacl implements NaCl (Networking and Cryptography library) cryptography.
 */
__exportStar(require("./box"), exports);
__exportStar(require("./secretbox"), exports);

},{"./box":152,"./secretbox":154}],154:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateKey = exports.openSecretBox = exports.secretBox = void 0;
const xsalsa20_1 = require("@stablelib/xsalsa20");
const poly1305_1 = require("@stablelib/poly1305");
const wipe_1 = require("@stablelib/wipe");
const random_1 = require("@stablelib/random");
function secretBox(key, nonce, data) {
    if (nonce.length !== 24) {
        throw new Error("secretBox nonce must be 24 bytes");
    }
    const firstBlock = new Uint8Array(64);
    // Allocate place for nonce and counter.
    const nonceCounter = new Uint8Array(24 + 8);
    // Set first bytes to nonce. Last 8 bytes will be counter.
    nonceCounter.set(nonce);
    // Generate first block of XSalsa20 stream, of which
    // first 32 bytes will be authentication key, and the rest
    // will be used for encryption.
    (0, xsalsa20_1.stream)(key, nonceCounter, firstBlock, 8);
    // Allocate result, which will contain 16-byte authenticator
    // concatenated with ciphertext.
    const result = new Uint8Array(16 + data.length);
    // Encrypt first 32 bytes of data with last 32 bytes of generated stream.
    for (let i = 0; i < 32 && i < data.length; i++) {
        result[16 + i] = data[i] ^ firstBlock[32 + i];
    }
    // Encrypt the rest of data.
    if (data.length > 32) {
        (0, xsalsa20_1.streamXOR)(key, nonceCounter, data.subarray(32), result.subarray(16 + 32), 8);
    }
    // Calculate Poly1305 authenticator of encrypted data using
    // authentication key in the first block of XSalsa20 stream.
    const auth = (0, poly1305_1.oneTimeAuth)(firstBlock.subarray(0, 32), result.subarray(16));
    // Copy authenticator to the beginning of result.
    for (let i = 0; i < auth.length; i++) {
        result[i] = auth[i];
    }
    // Clean auth.
    (0, wipe_1.wipe)(auth);
    // Clean first block.
    (0, wipe_1.wipe)(firstBlock);
    // Clean nonceCounter.
    (0, wipe_1.wipe)(nonceCounter);
    return result;
}
exports.secretBox = secretBox;
function openSecretBox(key, nonce, box) {
    if (nonce.length !== 24) {
        throw new Error("secretBox nonce must be 24 bytes");
    }
    if (box.length < 16) {
        throw new Error("secretBox data must be at least 16 bytes");
    }
    const firstBlock = new Uint8Array(64);
    // Allocate place for nonce and counter.
    const nonceCounter = new Uint8Array(24 + 8);
    // Set first bytes to nonce. Last 8 bytes will be counter.
    nonceCounter.set(nonce);
    // Generate first block of XSalsa20 stream, of which
    // first 32 bytes will be authentication key, and the rest
    // will be used for encryption.
    (0, xsalsa20_1.stream)(key, nonceCounter, firstBlock, 8);
    // Calculate Poly1305 authenticator of encrypted data using
    // authentication key in the first block of XSalsa20 stream.
    const auth = (0, poly1305_1.oneTimeAuth)(firstBlock.subarray(0, 32), box.subarray(16));
    // Check authenticator.
    if (!(0, poly1305_1.equal)(auth, box.subarray(0, 16))) {
        // Authenticator is incorrect: ciphertext or authenticator
        // was corrupted, maybe maliciously.
        return null;
    }
    // Authenticator verifies, so we can decrypt ciphertext.
    const ciphertext = box.subarray(16);
    // Allocate result array.
    const result = new Uint8Array(ciphertext.length);
    // Decrypt first 32 bytes of box with last 32 bytes of generated stream.
    for (let i = 0; i < 32 && i < ciphertext.length; i++) {
        result[i] = ciphertext[i] ^ firstBlock[32 + i];
    }
    // Decrypt the rest of data.
    if (ciphertext.length > 32) {
        (0, xsalsa20_1.streamXOR)(key, nonceCounter, ciphertext.subarray(32), result.subarray(32), 8);
    }
    // Clean auth.
    (0, wipe_1.wipe)(auth);
    // Clean first block.
    (0, wipe_1.wipe)(firstBlock);
    // Clean nonceCounter.
    (0, wipe_1.wipe)(nonceCounter);
    return result;
}
exports.openSecretBox = openSecretBox;
/** Generates a 32-byte random secret key.  */
function generateKey(prng) {
    return (0, random_1.randomBytes)(32, prng);
}
exports.generateKey = generateKey;

},{"@stablelib/poly1305":155,"@stablelib/random":156,"@stablelib/wipe":163,"@stablelib/xsalsa20":167}],155:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package poly1305 implements Poly1305 one-time message authentication algorithm.
 */
var constant_time_1 = require("@stablelib/constant-time");
var wipe_1 = require("@stablelib/wipe");
exports.DIGEST_LENGTH = 16;
// Port of Andrew Moon's Poly1305-donna-16. Public domain.
// https://github.com/floodyberry/poly1305-donna
/**
 * Poly1305 computes 16-byte authenticator of message using
 * a one-time 32-byte key.
 *
 * Important: key should be used for only one message,
 * it should never repeat.
 */
var Poly1305 = /** @class */ (function () {
    function Poly1305(key) {
        this.digestLength = exports.DIGEST_LENGTH;
        this._buffer = new Uint8Array(16);
        this._r = new Uint16Array(10);
        this._h = new Uint16Array(10);
        this._pad = new Uint16Array(8);
        this._leftover = 0;
        this._fin = 0;
        this._finished = false;
        var t0 = key[0] | key[1] << 8;
        this._r[0] = (t0) & 0x1fff;
        var t1 = key[2] | key[3] << 8;
        this._r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;
        var t2 = key[4] | key[5] << 8;
        this._r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;
        var t3 = key[6] | key[7] << 8;
        this._r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;
        var t4 = key[8] | key[9] << 8;
        this._r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;
        this._r[5] = ((t4 >>> 1)) & 0x1ffe;
        var t5 = key[10] | key[11] << 8;
        this._r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;
        var t6 = key[12] | key[13] << 8;
        this._r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;
        var t7 = key[14] | key[15] << 8;
        this._r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;
        this._r[9] = ((t7 >>> 5)) & 0x007f;
        this._pad[0] = key[16] | key[17] << 8;
        this._pad[1] = key[18] | key[19] << 8;
        this._pad[2] = key[20] | key[21] << 8;
        this._pad[3] = key[22] | key[23] << 8;
        this._pad[4] = key[24] | key[25] << 8;
        this._pad[5] = key[26] | key[27] << 8;
        this._pad[6] = key[28] | key[29] << 8;
        this._pad[7] = key[30] | key[31] << 8;
    }
    Poly1305.prototype._blocks = function (m, mpos, bytes) {
        var hibit = this._fin ? 0 : 1 << 11;
        var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
        var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
        while (bytes >= 16) {
            var t0 = m[mpos + 0] | m[mpos + 1] << 8;
            h0 += (t0) & 0x1fff;
            var t1 = m[mpos + 2] | m[mpos + 3] << 8;
            h1 += ((t0 >>> 13) | (t1 << 3)) & 0x1fff;
            var t2 = m[mpos + 4] | m[mpos + 5] << 8;
            h2 += ((t1 >>> 10) | (t2 << 6)) & 0x1fff;
            var t3 = m[mpos + 6] | m[mpos + 7] << 8;
            h3 += ((t2 >>> 7) | (t3 << 9)) & 0x1fff;
            var t4 = m[mpos + 8] | m[mpos + 9] << 8;
            h4 += ((t3 >>> 4) | (t4 << 12)) & 0x1fff;
            h5 += ((t4 >>> 1)) & 0x1fff;
            var t5 = m[mpos + 10] | m[mpos + 11] << 8;
            h6 += ((t4 >>> 14) | (t5 << 2)) & 0x1fff;
            var t6 = m[mpos + 12] | m[mpos + 13] << 8;
            h7 += ((t5 >>> 11) | (t6 << 5)) & 0x1fff;
            var t7 = m[mpos + 14] | m[mpos + 15] << 8;
            h8 += ((t6 >>> 8) | (t7 << 8)) & 0x1fff;
            h9 += ((t7 >>> 5)) | hibit;
            var c = 0;
            var d0 = c;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h2 * (5 * r8);
            d0 += h3 * (5 * r7);
            d0 += h4 * (5 * r6);
            c = (d0 >>> 13);
            d0 &= 0x1fff;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c += (d0 >>> 13);
            d0 &= 0x1fff;
            var d1 = c;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h2 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c = (d1 >>> 13);
            d1 &= 0x1fff;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c += (d1 >>> 13);
            d1 &= 0x1fff;
            var d2 = c;
            d2 += h0 * r2;
            d2 += h1 * r1;
            d2 += h2 * r0;
            d2 += h3 * (5 * r9);
            d2 += h4 * (5 * r8);
            c = (d2 >>> 13);
            d2 &= 0x1fff;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c += (d2 >>> 13);
            d2 &= 0x1fff;
            var d3 = c;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h2 * r1;
            d3 += h3 * r0;
            d3 += h4 * (5 * r9);
            c = (d3 >>> 13);
            d3 &= 0x1fff;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c += (d3 >>> 13);
            d3 &= 0x1fff;
            var d4 = c;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h2 * r2;
            d4 += h3 * r1;
            d4 += h4 * r0;
            c = (d4 >>> 13);
            d4 &= 0x1fff;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c += (d4 >>> 13);
            d4 &= 0x1fff;
            var d5 = c;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h2 * r3;
            d5 += h3 * r2;
            d5 += h4 * r1;
            c = (d5 >>> 13);
            d5 &= 0x1fff;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c += (d5 >>> 13);
            d5 &= 0x1fff;
            var d6 = c;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h2 * r4;
            d6 += h3 * r3;
            d6 += h4 * r2;
            c = (d6 >>> 13);
            d6 &= 0x1fff;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c += (d6 >>> 13);
            d6 &= 0x1fff;
            var d7 = c;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h2 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c = (d7 >>> 13);
            d7 &= 0x1fff;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c += (d7 >>> 13);
            d7 &= 0x1fff;
            var d8 = c;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h2 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c = (d8 >>> 13);
            d8 &= 0x1fff;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c += (d8 >>> 13);
            d8 &= 0x1fff;
            var d9 = c;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h2 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c = (d9 >>> 13);
            d9 &= 0x1fff;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c += (d9 >>> 13);
            d9 &= 0x1fff;
            c = (((c << 2) + c)) | 0;
            c = (c + d0) | 0;
            d0 = c & 0x1fff;
            c = (c >>> 13);
            d1 += c;
            h0 = d0;
            h1 = d1;
            h2 = d2;
            h3 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
        }
        this._h[0] = h0;
        this._h[1] = h1;
        this._h[2] = h2;
        this._h[3] = h3;
        this._h[4] = h4;
        this._h[5] = h5;
        this._h[6] = h6;
        this._h[7] = h7;
        this._h[8] = h8;
        this._h[9] = h9;
    };
    Poly1305.prototype.finish = function (mac, macpos) {
        if (macpos === void 0) { macpos = 0; }
        var g = new Uint16Array(10);
        var c;
        var mask;
        var f;
        var i;
        if (this._leftover) {
            i = this._leftover;
            this._buffer[i++] = 1;
            for (; i < 16; i++) {
                this._buffer[i] = 0;
            }
            this._fin = 1;
            this._blocks(this._buffer, 0, 16);
        }
        c = this._h[1] >>> 13;
        this._h[1] &= 0x1fff;
        for (i = 2; i < 10; i++) {
            this._h[i] += c;
            c = this._h[i] >>> 13;
            this._h[i] &= 0x1fff;
        }
        this._h[0] += (c * 5);
        c = this._h[0] >>> 13;
        this._h[0] &= 0x1fff;
        this._h[1] += c;
        c = this._h[1] >>> 13;
        this._h[1] &= 0x1fff;
        this._h[2] += c;
        g[0] = this._h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 0x1fff;
        for (i = 1; i < 10; i++) {
            g[i] = this._h[i] + c;
            c = g[i] >>> 13;
            g[i] &= 0x1fff;
        }
        g[9] -= (1 << 13);
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) {
            g[i] &= mask;
        }
        mask = ~mask;
        for (i = 0; i < 10; i++) {
            this._h[i] = (this._h[i] & mask) | g[i];
        }
        this._h[0] = ((this._h[0]) | (this._h[1] << 13)) & 0xffff;
        this._h[1] = ((this._h[1] >>> 3) | (this._h[2] << 10)) & 0xffff;
        this._h[2] = ((this._h[2] >>> 6) | (this._h[3] << 7)) & 0xffff;
        this._h[3] = ((this._h[3] >>> 9) | (this._h[4] << 4)) & 0xffff;
        this._h[4] = ((this._h[4] >>> 12) | (this._h[5] << 1) | (this._h[6] << 14)) & 0xffff;
        this._h[5] = ((this._h[6] >>> 2) | (this._h[7] << 11)) & 0xffff;
        this._h[6] = ((this._h[7] >>> 5) | (this._h[8] << 8)) & 0xffff;
        this._h[7] = ((this._h[8] >>> 8) | (this._h[9] << 5)) & 0xffff;
        f = this._h[0] + this._pad[0];
        this._h[0] = f & 0xffff;
        for (i = 1; i < 8; i++) {
            f = (((this._h[i] + this._pad[i]) | 0) + (f >>> 16)) | 0;
            this._h[i] = f & 0xffff;
        }
        mac[macpos + 0] = this._h[0] >>> 0;
        mac[macpos + 1] = this._h[0] >>> 8;
        mac[macpos + 2] = this._h[1] >>> 0;
        mac[macpos + 3] = this._h[1] >>> 8;
        mac[macpos + 4] = this._h[2] >>> 0;
        mac[macpos + 5] = this._h[2] >>> 8;
        mac[macpos + 6] = this._h[3] >>> 0;
        mac[macpos + 7] = this._h[3] >>> 8;
        mac[macpos + 8] = this._h[4] >>> 0;
        mac[macpos + 9] = this._h[4] >>> 8;
        mac[macpos + 10] = this._h[5] >>> 0;
        mac[macpos + 11] = this._h[5] >>> 8;
        mac[macpos + 12] = this._h[6] >>> 0;
        mac[macpos + 13] = this._h[6] >>> 8;
        mac[macpos + 14] = this._h[7] >>> 0;
        mac[macpos + 15] = this._h[7] >>> 8;
        this._finished = true;
        return this;
    };
    Poly1305.prototype.update = function (m) {
        var mpos = 0;
        var bytes = m.length;
        var want;
        if (this._leftover) {
            want = (16 - this._leftover);
            if (want > bytes) {
                want = bytes;
            }
            for (var i = 0; i < want; i++) {
                this._buffer[this._leftover + i] = m[mpos + i];
            }
            bytes -= want;
            mpos += want;
            this._leftover += want;
            if (this._leftover < 16) {
                return this;
            }
            this._blocks(this._buffer, 0, 16);
            this._leftover = 0;
        }
        if (bytes >= 16) {
            want = bytes - (bytes % 16);
            this._blocks(m, mpos, want);
            mpos += want;
            bytes -= want;
        }
        if (bytes) {
            for (var i = 0; i < bytes; i++) {
                this._buffer[this._leftover + i] = m[mpos + i];
            }
            this._leftover += bytes;
        }
        return this;
    };
    Poly1305.prototype.digest = function () {
        // TODO(dchest): it behaves differently than other hashes/HMAC,
        // because it throws when finished — others just return saved result.
        if (this._finished) {
            throw new Error("Poly1305 was finished");
        }
        var mac = new Uint8Array(16);
        this.finish(mac);
        return mac;
    };
    Poly1305.prototype.clean = function () {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._r);
        wipe_1.wipe(this._h);
        wipe_1.wipe(this._pad);
        this._leftover = 0;
        this._fin = 0;
        this._finished = true; // mark as finished even if not
        return this;
    };
    return Poly1305;
}());
exports.Poly1305 = Poly1305;
/**
 * Returns 16-byte authenticator of data using a one-time 32-byte key.
 *
 * Important: key should be used for only one message, it should never repeat.
 */
function oneTimeAuth(key, data) {
    var h = new Poly1305(key);
    h.update(data);
    var digest = h.digest();
    h.clean();
    return digest;
}
exports.oneTimeAuth = oneTimeAuth;
/**
 * Returns true if two authenticators are 16-byte long and equal.
 * Uses contant-time comparison to avoid leaking timing information.
 */
function equal(a, b) {
    if (a.length !== exports.DIGEST_LENGTH || b.length !== exports.DIGEST_LENGTH) {
        return false;
    }
    return constant_time_1.equal(a, b);
}
exports.equal = equal;

},{"@stablelib/constant-time":149,"@stablelib/wipe":163}],156:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
const system_1 = require("./source/system");
const binary_1 = require("@stablelib/binary");
const wipe_1 = require("@stablelib/wipe");
exports.defaultRandomSource = new system_1.SystemRandomSource();
function randomBytes(length, prng = exports.defaultRandomSource) {
    return prng.randomBytes(length);
}
exports.randomBytes = randomBytes;
/**
 * Returns a uniformly random unsigned 32-bit integer.
 */
function randomUint32(prng = exports.defaultRandomSource) {
    // Generate 4-byte random buffer.
    const buf = randomBytes(4, prng);
    // Convert bytes from buffer into a 32-bit integer.
    // It's not important which byte order to use, since
    // the result is random.
    const result = (0, binary_1.readUint32LE)(buf);
    // Clean the buffer.
    (0, wipe_1.wipe)(buf);
    return result;
}
exports.randomUint32 = randomUint32;
/** 62 alphanumeric characters for default charset of randomString() */
const ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
/**
 * Returns a uniform random string of the given length
 * with characters from the given charset.
 *
 * Charset must not have more than 256 characters.
 *
 * Default charset generates case-sensitive alphanumeric
 * strings (0-9, A-Z, a-z).
 */
function randomString(length, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    if (charset.length < 2) {
        throw new Error("randomString charset is too short");
    }
    if (charset.length > 256) {
        throw new Error("randomString charset is too long");
    }
    let out = '';
    const charsLen = charset.length;
    const maxByte = 256 - (256 % charsLen);
    while (length > 0) {
        const buf = randomBytes(Math.ceil(length * 256 / maxByte), prng);
        for (let i = 0; i < buf.length && length > 0; i++) {
            const randomByte = buf[i];
            if (randomByte < maxByte) {
                out += charset.charAt(randomByte % charsLen);
                length--;
            }
        }
        (0, wipe_1.wipe)(buf);
    }
    return out;
}
exports.randomString = randomString;
/**
 * Returns uniform random string containing at least the given
 * number of bits of entropy.
 *
 * For example, randomStringForEntropy(128) will return a 22-character
 * alphanumeric string, while randomStringForEntropy(128, "0123456789")
 * will return a 39-character numeric string, both will contain at
 * least 128 bits of entropy.
 *
 * Default charset generates case-sensitive alphanumeric
 * strings (0-9, A-Z, a-z).
 */
function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    const length = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
    return randomString(length, charset, prng);
}
exports.randomStringForEntropy = randomStringForEntropy;

},{"./source/system":159,"@stablelib/binary":146,"@stablelib/wipe":163}],157:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserRandomSource = void 0;
const QUOTA = 65536;
class BrowserRandomSource {
    constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        const browserCrypto = typeof self !== 'undefined'
            ? (self.crypto || self.msCrypto) // IE11 has msCrypto
            : null;
        if (browserCrypto && browserCrypto.getRandomValues !== undefined) {
            this._crypto = browserCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
        }
    }
    randomBytes(length) {
        if (!this.isAvailable || !this._crypto) {
            throw new Error("Browser random byte generator is not available.");
        }
        const out = new Uint8Array(length);
        for (let i = 0; i < out.length; i += QUOTA) {
            this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
        }
        return out;
    }
}
exports.BrowserRandomSource = BrowserRandomSource;

},{}],158:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeRandomSource = void 0;
const wipe_1 = require("@stablelib/wipe");
class NodeRandomSource {
    constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (typeof require !== "undefined") {
            const nodeCrypto = require("crypto");
            if (nodeCrypto && nodeCrypto.randomBytes) {
                this._crypto = nodeCrypto;
                this.isAvailable = true;
                this.isInstantiated = true;
            }
        }
    }
    randomBytes(length) {
        if (!this.isAvailable || !this._crypto) {
            throw new Error("Node.js random byte generator is not available.");
        }
        // Get random bytes (result is Buffer).
        let buffer = this._crypto.randomBytes(length);
        // Make sure we got the length that we requested.
        if (buffer.length !== length) {
            throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        // Allocate output array.
        const out = new Uint8Array(length);
        // Copy bytes from buffer to output.
        for (let i = 0; i < out.length; i++) {
            out[i] = buffer[i];
        }
        // Cleanup.
        (0, wipe_1.wipe)(buffer);
        return out;
    }
}
exports.NodeRandomSource = NodeRandomSource;

},{"@stablelib/wipe":163,"crypto":2}],159:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
exports.SystemRandomSource = void 0;
const browser_1 = require("./browser");
const node_1 = require("./node");
class SystemRandomSource {
    constructor() {
        this.isAvailable = false;
        this.name = "";
        // Try browser.
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
            this.isAvailable = true;
            this.name = "Browser";
            return;
        }
        // If no browser source, try Node.
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
            this.isAvailable = true;
            this.name = "Node";
            return;
        }
        // No sources, we're out of options.
    }
    randomBytes(length) {
        if (!this.isAvailable) {
            throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length);
    }
}
exports.SystemRandomSource = SystemRandomSource;

},{"./browser":157,"./node":158}],160:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package salsa20 implements Salsa20 stream cipher.
 */
var binary_1 = require("@stablelib/binary");
var wipe_1 = require("@stablelib/wipe");
// Number of Salsa20 rounds (Salsa20/20).
var ROUNDS = 20;
/**
 * Applies the Salsa20 core function to 16-byte input,
 * 32-byte key key, and puts the result into 64-byte array out.
 */
function core(out, input, key) {
    var j0 = 0x61707865; // "expa"
    var j1 = (key[3] << 24) | (key[2] << 16) | (key[1] << 8) | key[0];
    var j2 = (key[7] << 24) | (key[6] << 16) | (key[5] << 8) | key[4];
    var j3 = (key[11] << 24) | (key[10] << 16) | (key[9] << 8) | key[8];
    var j4 = (key[15] << 24) | (key[14] << 16) | (key[13] << 8) | key[12];
    var j5 = 0x3320646E; // "nd 3"
    var j6 = (input[3] << 24) | (input[2] << 16) | (input[1] << 8) | input[0];
    var j7 = (input[7] << 24) | (input[6] << 16) | (input[5] << 8) | input[4];
    var j8 = (input[11] << 24) | (input[10] << 16) | (input[9] << 8) | input[8];
    var j9 = (input[15] << 24) | (input[14] << 16) | (input[13] << 8) | input[12];
    var j10 = 0x79622D32; // "2-by"
    var j11 = (key[19] << 24) | (key[18] << 16) | (key[17] << 8) | key[16];
    var j12 = (key[23] << 24) | (key[22] << 16) | (key[21] << 8) | key[20];
    var j13 = (key[27] << 24) | (key[26] << 16) | (key[25] << 8) | key[24];
    var j14 = (key[31] << 24) | (key[30] << 16) | (key[29] << 8) | key[28];
    var j15 = 0x6B206574; // "te k"
    var x0 = j0;
    var x1 = j1;
    var x2 = j2;
    var x3 = j3;
    var x4 = j4;
    var x5 = j5;
    var x6 = j6;
    var x7 = j7;
    var x8 = j8;
    var x9 = j9;
    var x10 = j10;
    var x11 = j11;
    var x12 = j12;
    var x13 = j13;
    var x14 = j14;
    var x15 = j15;
    var u;
    for (var i = 0; i < ROUNDS; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> (32 - 7);
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> (32 - 9);
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> (32 - 13);
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> (32 - 18);
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> (32 - 7);
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> (32 - 9);
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> (32 - 13);
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> (32 - 18);
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> (32 - 7);
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> (32 - 9);
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> (32 - 13);
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> (32 - 18);
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> (32 - 7);
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> (32 - 9);
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> (32 - 13);
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> (32 - 18);
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> (32 - 7);
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> (32 - 9);
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> (32 - 13);
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> (32 - 18);
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> (32 - 7);
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> (32 - 9);
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> (32 - 13);
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> (32 - 18);
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> (32 - 7);
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> (32 - 9);
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> (32 - 13);
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> (32 - 18);
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> (32 - 7);
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> (32 - 9);
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> (32 - 13);
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> (32 - 18);
    }
    binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
    binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
    binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
    binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
    binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
    binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
    binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
    binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
    binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
    binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
    binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
    binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
    binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
    binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
    binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
    binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
}
/**
 * Encrypt src with Salsa20/20 stream generated for the given 32-byte key
 * and 8-byte and write the result into dst and return it.
 *
 * dst and src may be the same, but otherwise must not overlap.
 *
 * Never use the same key and nonce to encrypt more than one message.
 *
 * If nonceInplaceCounterLength is not 0, the nonce is assumed to be a 16-byte
 * array with stream counter in first nonceInplaceCounterLength bytes and nonce
 * in the last remaining bytes. The counter will be incremented inplace for
 * each Salsa20 block. This is useful if you need to encrypt one stream of data
 * in chunks.
 */
function streamXOR(key, nonce, src, dst, nonceInplaceCounterLength) {
    if (nonceInplaceCounterLength === void 0) { nonceInplaceCounterLength = 0; }
    // We only support 256-bit keys.
    if (key.length !== 32) {
        throw new Error("Salsa20: key size must be 32 bytes");
    }
    if (dst.length < src.length) {
        throw new Error("Salsa20: destination is shorter than source");
    }
    var nc;
    var counterStart;
    if (nonceInplaceCounterLength === 0) {
        if (nonce.length !== 8) {
            throw new Error("Salsa20 nonce must be 8 bytes");
        }
        nc = new Uint8Array(16);
        // First bytes of nc are nonce, set it.
        nc.set(nonce);
        // Last bytes are counter.
        counterStart = nonce.length;
    }
    else {
        if (nonce.length !== 16) {
            throw new Error("Salsa20 nonce with counter must be 16 bytes");
        }
        // This will update passed nonce with counter inplace.
        nc = nonce;
        counterStart = 16 - nonceInplaceCounterLength;
    }
    // Allocate temporary space for Salsa20 block.
    var block = new Uint8Array(64);
    for (var i = 0; i < src.length; i += 64) {
        // Generate a block.
        core(block, nc, key);
        // XOR block bytes with src into dst.
        for (var j = i; j < i + 64 && j < src.length; j++) {
            dst[j] = src[j] ^ block[j - i];
        }
        // Increment counter.
        incrementCounter(nc, counterStart, nc.length - counterStart);
    }
    // Cleanup temporary space.
    wipe_1.wipe(block);
    if (nonceInplaceCounterLength === 0) {
        // Cleanup counter.
        wipe_1.wipe(nc);
    }
    return dst;
}
exports.streamXOR = streamXOR;
/**
 * Generate Salsa20/20 stream for the given 32-byte key and 8-byte nonce
 * and write it into dst and return it.
 *
 * Never use the same key and nonce to generate more than one stream.
 *
 * If nonceInplaceCounterLength is not 0, it behaves the same
 * with respect to the nonce as described in streamXOR documentation.
 *
 * stream is like streamXOR with all-zero src.
 */
function stream(key, nonce, dst, nonceInplaceCounterLength) {
    if (nonceInplaceCounterLength === void 0) { nonceInplaceCounterLength = 0; }
    wipe_1.wipe(dst);
    return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
}
exports.stream = stream;
function incrementCounter(counter, pos, len) {
    var carry = 1;
    while (len--) {
        carry = carry + (counter[pos] & 0xff) | 0;
        counter[pos] = carry & 0xff;
        carry >>>= 8;
        pos++;
    }
    if (carry > 0) {
        throw new Error("Salsa20: counter overflow");
    }
}

},{"@stablelib/binary":146,"@stablelib/wipe":163}],161:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
var binary_1 = require("@stablelib/binary");
var wipe_1 = require("@stablelib/wipe");
exports.DIGEST_LENGTH = 64;
exports.BLOCK_SIZE = 128;
/**
 * SHA-2-512 cryptographic hash algorithm.
 */
var SHA512 = /** @class */ (function () {
    function SHA512() {
        /** Length of hash output */
        this.digestLength = exports.DIGEST_LENGTH;
        /** Block size */
        this.blockSize = exports.BLOCK_SIZE;
        // Note: Int32Array is used instead of Uint32Array for performance reasons.
        this._stateHi = new Int32Array(8); // hash state, high bytes
        this._stateLo = new Int32Array(8); // hash state, low bytes
        this._tempHi = new Int32Array(16); // temporary state, high bytes
        this._tempLo = new Int32Array(16); // temporary state, low bytes
        this._buffer = new Uint8Array(256); // buffer for data to hash
        this._bufferLength = 0; // number of bytes in buffer
        this._bytesHashed = 0; // number of total bytes hashed
        this._finished = false; // indicates whether the hash was finalized
        this.reset();
    }
    SHA512.prototype._initState = function () {
        this._stateHi[0] = 0x6a09e667;
        this._stateHi[1] = 0xbb67ae85;
        this._stateHi[2] = 0x3c6ef372;
        this._stateHi[3] = 0xa54ff53a;
        this._stateHi[4] = 0x510e527f;
        this._stateHi[5] = 0x9b05688c;
        this._stateHi[6] = 0x1f83d9ab;
        this._stateHi[7] = 0x5be0cd19;
        this._stateLo[0] = 0xf3bcc908;
        this._stateLo[1] = 0x84caa73b;
        this._stateLo[2] = 0xfe94f82b;
        this._stateLo[3] = 0x5f1d36f1;
        this._stateLo[4] = 0xade682d1;
        this._stateLo[5] = 0x2b3e6c1f;
        this._stateLo[6] = 0xfb41bd6b;
        this._stateLo[7] = 0x137e2179;
    };
    /**
     * Resets hash state making it possible
     * to re-use this instance to hash other data.
     */
    SHA512.prototype.reset = function () {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
    };
    /**
     * Cleans internal buffers and resets hash state.
     */
    SHA512.prototype.clean = function () {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._tempHi);
        wipe_1.wipe(this._tempLo);
        this.reset();
    };
    /**
     * Updates hash state with the given data.
     *
     * Throws error when trying to update already finalized hash:
     * instance must be reset to update it again.
     */
    SHA512.prototype.update = function (data, dataLength) {
        if (dataLength === void 0) { dataLength = data.length; }
        if (this._finished) {
            throw new Error("SHA512: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
            while (this._bufferLength < exports.BLOCK_SIZE && dataLength > 0) {
                this._buffer[this._bufferLength++] = data[dataPos++];
                dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
                hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
                this._bufferLength = 0;
            }
        }
        if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data, dataPos, dataLength);
            dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
        }
        return this;
    };
    /**
     * Finalizes hash state and puts hash into out.
     * If hash was already finalized, puts the same value.
     */
    SHA512.prototype.finish = function (out) {
        if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = (bytesHashed / 0x20000000) | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = (bytesHashed % 128 < 112) ? 128 : 256;
            this._buffer[left] = 0x80;
            for (var i = left + 1; i < padLength - 8; i++) {
                this._buffer[i] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
            this._finished = true;
        }
        for (var i = 0; i < this.digestLength / 8; i++) {
            binary_1.writeUint32BE(this._stateHi[i], out, i * 8);
            binary_1.writeUint32BE(this._stateLo[i], out, i * 8 + 4);
        }
        return this;
    };
    /**
     * Returns the final hash digest.
     */
    SHA512.prototype.digest = function () {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
    };
    /**
     * Function useful for HMAC/PBKDF2 optimization. Returns hash state to be
     * used with restoreState(). Only chain value is saved, not buffers or
     * other state variables.
     */
    SHA512.prototype.saveState = function () {
        if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
        }
        return {
            stateHi: new Int32Array(this._stateHi),
            stateLo: new Int32Array(this._stateLo),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : undefined,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
        };
    };
    /**
     * Function useful for HMAC/PBKDF2 optimization. Restores state saved by
     * saveState() and sets bytesHashed to the given value.
     */
    SHA512.prototype.restoreState = function (savedState) {
        this._stateHi.set(savedState.stateHi);
        this._stateLo.set(savedState.stateLo);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
    };
    /**
     * Cleans state returned by saveState().
     */
    SHA512.prototype.cleanSavedState = function (savedState) {
        wipe_1.wipe(savedState.stateHi);
        wipe_1.wipe(savedState.stateLo);
        if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
    };
    return SHA512;
}());
exports.SHA512 = SHA512;
// Constants
var K = new Int32Array([
    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]);
function hashBlocks(wh, wl, hh, hl, m, pos, len) {
    var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
    var h, l;
    var th, tl;
    var a, b, c, d;
    while (len >= 128) {
        for (var i = 0; i < 16; i++) {
            var j = 8 * i + pos;
            wh[i] = binary_1.readUint32BE(m, j);
            wl[i] = binary_1.readUint32BE(m, j + 4);
        }
        for (var i = 0; i < 80; i++) {
            var bh0 = ah0;
            var bh1 = ah1;
            var bh2 = ah2;
            var bh3 = ah3;
            var bh4 = ah4;
            var bh5 = ah5;
            var bh6 = ah6;
            var bh7 = ah7;
            var bl0 = al0;
            var bl1 = al1;
            var bl2 = al2;
            var bl3 = al3;
            var bl4 = al4;
            var bl5 = al5;
            var bl6 = al6;
            var bl7 = al7;
            // add
            h = ah7;
            l = al7;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            // Sigma1
            h = ((ah4 >>> 14) | (al4 << (32 - 14))) ^ ((ah4 >>> 18) |
                (al4 << (32 - 18))) ^ ((al4 >>> (41 - 32)) | (ah4 << (32 - (41 - 32))));
            l = ((al4 >>> 14) | (ah4 << (32 - 14))) ^ ((al4 >>> 18) |
                (ah4 << (32 - 18))) ^ ((ah4 >>> (41 - 32)) | (al4 << (32 - (41 - 32))));
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            // Ch
            h = (ah4 & ah5) ^ (~ah4 & ah6);
            l = (al4 & al5) ^ (~al4 & al6);
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            // K
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            // w
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 0xffff | d << 16;
            tl = a & 0xffff | b << 16;
            // add
            h = th;
            l = tl;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            // Sigma0
            h = ((ah0 >>> 28) | (al0 << (32 - 28))) ^ ((al0 >>> (34 - 32)) |
                (ah0 << (32 - (34 - 32)))) ^ ((al0 >>> (39 - 32)) | (ah0 << (32 - (39 - 32))));
            l = ((al0 >>> 28) | (ah0 << (32 - 28))) ^ ((ah0 >>> (34 - 32)) |
                (al0 << (32 - (34 - 32)))) ^ ((ah0 >>> (39 - 32)) | (al0 << (32 - (39 - 32))));
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            // Maj
            h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
            l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = (c & 0xffff) | (d << 16);
            bl7 = (a & 0xffff) | (b << 16);
            // add
            h = bh3;
            l = bl3;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = (c & 0xffff) | (d << 16);
            bl3 = (a & 0xffff) | (b << 16);
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
                for (var j = 0; j < 16; j++) {
                    // add
                    h = wh[j];
                    l = wl[j];
                    a = l & 0xffff;
                    b = l >>> 16;
                    c = h & 0xffff;
                    d = h >>> 16;
                    h = wh[(j + 9) % 16];
                    l = wl[(j + 9) % 16];
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    // sigma0
                    th = wh[(j + 1) % 16];
                    tl = wl[(j + 1) % 16];
                    h = ((th >>> 1) | (tl << (32 - 1))) ^ ((th >>> 8) |
                        (tl << (32 - 8))) ^ (th >>> 7);
                    l = ((tl >>> 1) | (th << (32 - 1))) ^ ((tl >>> 8) |
                        (th << (32 - 8))) ^ ((tl >>> 7) | (th << (32 - 7)));
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    // sigma1
                    th = wh[(j + 14) % 16];
                    tl = wl[(j + 14) % 16];
                    h = ((th >>> 19) | (tl << (32 - 19))) ^ ((tl >>> (61 - 32)) |
                        (th << (32 - (61 - 32)))) ^ (th >>> 6);
                    l = ((tl >>> 19) | (th << (32 - 19))) ^ ((th >>> (61 - 32)) |
                        (tl << (32 - (61 - 32)))) ^ ((tl >>> 6) | (th << (32 - 6)));
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    b += a >>> 16;
                    c += b >>> 16;
                    d += c >>> 16;
                    wh[j] = (c & 0xffff) | (d << 16);
                    wl[j] = (a & 0xffff) | (b << 16);
                }
            }
        }
        // add
        h = ah0;
        l = al0;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[0];
        l = hl[0];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[0] = ah0 = (c & 0xffff) | (d << 16);
        hl[0] = al0 = (a & 0xffff) | (b << 16);
        h = ah1;
        l = al1;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[1];
        l = hl[1];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[1] = ah1 = (c & 0xffff) | (d << 16);
        hl[1] = al1 = (a & 0xffff) | (b << 16);
        h = ah2;
        l = al2;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[2];
        l = hl[2];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[2] = ah2 = (c & 0xffff) | (d << 16);
        hl[2] = al2 = (a & 0xffff) | (b << 16);
        h = ah3;
        l = al3;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[3];
        l = hl[3];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[3] = ah3 = (c & 0xffff) | (d << 16);
        hl[3] = al3 = (a & 0xffff) | (b << 16);
        h = ah4;
        l = al4;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[4];
        l = hl[4];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[4] = ah4 = (c & 0xffff) | (d << 16);
        hl[4] = al4 = (a & 0xffff) | (b << 16);
        h = ah5;
        l = al5;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[5];
        l = hl[5];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[5] = ah5 = (c & 0xffff) | (d << 16);
        hl[5] = al5 = (a & 0xffff) | (b << 16);
        h = ah6;
        l = al6;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[6];
        l = hl[6];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[6] = ah6 = (c & 0xffff) | (d << 16);
        hl[6] = al6 = (a & 0xffff) | (b << 16);
        h = ah7;
        l = al7;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[7];
        l = hl[7];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[7] = ah7 = (c & 0xffff) | (d << 16);
        hl[7] = al7 = (a & 0xffff) | (b << 16);
        pos += 128;
        len -= 128;
    }
    return pos;
}
function hash(data) {
    var h = new SHA512();
    h.update(data);
    var digest = h.digest();
    h.clean();
    return digest;
}
exports.hash = hash;

},{"@stablelib/binary":146,"@stablelib/wipe":163}],162:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package utf8 implements UTF-8 encoding and decoding.
 */
var INVALID_UTF16 = "utf8: invalid string";
var INVALID_UTF8 = "utf8: invalid source encoding";
/**
 * Encodes the given string into UTF-8 byte array.
 * Throws if the source string has invalid UTF-16 encoding.
 */
function encode(s) {
    // Calculate result length and allocate output array.
    // encodedLength() also validates string and throws errors,
    // so we don't need repeat validation here.
    var arr = new Uint8Array(encodedLength(s));
    var pos = 0;
    for (var i = 0; i < s.length; i++) {
        var c = s.charCodeAt(i);
        if (c < 0x80) {
            arr[pos++] = c;
        }
        else if (c < 0x800) {
            arr[pos++] = 0xc0 | c >> 6;
            arr[pos++] = 0x80 | c & 0x3f;
        }
        else if (c < 0xd800) {
            arr[pos++] = 0xe0 | c >> 12;
            arr[pos++] = 0x80 | (c >> 6) & 0x3f;
            arr[pos++] = 0x80 | c & 0x3f;
        }
        else {
            i++; // get one more character
            c = (c & 0x3ff) << 10;
            c |= s.charCodeAt(i) & 0x3ff;
            c += 0x10000;
            arr[pos++] = 0xf0 | c >> 18;
            arr[pos++] = 0x80 | (c >> 12) & 0x3f;
            arr[pos++] = 0x80 | (c >> 6) & 0x3f;
            arr[pos++] = 0x80 | c & 0x3f;
        }
    }
    return arr;
}
exports.encode = encode;
/**
 * Returns the number of bytes required to encode the given string into UTF-8.
 * Throws if the source string has invalid UTF-16 encoding.
 */
function encodedLength(s) {
    var result = 0;
    for (var i = 0; i < s.length; i++) {
        var c = s.charCodeAt(i);
        if (c < 0x80) {
            result += 1;
        }
        else if (c < 0x800) {
            result += 2;
        }
        else if (c < 0xd800) {
            result += 3;
        }
        else if (c <= 0xdfff) {
            if (i >= s.length - 1) {
                throw new Error(INVALID_UTF16);
            }
            i++; // "eat" next character
            result += 4;
        }
        else {
            throw new Error(INVALID_UTF16);
        }
    }
    return result;
}
exports.encodedLength = encodedLength;
/**
 * Decodes the given byte array from UTF-8 into a string.
 * Throws if encoding is invalid.
 */
function decode(arr) {
    var chars = [];
    for (var i = 0; i < arr.length; i++) {
        var b = arr[i];
        if (b & 0x80) {
            var min = void 0;
            if (b < 0xe0) {
                // Need 1 more byte.
                if (i >= arr.length) {
                    throw new Error(INVALID_UTF8);
                }
                var n1 = arr[++i];
                if ((n1 & 0xc0) !== 0x80) {
                    throw new Error(INVALID_UTF8);
                }
                b = (b & 0x1f) << 6 | (n1 & 0x3f);
                min = 0x80;
            }
            else if (b < 0xf0) {
                // Need 2 more bytes.
                if (i >= arr.length - 1) {
                    throw new Error(INVALID_UTF8);
                }
                var n1 = arr[++i];
                var n2 = arr[++i];
                if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80) {
                    throw new Error(INVALID_UTF8);
                }
                b = (b & 0x0f) << 12 | (n1 & 0x3f) << 6 | (n2 & 0x3f);
                min = 0x800;
            }
            else if (b < 0xf8) {
                // Need 3 more bytes.
                if (i >= arr.length - 2) {
                    throw new Error(INVALID_UTF8);
                }
                var n1 = arr[++i];
                var n2 = arr[++i];
                var n3 = arr[++i];
                if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80 || (n3 & 0xc0) !== 0x80) {
                    throw new Error(INVALID_UTF8);
                }
                b = (b & 0x0f) << 18 | (n1 & 0x3f) << 12 | (n2 & 0x3f) << 6 | (n3 & 0x3f);
                min = 0x10000;
            }
            else {
                throw new Error(INVALID_UTF8);
            }
            if (b < min || (b >= 0xd800 && b <= 0xdfff)) {
                throw new Error(INVALID_UTF8);
            }
            if (b >= 0x10000) {
                // Surrogate pair.
                if (b > 0x10ffff) {
                    throw new Error(INVALID_UTF8);
                }
                b -= 0x10000;
                chars.push(String.fromCharCode(0xd800 | (b >> 10)));
                b = 0xdc00 | (b & 0x3ff);
            }
        }
        chars.push(String.fromCharCode(b));
    }
    return chars.join("");
}
exports.decode = decode;

},{}],163:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Sets all values in the given array to zero and returns it.
 *
 * The fact that it sets bytes to zero can be relied on.
 *
 * There is no guarantee that this function makes data disappear from memory,
 * as runtime implementation can, for example, have copying garbage collector
 * that will make copies of sensitive data before we wipe it. Or that an
 * operating system will write our data to swap or sleep image. Another thing
 * is that an optimizing compiler can remove calls to this function or make it
 * no-op. There's nothing we can do with it, so we just do our best and hope
 * that everything will be okay and good will triumph over evil.
 */
function wipe(array) {
    // Right now it's similar to array.fill(0). If it turns
    // out that runtimes optimize this call away, maybe
    // we can try something else.
    for (var i = 0; i < array.length; i++) {
        array[i] = 0;
    }
    return array;
}
exports.wipe = wipe;

},{}],164:[function(require,module,exports){
"use strict";
// Copyright (C) 2020 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
exports.X25519Session = exports.SECRET_SEED_LENGTH = exports.SAVED_STATE_LENGTH = exports.ACCEPT_MESSAGE_LENGTH = exports.OFFER_MESSAGE_LENGTH = void 0;
const random_1 = require("@stablelib/random");
const wipe_1 = require("@stablelib/wipe");
const x25519_1 = require("@stablelib/x25519");
const x25519_session_1 = require("./x25519-session");
/** Constants for key agreement */
exports.OFFER_MESSAGE_LENGTH = x25519_1.PUBLIC_KEY_LENGTH;
exports.ACCEPT_MESSAGE_LENGTH = x25519_1.PUBLIC_KEY_LENGTH;
exports.SAVED_STATE_LENGTH = x25519_1.SECRET_KEY_LENGTH;
exports.SECRET_SEED_LENGTH = x25519_1.SECRET_KEY_LENGTH;
/**
 * X25519 key agreement using ephemeral key pairs.
 *
 * Note that unless this key agreement is combined with an authentication
 * method, such as public key signatures, it's vulnerable to man-in-the-middle
 * attacks.
 */
class X25519Session {
    constructor(secretSeed, prng) {
        this.offerMessageLength = exports.OFFER_MESSAGE_LENGTH;
        this.acceptMessageLength = exports.ACCEPT_MESSAGE_LENGTH;
        this.sharedKeyLength = x25519_1.SHARED_KEY_LENGTH;
        this.savedStateLength = exports.SAVED_STATE_LENGTH;
        this._seed = secretSeed || (0, random_1.randomBytes)(x25519_1.SECRET_KEY_LENGTH, prng);
    }
    saveState() {
        return new Uint8Array(this._seed);
    }
    restoreState(savedState) {
        this._seed = new Uint8Array(savedState);
        return this;
    }
    clean() {
        if (this._seed) {
            (0, wipe_1.wipe)(this._seed);
        }
        if (this._keyPair) {
            (0, wipe_1.wipe)(this._keyPair.secretKey);
            (0, wipe_1.wipe)(this._keyPair.publicKey);
        }
        if (this._sharedKey) {
            (0, wipe_1.wipe)(this._sharedKey);
        }
        if (this._sessionKeys) {
            (0, wipe_1.wipe)(this._sessionKeys.receive);
            (0, wipe_1.wipe)(this._sessionKeys.send);
        }
    }
    offer() {
        this._keyPair = (0, x25519_1.generateKeyPairFromSeed)(this._seed);
        return new Uint8Array(this._keyPair.publicKey);
    }
    accept(offerMsg) {
        if (this._keyPair) {
            throw new Error("X25519Session: accept shouldn't be called by offering party");
        }
        if (offerMsg.length !== this.offerMessageLength) {
            throw new Error("X25519Session: incorrect offer message length");
        }
        if (this._sharedKey) {
            throw new Error("X25519Session: accept was already called");
        }
        const keyPair = (0, x25519_1.generateKeyPairFromSeed)(this._seed);
        this._sharedKey = (0, x25519_1.sharedKey)(keyPair.secretKey, offerMsg);
        this._sessionKeys = (0, x25519_session_1.clientSessionKeysFromSharedKey)(this._sharedKey, keyPair.publicKey, offerMsg);
        (0, wipe_1.wipe)(keyPair.secretKey);
        return keyPair.publicKey;
    }
    finish(acceptMsg) {
        if (acceptMsg.length !== this.acceptMessageLength) {
            throw new Error("X25519Session: incorrect accept message length");
        }
        if (!this._keyPair) {
            throw new Error("X25519Session: no offer state");
        }
        if (this._sharedKey) {
            throw new Error("X25519Session: finish was already called");
        }
        this._sharedKey = (0, x25519_1.sharedKey)(this._keyPair.secretKey, acceptMsg);
        this._sessionKeys = (0, x25519_session_1.serverSessionKeysFromSharedKey)(this._sharedKey, this._keyPair.publicKey, acceptMsg);
        return this;
    }
    getSharedKey() {
        if (!this._sharedKey) {
            throw new Error("X25519Session: no shared key established");
        }
        return new Uint8Array(this._sharedKey);
    }
    getSessionKeys() {
        if (!this._sessionKeys) {
            throw new Error("X25519Session: no shared key established");
        }
        return {
            receive: new Uint8Array(this._sessionKeys.receive),
            send: new Uint8Array(this._sessionKeys.send),
        };
    }
}
exports.X25519Session = X25519Session;

},{"./x25519-session":165,"@stablelib/random":156,"@stablelib/wipe":163,"@stablelib/x25519":166}],165:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
exports.clientSessionKeys = exports.serverSessionKeys = exports.clientSessionKeysFromSharedKey = exports.serverSessionKeysFromSharedKey = exports.X25519Session = void 0;
/**
 * Package x25519-session implements libsodium compatible session keys generation based on X25519 key agreement.
 */
const blake2b_1 = require("@stablelib/blake2b");
const x25519_1 = require("@stablelib/x25519");
var keyagreement_1 = require("./keyagreement");
Object.defineProperty(exports, "X25519Session", { enumerable: true, get: function () { return keyagreement_1.X25519Session; } });
const SESSION_KEY_LENGTH = 32;
/**
 * Generates server-side session encryption keys from the shared key obtained during agreement phase.
 */
function serverSessionKeysFromSharedKey(sharedKey, myPublicKey, theirPublicKey, hash = blake2b_1.BLAKE2b) {
    const state = new hash();
    if (state.digestLength !== SESSION_KEY_LENGTH * 2) {
        throw new Error("X25519: incorrect digest length");
    }
    const h = state.update(sharedKey).update(theirPublicKey).update(myPublicKey).digest();
    return {
        send: h.subarray(0, SESSION_KEY_LENGTH),
        receive: h.subarray(SESSION_KEY_LENGTH),
    };
}
exports.serverSessionKeysFromSharedKey = serverSessionKeysFromSharedKey;
/**
 * Generates client-side session encryption keys from the shared key obtained during agreement phase.
 */
function clientSessionKeysFromSharedKey(sharedKey, myPublicKey, theirPublicKey, hash = blake2b_1.BLAKE2b) {
    const state = new hash();
    if (state.digestLength !== SESSION_KEY_LENGTH * 2) {
        throw new Error("X25519: incorrect digest length");
    }
    const h = state.update(sharedKey).update(myPublicKey).update(theirPublicKey).digest();
    return {
        receive: h.subarray(0, SESSION_KEY_LENGTH),
        send: h.subarray(SESSION_KEY_LENGTH),
    };
}
exports.clientSessionKeysFromSharedKey = clientSessionKeysFromSharedKey;
/**
 * Generates server-side session encryption keys. Uses a key pair and a peer's public key to generate the shared key.
 */
function serverSessionKeys(myKeyPair, theirPublicKey, hash = blake2b_1.BLAKE2b) {
    const sk = (0, x25519_1.sharedKey)(myKeyPair.secretKey, theirPublicKey);
    return serverSessionKeysFromSharedKey(sk, myKeyPair.publicKey, theirPublicKey, hash);
}
exports.serverSessionKeys = serverSessionKeys;
/**
 * Generates client-side session encryption keys. Uses a key pair and a peer's public key to generate the shared key.
 */
function clientSessionKeys(myKeyPair, theirPublicKey, hash = blake2b_1.BLAKE2b) {
    const sk = (0, x25519_1.sharedKey)(myKeyPair.secretKey, theirPublicKey);
    return clientSessionKeysFromSharedKey(sk, myKeyPair.publicKey, theirPublicKey, hash);
}
exports.clientSessionKeys = clientSessionKeys;

},{"./keyagreement":164,"@stablelib/blake2b":147,"@stablelib/x25519":166}],166:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
/**
 * Package x25519 implements X25519 key agreement.
 */
const random_1 = require("@stablelib/random");
const wipe_1 = require("@stablelib/wipe");
exports.PUBLIC_KEY_LENGTH = 32;
exports.SECRET_KEY_LENGTH = 32;
exports.SHARED_KEY_LENGTH = 32;
// Returns new zero-filled 16-element GF (Float64Array).
// If passed an array of numbers, prefills the returned
// array with them.
//
// We use Float64Array, because we need 48-bit numbers
// for this implementation.
function gf(init) {
    const r = new Float64Array(16);
    if (init) {
        for (let i = 0; i < init.length; i++) {
            r[i] = init[i];
        }
    }
    return r;
}
// Base point.
const _9 = new Uint8Array(32);
_9[0] = 9;
const _121665 = gf([0xdb41, 1]);
function car25519(o) {
    let c = 1;
    for (let i = 0; i < 16; i++) {
        let v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
    }
    o[0] += c - 1 + 37 * (c - 1);
}
function sel25519(p, q, b) {
    const c = ~(b - 1);
    for (let i = 0; i < 16; i++) {
        const t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
    }
}
function pack25519(o, n) {
    const m = gf();
    const t = gf();
    for (let i = 0; i < 16; i++) {
        t[i] = n[i];
    }
    car25519(t);
    car25519(t);
    car25519(t);
    for (let j = 0; j < 2; j++) {
        m[0] = t[0] - 0xffed;
        for (let i = 1; i < 15; i++) {
            m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
            m[i - 1] &= 0xffff;
        }
        m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
        const b = (m[15] >> 16) & 1;
        m[14] &= 0xffff;
        sel25519(t, m, 1 - b);
    }
    for (let i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 0xff;
        o[2 * i + 1] = t[i] >> 8;
    }
}
function unpack25519(o, n) {
    for (let i = 0; i < 16; i++) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
    }
    o[15] &= 0x7fff;
}
function add(o, a, b) {
    for (let i = 0; i < 16; i++) {
        o[i] = a[i] + b[i];
    }
}
function sub(o, a, b) {
    for (let i = 0; i < 16; i++) {
        o[i] = a[i] - b[i];
    }
}
function mul(o, a, b) {
    let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    v = a[0];
    t0 += v * b0;
    t1 += v * b1;
    t2 += v * b2;
    t3 += v * b3;
    t4 += v * b4;
    t5 += v * b5;
    t6 += v * b6;
    t7 += v * b7;
    t8 += v * b8;
    t9 += v * b9;
    t10 += v * b10;
    t11 += v * b11;
    t12 += v * b12;
    t13 += v * b13;
    t14 += v * b14;
    t15 += v * b15;
    v = a[1];
    t1 += v * b0;
    t2 += v * b1;
    t3 += v * b2;
    t4 += v * b3;
    t5 += v * b4;
    t6 += v * b5;
    t7 += v * b6;
    t8 += v * b7;
    t9 += v * b8;
    t10 += v * b9;
    t11 += v * b10;
    t12 += v * b11;
    t13 += v * b12;
    t14 += v * b13;
    t15 += v * b14;
    t16 += v * b15;
    v = a[2];
    t2 += v * b0;
    t3 += v * b1;
    t4 += v * b2;
    t5 += v * b3;
    t6 += v * b4;
    t7 += v * b5;
    t8 += v * b6;
    t9 += v * b7;
    t10 += v * b8;
    t11 += v * b9;
    t12 += v * b10;
    t13 += v * b11;
    t14 += v * b12;
    t15 += v * b13;
    t16 += v * b14;
    t17 += v * b15;
    v = a[3];
    t3 += v * b0;
    t4 += v * b1;
    t5 += v * b2;
    t6 += v * b3;
    t7 += v * b4;
    t8 += v * b5;
    t9 += v * b6;
    t10 += v * b7;
    t11 += v * b8;
    t12 += v * b9;
    t13 += v * b10;
    t14 += v * b11;
    t15 += v * b12;
    t16 += v * b13;
    t17 += v * b14;
    t18 += v * b15;
    v = a[4];
    t4 += v * b0;
    t5 += v * b1;
    t6 += v * b2;
    t7 += v * b3;
    t8 += v * b4;
    t9 += v * b5;
    t10 += v * b6;
    t11 += v * b7;
    t12 += v * b8;
    t13 += v * b9;
    t14 += v * b10;
    t15 += v * b11;
    t16 += v * b12;
    t17 += v * b13;
    t18 += v * b14;
    t19 += v * b15;
    v = a[5];
    t5 += v * b0;
    t6 += v * b1;
    t7 += v * b2;
    t8 += v * b3;
    t9 += v * b4;
    t10 += v * b5;
    t11 += v * b6;
    t12 += v * b7;
    t13 += v * b8;
    t14 += v * b9;
    t15 += v * b10;
    t16 += v * b11;
    t17 += v * b12;
    t18 += v * b13;
    t19 += v * b14;
    t20 += v * b15;
    v = a[6];
    t6 += v * b0;
    t7 += v * b1;
    t8 += v * b2;
    t9 += v * b3;
    t10 += v * b4;
    t11 += v * b5;
    t12 += v * b6;
    t13 += v * b7;
    t14 += v * b8;
    t15 += v * b9;
    t16 += v * b10;
    t17 += v * b11;
    t18 += v * b12;
    t19 += v * b13;
    t20 += v * b14;
    t21 += v * b15;
    v = a[7];
    t7 += v * b0;
    t8 += v * b1;
    t9 += v * b2;
    t10 += v * b3;
    t11 += v * b4;
    t12 += v * b5;
    t13 += v * b6;
    t14 += v * b7;
    t15 += v * b8;
    t16 += v * b9;
    t17 += v * b10;
    t18 += v * b11;
    t19 += v * b12;
    t20 += v * b13;
    t21 += v * b14;
    t22 += v * b15;
    v = a[8];
    t8 += v * b0;
    t9 += v * b1;
    t10 += v * b2;
    t11 += v * b3;
    t12 += v * b4;
    t13 += v * b5;
    t14 += v * b6;
    t15 += v * b7;
    t16 += v * b8;
    t17 += v * b9;
    t18 += v * b10;
    t19 += v * b11;
    t20 += v * b12;
    t21 += v * b13;
    t22 += v * b14;
    t23 += v * b15;
    v = a[9];
    t9 += v * b0;
    t10 += v * b1;
    t11 += v * b2;
    t12 += v * b3;
    t13 += v * b4;
    t14 += v * b5;
    t15 += v * b6;
    t16 += v * b7;
    t17 += v * b8;
    t18 += v * b9;
    t19 += v * b10;
    t20 += v * b11;
    t21 += v * b12;
    t22 += v * b13;
    t23 += v * b14;
    t24 += v * b15;
    v = a[10];
    t10 += v * b0;
    t11 += v * b1;
    t12 += v * b2;
    t13 += v * b3;
    t14 += v * b4;
    t15 += v * b5;
    t16 += v * b6;
    t17 += v * b7;
    t18 += v * b8;
    t19 += v * b9;
    t20 += v * b10;
    t21 += v * b11;
    t22 += v * b12;
    t23 += v * b13;
    t24 += v * b14;
    t25 += v * b15;
    v = a[11];
    t11 += v * b0;
    t12 += v * b1;
    t13 += v * b2;
    t14 += v * b3;
    t15 += v * b4;
    t16 += v * b5;
    t17 += v * b6;
    t18 += v * b7;
    t19 += v * b8;
    t20 += v * b9;
    t21 += v * b10;
    t22 += v * b11;
    t23 += v * b12;
    t24 += v * b13;
    t25 += v * b14;
    t26 += v * b15;
    v = a[12];
    t12 += v * b0;
    t13 += v * b1;
    t14 += v * b2;
    t15 += v * b3;
    t16 += v * b4;
    t17 += v * b5;
    t18 += v * b6;
    t19 += v * b7;
    t20 += v * b8;
    t21 += v * b9;
    t22 += v * b10;
    t23 += v * b11;
    t24 += v * b12;
    t25 += v * b13;
    t26 += v * b14;
    t27 += v * b15;
    v = a[13];
    t13 += v * b0;
    t14 += v * b1;
    t15 += v * b2;
    t16 += v * b3;
    t17 += v * b4;
    t18 += v * b5;
    t19 += v * b6;
    t20 += v * b7;
    t21 += v * b8;
    t22 += v * b9;
    t23 += v * b10;
    t24 += v * b11;
    t25 += v * b12;
    t26 += v * b13;
    t27 += v * b14;
    t28 += v * b15;
    v = a[14];
    t14 += v * b0;
    t15 += v * b1;
    t16 += v * b2;
    t17 += v * b3;
    t18 += v * b4;
    t19 += v * b5;
    t20 += v * b6;
    t21 += v * b7;
    t22 += v * b8;
    t23 += v * b9;
    t24 += v * b10;
    t25 += v * b11;
    t26 += v * b12;
    t27 += v * b13;
    t28 += v * b14;
    t29 += v * b15;
    v = a[15];
    t15 += v * b0;
    t16 += v * b1;
    t17 += v * b2;
    t18 += v * b3;
    t19 += v * b4;
    t20 += v * b5;
    t21 += v * b6;
    t22 += v * b7;
    t23 += v * b8;
    t24 += v * b9;
    t25 += v * b10;
    t26 += v * b11;
    t27 += v * b12;
    t28 += v * b13;
    t29 += v * b14;
    t30 += v * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    // t15 left as is
    // first car
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    // second car
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
}
function square(o, a) {
    mul(o, a, a);
}
function inv25519(o, inp) {
    const c = gf();
    for (let i = 0; i < 16; i++) {
        c[i] = inp[i];
    }
    for (let i = 253; i >= 0; i--) {
        square(c, c);
        if (i !== 2 && i !== 4) {
            mul(c, c, inp);
        }
    }
    for (let i = 0; i < 16; i++) {
        o[i] = c[i];
    }
}
function scalarMult(n, p) {
    const z = new Uint8Array(32);
    const x = new Float64Array(80);
    const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
    for (let i = 0; i < 31; i++) {
        z[i] = n[i];
    }
    z[31] = (n[31] & 127) | 64;
    z[0] &= 248;
    unpack25519(x, p);
    for (let i = 0; i < 16; i++) {
        b[i] = x[i];
    }
    a[0] = d[0] = 1;
    for (let i = 254; i >= 0; --i) {
        const r = (z[i >>> 3] >>> (i & 7)) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        add(e, a, c);
        sub(a, a, c);
        add(c, b, d);
        sub(b, b, d);
        square(d, e);
        square(f, a);
        mul(a, c, a);
        mul(c, b, e);
        add(e, a, c);
        sub(a, a, c);
        square(b, a);
        sub(c, d, f);
        mul(a, c, _121665);
        add(a, a, d);
        mul(c, c, a);
        mul(a, d, f);
        mul(d, b, x);
        square(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
    }
    for (let i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
    }
    const x32 = x.subarray(32);
    const x16 = x.subarray(16);
    inv25519(x32, x32);
    mul(x16, x16, x32);
    const q = new Uint8Array(32);
    pack25519(q, x16);
    return q;
}
exports.scalarMult = scalarMult;
function scalarMultBase(n) {
    return scalarMult(n, _9);
}
exports.scalarMultBase = scalarMultBase;
function generateKeyPairFromSeed(seed) {
    if (seed.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
    }
    const secretKey = new Uint8Array(seed);
    const publicKey = scalarMultBase(secretKey);
    return {
        publicKey,
        secretKey
    };
}
exports.generateKeyPairFromSeed = generateKeyPairFromSeed;
function generateKeyPair(prng) {
    const seed = (0, random_1.randomBytes)(32, prng);
    const result = generateKeyPairFromSeed(seed);
    (0, wipe_1.wipe)(seed);
    return result;
}
exports.generateKeyPair = generateKeyPair;
/**
 * Returns a shared key between our secret key and a peer's public key.
 *
 * Throws an error if the given keys are of wrong length.
 *
 * If rejectZero is true throws if the calculated shared key is all-zero.
 * From RFC 7748:
 *
 * > Protocol designers using Diffie-Hellman over the curves defined in
 * > this document must not assume "contributory behavior".  Specially,
 * > contributory behavior means that both parties' private keys
 * > contribute to the resulting shared key.  Since curve25519 and
 * > curve448 have cofactors of 8 and 4 (respectively), an input point of
 * > small order will eliminate any contribution from the other party's
 * > private key.  This situation can be detected by checking for the all-
 * > zero output, which implementations MAY do, as specified in Section 6.
 * > However, a large number of existing implementations do not do this.
 *
 * IMPORTANT: the returned key is a raw result of scalar multiplication.
 * To use it as a key material, hash it with a cryptographic hash function.
 */
function sharedKey(mySecretKey, theirPublicKey, rejectZero = false) {
    if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect secret key length");
    }
    if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect public key length");
    }
    const result = scalarMult(mySecretKey, theirPublicKey);
    if (rejectZero) {
        let zeros = 0;
        for (let i = 0; i < result.length; i++) {
            zeros |= result[i];
        }
        if (zeros === 0) {
            throw new Error("X25519: invalid shared key");
        }
    }
    return result;
}
exports.sharedKey = sharedKey;

},{"@stablelib/random":156,"@stablelib/wipe":163}],167:[function(require,module,exports){
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package xsalsa20 implements XSalsa20 stream cipher.
 */
var binary_1 = require("@stablelib/binary");
var salsa20_1 = require("@stablelib/salsa20");
var wipe_1 = require("@stablelib/wipe");
/**
 * Encrypt src with Salsa20/20 stream generated for the given 32-byte key
 * and 24-byte and write the result into dst and return it.
 *
 * dst and src may be the same, but otherwise must not overlap.
 *
 * Never use the same key and nonce to encrypt more than one message.
 */
function streamXOR(key, nonce, src, dst, nonceInplaceCounterLength) {
    if (nonceInplaceCounterLength === void 0) { nonceInplaceCounterLength = 0; }
    if (nonceInplaceCounterLength === 0) {
        if (nonce.length !== 24) {
            throw new Error("XSalsa20 nonce must be 24 bytes");
        }
    }
    else {
        if (nonce.length !== 32) {
            throw new Error("XSalsa20 nonce with counter must be 32 bytes");
        }
    }
    // Use HSalsa one-way function to transform first 16 bytes of
    // 24-byte extended nonce and key into a new key for Salsa
    // stream -- "subkey".
    var subkey = hsalsa(key, nonce.subarray(0, 16), new Uint8Array(32));
    // Use last 8 bytes of 24-byte extended nonce as an actual nonce,
    // and a subkey derived in the previous step as key to encrypt.
    //
    // If nonceInplaceCounterLength > 0, we'll still pass the correct
    // nonce || counter, as we don't limit the end of nonce subarray.
    var result = salsa20_1.streamXOR(subkey, nonce.subarray(16), src, dst, nonceInplaceCounterLength);
    // Clean subkey.
    wipe_1.wipe(subkey);
    return result;
}
exports.streamXOR = streamXOR;
/**
 * Generate Salsa20/20 stream for the given 32-byte key and
 * 24-byte nonce and write it into dst and return it.
 *
 * Never use the same key and nonce to generate more than one stream.
 *
 * stream is like streamXOR with all-zero src.
 */
function stream(key, nonce, dst, nonceInplaceCounterLength) {
    if (nonceInplaceCounterLength === void 0) { nonceInplaceCounterLength = 0; }
    wipe_1.wipe(dst);
    return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
}
exports.stream = stream;
// Number of Salsa20 rounds (Salsa20/20).
var ROUNDS = 20;
/**
 * HSalsa20 is a one-way function used in XSalsa20 to extend nonce,
 * and in NaCl to hash X25519 shared keys. It takes 32-byte key and
 * 16-byte src and writes 32-byte result into dst and returns it.
 */
function hsalsa(key, src, dst) {
    var x0 = 0x61707865; // "expa"
    var x1 = (key[3] << 24) | (key[2] << 16) | (key[1] << 8) | key[0];
    var x2 = (key[7] << 24) | (key[6] << 16) | (key[5] << 8) | key[4];
    var x3 = (key[11] << 24) | (key[10] << 16) | (key[9] << 8) | key[8];
    var x4 = (key[15] << 24) | (key[14] << 16) | (key[13] << 8) | key[12];
    var x5 = 0x3320646E; // "nd 3"
    var x6 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
    var x7 = (src[7] << 24) | (src[6] << 16) | (src[5] << 8) | src[4];
    var x8 = (src[11] << 24) | (src[10] << 16) | (src[9] << 8) | src[8];
    var x9 = (src[15] << 24) | (src[14] << 16) | (src[13] << 8) | src[12];
    var x10 = 0x79622D32; // "2-by"
    var x11 = (key[19] << 24) | (key[18] << 16) | (key[17] << 8) | key[16];
    var x12 = (key[23] << 24) | (key[22] << 16) | (key[21] << 8) | key[20];
    var x13 = (key[27] << 24) | (key[26] << 16) | (key[25] << 8) | key[24];
    var x14 = (key[31] << 24) | (key[30] << 16) | (key[29] << 8) | key[28];
    var x15 = 0x6B206574; // "te k"
    var u;
    for (var i = 0; i < ROUNDS; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> (32 - 7);
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> (32 - 9);
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> (32 - 13);
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> (32 - 18);
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> (32 - 7);
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> (32 - 9);
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> (32 - 13);
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> (32 - 18);
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> (32 - 7);
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> (32 - 9);
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> (32 - 13);
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> (32 - 18);
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> (32 - 7);
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> (32 - 9);
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> (32 - 13);
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> (32 - 18);
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> (32 - 7);
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> (32 - 9);
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> (32 - 13);
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> (32 - 18);
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> (32 - 7);
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> (32 - 9);
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> (32 - 13);
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> (32 - 18);
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> (32 - 7);
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> (32 - 9);
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> (32 - 13);
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> (32 - 18);
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> (32 - 7);
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> (32 - 9);
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> (32 - 13);
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> (32 - 18);
    }
    binary_1.writeUint32LE(x0, dst, 0);
    binary_1.writeUint32LE(x5, dst, 4);
    binary_1.writeUint32LE(x10, dst, 8);
    binary_1.writeUint32LE(x15, dst, 12);
    binary_1.writeUint32LE(x6, dst, 16);
    binary_1.writeUint32LE(x7, dst, 20);
    binary_1.writeUint32LE(x8, dst, 24);
    binary_1.writeUint32LE(x9, dst, 28);
    return dst;
}
exports.hsalsa = hsalsa;

},{"@stablelib/binary":146,"@stablelib/salsa20":160,"@stablelib/wipe":163}],168:[function(require,module,exports){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@airgap/beacon-dapp'), require('@taquito/taquito')) :
    typeof define === 'function' && define.amd ? define(['exports', '@airgap/beacon-dapp', '@taquito/taquito'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.taquitoBeaconWallet = {}, global.beaconDapp, global.taquito));
})(this, (function (exports, beaconDapp, taquito) { 'use strict';

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
    const VERSION = {
        "commitHash": "178bea7c6a3b3c58f23163fcc72e28aa5f08702a",
        "version": "15.1.0"
    };

    /**
     * @packageDocumentation
     * @module @taquito/beacon-wallet
     */
    /**
     *  @category Error
     *  @description Error that indicates the Beacon wallet not being initialized
     */
    class BeaconWalletNotInitialized extends Error {
        constructor() {
            super('You need to initialize BeaconWallet by calling beaconWallet.requestPermissions first');
            this.name = 'BeaconWalletNotInitialized';
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates missing required persmission scopes
     */
    class MissingRequiredScopes extends Error {
        constructor(requiredScopes) {
            super(`Required permissions scopes were not granted: ${requiredScopes.join(',')}`);
            this.requiredScopes = requiredScopes;
            this.name = 'MissingRequiredScopes';
        }
    }
    class BeaconWallet {
        constructor(options) {
            this.client = beaconDapp.getDAppClientInstance(options);
        }
        validateRequiredScopesOrFail(permissionScopes, requiredScopes) {
            const mandatoryScope = new Set(requiredScopes);
            for (const scope of permissionScopes) {
                if (mandatoryScope.has(scope)) {
                    mandatoryScope.delete(scope);
                }
            }
            if (mandatoryScope.size > 0) {
                throw new MissingRequiredScopes(Array.from(mandatoryScope));
            }
        }
        requestPermissions(request) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.client.requestPermissions(request);
            });
        }
        getPKH() {
            return __awaiter(this, void 0, void 0, function* () {
                const account = yield this.client.getActiveAccount();
                if (!account) {
                    throw new BeaconWalletNotInitialized();
                }
                return account.address;
            });
        }
        mapTransferParamsToWalletParams(params) {
            return __awaiter(this, void 0, void 0, function* () {
                let walletParams;
                yield this.client.showPrepare();
                try {
                    walletParams = yield params();
                }
                catch (err) {
                    yield this.client.hideUI();
                    throw err;
                }
                return this.removeDefaultParams(walletParams, yield taquito.createTransferOperation(this.formatParameters(walletParams)));
            });
        }
        mapIncreasePaidStorageWalletParams(params) {
            return __awaiter(this, void 0, void 0, function* () {
                let walletParams;
                yield this.client.showPrepare();
                try {
                    walletParams = yield params();
                }
                catch (err) {
                    yield this.client.hideUI();
                    throw err;
                }
                return this.removeDefaultParams(walletParams, yield taquito.createIncreasePaidStorageOperation(this.formatParameters(walletParams)));
            });
        }
        mapOriginateParamsToWalletParams(params) {
            return __awaiter(this, void 0, void 0, function* () {
                let walletParams;
                yield this.client.showPrepare();
                try {
                    walletParams = yield params();
                }
                catch (err) {
                    yield this.client.hideUI();
                    throw err;
                }
                return this.removeDefaultParams(walletParams, yield taquito.createOriginationOperation(this.formatParameters(walletParams)));
            });
        }
        mapDelegateParamsToWalletParams(params) {
            return __awaiter(this, void 0, void 0, function* () {
                let walletParams;
                yield this.client.showPrepare();
                try {
                    walletParams = yield params();
                }
                catch (err) {
                    yield this.client.hideUI();
                    throw err;
                }
                return this.removeDefaultParams(walletParams, yield taquito.createSetDelegateOperation(this.formatParameters(walletParams)));
            });
        }
        formatParameters(params) {
            if (params.fee) {
                params.fee = params.fee.toString();
            }
            if (params.storageLimit) {
                params.storageLimit = params.storageLimit.toString();
            }
            if (params.gasLimit) {
                params.gasLimit = params.gasLimit.toString();
            }
            return params;
        }
        removeDefaultParams(params, operatedParams) {
            // If fee, storageLimit or gasLimit is undefined by user
            // in case of beacon wallet, dont override it by
            // defaults.
            if (!params.fee) {
                delete operatedParams.fee;
            }
            if (!params.storageLimit) {
                delete operatedParams.storage_limit;
            }
            if (!params.gasLimit) {
                delete operatedParams.gas_limit;
            }
            return operatedParams;
        }
        sendOperations(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const account = yield this.client.getActiveAccount();
                if (!account) {
                    throw new BeaconWalletNotInitialized();
                }
                const permissions = account.scopes;
                this.validateRequiredScopesOrFail(permissions, [beaconDapp.PermissionScope.OPERATION_REQUEST]);
                const { transactionHash } = yield this.client.requestOperation({ operationDetails: params });
                return transactionHash;
            });
        }
        /**
         *
         * @description Removes all beacon values from the storage. After using this method, this instance is no longer usable.
         * You will have to instantiate a new BeaconWallet.
         */
        disconnect() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.client.destroy();
            });
        }
        /**
         *
         * @description This method removes the active account from local storage by setting it to undefined.
         */
        clearActiveAccount() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.client.setActiveAccount();
            });
        }
    }

    exports.BeaconWallet = BeaconWallet;
    exports.BeaconWalletNotInitialized = BeaconWalletNotInitialized;
    exports.MissingRequiredScopes = MissingRequiredScopes;
    exports.VERSION = VERSION;

    Object.defineProperty(exports, '__esModule', { value: true });

}));


},{"@airgap/beacon-dapp":78,"@taquito/taquito":204}],169:[function(require,module,exports){
(function (process){(function (){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('axios')) :
    typeof define === 'function' && define.amd ? define(['exports', 'axios'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.taquitoHttpUtils = {}, global.axios));
})(this, (function (exports, axios) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /**
     * Hypertext Transfer Protocol (HTTP) response status codes.
     * @see {@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}
     */
    exports.STATUS_CODE = void 0;
    (function (STATUS_CODE) {
        /**
         * The server has received the request headers and the client should proceed to send the request body
         * (in the case of a request for which a body needs to be sent; for example, a POST request).
         * Sending a large request body to a server after a request has been rejected for inappropriate headers would be inefficient.
         * To have a server check the request's headers, a client must send Expect: 100-continue as a header in its initial request
         * and receive a 100 Continue status code in response before sending the body. The response 417 Expectation Failed indicates the request should not be continued.
         */
        STATUS_CODE[STATUS_CODE["CONTINUE"] = 100] = "CONTINUE";
        /**
         * The requester has asked the server to switch protocols and the server has agreed to do so.
         */
        STATUS_CODE[STATUS_CODE["SWITCHING_PROTOCOLS"] = 101] = "SWITCHING_PROTOCOLS";
        /**
         * A WebDAV request may contain many sub-requests involving file operations, requiring a long time to complete the request.
         * This code indicates that the server has received and is processing the request, but no response is available yet.
         * This prevents the client from timing out and assuming the request was lost.
         */
        STATUS_CODE[STATUS_CODE["PROCESSING"] = 102] = "PROCESSING";
        /**
         * Standard response for successful HTTP requests.
         * The actual response will depend on the request method used.
         * In a GET request, the response will contain an entity corresponding to the requested resource.
         * In a POST request, the response will contain an entity describing or containing the result of the action.
         */
        STATUS_CODE[STATUS_CODE["OK"] = 200] = "OK";
        /**
         * The request has been fulfilled, resulting in the creation of a new resource.
         */
        STATUS_CODE[STATUS_CODE["CREATED"] = 201] = "CREATED";
        /**
         * The request has been accepted for processing, but the processing has not been completed.
         * The request might or might not be eventually acted upon, and may be disallowed when processing occurs.
         */
        STATUS_CODE[STATUS_CODE["ACCEPTED"] = 202] = "ACCEPTED";
        /**
         * SINCE HTTP/1.1
         * The server is a transforming proxy that received a 200 OK from its origin,
         * but is returning a modified version of the origin's response.
         */
        STATUS_CODE[STATUS_CODE["NON_AUTHORITATIVE_INFORMATION"] = 203] = "NON_AUTHORITATIVE_INFORMATION";
        /**
         * The server successfully processed the request and is not returning any content.
         */
        STATUS_CODE[STATUS_CODE["NO_CONTENT"] = 204] = "NO_CONTENT";
        /**
         * The server successfully processed the request, but is not returning any content.
         * Unlike a 204 response, this response requires that the requester reset the document view.
         */
        STATUS_CODE[STATUS_CODE["RESET_CONTENT"] = 205] = "RESET_CONTENT";
        /**
         * The server is delivering only part of the resource (byte serving) due to a range header sent by the client.
         * The range header is used by HTTP clients to enable resuming of interrupted downloads,
         * or split a download into multiple simultaneous streams.
         */
        STATUS_CODE[STATUS_CODE["PARTIAL_CONTENT"] = 206] = "PARTIAL_CONTENT";
        /**
         * The message body that follows is an XML message and can contain a number of separate response codes,
         * depending on how many sub-requests were made.
         */
        STATUS_CODE[STATUS_CODE["MULTI_STATUS"] = 207] = "MULTI_STATUS";
        /**
         * The members of a DAV binding have already been enumerated in a preceding part of the (multistatus) response,
         * and are not being included again.
         */
        STATUS_CODE[STATUS_CODE["ALREADY_REPORTED"] = 208] = "ALREADY_REPORTED";
        /**
         * The server has fulfilled a request for the resource,
         * and the response is a representation of the result of one or more instance-manipulations applied to the current instance.
         */
        STATUS_CODE[STATUS_CODE["IM_USED"] = 226] = "IM_USED";
        /**
         * Indicates multiple options for the resource from which the client may choose (via agent-driven content negotiation).
         * For example, this code could be used to present multiple video format options,
         * to list files with different filename extensions, or to suggest word-sense disambiguation.
         */
        STATUS_CODE[STATUS_CODE["MULTIPLE_CHOICES"] = 300] = "MULTIPLE_CHOICES";
        /**
         * This and all future requests should be directed to the given URI.
         */
        STATUS_CODE[STATUS_CODE["MOVED_PERMANENTLY"] = 301] = "MOVED_PERMANENTLY";
        /**
         * This is an example of industry practice contradicting the standard.
         * The HTTP/1.0 specification (RFC 1945) required the client to perform a temporary redirect
         * (the original describing phrase was "Moved Temporarily"), but popular browsers implemented 302
         * with the functionality of a 303 See Other. Therefore, HTTP/1.1 added status codes 303 and 307
         * to distinguish between the two behaviours. However, some Web applications and frameworks
         * use the 302 status code as if it were the 303.
         */
        STATUS_CODE[STATUS_CODE["FOUND"] = 302] = "FOUND";
        /**
         * SINCE HTTP/1.1
         * The response to the request can be found under another URI using a GET method.
         * When received in response to a POST (or PUT/DELETE), the client should presume that
         * the server has received the data and should issue a redirect with a separate GET message.
         */
        STATUS_CODE[STATUS_CODE["SEE_OTHER"] = 303] = "SEE_OTHER";
        /**
         * Indicates that the resource has not been modified since the version specified by the request headers If-Modified-Since or If-None-Match.
         * In such case, there is no need to retransmit the resource since the client still has a previously-downloaded copy.
         */
        STATUS_CODE[STATUS_CODE["NOT_MODIFIED"] = 304] = "NOT_MODIFIED";
        /**
         * SINCE HTTP/1.1
         * The requested resource is available only through a proxy, the address for which is provided in the response.
         * Many HTTP clients (such as Mozilla and Internet Explorer) do not correctly handle responses with this status code, primarily for security reasons.
         */
        STATUS_CODE[STATUS_CODE["USE_PROXY"] = 305] = "USE_PROXY";
        /**
         * No longer used. Originally meant "Subsequent requests should use the specified proxy."
         */
        STATUS_CODE[STATUS_CODE["SWITCH_PROXY"] = 306] = "SWITCH_PROXY";
        /**
         * SINCE HTTP/1.1
         * In this case, the request should be repeated with another URI; however, future requests should still use the original URI.
         * In contrast to how 302 was historically implemented, the request method is not allowed to be changed when reissuing the original request.
         * For example, a POST request should be repeated using another POST request.
         */
        STATUS_CODE[STATUS_CODE["TEMPORARY_REDIRECT"] = 307] = "TEMPORARY_REDIRECT";
        /**
         * The request and all future requests should be repeated using another URI.
         * 307 and 308 parallel the behaviors of 302 and 301, but do not allow the HTTP method to change.
         * So, for example, submitting a form to a permanently redirected resource may continue smoothly.
         */
        STATUS_CODE[STATUS_CODE["PERMANENT_REDIRECT"] = 308] = "PERMANENT_REDIRECT";
        /**
         * The server cannot or will not process the request due to an apparent client error
         * (e.g., malformed request syntax, too large size, invalid request message framing, or deceptive request routing).
         */
        STATUS_CODE[STATUS_CODE["BAD_REQUEST"] = 400] = "BAD_REQUEST";
        /**
         * Similar to 403 Forbidden, but specifically for use when authentication is required and has failed or has not yet
         * been provided. The response must include a WWW-Authenticate header field containing a challenge applicable to the
         * requested resource. See Basic access authentication and Digest access authentication. 401 semantically means
         * "unauthenticated",i.e. the user does not have the necessary credentials.
         */
        STATUS_CODE[STATUS_CODE["UNAUTHORIZED"] = 401] = "UNAUTHORIZED";
        /**
         * Reserved for future use. The original intention was that this code might be used as part of some form of digital
         * cash or micro payment scheme, but that has not happened, and this code is not usually used.
         * Google Developers API uses this status if a particular developer has exceeded the daily limit on requests.
         */
        STATUS_CODE[STATUS_CODE["PAYMENT_REQUIRED"] = 402] = "PAYMENT_REQUIRED";
        /**
         * The request was valid, but the server is refusing action.
         * The user might not have the necessary permissions for a resource.
         */
        STATUS_CODE[STATUS_CODE["FORBIDDEN"] = 403] = "FORBIDDEN";
        /**
         * The requested resource could not be found but may be available in the future.
         * Subsequent requests by the client are permissible.
         */
        STATUS_CODE[STATUS_CODE["NOT_FOUND"] = 404] = "NOT_FOUND";
        /**
         * A request method is not supported for the requested resource;
         * for example, a GET request on a form that requires data to be presented via POST, or a PUT request on a read-only resource.
         */
        STATUS_CODE[STATUS_CODE["METHOD_NOT_ALLOWED"] = 405] = "METHOD_NOT_ALLOWED";
        /**
         * The requested resource is capable of generating only content not acceptable according to the Accept headers sent in the request.
         */
        STATUS_CODE[STATUS_CODE["NOT_ACCEPTABLE"] = 406] = "NOT_ACCEPTABLE";
        /**
         * The client must first authenticate itself with the proxy.
         */
        STATUS_CODE[STATUS_CODE["PROXY_AUTHENTICATION_REQUIRED"] = 407] = "PROXY_AUTHENTICATION_REQUIRED";
        /**
         * The server timed out waiting for the request.
         * According to HTTP specifications:
         * "The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time."
         */
        STATUS_CODE[STATUS_CODE["REQUEST_TIMEOUT"] = 408] = "REQUEST_TIMEOUT";
        /**
         * Indicates that the request could not be processed because of conflict in the request,
         * such as an edit conflict between multiple simultaneous updates.
         */
        STATUS_CODE[STATUS_CODE["CONFLICT"] = 409] = "CONFLICT";
        /**
         * Indicates that the resource requested is no longer available and will not be available again.
         * This should be used when a resource has been intentionally removed and the resource should be purged.
         * Upon receiving a 410 status code, the client should not request the resource in the future.
         * Clients such as search engines should remove the resource from their indices.
         * Most use cases do not require clients and search engines to purge the resource, and a "404 Not Found" may be used instead.
         */
        STATUS_CODE[STATUS_CODE["GONE"] = 410] = "GONE";
        /**
         * The request did not specify the length of its content, which is required by the requested resource.
         */
        STATUS_CODE[STATUS_CODE["LENGTH_REQUIRED"] = 411] = "LENGTH_REQUIRED";
        /**
         * The server does not meet one of the preconditions that the requester put on the request.
         */
        STATUS_CODE[STATUS_CODE["PRECONDITION_FAILED"] = 412] = "PRECONDITION_FAILED";
        /**
         * The request is larger than the server is willing or able to process. Previously called "Request Entity Too Large".
         */
        STATUS_CODE[STATUS_CODE["PAYLOAD_TOO_LARGE"] = 413] = "PAYLOAD_TOO_LARGE";
        /**
         * The URI provided was too long for the server to process. Often the result of too much data being encoded as a query-string of a GET request,
         * in which case it should be converted to a POST request.
         * Called "Request-URI Too Long" previously.
         */
        STATUS_CODE[STATUS_CODE["URI_TOO_LONG"] = 414] = "URI_TOO_LONG";
        /**
         * The request entity has a media type which the server or resource does not support.
         * For example, the client uploads an image as image/svg+xml, but the server requires that images use a different format.
         */
        STATUS_CODE[STATUS_CODE["UNSUPPORTED_MEDIA_TYPE"] = 415] = "UNSUPPORTED_MEDIA_TYPE";
        /**
         * The client has asked for a portion of the file (byte serving), but the server cannot supply that portion.
         * For example, if the client asked for a part of the file that lies beyond the end of the file.
         * Called "Requested Range Not Satisfiable" previously.
         */
        STATUS_CODE[STATUS_CODE["RANGE_NOT_SATISFIABLE"] = 416] = "RANGE_NOT_SATISFIABLE";
        /**
         * The server cannot meet the requirements of the Expect request-header field.
         */
        STATUS_CODE[STATUS_CODE["EXPECTATION_FAILED"] = 417] = "EXPECTATION_FAILED";
        /**
         * This code was defined in 1998 as one of the traditional IETF April Fools' jokes, in RFC 2324, Hyper Text Coffee Pot Control Protocol,
         * and is not expected to be implemented by actual HTTP servers. The RFC specifies this code should be returned by
         * teapots requested to brew coffee. This HTTP status is used as an Easter egg in some websites, including Google.com.
         */
        STATUS_CODE[STATUS_CODE["I_AM_A_TEAPOT"] = 418] = "I_AM_A_TEAPOT";
        /**
         * The request was directed at a server that is not able to produce a response (for example because a connection reuse).
         */
        STATUS_CODE[STATUS_CODE["MISDIRECTED_REQUEST"] = 421] = "MISDIRECTED_REQUEST";
        /**
         * The request was well-formed but was unable to be followed due to semantic errors.
         */
        STATUS_CODE[STATUS_CODE["UNPROCESSABLE_ENTITY"] = 422] = "UNPROCESSABLE_ENTITY";
        /**
         * The resource that is being accessed is locked.
         */
        STATUS_CODE[STATUS_CODE["LOCKED"] = 423] = "LOCKED";
        /**
         * The request failed due to failure of a previous request (e.g., a PROPPATCH).
         */
        STATUS_CODE[STATUS_CODE["FAILED_DEPENDENCY"] = 424] = "FAILED_DEPENDENCY";
        /**
         * The client should switch to a different protocol such as TLS/1.0, given in the Upgrade header field.
         */
        STATUS_CODE[STATUS_CODE["UPGRADE_REQUIRED"] = 426] = "UPGRADE_REQUIRED";
        /**
         * The origin server requires the request to be conditional.
         * Intended to prevent "the 'lost update' problem, where a client
         * GETs a resource's state, modifies it, and PUTs it back to the server,
         * when meanwhile a third party has modified the state on the server, leading to a conflict."
         */
        STATUS_CODE[STATUS_CODE["PRECONDITION_REQUIRED"] = 428] = "PRECONDITION_REQUIRED";
        /**
         * The user has sent too many requests in a given amount of time. Intended for use with rate-limiting schemes.
         */
        STATUS_CODE[STATUS_CODE["TOO_MANY_REQUESTS"] = 429] = "TOO_MANY_REQUESTS";
        /**
         * The server is unwilling to process the request because either an individual header field,
         * or all the header fields collectively, are too large.
         */
        STATUS_CODE[STATUS_CODE["REQUEST_HEADER_FIELDS_TOO_LARGE"] = 431] = "REQUEST_HEADER_FIELDS_TOO_LARGE";
        /**
         * A server operator has received a legal demand to deny access to a resource or to a set of resources
         * that includes the requested resource. The code 451 was chosen as a reference to the novel Fahrenheit 451.
         */
        STATUS_CODE[STATUS_CODE["UNAVAILABLE_FOR_LEGAL_REASONS"] = 451] = "UNAVAILABLE_FOR_LEGAL_REASONS";
        /**
         * A generic error message, given when an unexpected condition was encountered and no more specific message is suitable.
         */
        STATUS_CODE[STATUS_CODE["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";
        /**
         * The server either does not recognize the request method, or it lacks the ability to fulfill the request.
         * Usually this implies future availability (e.g., a new feature of a web-service API).
         */
        STATUS_CODE[STATUS_CODE["NOT_IMPLEMENTED"] = 501] = "NOT_IMPLEMENTED";
        /**
         * The server was acting as a gateway or proxy and received an invalid response from the upstream server.
         */
        STATUS_CODE[STATUS_CODE["BAD_GATEWAY"] = 502] = "BAD_GATEWAY";
        /**
         * The server is currently unavailable (because it is overloaded or down for maintenance).
         * Generally, this is a temporary state.
         */
        STATUS_CODE[STATUS_CODE["SERVICE_UNAVAILABLE"] = 503] = "SERVICE_UNAVAILABLE";
        /**
         * The server was acting as a gateway or proxy and did not receive a timely response from the upstream server.
         */
        STATUS_CODE[STATUS_CODE["GATEWAY_TIMEOUT"] = 504] = "GATEWAY_TIMEOUT";
        /**
         * The server does not support the HTTP protocol version used in the request
         */
        STATUS_CODE[STATUS_CODE["HTTP_VERSION_NOT_SUPPORTED"] = 505] = "HTTP_VERSION_NOT_SUPPORTED";
        /**
         * Transparent content negotiation for the request results in a circular reference.
         */
        STATUS_CODE[STATUS_CODE["VARIANT_ALSO_NEGOTIATES"] = 506] = "VARIANT_ALSO_NEGOTIATES";
        /**
         * The server is unable to store the representation needed to complete the request.
         */
        STATUS_CODE[STATUS_CODE["INSUFFICIENT_STORAGE"] = 507] = "INSUFFICIENT_STORAGE";
        /**
         * The server detected an infinite loop while processing the request.
         */
        STATUS_CODE[STATUS_CODE["LOOP_DETECTED"] = 508] = "LOOP_DETECTED";
        /**
         * Further extensions to the request are required for the server to fulfill it.
         */
        STATUS_CODE[STATUS_CODE["NOT_EXTENDED"] = 510] = "NOT_EXTENDED";
        /**
         * The client needs to authenticate to gain network access.
         * Intended for use by intercepting proxies used to control access to the network (e.g., "captive portals" used
         * to require agreement to Terms of Service before granting full Internet access via a Wi-Fi hotspot).
         */
        STATUS_CODE[STATUS_CODE["NETWORK_AUTHENTICATION_REQUIRED"] = 511] = "NETWORK_AUTHENTICATION_REQUIRED";
    })(exports.STATUS_CODE || (exports.STATUS_CODE = {}));

    // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
    const VERSION = {
        "commitHash": "178bea7c6a3b3c58f23163fcc72e28aa5f08702a",
        "version": "15.1.0"
    };

    /**
     * @packageDocumentation
     * @module @taquito/http-utils
     */
    const isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
    const adapterPromise = isNode
        ? undefined
        : import('@vespaiach/axios-fetch-adapter').then((mod) => mod.default).catch(() => undefined);
    var ResponseType;
    (function (ResponseType) {
        ResponseType["TEXT"] = "text";
        ResponseType["JSON"] = "json";
    })(ResponseType || (ResponseType = {}));
    /**
     *  @category Error
     *  @description This error will be thrown when the endpoint returns an HTTP error to the client
     */
    class HttpResponseError extends Error {
        constructor(message, status, statusText, body, url) {
            super(message);
            this.message = message;
            this.status = status;
            this.statusText = statusText;
            this.body = body;
            this.url = url;
            this.name = 'HttpResponse';
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates a general failure in making the HTTP request
     */
    class HttpRequestFailed extends Error {
        constructor(message) {
            super(message);
            this.message = message;
            this.name = 'HttpRequestFailed';
        }
    }
    class HttpBackend {
        constructor(timeout = 30000) {
            this.timeout = timeout;
        }
        serialize(obj) {
            if (!obj) {
                return '';
            }
            const str = [];
            for (const p in obj) {
                // eslint-disable-next-line no-prototype-builtins
                if (obj.hasOwnProperty(p) && typeof obj[p] !== 'undefined') {
                    const prop = typeof obj[p].toJSON === 'function' ? obj[p].toJSON() : obj[p];
                    // query arguments can have no value so we need some way of handling that
                    // example https://domain.com/query?all
                    if (prop === null) {
                        str.push(encodeURIComponent(p));
                        continue;
                    }
                    // another use case is multiple arguments with the same name
                    // they are passed as array
                    if (Array.isArray(prop)) {
                        prop.forEach((item) => {
                            str.push(encodeURIComponent(p) + '=' + encodeURIComponent(item));
                        });
                        continue;
                    }
                    str.push(encodeURIComponent(p) + '=' + encodeURIComponent(prop));
                }
            }
            const serialized = str.join('&');
            if (serialized) {
                return `?${serialized}`;
            }
            else {
                return '';
            }
        }
        /**
         *
         * @param options contains options to be passed for the HTTP request (url, method and timeout)
         */
        createRequest({ url, method, timeout = this.timeout, query, headers = {}, json = true }, data) {
            return __awaiter(this, void 0, void 0, function* () {
                let resType;
                let transformResponse = undefined;
                if (!headers['Content-Type']) {
                    headers['Content-Type'] = 'application/json';
                }
                if (!json) {
                    resType = ResponseType.TEXT;
                    transformResponse = [(v) => v];
                }
                else {
                    resType = ResponseType.JSON;
                }
                try {
                    const adapter = adapterPromise && (yield adapterPromise);
                    const response = yield axios__default["default"].request({
                        url: url + this.serialize(query),
                        method: method !== null && method !== void 0 ? method : 'GET',
                        headers: headers,
                        responseType: resType,
                        transformResponse,
                        timeout: timeout,
                        data: data,
                        adapter,
                    });
                    return response.data;
                }
                catch (err) {
                    if ((axios__default["default"].isAxiosError(err) && err.response) || (!isNode && err.response)) {
                        let errorData;
                        if (typeof err.response.data === 'object') {
                            errorData = JSON.stringify(err.response.data);
                        }
                        else {
                            errorData = err.response.data;
                        }
                        throw new HttpResponseError(`Http error response: (${err.response.status}) ${errorData}`, err.response.status, err.response.statusText, errorData, url + this.serialize(query));
                    }
                    else {
                        throw new HttpRequestFailed(`${method} ${url + this.serialize(query)} ${String(err)}`);
                    }
                }
            });
        }
    }

    exports.HttpBackend = HttpBackend;
    exports.HttpRequestFailed = HttpRequestFailed;
    exports.HttpResponseError = HttpResponseError;
    exports.VERSION = VERSION;

    Object.defineProperty(exports, '__esModule', { value: true });

}));


}).call(this)}).call(this,require('_process'))
},{"_process":7,"axios":170}],170:[function(require,module,exports){
module.exports = require('./lib/axios');
},{"./lib/axios":172}],171:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var settle = require('./../core/settle');
var cookies = require('./../helpers/cookies');
var buildURL = require('./../helpers/buildURL');
var buildFullPath = require('../core/buildFullPath');
var parseHeaders = require('./../helpers/parseHeaders');
var isURLSameOrigin = require('./../helpers/isURLSameOrigin');
var createError = require('../core/createError');
var transitionalDefaults = require('../defaults/transitional');
var Cancel = require('../cancel/Cancel');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      var transitional = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || (cancel && cancel.type) ? new Cancel('canceled') : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

},{"../cancel/Cancel":173,"../core/buildFullPath":178,"../core/createError":179,"../defaults/transitional":186,"./../core/settle":183,"./../helpers/buildURL":189,"./../helpers/cookies":191,"./../helpers/isURLSameOrigin":194,"./../helpers/parseHeaders":196,"./../utils":199}],172:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var mergeConfig = require('./core/mergeConfig');
var defaults = require('./defaults');

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Expose Cancel & CancelToken
axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');
axios.VERSION = require('./env/data').version;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = require('./helpers/spread');

// Expose isAxiosError
axios.isAxiosError = require('./helpers/isAxiosError');

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

},{"./cancel/Cancel":173,"./cancel/CancelToken":174,"./cancel/isCancel":175,"./core/Axios":176,"./core/mergeConfig":182,"./defaults":185,"./env/data":187,"./helpers/bind":188,"./helpers/isAxiosError":193,"./helpers/spread":197,"./utils":199}],173:[function(require,module,exports){
'use strict';

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

},{}],174:[function(require,module,exports){
'use strict';

var Cancel = require('./Cancel');

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;

  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;

  // eslint-disable-next-line func-names
  this.promise.then(function(cancel) {
    if (!token._listeners) return;

    var i;
    var l = token._listeners.length;

    for (i = 0; i < l; i++) {
      token._listeners[i](cancel);
    }
    token._listeners = null;
  });

  // eslint-disable-next-line func-names
  this.promise.then = function(onfulfilled) {
    var _resolve;
    // eslint-disable-next-line func-names
    var promise = new Promise(function(resolve) {
      token.subscribe(resolve);
      _resolve = resolve;
    }).then(onfulfilled);

    promise.cancel = function reject() {
      token.unsubscribe(_resolve);
    };

    return promise;
  };

  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Subscribe to the cancel signal
 */

CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }

  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};

/**
 * Unsubscribe from the cancel signal
 */

CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index = this._listeners.indexOf(listener);
  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

},{"./Cancel":173}],175:[function(require,module,exports){
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

},{}],176:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var buildURL = require('../helpers/buildURL');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');
var mergeConfig = require('./mergeConfig');
var validator = require('../helpers/validator');

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(configOrUrl, config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof configOrUrl === 'string') {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

},{"../helpers/buildURL":189,"../helpers/validator":198,"./../utils":199,"./InterceptorManager":177,"./dispatchRequest":180,"./mergeConfig":182}],177:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

},{"./../utils":199}],178:[function(require,module,exports){
'use strict';

var isAbsoluteURL = require('../helpers/isAbsoluteURL');
var combineURLs = require('../helpers/combineURLs');

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};

},{"../helpers/combineURLs":190,"../helpers/isAbsoluteURL":192}],179:[function(require,module,exports){
'use strict';

var enhanceError = require('./enhanceError');

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

},{"./enhanceError":181}],180:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var transformData = require('./transformData');
var isCancel = require('../cancel/isCancel');
var defaults = require('../defaults');
var Cancel = require('../cancel/Cancel');

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new Cancel('canceled');
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

},{"../cancel/Cancel":173,"../cancel/isCancel":175,"../defaults":185,"./../utils":199,"./transformData":184}],181:[function(require,module,exports){
'use strict';

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  };
  return error;
};

},{}],182:[function(require,module,exports){
'use strict';

var utils = require('../utils');

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
};

},{"../utils":199}],183:[function(require,module,exports){
'use strict';

var createError = require('./createError');

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};

},{"./createError":179}],184:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var defaults = require('../defaults');

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};

},{"../defaults":185,"./../utils":199}],185:[function(require,module,exports){
(function (process){(function (){
'use strict';

var utils = require('../utils');
var normalizeHeaderName = require('../helpers/normalizeHeaderName');
var enhanceError = require('../core/enhanceError');
var transitionalDefaults = require('./transitional');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('../adapters/xhr');
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = require('../adapters/http');
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: transitionalDefaults,

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

}).call(this)}).call(this,require('_process'))
},{"../adapters/http":171,"../adapters/xhr":171,"../core/enhanceError":181,"../helpers/normalizeHeaderName":195,"../utils":199,"./transitional":186,"_process":7}],186:[function(require,module,exports){
'use strict';

module.exports = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

},{}],187:[function(require,module,exports){
module.exports = {
  "version": "0.26.1"
};
},{}],188:[function(require,module,exports){
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

},{}],189:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

},{"./../utils":199}],190:[function(require,module,exports){
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

},{}],191:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);

},{"./../utils":199}],192:[function(require,module,exports){
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};

},{}],193:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
};

},{"./../utils":199}],194:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);

},{"./../utils":199}],195:[function(require,module,exports){
'use strict';

var utils = require('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

},{"../utils":199}],196:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

},{"./../utils":199}],197:[function(require,module,exports){
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

},{}],198:[function(require,module,exports){
'use strict';

var VERSION = require('../env/data').version;

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};

/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')));
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new TypeError('options must be an object');
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  assertOptions: assertOptions,
  validators: validators
};

},{"../env/data":187}],199:[function(require,module,exports){
'use strict';

var bind = require('./helpers/bind');

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return Array.isArray(val);
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return toString.call(val) === '[object FormData]';
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return toString.call(val) === '[object URLSearchParams]';
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};

},{"./helpers/bind":188}],200:[function(require,module,exports){
(function (Buffer){(function (){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taquito/utils'), require('bignumber.js')) :
  typeof define === 'function' && define.amd ? define(['exports', '@taquito/utils', 'bignumber.js'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.taquitoLocalForging = {}, global.utils, global.BigNumber));
})(this, (function (exports, utils, BigNumber) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var BigNumber__default = /*#__PURE__*/_interopDefaultLegacy(BigNumber);

  const toHexString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
  const pad = (num, paddingLen = 8) => {
      return num.toString(16).padStart(paddingLen, '0');
  };

  /*
   * Some code in this file is originally from sotez
   * Copyright (c) 2018 Andrew Kishino
   */
  // See: https://tezos.gitlab.io/protocols/005_babylon.html#transactions-now-have-an-entrypoint
  const ENTRYPOINT_MAX_LENGTH = 31;
  exports.CODEC = void 0;
  (function (CODEC) {
      CODEC["SECRET"] = "secret";
      CODEC["RAW"] = "raw";
      CODEC["TZ1"] = "tz1";
      CODEC["BRANCH"] = "branch";
      CODEC["ZARITH"] = "zarith";
      CODEC["PUBLIC_KEY"] = "public_key";
      CODEC["PKH"] = "pkh";
      CODEC["DELEGATE"] = "delegate";
      CODEC["SCRIPT"] = "script";
      CODEC["BALLOT_STATEMENT"] = "ballotStmt";
      CODEC["PROPOSAL"] = "proposal";
      CODEC["PROPOSAL_ARR"] = "proposalArr";
      CODEC["INT32"] = "int32";
      CODEC["INT16"] = "int16";
      CODEC["PARAMETERS"] = "parameters";
      CODEC["ADDRESS"] = "address";
      CODEC["SMART_CONTRACT_ADDRESS"] = "smart_contract_address";
      CODEC["VALUE"] = "value";
      CODEC["MANAGER"] = "manager";
      CODEC["BLOCK_PAYLOAD_HASH"] = "blockPayloadHash";
      CODEC["ENTRYPOINT"] = "entrypoint";
      CODEC["OPERATION"] = "operation";
      CODEC["OP_ACTIVATE_ACCOUNT"] = "activate_account";
      CODEC["OP_DELEGATION"] = "delegation";
      CODEC["OP_TRANSACTION"] = "transaction";
      CODEC["OP_ORIGINATION"] = "origination";
      CODEC["OP_BALLOT"] = "ballot";
      CODEC["OP_ENDORSEMENT"] = "endorsement";
      CODEC["OP_SEED_NONCE_REVELATION"] = "seed_nonce_revelation";
      CODEC["OP_REVEAL"] = "reveal";
      CODEC["OP_PROPOSALS"] = "proposals";
      CODEC["OP_REGISTER_GLOBAL_CONSTANT"] = "register_global_constant";
      CODEC["OP_TRANSFER_TICKET"] = "transfer_ticket";
      CODEC["OP_TX_ROLLUP_ORIGINATION"] = "tx_rollup_origination";
      CODEC["OP_TX_ROLLUP_SUBMIT_BATCH"] = "tx_rollup_submit_batch";
      CODEC["BURN_LIMIT"] = "burn_limit";
      CODEC["TX_ROLLUP_ORIGINATION_PARAM"] = "tx_rollup_origination_param";
      CODEC["TX_ROLLUP_ID"] = "tx_rollup_id";
      CODEC["TX_ROLLUP_BATCH_CONTENT"] = "tx_rollup_batch_content";
      CODEC["OP_INCREASE_PAID_STORAGE"] = "increase_paid_storage";
      CODEC["OP_UPDATE_CONSENSUS_KEY"] = "update_consensus_key";
      CODEC["OP_DRAIN_DELEGATE"] = "drain_delegate";
  })(exports.CODEC || (exports.CODEC = {}));
  // See https://tezos.gitlab.io/whitedoc/michelson.html#full-grammar
  const opMapping = {
      '00': 'parameter',
      '01': 'storage',
      '02': 'code',
      '03': 'False',
      '04': 'Elt',
      '05': 'Left',
      '06': 'None',
      '07': 'Pair',
      '08': 'Right',
      '09': 'Some',
      '0a': 'True',
      '0b': 'Unit',
      '0c': 'PACK',
      '0d': 'UNPACK',
      '0e': 'BLAKE2B',
      '0f': 'SHA256',
      '10': 'SHA512',
      '11': 'ABS',
      '12': 'ADD',
      '13': 'AMOUNT',
      '14': 'AND',
      '15': 'BALANCE',
      '16': 'CAR',
      '17': 'CDR',
      '18': 'CHECK_SIGNATURE',
      '19': 'COMPARE',
      '1a': 'CONCAT',
      '1b': 'CONS',
      '1c': 'CREATE_ACCOUNT',
      '1d': 'CREATE_CONTRACT',
      '1e': 'IMPLICIT_ACCOUNT',
      '1f': 'DIP',
      '20': 'DROP',
      '21': 'DUP',
      '22': 'EDIV',
      '23': 'EMPTY_MAP',
      '24': 'EMPTY_SET',
      '25': 'EQ',
      '26': 'EXEC',
      '27': 'FAILWITH',
      '28': 'GE',
      '29': 'GET',
      '2a': 'GT',
      '2b': 'HASH_KEY',
      '2c': 'IF',
      '2d': 'IF_CONS',
      '2e': 'IF_LEFT',
      '2f': 'IF_NONE',
      '30': 'INT',
      '31': 'LAMBDA',
      '32': 'LE',
      '33': 'LEFT',
      '34': 'LOOP',
      '35': 'LSL',
      '36': 'LSR',
      '37': 'LT',
      '38': 'MAP',
      '39': 'MEM',
      '3a': 'MUL',
      '3b': 'NEG',
      '3c': 'NEQ',
      '3d': 'NIL',
      '3e': 'NONE',
      '3f': 'NOT',
      '40': 'NOW',
      '41': 'OR',
      '42': 'PAIR',
      '43': 'PUSH',
      '44': 'RIGHT',
      '45': 'SIZE',
      '46': 'SOME',
      '47': 'SOURCE',
      '48': 'SENDER',
      '49': 'SELF',
      '4a': 'STEPS_TO_QUOTA',
      '4b': 'SUB',
      '4c': 'SWAP',
      '4d': 'TRANSFER_TOKENS',
      '4e': 'SET_DELEGATE',
      '4f': 'UNIT',
      '50': 'UPDATE',
      '51': 'XOR',
      '52': 'ITER',
      '53': 'LOOP_LEFT',
      '54': 'ADDRESS',
      '55': 'CONTRACT',
      '56': 'ISNAT',
      '57': 'CAST',
      '58': 'RENAME',
      '59': 'bool',
      '5a': 'contract',
      '5b': 'int',
      '5c': 'key',
      '5d': 'key_hash',
      '5e': 'lambda',
      '5f': 'list',
      '60': 'map',
      '61': 'big_map',
      '62': 'nat',
      '63': 'option',
      '64': 'or',
      '65': 'pair',
      '66': 'set',
      '67': 'signature',
      '68': 'string',
      '69': 'bytes',
      '6a': 'mutez',
      '6b': 'timestamp',
      '6c': 'unit',
      '6d': 'operation',
      '6e': 'address',
      '6f': 'SLICE',
      '70': 'DIG',
      '71': 'DUG',
      '72': 'EMPTY_BIG_MAP',
      '73': 'APPLY',
      '74': 'chain_id',
      '75': 'CHAIN_ID',
      '76': 'LEVEL',
      '77': 'SELF_ADDRESS',
      '78': 'never',
      '79': 'NEVER',
      '7a': 'UNPAIR',
      '7b': 'VOTING_POWER',
      '7c': 'TOTAL_VOTING_POWER',
      '7d': 'KECCAK',
      '7e': 'SHA3',
      '7f': 'PAIRING_CHECK',
      '80': 'bls12_381_g1',
      '81': 'bls12_381_g2',
      '82': 'bls12_381_fr',
      '83': 'sapling_state',
      '84': 'sapling_transaction_deprecated',
      '85': 'SAPLING_EMPTY_STATE',
      '86': 'SAPLING_VERIFY_UPDATE',
      '87': 'ticket',
      '88': 'TICKET_DEPRECATED',
      '89': 'READ_TICKET',
      '8a': 'SPLIT_TICKET',
      '8b': 'JOIN_TICKETS',
      '8c': 'GET_AND_UPDATE',
      '8d': 'chest',
      '8e': 'chest_key',
      '8f': 'OPEN_CHEST',
      '90': 'VIEW',
      '91': 'view',
      '92': 'constant',
      '93': 'SUB_MUTEZ',
      '94': 'tx_rollup_l2_address',
      '95': 'MIN_BLOCK_TIME',
      '96': 'sapling_transaction',
      '97': 'EMIT',
      '98': 'Lambda_rec',
      '99': 'LAMBDA_REC',
      '9a': 'TICKET',
  };
  const opMappingReverse = (() => {
      const result = {};
      Object.keys(opMapping).forEach((key) => {
          result[opMapping[key]] = key;
      });
      return result;
  })();
  // See https://tezos.gitlab.io/shell/p2p_api.html?highlight=p2p
  const kindMapping = {
      0x04: 'activate_account',
      0x6b: 'reveal',
      0x6e: 'delegation',
      0x6c: 'transaction',
      0x6d: 'origination',
      0x06: 'ballot',
      0x15: 'endorsement',
      0x01: 'seed_nonce_revelation',
      0x05: 'proposals',
      0x6f: 'register_global_constant',
      0x96: 'tx_rollup_origination',
      0x97: 'tx_rollup_submit_batch',
      0x9e: 'transfer_ticket',
      0x71: 'increase_paid_storage',
      0x72: 'update_consensus_key',
      0x09: 'drain_delegate',
  };
  const kindMappingReverse = (() => {
      const result = {};
      Object.keys(kindMapping).forEach((key) => {
          const keyNum = typeof key === 'string' ? parseInt(key, 10) : key;
          result[kindMapping[keyNum]] = pad(keyNum, 2);
      });
      return result;
  })();
  // See https://tezos.gitlab.io/protocols/005_babylon.html#transactions-now-have-an-entrypoint
  const entrypointMapping = {
      '00': 'default',
      '01': 'root',
      '02': 'do',
      '03': 'set_delegate',
      '04': 'remove_delegate',
      '05': 'deposit',
  };
  const entrypointMappingReverse = (() => {
      const result = {};
      Object.keys(entrypointMapping).forEach((key) => {
          result[entrypointMapping[key]] = key;
      });
      return result;
  })();

  /**
   *  @category Error
   *  @description Error that indicates an invalid block hash being passed or used
   */
  class InvalidBlockHashError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'InvalidBlockHashError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid operation schema being passed or used
   */ class InvalidOperationSchemaError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'InvalidOperationSchemaError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an entrypoint exceeding maximum size
   */
  class OversizedEntryPointError extends Error {
      constructor(entrypoint) {
          super(`Oversized entrypoint: ${entrypoint}. The maximum length of entrypoint is ${ENTRYPOINT_MAX_LENGTH}`);
          this.entrypoint = entrypoint;
          this.name = 'OversizedEntryPointError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid ballot value
   */
  class InvalidBallotValueError extends Error {
      constructor(ballotValue) {
          super(`The ballot value '${ballotValue}' is invalid`);
          this.ballotValue = ballotValue;
          this.name = 'InvalidBallotValueError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates a failure when trying to decode ballot value
   */
  class DecodeBallotValueError extends Error {
      constructor(ballotValue) {
          super(`Failed to decode ballot value ${ballotValue}`);
          this.ballotValue = ballotValue;
          this.name = 'DecodeBallotValueError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid hex string have been passed or used
   */
  class InvalidHexStringError extends Error {
      constructor(hexString) {
          super(`The hex string '${hexString}' is invalid`);
          this.hexString = hexString;
          this.name = 'InvalidHexStringError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates unexpected Michelson Value being passed or used
   */
  class UnexpectedMichelsonValueError extends Error {
      constructor(value) {
          super(`Failed to encode michelson value '${value}'`);
          this.value = value;
          this.name = 'UnexpectedMichelsonValueError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates a failure when trying to decode an operation
   */
  class OperationDecodingError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'OperationDecodingError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates a failure when trying to encode an operation
   */
  class OperationEncodingError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'OperationEncodingError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an unsupported operation being passed or used
   */
  class UnsupportedOperationError extends Error {
      constructor(op) {
          super(`The operation '${op}' is unsupported`);
          this.op = op;
          this.name = 'UnsupportedOperationError';
      }
  }

  class Uint8ArrayConsumer {
      constructor(arr, offset = 0) {
          this.arr = arr;
          this.offset = offset;
      }
      static fromHexString(hex) {
          const lowHex = hex.toLowerCase();
          if (/^(([a-f]|\d){2})*$/.test(lowHex)) {
              const arr = new Uint8Array((lowHex.match(/([a-z]|\d){2}/g) || []).map((byte) => parseInt(byte, 16)));
              return new Uint8ArrayConsumer(arr);
          }
          else {
              throw new InvalidHexStringError(lowHex);
          }
      }
      consume(count) {
          const subArr = this.arr.subarray(this.offset, this.offset + count);
          this.offset += count;
          return subArr;
      }
      get(idx) {
          return this.arr[this.offset + idx];
      }
      length() {
          return this.arr.length - this.offset;
      }
  }

  const isPrim = (value) => {
      return 'prim' in value;
  };
  const isBytes = (value) => {
      return 'bytes' in value && typeof value.bytes === 'string';
  };
  const isString = (value) => {
      return 'string' in value && typeof value.string === 'string';
  };
  const isInt = (value) => {
      return 'int' in value && typeof value.int === 'string';
  };
  const scriptEncoder = (script) => {
      const code = valueEncoder(script.code);
      const storage = valueEncoder(script.storage);
      return `${pad(code.length / 2, 8)}${code}${pad(storage.length / 2, 8)}${storage}`;
  };
  const scriptDecoder = (value) => {
      const code = extractRequiredLen(value);
      const storage = extractRequiredLen(value);
      return {
          code: valueDecoder(new Uint8ArrayConsumer(code)),
          storage: valueDecoder(new Uint8ArrayConsumer(storage)),
      };
  };
  const valueEncoder = (value) => {
      if (Array.isArray(value)) {
          const encoded = value.map((x) => valueEncoder(x)).join('');
          const len = encoded.length / 2;
          return `02${pad(len)}${encoded}`;
      }
      else if (isPrim(value)) {
          return primEncoder(value);
      }
      else if (isBytes(value)) {
          return bytesEncoder(value);
      }
      else if (isString(value)) {
          return stringEncoder(value);
      }
      else if (isInt(value)) {
          return intEncoder(value);
      }
      throw new UnexpectedMichelsonValueError(JSON.stringify(value));
  };
  const valueDecoder = (value) => {
      const preamble = value.consume(1);
      switch (preamble[0]) {
          case 0x0a:
              return bytesDecoder(value);
          case 0x01:
              return stringDecoder(value);
          case 0x00:
              return intDecoder(value);
          case 0x02: {
              const val = new Uint8ArrayConsumer(extractRequiredLen(value));
              const results = [];
              while (val.length() > 0) {
                  results.push(valueDecoder(val));
              }
              return results;
          }
          default:
              return primDecoder(value, preamble);
      }
  };
  const extractRequiredLen = (value, bytesLength = 4) => {
      const len = value.consume(bytesLength);
      const valueLen = parseInt(Buffer.from(len).toString('hex'), 16);
      return value.consume(valueLen);
  };
  const bytesEncoder = (value) => {
      if (!/^([A-Fa-f0-9]{2})*$/.test(value.bytes)) {
          throw new InvalidHexStringError(value.bytes);
      }
      const len = value.bytes.length / 2;
      return `0a${pad(len)}${value.bytes}`;
  };
  const bytesDecoder = (value) => {
      const bytes = extractRequiredLen(value);
      return {
          bytes: Buffer.from(bytes).toString('hex'),
      };
  };
  const stringEncoder = (value) => {
      const str = Buffer.from(value.string, 'utf8').toString('hex');
      const hexLength = str.length / 2;
      return `01${pad(hexLength)}${str}`;
  };
  const stringDecoder = (value) => {
      const str = extractRequiredLen(value);
      return {
          string: Buffer.from(str).toString('utf8'),
      };
  };
  const intEncoder = ({ int }) => {
      const num = new BigNumber.BigNumber(int, 10);
      const positiveMark = num.toString(2)[0] === '-' ? '1' : '0';
      const binary = num.toString(2).replace(/-/g, '');
      const pad = binary.length <= 6
          ? 6
          : (binary.length - 6) % 7
              ? binary.length + 7 - ((binary.length - 6) % 7)
              : binary.length;
      const splitted = binary.padStart(pad, '0').match(/\d{6,7}/g);
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const reversed = splitted.reverse();
      reversed[0] = positiveMark + reversed[0];
      const numHex = reversed.map((x, i) => 
      // Add one to the last chunk
      parseInt((i === reversed.length - 1 ? '0' : '1') + x, 2)
          .toString(16)
          .padStart(2, '0'));
      return `00${numHex.join('')}`;
  };
  const intDecoder = (value) => {
      let c = value.consume(1)[0];
      const hexNumber = [];
      const isNotLastChunkMask = 1 << 7;
      while (c & isNotLastChunkMask) {
          hexNumber.push(c);
          c = value.consume(1)[0];
      }
      hexNumber.push(c);
      const isNegative = !!((1 << 6) & hexNumber[0]);
      hexNumber[0] = hexNumber[0] & 0b1111111;
      const numBin = hexNumber
          .map((x, i) => x
          .toString(2)
          .slice(i === 0 ? -6 : -7)
          .padStart(i === 0 ? 6 : 7, '0'))
          .reverse();
      let num = new BigNumber.BigNumber(numBin.join(''), 2);
      if (isNegative) {
          num = num.times(-1);
      }
      return {
          int: num.toFixed(),
      };
  };
  const primEncoder = (value) => {
      const hasAnnot = +Array.isArray(value.annots);
      const argsCount = Array.isArray(value.args) ? value.args.length : 0;
      // Specify the number of args max is 3 without annotation
      const preamble = pad(Math.min(2 * argsCount + hasAnnot + 0x03, 9), 2);
      const op = opMappingReverse[value.prim];
      let encodedArgs = (value.args || []).map((arg) => valueEncoder(arg)).join('');
      const encodedAnnots = Array.isArray(value.annots) ? encodeAnnots(value.annots) : '';
      if ((value.prim === 'LAMBDA' || value.prim === 'LAMBDA_REC') && argsCount) {
          encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
      }
      if ((value.prim === 'pair' || value.prim === 'Pair') && argsCount > 2) {
          encodedArgs =
              encodedAnnots === ''
                  ? pad(encodedArgs.length / 2) + encodedArgs + pad(0)
                  : pad(encodedArgs.length / 2) + encodedArgs;
      }
      if (value.prim === 'view' && value.args) {
          encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
      }
      return `${preamble}${op}${encodedArgs}${encodedAnnots}`;
  };
  const primDecoder = (value, preamble) => {
      const hasAnnot = (preamble[0] - 0x03) % 2 === 1;
      let argsCount = Math.floor((preamble[0] - 0x03) / 2);
      const op = value.consume(1)[0].toString(16).padStart(2, '0');
      const result = {
          prim: opMapping[op],
      };
      if (opMapping[op] === 'LAMBDA' || opMapping[op] === 'LAMBDA_REC') {
          value.consume(4);
      }
      if (opMapping[op] === 'view') {
          if (argsCount != 0) {
              return primViewDecoder(value, result);
          }
          else {
              return result;
          }
      }
      let combPairArgs;
      let combPairAnnots;
      if ((opMapping[op] === 'pair' || opMapping[op] === 'Pair') && argsCount > 2) {
          combPairArgs = decodeCombPair$1(value);
          argsCount = 0;
          combPairAnnots = decodeAnnots(value);
      }
      const args = new Array(argsCount).fill(0).map(() => valueDecoder(value));
      if (opMapping[op] === 'LAMBDA' || opMapping[op] === 'LAMBDA_REC') {
          value.consume(4);
      }
      if (combPairArgs) {
          result['args'] = combPairArgs;
      }
      else if (args.length) {
          result['args'] = args;
      }
      if (combPairAnnots && combPairAnnots[0] !== '') {
          result['annots'] = combPairAnnots;
      }
      else if (hasAnnot) {
          result['annots'] = decodeAnnots(value);
      }
      return result;
  };
  const primViewDecoder = (value, result) => {
      value.consume(4);
      result['args'] = new Array(4).fill(0).map(() => valueDecoder(value));
      value.consume(4);
      return result;
  };
  const decodeCombPair$1 = (val) => {
      const array = new Uint8ArrayConsumer(extractRequiredLen(val));
      const args = [];
      while (array.length() > 0) {
          args.push(valueDecoder(array));
      }
      return args;
  };
  const encodeAnnots = (value) => {
      const mergedAnnot = value
          .map((x) => {
          return Buffer.from(x, 'utf8').toString('hex');
      })
          .join('20');
      const len = mergedAnnot.length / 2;
      return `${pad(len)}${mergedAnnot}`;
  };
  const decodeAnnots = (val) => {
      const len = val.consume(4);
      const annotLen = parseInt(Buffer.from(len).toString('hex'), 16);
      const restOfAnnot = val.consume(annotLen);
      const restOfAnnotHex = Buffer.from(restOfAnnot).toString('hex');
      return restOfAnnotHex.split('20').map((x) => Buffer.from(x, 'hex').toString('utf8'));
  };

  const prefixEncoder = (prefix) => (str) => {
      return utils.buf2hex(Buffer.from(utils.b58cdecode(str, utils.prefix[prefix])));
  };
  const prefixDecoder = (pre) => (str) => {
      const val = str.consume(utils.prefixLength[pre]);
      return utils.b58cencode(val, utils.prefix[pre]);
  };
  const tz1Decoder = prefixDecoder(utils.Prefix.TZ1);
  const branchDecoder = prefixDecoder(utils.Prefix.B);
  const pkhDecoder = (val) => {
      const prefix = val.consume(1);
      if (prefix[0] === 0x00) {
          return prefixDecoder(utils.Prefix.TZ1)(val);
      }
      else if (prefix[0] === 0x01) {
          return prefixDecoder(utils.Prefix.TZ2)(val);
      }
      else if (prefix[0] === 0x02) {
          return prefixDecoder(utils.Prefix.TZ3)(val);
      }
  };
  const branchEncoder = prefixEncoder(utils.Prefix.B);
  const tz1Encoder = prefixEncoder(utils.Prefix.TZ1);
  const boolEncoder = (bool) => (bool ? 'ff' : '00');
  const proposalEncoder = (proposal) => {
      return prefixEncoder(utils.Prefix.P)(proposal);
  };
  const proposalDecoder = (proposal) => {
      return prefixDecoder(utils.Prefix.P)(proposal);
  };
  const proposalsDecoder = (proposal) => {
      const proposals = [];
      proposal.consume(4);
      while (proposal.length() > 0) {
          proposals.push(proposalDecoder(proposal));
      }
      return proposals;
  };
  const proposalsEncoder = (proposals) => {
      return pad(32 * proposals.length) + proposals.map((x) => proposalEncoder(x)).join('');
  };
  const ballotEncoder = (ballot) => {
      switch (ballot) {
          case 'yay':
              return '00';
          case 'nay':
              return '01';
          case 'pass':
              return '02';
          default:
              throw new InvalidBallotValueError(ballot);
      }
  };
  const ballotDecoder = (ballot) => {
      const value = ballot.consume(1);
      switch (value[0]) {
          case 0x00:
              return 'yay';
          case 0x01:
              return 'nay';
          case 0x02:
              return 'pass';
          default:
              throw new DecodeBallotValueError(value[0].toString());
      }
  };
  const delegateEncoder = (val) => {
      if (val) {
          return boolEncoder(true) + pkhEncoder(val);
      }
      else {
          return boolEncoder(false);
      }
  };
  const int32Encoder = (val) => {
      const num = parseInt(String(val), 10);
      const byte = [];
      for (let i = 0; i < 4; i++) {
          const shiftBy = (4 - (i + 1)) * 8;
          byte.push((num & (0xff << shiftBy)) >> shiftBy);
      }
      return Buffer.from(byte).toString('hex');
  };
  const int32Decoder = (val) => {
      const num = val.consume(4);
      let finalNum = 0;
      for (let i = 0; i < num.length; i++) {
          finalNum = finalNum | (num[i] << ((num.length - (i + 1)) * 8));
      }
      return finalNum;
  };
  const int16Encoder = (val) => {
      const num = parseInt(String(val), 10);
      const byte = [];
      for (let i = 0; i < 2; i++) {
          const shiftBy = (2 - (i + 1)) * 8;
          byte.push((num & (0xff << shiftBy)) >> shiftBy);
      }
      return Buffer.from(byte).toString('hex');
  };
  const int16Decoder = (val) => {
      const num = val.consume(2);
      let finalNum = 0;
      for (let i = 0; i < num.length; i++) {
          finalNum = finalNum | (num[i] << ((num.length - (i + 1)) * 8));
      }
      return finalNum;
  };
  const boolDecoder = (val) => {
      const bool = val.consume(1);
      return bool[0] === 0xff;
  };
  const delegateDecoder = (val) => {
      const hasDelegate = boolDecoder(val);
      if (hasDelegate) {
          return pkhDecoder(val);
      }
  };
  const pkhEncoder = (val) => {
      const pubkeyPrefix = val.substr(0, 3);
      switch (pubkeyPrefix) {
          case utils.Prefix.TZ1:
              return '00' + prefixEncoder(utils.Prefix.TZ1)(val);
          case utils.Prefix.TZ2:
              return '01' + prefixEncoder(utils.Prefix.TZ2)(val);
          case utils.Prefix.TZ3:
              return '02' + prefixEncoder(utils.Prefix.TZ3)(val);
          default:
              throw new utils.InvalidKeyHashError(val);
      }
  };
  const publicKeyEncoder = (val) => {
      const pubkeyPrefix = val.substr(0, 4);
      switch (pubkeyPrefix) {
          case utils.Prefix.EDPK:
              return '00' + prefixEncoder(utils.Prefix.EDPK)(val);
          case utils.Prefix.SPPK:
              return '01' + prefixEncoder(utils.Prefix.SPPK)(val);
          case utils.Prefix.P2PK:
              return '02' + prefixEncoder(utils.Prefix.P2PK)(val);
          default:
              throw new utils.InvalidPublicKeyError(val);
      }
  };
  const addressEncoder = (val) => {
      const pubkeyPrefix = val.substr(0, 3);
      switch (pubkeyPrefix) {
          case utils.Prefix.TZ1:
          case utils.Prefix.TZ2:
          case utils.Prefix.TZ3:
              return '00' + pkhEncoder(val);
          case utils.Prefix.KT1:
              return '01' + prefixEncoder(utils.Prefix.KT1)(val) + '00';
          default:
              throw new utils.InvalidAddressError(val);
      }
  };
  const smartContractAddressEncoder = (val) => {
      const prefix = val.substring(0, 3);
      if (prefix === utils.Prefix.KT1) {
          return '01' + prefixEncoder(utils.Prefix.KT1)(val) + '00';
      }
      throw new utils.InvalidContractAddressError(val);
  };
  const publicKeyDecoder = (val) => {
      const preamble = val.consume(1);
      switch (preamble[0]) {
          case 0x00:
              return prefixDecoder(utils.Prefix.EDPK)(val);
          case 0x01:
              return prefixDecoder(utils.Prefix.SPPK)(val);
          case 0x02:
              return prefixDecoder(utils.Prefix.P2PK)(val);
          default:
              throw new utils.InvalidPublicKeyError(val.toString());
      }
  };
  const addressDecoder = (val) => {
      const preamble = val.consume(1);
      switch (preamble[0]) {
          case 0x00:
              return pkhDecoder(val);
          case 0x01: {
              const address = prefixDecoder(utils.Prefix.KT1)(val);
              val.consume(1);
              return address;
          }
          default:
              throw new utils.InvalidAddressError(val.toString());
      }
  };
  const smartContractAddressDecoder = (val) => {
      const preamble = val.consume(1);
      if (preamble[0] === 0x01) {
          const scAddress = prefixDecoder(utils.Prefix.KT1)(val);
          val.consume(1);
          return scAddress;
      }
      throw new utils.InvalidContractAddressError(val.toString());
  };
  const zarithEncoder = (n) => {
      const fn = [];
      let nn = new BigNumber__default["default"](n, 10);
      if (nn.isNaN()) {
          throw new TypeError(`Invalid zarith number ${n}`);
      }
      // eslint-disable-next-line no-constant-condition
      while (true) {
          if (nn.lt(128)) {
              if (nn.lt(16))
                  fn.push('0');
              fn.push(nn.toString(16));
              break;
          }
          else {
              let b = nn.mod(128);
              nn = nn.minus(b);
              nn = nn.dividedBy(128);
              b = b.plus(128);
              fn.push(b.toString(16));
          }
      }
      return fn.join('');
  };
  const zarithDecoder = (n) => {
      let mostSignificantByte = 0;
      while (mostSignificantByte < n.length() && (n.get(mostSignificantByte) & 128) !== 0) {
          mostSignificantByte += 1;
      }
      let num = new BigNumber__default["default"](0);
      for (let i = mostSignificantByte; i >= 0; i -= 1) {
          const tmp = n.get(i) & 0x7f;
          num = num.multipliedBy(128);
          num = num.plus(tmp);
      }
      n.consume(mostSignificantByte + 1);
      return new BigNumber__default["default"](num).toString();
  };
  const entrypointDecoder = (value) => {
      const preamble = pad(value.consume(1)[0], 2);
      if (preamble in entrypointMapping) {
          return entrypointMapping[preamble];
      }
      else {
          const entry = extractRequiredLen(value, 1);
          const entrypoint = Buffer.from(entry).toString('utf8');
          if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {
              throw new OversizedEntryPointError(entrypoint);
          }
          return entrypoint;
      }
  };
  const parametersDecoder = (val) => {
      const preamble = val.consume(1);
      if (preamble[0] === 0x00) {
          return;
      }
      else {
          const encodedEntrypoint = entrypointDecoder(val);
          const params = extractRequiredLen(val);
          const parameters = valueDecoder(new Uint8ArrayConsumer(params));
          return {
              entrypoint: encodedEntrypoint,
              value: parameters,
          };
      }
  };
  const entrypointEncoder = (entrypoint) => {
      if (entrypoint in entrypointMappingReverse) {
          return `${entrypointMappingReverse[entrypoint]}`;
      }
      else {
          if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {
              throw new OversizedEntryPointError(entrypoint);
          }
          const value = { string: entrypoint };
          return `ff${valueEncoder(value).slice(8)}`;
      }
  };
  const parametersEncoder = (val) => {
      if (!val || (val.entrypoint === 'default' && 'prim' in val.value && val.value.prim === 'Unit')) {
          return '00';
      }
      const encodedEntrypoint = entrypointEncoder(val.entrypoint);
      const parameters = valueEncoder(val.value);
      const length = (parameters.length / 2).toString(16).padStart(8, '0');
      return `ff${encodedEntrypoint}${length}${parameters}`;
  };
  const valueParameterEncoder = (value) => {
      const valueEncoded = valueEncoder(value);
      return `${pad(valueEncoded.length / 2)}${valueEncoded}`;
  };
  const valueParameterDecoder = (val) => {
      const value = extractRequiredLen(val);
      return valueDecoder(new Uint8ArrayConsumer(value));
  };
  const blockPayloadHashEncoder = prefixEncoder(utils.Prefix.VH);
  const blockPayloadHashDecoder = prefixDecoder(utils.Prefix.VH);
  const entrypointNameEncoder = (entrypoint) => {
      const value = { string: entrypoint };
      return `${valueEncoder(value).slice(2)}`;
  };
  const entrypointNameDecoder = (val) => {
      const entry = extractRequiredLen(val);
      return Buffer.from(entry).toString('utf8');
  };
  const txRollupOriginationParamEncoder = (_value) => {
      return '';
  };
  const txRollupOriginationParamDecoder = (_val) => {
      return {};
  };
  const txRollupIdEncoder = prefixEncoder(utils.Prefix.TXR1);
  const txRollupIdDecoder = prefixDecoder(utils.Prefix.TXR1);
  const txRollupBatchContentEncoder = (value) => {
      return `${pad(value.length / 2)}${value}`;
  };
  const txRollupBatchContentDecoder = (val) => {
      const value = extractRequiredLen(val);
      return Buffer.from(value).toString('hex');
  };
  const burnLimitEncoder = (val) => {
      return !val ? '00' : `ff${zarithEncoder(val)}`;
  };
  const burnLimitDecoder = (value) => {
      const prefix = value.consume(1);
      if (Buffer.from(prefix).toString('hex') !== '00') {
          return zarithDecoder(value);
      }
  };

  const ManagerOperationSchema = {
      branch: exports.CODEC.BRANCH,
      contents: [exports.CODEC.OPERATION],
  };
  const ActivationSchema = {
      pkh: exports.CODEC.TZ1,
      secret: exports.CODEC.SECRET,
  };
  const RevealSchema = {
      source: exports.CODEC.PKH,
      fee: exports.CODEC.ZARITH,
      counter: exports.CODEC.ZARITH,
      gas_limit: exports.CODEC.ZARITH,
      storage_limit: exports.CODEC.ZARITH,
      public_key: exports.CODEC.PUBLIC_KEY,
  };
  const DelegationSchema = {
      source: exports.CODEC.PKH,
      fee: exports.CODEC.ZARITH,
      counter: exports.CODEC.ZARITH,
      gas_limit: exports.CODEC.ZARITH,
      storage_limit: exports.CODEC.ZARITH,
      delegate: exports.CODEC.DELEGATE,
  };
  const TransactionSchema = {
      source: exports.CODEC.PKH,
      fee: exports.CODEC.ZARITH,
      counter: exports.CODEC.ZARITH,
      gas_limit: exports.CODEC.ZARITH,
      storage_limit: exports.CODEC.ZARITH,
      amount: exports.CODEC.ZARITH,
      destination: exports.CODEC.ADDRESS,
      parameters: exports.CODEC.PARAMETERS,
  };
  const OriginationSchema = {
      source: exports.CODEC.PKH,
      fee: exports.CODEC.ZARITH,
      counter: exports.CODEC.ZARITH,
      gas_limit: exports.CODEC.ZARITH,
      storage_limit: exports.CODEC.ZARITH,
      balance: exports.CODEC.ZARITH,
      delegate: exports.CODEC.DELEGATE,
      script: exports.CODEC.SCRIPT,
  };
  const BallotSchema = {
      source: exports.CODEC.PKH,
      period: exports.CODEC.INT32,
      proposal: exports.CODEC.PROPOSAL,
      ballot: exports.CODEC.BALLOT_STATEMENT,
  };
  const EndorsementSchema = {
      slot: exports.CODEC.INT16,
      level: exports.CODEC.INT32,
      round: exports.CODEC.INT32,
      block_payload_hash: exports.CODEC.BLOCK_PAYLOAD_HASH,
  };
  const SeedNonceRevelationSchema = {
      level: exports.CODEC.INT32,
      nonce: exports.CODEC.RAW,
  };
  const ProposalsSchema = {
      source: exports.CODEC.PKH,
      period: exports.CODEC.INT32,
      proposals: exports.CODEC.PROPOSAL_ARR,
  };
  const RegisterGlobalConstantSchema = {
      source: exports.CODEC.PKH,
      fee: exports.CODEC.ZARITH,
      counter: exports.CODEC.ZARITH,
      gas_limit: exports.CODEC.ZARITH,
      storage_limit: exports.CODEC.ZARITH,
      value: exports.CODEC.VALUE,
  };
  const TransferTicketSchema = {
      source: exports.CODEC.PKH,
      fee: exports.CODEC.ZARITH,
      counter: exports.CODEC.ZARITH,
      gas_limit: exports.CODEC.ZARITH,
      storage_limit: exports.CODEC.ZARITH,
      ticket_contents: exports.CODEC.VALUE,
      ticket_ty: exports.CODEC.VALUE,
      ticket_ticketer: exports.CODEC.ADDRESS,
      ticket_amount: exports.CODEC.ZARITH,
      destination: exports.CODEC.ADDRESS,
      entrypoint: exports.CODEC.ENTRYPOINT,
  };
  const TxRollupOriginationSchema = {
      source: exports.CODEC.PKH,
      fee: exports.CODEC.ZARITH,
      counter: exports.CODEC.ZARITH,
      gas_limit: exports.CODEC.ZARITH,
      storage_limit: exports.CODEC.ZARITH,
      tx_rollup_origination: exports.CODEC.TX_ROLLUP_ORIGINATION_PARAM,
  };
  const TxRollupSubmitBatchSchema = {
      source: exports.CODEC.PKH,
      fee: exports.CODEC.ZARITH,
      counter: exports.CODEC.ZARITH,
      gas_limit: exports.CODEC.ZARITH,
      storage_limit: exports.CODEC.ZARITH,
      rollup: exports.CODEC.TX_ROLLUP_ID,
      content: exports.CODEC.TX_ROLLUP_BATCH_CONTENT,
      burn_limit: exports.CODEC.BURN_LIMIT,
  };
  const IncreasePaidStorageSchema = {
      source: exports.CODEC.PKH,
      fee: exports.CODEC.ZARITH,
      counter: exports.CODEC.ZARITH,
      gas_limit: exports.CODEC.ZARITH,
      storage_limit: exports.CODEC.ZARITH,
      amount: exports.CODEC.ZARITH,
      destination: exports.CODEC.SMART_CONTRACT_ADDRESS,
  };
  const UpdateConsensusKeySchema = {
      source: exports.CODEC.PKH,
      fee: exports.CODEC.ZARITH,
      counter: exports.CODEC.ZARITH,
      gas_limit: exports.CODEC.ZARITH,
      storage_limit: exports.CODEC.ZARITH,
      pk: exports.CODEC.PUBLIC_KEY,
  };
  const DrainDelegateSchema = {
      consensus_key: exports.CODEC.PKH,
      delegate: exports.CODEC.PKH,
      destination: exports.CODEC.PKH,
  };
  const operationEncoder = (encoders) => (operation) => {
      if (!(operation.kind in encoders) || !(operation.kind in kindMappingReverse)) {
          throw new utils.InvalidOperationKindError(operation.kind);
      }
      return kindMappingReverse[operation.kind] + encoders[operation.kind](operation);
  };
  const operationDecoder = (decoders) => (value) => {
      const op = value.consume(1);
      const operationName = kindMapping[op[0]];
      if (operationName === undefined) {
          throw new UnsupportedOperationError(op[0].toString());
      }
      const decodedObj = decoders[operationName](value);
      if (typeof decodedObj !== 'object') {
          throw new OperationDecodingError('Decoded invalid operation');
      }
      return Object.assign({ kind: operationName }, decodedObj);
  };
  const schemaEncoder = (encoders) => (schema) => (value) => {
      const keys = Object.keys(schema);
      return keys.reduce((prev, key) => {
          const valueToEncode = schema[key];
          if (value && Array.isArray(valueToEncode)) {
              const encoder = encoders[valueToEncode[0]];
              const values = value[key];
              if (!Array.isArray(values)) {
                  throw new OperationEncodingError(`Expected value to be Array ${JSON.stringify(values)}`);
              }
              return prev + values.reduce((prevBytes, current) => prevBytes + encoder(current), '');
          }
          else {
              const encoder = encoders[valueToEncode];
              return prev + encoder(value[key]);
          }
      }, '');
  };
  const schemaDecoder = (decoders) => (schema) => (value) => {
      const keys = Object.keys(schema);
      return keys.reduce((prev, key) => {
          const valueToEncode = schema[key];
          if (Array.isArray(valueToEncode)) {
              const decoder = decoders[valueToEncode[0]];
              const decoded = [];
              const lastLength = value.length();
              while (value.length() > 0) {
                  decoded.push(decoder(value));
                  if (lastLength === value.length()) {
                      throw new OperationDecodingError('Unable to decode value');
                  }
              }
              return Object.assign(Object.assign({}, prev), { [key]: decoded });
          }
          else {
              const decoder = decoders[valueToEncode];
              const result = decoder(value);
              if (typeof result !== 'undefined') {
                  return Object.assign(Object.assign({}, prev), { [key]: result });
              }
              else {
                  return Object.assign({}, prev);
              }
          }
      }, {});
  };

  const decoders = {
      [exports.CODEC.SECRET]: (val) => toHexString(val.consume(20)),
      [exports.CODEC.RAW]: (val) => toHexString(val.consume(32)),
      [exports.CODEC.TZ1]: tz1Decoder,
      [exports.CODEC.BRANCH]: branchDecoder,
      [exports.CODEC.ZARITH]: zarithDecoder,
      [exports.CODEC.PUBLIC_KEY]: publicKeyDecoder,
      [exports.CODEC.PKH]: pkhDecoder,
      [exports.CODEC.DELEGATE]: delegateDecoder,
      [exports.CODEC.INT32]: int32Decoder,
      [exports.CODEC.SCRIPT]: scriptDecoder,
      [exports.CODEC.BALLOT_STATEMENT]: ballotDecoder,
      [exports.CODEC.PROPOSAL]: proposalDecoder,
      [exports.CODEC.PROPOSAL_ARR]: proposalsDecoder,
      [exports.CODEC.PARAMETERS]: parametersDecoder,
      [exports.CODEC.ADDRESS]: addressDecoder,
      [exports.CODEC.SMART_CONTRACT_ADDRESS]: smartContractAddressDecoder,
      [exports.CODEC.VALUE]: valueParameterDecoder,
      [exports.CODEC.INT16]: int16Decoder,
      [exports.CODEC.BLOCK_PAYLOAD_HASH]: blockPayloadHashDecoder,
      [exports.CODEC.ENTRYPOINT]: entrypointNameDecoder,
      [exports.CODEC.TX_ROLLUP_ORIGINATION_PARAM]: txRollupOriginationParamDecoder,
      [exports.CODEC.TX_ROLLUP_ID]: txRollupIdDecoder,
      [exports.CODEC.TX_ROLLUP_BATCH_CONTENT]: txRollupBatchContentDecoder,
      [exports.CODEC.BURN_LIMIT]: burnLimitDecoder,
  };
  decoders[exports.CODEC.OPERATION] = operationDecoder(decoders);
  decoders[exports.CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaDecoder(decoders)(ActivationSchema)(val);
  decoders[exports.CODEC.OP_DELEGATION] = (val) => schemaDecoder(decoders)(DelegationSchema)(val);
  decoders[exports.CODEC.OP_TRANSACTION] = (val) => schemaDecoder(decoders)(TransactionSchema)(val);
  decoders[exports.CODEC.OP_ORIGINATION] = (val) => schemaDecoder(decoders)(OriginationSchema)(val);
  decoders[exports.CODEC.OP_BALLOT] = (val) => schemaDecoder(decoders)(BallotSchema)(val);
  decoders[exports.CODEC.OP_ENDORSEMENT] = (val) => schemaDecoder(decoders)(EndorsementSchema)(val);
  decoders[exports.CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaDecoder(decoders)(SeedNonceRevelationSchema)(val);
  decoders[exports.CODEC.OP_PROPOSALS] = (val) => schemaDecoder(decoders)(ProposalsSchema)(val);
  decoders[exports.CODEC.OP_REVEAL] = (val) => schemaDecoder(decoders)(RevealSchema)(val);
  decoders[exports.CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaDecoder(decoders)(RegisterGlobalConstantSchema)(val);
  decoders[exports.CODEC.OP_TRANSFER_TICKET] = (val) => schemaDecoder(decoders)(TransferTicketSchema)(val);
  decoders[exports.CODEC.OP_TX_ROLLUP_ORIGINATION] = (val) => schemaDecoder(decoders)(TxRollupOriginationSchema)(val);
  decoders[exports.CODEC.OP_TX_ROLLUP_SUBMIT_BATCH] = (val) => schemaDecoder(decoders)(TxRollupSubmitBatchSchema)(val);
  decoders[exports.CODEC.OP_INCREASE_PAID_STORAGE] = (val) => schemaDecoder(decoders)(IncreasePaidStorageSchema)(val);
  decoders[exports.CODEC.OP_UPDATE_CONSENSUS_KEY] = (val) => schemaDecoder(decoders)(UpdateConsensusKeySchema)(val);
  decoders[exports.CODEC.OP_DRAIN_DELEGATE] = (val) => schemaDecoder(decoders)(DrainDelegateSchema)(val);
  decoders[exports.CODEC.MANAGER] = schemaDecoder(decoders)(ManagerOperationSchema);

  const encoders = {
      [exports.CODEC.SECRET]: (val) => val,
      [exports.CODEC.RAW]: (val) => val,
      [exports.CODEC.TZ1]: tz1Encoder,
      [exports.CODEC.BRANCH]: branchEncoder,
      [exports.CODEC.ZARITH]: zarithEncoder,
      [exports.CODEC.PUBLIC_KEY]: publicKeyEncoder,
      [exports.CODEC.PKH]: pkhEncoder,
      [exports.CODEC.DELEGATE]: delegateEncoder,
      [exports.CODEC.SCRIPT]: scriptEncoder,
      [exports.CODEC.BALLOT_STATEMENT]: ballotEncoder,
      [exports.CODEC.PROPOSAL]: proposalEncoder,
      [exports.CODEC.PROPOSAL_ARR]: proposalsEncoder,
      [exports.CODEC.INT32]: int32Encoder,
      [exports.CODEC.PARAMETERS]: parametersEncoder,
      [exports.CODEC.ADDRESS]: addressEncoder,
      [exports.CODEC.SMART_CONTRACT_ADDRESS]: smartContractAddressEncoder,
      [exports.CODEC.VALUE]: valueParameterEncoder,
      [exports.CODEC.INT16]: int16Encoder,
      [exports.CODEC.BLOCK_PAYLOAD_HASH]: blockPayloadHashEncoder,
      [exports.CODEC.ENTRYPOINT]: entrypointNameEncoder,
      [exports.CODEC.TX_ROLLUP_ORIGINATION_PARAM]: txRollupOriginationParamEncoder,
      [exports.CODEC.TX_ROLLUP_ID]: txRollupIdEncoder,
      [exports.CODEC.TX_ROLLUP_BATCH_CONTENT]: txRollupBatchContentEncoder,
      [exports.CODEC.BURN_LIMIT]: burnLimitEncoder,
  };
  encoders[exports.CODEC.OPERATION] = operationEncoder(encoders);
  encoders[exports.CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaEncoder(encoders)(ActivationSchema)(val);
  encoders[exports.CODEC.OP_DELEGATION] = (val) => schemaEncoder(encoders)(DelegationSchema)(val);
  encoders[exports.CODEC.OP_TRANSACTION] = (val) => schemaEncoder(encoders)(TransactionSchema)(val);
  encoders[exports.CODEC.OP_ORIGINATION] = (val) => schemaEncoder(encoders)(OriginationSchema)(val);
  encoders[exports.CODEC.OP_BALLOT] = (val) => schemaEncoder(encoders)(BallotSchema)(val);
  encoders[exports.CODEC.OP_ENDORSEMENT] = (val) => schemaEncoder(encoders)(EndorsementSchema)(val);
  encoders[exports.CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaEncoder(encoders)(SeedNonceRevelationSchema)(val);
  encoders[exports.CODEC.OP_PROPOSALS] = (val) => schemaEncoder(encoders)(ProposalsSchema)(val);
  encoders[exports.CODEC.OP_REVEAL] = (val) => schemaEncoder(encoders)(RevealSchema)(val);
  encoders[exports.CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaEncoder(encoders)(RegisterGlobalConstantSchema)(val);
  encoders[exports.CODEC.OP_TRANSFER_TICKET] = (val) => schemaEncoder(encoders)(TransferTicketSchema)(val);
  encoders[exports.CODEC.OP_TX_ROLLUP_ORIGINATION] = (val) => schemaEncoder(encoders)(TxRollupOriginationSchema)(val);
  encoders[exports.CODEC.OP_TX_ROLLUP_SUBMIT_BATCH] = (val) => schemaEncoder(encoders)(TxRollupSubmitBatchSchema)(val);
  encoders[exports.CODEC.OP_INCREASE_PAID_STORAGE] = (val) => schemaEncoder(encoders)(IncreasePaidStorageSchema)(val);
  encoders[exports.CODEC.OP_UPDATE_CONSENSUS_KEY] = (val) => schemaEncoder(encoders)(UpdateConsensusKeySchema)(val);
  encoders[exports.CODEC.OP_DRAIN_DELEGATE] = (val) => schemaEncoder(encoders)(DrainDelegateSchema)(val);
  encoders[exports.CODEC.MANAGER] = schemaEncoder(encoders)(ManagerOperationSchema);

  const OperationKindMapping = {
      activate_account: ActivationSchema,
      reveal: RevealSchema,
      delegation: DelegationSchema,
      transaction: TransactionSchema,
      origination: OriginationSchema,
      ballot: BallotSchema,
      endorsement: EndorsementSchema,
      seed_nonce_revelation: SeedNonceRevelationSchema,
      proposals: ProposalsSchema,
      register_global_constant: RegisterGlobalConstantSchema,
      transfer_ticket: TransferTicketSchema,
      tx_rollup_origination: TxRollupOriginationSchema,
      tx_rollup_submit_batch: TxRollupSubmitBatchSchema,
      increase_paid_storage: IncreasePaidStorageSchema,
      update_consensus_key: UpdateConsensusKeySchema,
      drain_delegate: DrainDelegateSchema,
  };
  // Asymmetric difference: only account for things in arr2 that are not present in arr1, not vice versa
  const getArrayDifference = (arr1, arr2) => {
      return arr2.filter((x) => !arr1.includes(x));
  };
  const deleteArrayElementByValue = (array, item) => {
      return array.filter((e) => e !== item);
  };
  /**
   * @returns A boolean value to indicate whether the operation kind is valid or not
   */
  const validateOperationKind = (opKind) => {
      const opKindList = Object.keys(OperationKindMapping);
      return opKindList.includes(opKind);
  };
  /**
   *  returns 0 when the two array of properties are identical or the passed property
   *  does not have any missing parameters from the corresponding schema
   *
   *  @returns array element differences if there are missing required property keys
   */
  const validateMissingProperty = (operationContent) => {
      const kind = operationContent.kind;
      const keys = Object.keys(operationContent);
      const cleanKeys = deleteArrayElementByValue(keys, 'kind');
      const schemaKeys = Object.keys(OperationKindMapping[kind]);
      return getArrayDifference(cleanKeys, schemaKeys);
  };

  exports.ProtocolsHash = void 0;
  (function (ProtocolsHash) {
      ProtocolsHash["Pt24m4xi"] = "Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd";
      ProtocolsHash["PsBABY5H"] = "PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU";
      ProtocolsHash["PsBabyM1"] = "PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS";
      ProtocolsHash["PsCARTHA"] = "PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb";
      ProtocolsHash["PsDELPH1"] = "PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo";
      ProtocolsHash["PtEdo2Zk"] = "PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA";
      ProtocolsHash["PsFLorena"] = "PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i";
      ProtocolsHash["PtGRANADs"] = "PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV";
      ProtocolsHash["PtHangz2"] = "PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx";
      ProtocolsHash["Psithaca2"] = "Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A";
      ProtocolsHash["PtJakart2"] = "PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY";
      ProtocolsHash["PtKathman"] = "PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg";
      ProtocolsHash["PtLimaPtL"] = "PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW";
      ProtocolsHash["ProtoALpha"] = "ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK";
  })(exports.ProtocolsHash || (exports.ProtocolsHash = {}));
  const protoLevel = {
      Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd: 4,
      PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU: 5,
      PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS: 5,
      PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb: 6,
      PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo: 7,
      PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA: 8,
      PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i: 9,
      PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV: 10,
      PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx: 11,
      Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A: 12,
      PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY: 13,
      PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg: 14,
      PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW: 15,
      ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK: 16,
  };
  function ProtoInferiorTo(a, b) {
      return protoLevel[a] < protoLevel[b];
  }

  /*
   * Some code in this file is originally from sotez
   * Copyright (c) 2018 Andrew Kishino
   */
  // See https://tezos.gitlab.io/whitedoc/michelson.html#full-grammar
  const opMappingProto14 = {
      '00': 'parameter',
      '01': 'storage',
      '02': 'code',
      '03': 'False',
      '04': 'Elt',
      '05': 'Left',
      '06': 'None',
      '07': 'Pair',
      '08': 'Right',
      '09': 'Some',
      '0a': 'True',
      '0b': 'Unit',
      '0c': 'PACK',
      '0d': 'UNPACK',
      '0e': 'BLAKE2B',
      '0f': 'SHA256',
      '10': 'SHA512',
      '11': 'ABS',
      '12': 'ADD',
      '13': 'AMOUNT',
      '14': 'AND',
      '15': 'BALANCE',
      '16': 'CAR',
      '17': 'CDR',
      '18': 'CHECK_SIGNATURE',
      '19': 'COMPARE',
      '1a': 'CONCAT',
      '1b': 'CONS',
      '1c': 'CREATE_ACCOUNT',
      '1d': 'CREATE_CONTRACT',
      '1e': 'IMPLICIT_ACCOUNT',
      '1f': 'DIP',
      '20': 'DROP',
      '21': 'DUP',
      '22': 'EDIV',
      '23': 'EMPTY_MAP',
      '24': 'EMPTY_SET',
      '25': 'EQ',
      '26': 'EXEC',
      '27': 'FAILWITH',
      '28': 'GE',
      '29': 'GET',
      '2a': 'GT',
      '2b': 'HASH_KEY',
      '2c': 'IF',
      '2d': 'IF_CONS',
      '2e': 'IF_LEFT',
      '2f': 'IF_NONE',
      '30': 'INT',
      '31': 'LAMBDA',
      '32': 'LE',
      '33': 'LEFT',
      '34': 'LOOP',
      '35': 'LSL',
      '36': 'LSR',
      '37': 'LT',
      '38': 'MAP',
      '39': 'MEM',
      '3a': 'MUL',
      '3b': 'NEG',
      '3c': 'NEQ',
      '3d': 'NIL',
      '3e': 'NONE',
      '3f': 'NOT',
      '40': 'NOW',
      '41': 'OR',
      '42': 'PAIR',
      '43': 'PUSH',
      '44': 'RIGHT',
      '45': 'SIZE',
      '46': 'SOME',
      '47': 'SOURCE',
      '48': 'SENDER',
      '49': 'SELF',
      '4a': 'STEPS_TO_QUOTA',
      '4b': 'SUB',
      '4c': 'SWAP',
      '4d': 'TRANSFER_TOKENS',
      '4e': 'SET_DELEGATE',
      '4f': 'UNIT',
      '50': 'UPDATE',
      '51': 'XOR',
      '52': 'ITER',
      '53': 'LOOP_LEFT',
      '54': 'ADDRESS',
      '55': 'CONTRACT',
      '56': 'ISNAT',
      '57': 'CAST',
      '58': 'RENAME',
      '59': 'bool',
      '5a': 'contract',
      '5b': 'int',
      '5c': 'key',
      '5d': 'key_hash',
      '5e': 'lambda',
      '5f': 'list',
      '60': 'map',
      '61': 'big_map',
      '62': 'nat',
      '63': 'option',
      '64': 'or',
      '65': 'pair',
      '66': 'set',
      '67': 'signature',
      '68': 'string',
      '69': 'bytes',
      '6a': 'mutez',
      '6b': 'timestamp',
      '6c': 'unit',
      '6d': 'operation',
      '6e': 'address',
      '6f': 'SLICE',
      '70': 'DIG',
      '71': 'DUG',
      '72': 'EMPTY_BIG_MAP',
      '73': 'APPLY',
      '74': 'chain_id',
      '75': 'CHAIN_ID',
      '76': 'LEVEL',
      '77': 'SELF_ADDRESS',
      '78': 'never',
      '79': 'NEVER',
      '7a': 'UNPAIR',
      '7b': 'VOTING_POWER',
      '7c': 'TOTAL_VOTING_POWER',
      '7d': 'KECCAK',
      '7e': 'SHA3',
      '7f': 'PAIRING_CHECK',
      '80': 'bls12_381_g1',
      '81': 'bls12_381_g2',
      '82': 'bls12_381_fr',
      '83': 'sapling_state',
      '84': 'sapling_transaction_deprecated',
      '85': 'SAPLING_EMPTY_STATE',
      '86': 'SAPLING_VERIFY_UPDATE',
      '87': 'ticket',
      '88': 'TICKET',
      '89': 'READ_TICKET',
      '8a': 'SPLIT_TICKET',
      '8b': 'JOIN_TICKETS',
      '8c': 'GET_AND_UPDATE',
      '8d': 'chest',
      '8e': 'chest_key',
      '8f': 'OPEN_CHEST',
      '90': 'VIEW',
      '91': 'view',
      '92': 'constant',
      '93': 'SUB_MUTEZ',
      '94': 'tx_rollup_l2_address',
      '95': 'MIN_BLOCK_TIME',
      '96': 'sapling_transaction',
      '97': 'EMIT',
  };
  const opMappingReverseProto14 = (() => {
      const result = {};
      Object.keys(opMappingProto14).forEach((key) => {
          result[opMappingProto14[key]] = key;
      });
      return result;
  })();
  const entrypointMappingProto14 = {
      '00': 'default',
      '01': 'root',
      '02': 'do',
      '03': 'set_delegate',
      '04': 'remove_delegate',
  };
  const entrypointMappingReverseProto14 = (() => {
      const result = {};
      Object.keys(entrypointMappingProto14).forEach((key) => {
          result[entrypointMappingProto14[key]] = key;
      });
      return result;
  })();

  const scriptEncoderProto14 = (script) => {
      const code = valueEncoderProto14(script.code);
      const storage = valueEncoderProto14(script.storage);
      return `${pad(code.length / 2, 8)}${code}${pad(storage.length / 2, 8)}${storage}`;
  };
  const scriptDecoderProto14 = (value) => {
      const code = extractRequiredLen(value);
      const storage = extractRequiredLen(value);
      return {
          code: valueDecoderProto14(new Uint8ArrayConsumer(code)),
          storage: valueDecoderProto14(new Uint8ArrayConsumer(storage)),
      };
  };
  const valueEncoderProto14 = (value) => {
      if (Array.isArray(value)) {
          const encoded = value.map((x) => valueEncoderProto14(x)).join('');
          const len = encoded.length / 2;
          return `02${pad(len)}${encoded}`;
      }
      else if (isPrim(value)) {
          return primEncoderProto14(value);
      }
      else if (isBytes(value)) {
          return bytesEncoder(value);
      }
      else if (isString(value)) {
          return stringEncoder(value);
      }
      else if (isInt(value)) {
          return intEncoder(value);
      }
      throw new UnexpectedMichelsonValueError(JSON.stringify(value));
  };
  const valueDecoderProto14 = (value) => {
      const preamble = value.consume(1);
      switch (preamble[0]) {
          case 0x0a:
              return bytesDecoder(value);
          case 0x01:
              return stringDecoder(value);
          case 0x00:
              return intDecoder(value);
          case 0x02: {
              const val = new Uint8ArrayConsumer(extractRequiredLen(value));
              const results = [];
              while (val.length() > 0) {
                  results.push(valueDecoderProto14(val));
              }
              return results;
          }
          default:
              return primDecoderProto14(value, preamble);
      }
  };
  const primEncoderProto14 = (value) => {
      const hasAnnot = +Array.isArray(value.annots);
      const argsCount = Array.isArray(value.args) ? value.args.length : 0;
      // Specify the number of args max is 3 without annotation
      const preamble = pad(Math.min(2 * argsCount + hasAnnot + 0x03, 9), 2);
      const op = opMappingReverseProto14[value.prim];
      let encodedArgs = (value.args || []).map((arg) => valueEncoderProto14(arg)).join('');
      const encodedAnnots = Array.isArray(value.annots) ? encodeAnnots(value.annots) : '';
      if (value.prim === 'LAMBDA' && argsCount) {
          encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
      }
      if ((value.prim === 'pair' || value.prim === 'Pair') && argsCount > 2) {
          encodedArgs =
              encodedAnnots === ''
                  ? pad(encodedArgs.length / 2) + encodedArgs + pad(0)
                  : pad(encodedArgs.length / 2) + encodedArgs;
      }
      if (value.prim === 'view' && value.args) {
          encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
      }
      return `${preamble}${op}${encodedArgs}${encodedAnnots}`;
  };
  const primDecoderProto14 = (value, preamble) => {
      const hasAnnot = (preamble[0] - 0x03) % 2 === 1;
      let argsCount = Math.floor((preamble[0] - 0x03) / 2);
      const op = value.consume(1)[0].toString(16).padStart(2, '0');
      const result = {
          prim: opMappingProto14[op],
      };
      if (opMappingProto14[op] === 'LAMBDA') {
          value.consume(4);
      }
      if (opMappingProto14[op] === 'view') {
          if (argsCount != 0) {
              return primViewDecoderProto14(value, result);
          }
          else {
              return result;
          }
      }
      let combPairArgs;
      let combPairAnnots;
      if ((opMappingProto14[op] === 'pair' || opMappingProto14[op] === 'Pair') && argsCount > 2) {
          combPairArgs = decodeCombPair(value);
          argsCount = 0;
          combPairAnnots = decodeAnnots(value);
      }
      const args = new Array(argsCount).fill(0).map(() => valueDecoderProto14(value));
      if (opMappingProto14[op] === 'LAMBDA') {
          value.consume(4);
      }
      if (combPairArgs) {
          result['args'] = combPairArgs;
      }
      else if (args.length) {
          result['args'] = args;
      }
      if (combPairAnnots && combPairAnnots[0] !== '') {
          result['annots'] = combPairAnnots;
      }
      else if (hasAnnot) {
          result['annots'] = decodeAnnots(value);
      }
      return result;
  };
  const primViewDecoderProto14 = (value, result) => {
      value.consume(4);
      result['args'] = new Array(4).fill(0).map(() => valueDecoderProto14(value));
      value.consume(4);
      return result;
  };
  const decodeCombPair = (val) => {
      const array = new Uint8ArrayConsumer(extractRequiredLen(val));
      const args = [];
      while (array.length() > 0) {
          args.push(valueDecoderProto14(array));
      }
      return args;
  };

  const parametersDecoderProto14 = (val) => {
      const preamble = val.consume(1);
      if (preamble[0] === 0x00) {
          return;
      }
      else {
          const encodedEntrypoint = entrypointDecoderProto14(val);
          const params = extractRequiredLen(val);
          const parameters = valueDecoderProto14(new Uint8ArrayConsumer(params));
          return {
              entrypoint: encodedEntrypoint,
              value: parameters,
          };
      }
  };
  const entrypointEncoderProto14 = (entrypoint) => {
      if (entrypoint in entrypointMappingReverseProto14) {
          return `${entrypointMappingReverseProto14[entrypoint]}`;
      }
      else {
          if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {
              throw new OversizedEntryPointError(entrypoint);
          }
          const value = { string: entrypoint };
          return `ff${valueEncoderProto14(value).slice(8)}`;
      }
  };
  const entrypointDecoderProto14 = (value) => {
      const preamble = pad(value.consume(1)[0], 2);
      if (preamble in entrypointMappingProto14) {
          return entrypointMappingProto14[preamble];
      }
      else {
          const entry = extractRequiredLen(value, 1);
          const entrypoint = Buffer.from(entry).toString('utf8');
          if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {
              throw new OversizedEntryPointError(entrypoint);
          }
          return entrypoint;
      }
  };
  const parametersEncoderProto14 = (val) => {
      if (!val || (val.entrypoint === 'default' && 'prim' in val.value && val.value.prim === 'Unit')) {
          return '00';
      }
      const encodedEntrypoint = entrypointEncoderProto14(val.entrypoint);
      const parameters = valueEncoderProto14(val.value);
      const length = (parameters.length / 2).toString(16).padStart(8, '0');
      return `ff${encodedEntrypoint}${length}${parameters}`;
  };
  const valueParameterEncoderProto14 = (value) => {
      const valueEncoded = valueEncoderProto14(value);
      return `${pad(valueEncoded.length / 2)}${valueEncoded}`;
  };
  const valueParameterDecoderProto14 = (val) => {
      const value = extractRequiredLen(val);
      return valueDecoderProto14(new Uint8ArrayConsumer(value));
  };
  const entrypointNameEncoderProto14 = (entrypoint) => {
      const value = { string: entrypoint };
      return `${valueEncoderProto14(value).slice(2)}`;
  };

  const decodersProto14 = {
      [exports.CODEC.SECRET]: (val) => toHexString(val.consume(20)),
      [exports.CODEC.RAW]: (val) => toHexString(val.consume(32)),
      [exports.CODEC.TZ1]: tz1Decoder,
      [exports.CODEC.BRANCH]: branchDecoder,
      [exports.CODEC.ZARITH]: zarithDecoder,
      [exports.CODEC.PUBLIC_KEY]: publicKeyDecoder,
      [exports.CODEC.PKH]: pkhDecoder,
      [exports.CODEC.DELEGATE]: delegateDecoder,
      [exports.CODEC.INT32]: int32Decoder,
      [exports.CODEC.SCRIPT]: scriptDecoderProto14,
      [exports.CODEC.BALLOT_STATEMENT]: ballotDecoder,
      [exports.CODEC.PROPOSAL]: proposalDecoder,
      [exports.CODEC.PROPOSAL_ARR]: proposalsDecoder,
      [exports.CODEC.PARAMETERS]: parametersDecoderProto14,
      [exports.CODEC.ADDRESS]: addressDecoder,
      [exports.CODEC.SMART_CONTRACT_ADDRESS]: smartContractAddressDecoder,
      [exports.CODEC.VALUE]: valueParameterDecoderProto14,
      [exports.CODEC.INT16]: int16Decoder,
      [exports.CODEC.BLOCK_PAYLOAD_HASH]: blockPayloadHashDecoder,
      [exports.CODEC.ENTRYPOINT]: entrypointNameDecoder,
      [exports.CODEC.TX_ROLLUP_ORIGINATION_PARAM]: txRollupOriginationParamDecoder,
      [exports.CODEC.TX_ROLLUP_ID]: txRollupIdDecoder,
      [exports.CODEC.TX_ROLLUP_BATCH_CONTENT]: txRollupBatchContentDecoder,
      [exports.CODEC.BURN_LIMIT]: burnLimitDecoder,
  };
  decodersProto14[exports.CODEC.OPERATION] = operationDecoder(decodersProto14);
  decodersProto14[exports.CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaDecoder(decodersProto14)(ActivationSchema)(val);
  decodersProto14[exports.CODEC.OP_DELEGATION] = (val) => schemaDecoder(decodersProto14)(DelegationSchema)(val);
  decodersProto14[exports.CODEC.OP_TRANSACTION] = (val) => schemaDecoder(decodersProto14)(TransactionSchema)(val);
  decodersProto14[exports.CODEC.OP_ORIGINATION] = (val) => schemaDecoder(decodersProto14)(OriginationSchema)(val);
  decodersProto14[exports.CODEC.OP_BALLOT] = (val) => schemaDecoder(decodersProto14)(BallotSchema)(val);
  decodersProto14[exports.CODEC.OP_ENDORSEMENT] = (val) => schemaDecoder(decodersProto14)(EndorsementSchema)(val);
  decodersProto14[exports.CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaDecoder(decodersProto14)(SeedNonceRevelationSchema)(val);
  decodersProto14[exports.CODEC.OP_PROPOSALS] = (val) => schemaDecoder(decodersProto14)(ProposalsSchema)(val);
  decodersProto14[exports.CODEC.OP_REVEAL] = (val) => schemaDecoder(decodersProto14)(RevealSchema)(val);
  decodersProto14[exports.CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaDecoder(decodersProto14)(RegisterGlobalConstantSchema)(val);
  decodersProto14[exports.CODEC.OP_TRANSFER_TICKET] = (val) => schemaDecoder(decodersProto14)(TransferTicketSchema)(val);
  decodersProto14[exports.CODEC.OP_TX_ROLLUP_ORIGINATION] = (val) => schemaDecoder(decodersProto14)(TxRollupOriginationSchema)(val);
  decodersProto14[exports.CODEC.OP_TX_ROLLUP_SUBMIT_BATCH] = (val) => schemaDecoder(decodersProto14)(TxRollupSubmitBatchSchema)(val);
  decodersProto14[exports.CODEC.OP_INCREASE_PAID_STORAGE] = (val) => schemaDecoder(decodersProto14)(IncreasePaidStorageSchema)(val);
  decodersProto14[exports.CODEC.MANAGER] = schemaDecoder(decodersProto14)(ManagerOperationSchema);

  const encodersProto14 = {
      [exports.CODEC.SECRET]: (val) => val,
      [exports.CODEC.RAW]: (val) => val,
      [exports.CODEC.TZ1]: tz1Encoder,
      [exports.CODEC.BRANCH]: branchEncoder,
      [exports.CODEC.ZARITH]: zarithEncoder,
      [exports.CODEC.PUBLIC_KEY]: publicKeyEncoder,
      [exports.CODEC.PKH]: pkhEncoder,
      [exports.CODEC.DELEGATE]: delegateEncoder,
      [exports.CODEC.SCRIPT]: scriptEncoderProto14,
      [exports.CODEC.BALLOT_STATEMENT]: ballotEncoder,
      [exports.CODEC.PROPOSAL]: proposalEncoder,
      [exports.CODEC.PROPOSAL_ARR]: proposalsEncoder,
      [exports.CODEC.INT32]: int32Encoder,
      [exports.CODEC.PARAMETERS]: parametersEncoderProto14,
      [exports.CODEC.ADDRESS]: addressEncoder,
      [exports.CODEC.SMART_CONTRACT_ADDRESS]: smartContractAddressEncoder,
      [exports.CODEC.VALUE]: valueParameterEncoderProto14,
      [exports.CODEC.INT16]: int16Encoder,
      [exports.CODEC.BLOCK_PAYLOAD_HASH]: blockPayloadHashEncoder,
      [exports.CODEC.ENTRYPOINT]: entrypointNameEncoderProto14,
      [exports.CODEC.TX_ROLLUP_ORIGINATION_PARAM]: txRollupOriginationParamEncoder,
      [exports.CODEC.TX_ROLLUP_ID]: txRollupIdEncoder,
      [exports.CODEC.TX_ROLLUP_BATCH_CONTENT]: txRollupBatchContentEncoder,
      [exports.CODEC.BURN_LIMIT]: burnLimitEncoder,
  };
  encodersProto14[exports.CODEC.OPERATION] = operationEncoder(encodersProto14);
  encodersProto14[exports.CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaEncoder(encodersProto14)(ActivationSchema)(val);
  encodersProto14[exports.CODEC.OP_DELEGATION] = (val) => schemaEncoder(encodersProto14)(DelegationSchema)(val);
  encodersProto14[exports.CODEC.OP_TRANSACTION] = (val) => schemaEncoder(encodersProto14)(TransactionSchema)(val);
  encodersProto14[exports.CODEC.OP_ORIGINATION] = (val) => schemaEncoder(encodersProto14)(OriginationSchema)(val);
  encodersProto14[exports.CODEC.OP_BALLOT] = (val) => schemaEncoder(encodersProto14)(BallotSchema)(val);
  encodersProto14[exports.CODEC.OP_ENDORSEMENT] = (val) => schemaEncoder(encodersProto14)(EndorsementSchema)(val);
  encodersProto14[exports.CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaEncoder(encodersProto14)(SeedNonceRevelationSchema)(val);
  encodersProto14[exports.CODEC.OP_PROPOSALS] = (val) => schemaEncoder(encodersProto14)(ProposalsSchema)(val);
  encodersProto14[exports.CODEC.OP_REVEAL] = (val) => schemaEncoder(encodersProto14)(RevealSchema)(val);
  encodersProto14[exports.CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaEncoder(encodersProto14)(RegisterGlobalConstantSchema)(val);
  encodersProto14[exports.CODEC.OP_TRANSFER_TICKET] = (val) => schemaEncoder(encodersProto14)(TransferTicketSchema)(val);
  encodersProto14[exports.CODEC.OP_TX_ROLLUP_ORIGINATION] = (val) => schemaEncoder(encodersProto14)(TxRollupOriginationSchema)(val);
  encodersProto14[exports.CODEC.OP_TX_ROLLUP_SUBMIT_BATCH] = (val) => schemaEncoder(encodersProto14)(TxRollupSubmitBatchSchema)(val);
  encodersProto14[exports.CODEC.OP_INCREASE_PAID_STORAGE] = (val) => schemaEncoder(encodersProto14)(IncreasePaidStorageSchema)(val);
  encodersProto14[exports.CODEC.MANAGER] = schemaEncoder(encodersProto14)(ManagerOperationSchema);

  // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
  const VERSION = {
      "commitHash": "178bea7c6a3b3c58f23163fcc72e28aa5f08702a",
      "version": "15.1.0"
  };

  /**
   * @packageDocumentation
   * @module @taquito/local-forging
   */
  const PROTOCOL_CURRENT = exports.ProtocolsHash.PtLimaPtL;
  function getCodec(codec, _proto) {
      // use proto14 encoders & decoders if it's kathmandu or prior
      if (_proto === exports.ProtocolsHash.PtKathman || ProtoInferiorTo(_proto, PROTOCOL_CURRENT)) {
          return {
              encoder: encodersProto14[codec],
              decoder: (hex) => {
                  const consumer = Uint8ArrayConsumer.fromHexString(hex);
                  return decodersProto14[codec](consumer);
              },
          };
      }
      else {
          return {
              encoder: encoders[codec],
              decoder: (hex) => {
                  const consumer = Uint8ArrayConsumer.fromHexString(hex);
                  return decoders[codec](consumer);
              },
          };
      }
  }
  class LocalForger {
      constructor(protocolHash = PROTOCOL_CURRENT) {
          this.protocolHash = protocolHash;
          this.codec = getCodec(exports.CODEC.MANAGER, this.protocolHash);
      }
      forge(params) {
          if (utils.validateBlock(params.branch) !== utils.ValidationResult.VALID) {
              throw new InvalidBlockHashError(`The block hash ${params.branch} is invalid`);
          }
          for (const content of params.contents) {
              if (!validateOperationKind(content.kind)) {
                  throw new utils.InvalidOperationKindError(content.kind);
              }
              const diff = validateMissingProperty(content);
              if (diff.length === 1) {
                  if (content.kind === 'delegation' && diff[0] === 'delegate') {
                      continue;
                  }
                  else if (content.kind === 'origination' && diff[0] === 'delegate') {
                      continue;
                  }
                  else if (content.kind === 'transaction' && diff[0] === 'parameters') {
                      continue;
                  }
                  else if (content.kind === 'tx_rollup_submit_batch' &&
                      diff[0] === 'burn_limit') {
                      continue;
                  }
                  else {
                      throw new InvalidOperationSchemaError(`Missing properties: ${diff.join(', ').toString()}`);
                  }
              }
              else if (diff.length > 1) {
                  throw new InvalidOperationSchemaError(`Missing properties: ${diff.join(', ').toString()}`);
              }
          }
          const forged = this.codec.encoder(params).toLowerCase();
          return Promise.resolve(forged);
      }
      parse(hex) {
          return Promise.resolve(this.codec.decoder(hex));
      }
  }
  const localForger = new LocalForger();

  exports.LocalForger = LocalForger;
  exports.Uint8ArrayConsumer = Uint8ArrayConsumer;
  exports.VERSION = VERSION;
  exports.decoders = decoders;
  exports.encoders = encoders;
  exports.getCodec = getCodec;
  exports.localForger = localForger;
  exports.opMapping = opMapping;
  exports.opMappingReverse = opMappingReverse;

  Object.defineProperty(exports, '__esModule', { value: true });

}));


}).call(this)}).call(this,require("buffer").Buffer)
},{"@taquito/utils":205,"bignumber.js":242,"buffer":3}],201:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.taquitoMichelCodec = {}));
})(this, (function (exports) { 'use strict';

  // Michelson abstract syntax tree types https://tezos.gitlab.io/whitedoc/michelson.html#concrete-syntax
  const sourceReference = Symbol('source_reference');

  /**
   *  @category Error
   *  @description Error that indicates a failure when performing the scan step when parsing Michelson
   */
  class ScanError extends Error {
      constructor(src, idx, message) {
          super(message);
          this.src = src;
          this.idx = idx;
          Object.setPrototypeOf(this, ScanError.prototype);
      }
  }
  var Literal;
  (function (Literal) {
      Literal[Literal["Comment"] = 0] = "Comment";
      Literal[Literal["Number"] = 1] = "Number";
      Literal[Literal["String"] = 2] = "String";
      Literal[Literal["Bytes"] = 3] = "Bytes";
      Literal[Literal["Ident"] = 4] = "Ident";
  })(Literal || (Literal = {}));
  const isSpace = new RegExp('\\s');
  const isIdentStart = new RegExp('[:@%_A-Za-z]');
  const isIdent = new RegExp('[@%_\\.A-Za-z0-9]');
  const isDigit = new RegExp('[0-9]');
  const isHex = new RegExp('[0-9a-fA-F]');
  function* scan(src, scanComments = false) {
      let i = 0;
      while (i < src.length) {
          // Skip space
          while (i < src.length && isSpace.test(src[i])) {
              i++;
          }
          if (i === src.length) {
              return;
          }
          const s = src[i];
          const start = i;
          if (isIdentStart.test(s)) {
              // Identifier
              i++;
              while (i < src.length && isIdent.test(src[i])) {
                  i++;
              }
              yield { t: Literal.Ident, v: src.slice(start, i), first: start, last: i };
          }
          else if (src.length - i > 1 && src.substr(i, 2) === '0x') {
              // Bytes
              i += 2;
              while (i < src.length && isHex.test(src[i])) {
                  i++;
              }
              if (((i - start) & 1) !== 0) {
                  throw new ScanError(src, i, 'Bytes literal length is expected to be power of two');
              }
              yield { t: Literal.Bytes, v: src.slice(start, i), first: start, last: i };
          }
          else if (isDigit.test(s) || s === '-') {
              // Number
              if (s === '-') {
                  i++;
              }
              const ii = i;
              while (i < src.length && isDigit.test(src[i])) {
                  i++;
              }
              if (ii === i) {
                  throw new ScanError(src, i, 'Number literal is too short');
              }
              yield { t: Literal.Number, v: src.slice(start, i), first: start, last: i };
          }
          else if (s === '"') {
              // String
              i++;
              let esc = false;
              for (; i < src.length && (esc || src[i] !== '"'); i++) {
                  if (!esc && src[i] === '\\') {
                      esc = true;
                  }
                  else {
                      esc = false;
                  }
              }
              if (i === src.length) {
                  throw new ScanError(src, i, 'Unterminated string literal');
              }
              i++;
              yield { t: Literal.String, v: src.slice(start, i), first: start, last: i };
          }
          else if (s === '#') {
              // Comment
              i++;
              while (i < src.length && src[i] !== '\n') {
                  i++;
              }
              if (scanComments) {
                  yield { t: Literal.Comment, v: src.slice(start, i), first: start, last: i };
              }
          }
          else if (src.length - i > 1 && src.substr(i, 2) === '/*') {
              // C style comment
              i += 2;
              while (i < src.length && !(src.length - i > 1 && src.substr(i, 2) === '*/')) {
                  i++;
              }
              if (i === src.length) {
                  throw new ScanError(src, i, 'Unterminated C style comment');
              }
              i += 2;
              if (scanComments) {
                  yield { t: Literal.Comment, v: src.slice(start, i), first: start, last: i };
              }
          }
          else if (s === '(' || s === ')' || s === '{' || s === '}' || s === ';') {
              i++;
              yield { t: s, v: s, first: start, last: i };
          }
          else {
              throw new ScanError(src, i, `Invalid character at offset ${i}: \`${s}'`);
          }
      }
  }

  // Michelson types
  const refContract = Symbol('ref_contract');
  exports.Protocol = void 0;
  (function (Protocol) {
      Protocol["Ps9mPmXa"] = "Ps9mPmXaRzmzk35gbAYNCAw6UXdE2qoABTHbN2oEEc1qM7CwT9P";
      Protocol["PtCJ7pwo"] = "PtCJ7pwoxe8JasnHY8YonnLYjcVHmhiARPJvqcC6VfHT5s8k8sY";
      Protocol["PsYLVpVv"] = "PsYLVpVvgbLhAhoqAkMFUo6gudkJ9weNXhUYCiLDzcUpFpkk8Wt";
      Protocol["PsddFKi3"] = "PsddFKi32cMJ2qPjf43Qv5GDWLDPZb3T3bF6fLKiF5HtvHNU7aP";
      Protocol["Pt24m4xi"] = "Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd";
      Protocol["PsBABY5H"] = "PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU";
      Protocol["PsBabyM1"] = "PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS";
      Protocol["PsCARTHA"] = "PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb";
      Protocol["PsDELPH1"] = "PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo";
      Protocol["PtEdoTez"] = "PtEdoTezd3RHSC31mpxxo1npxFjoWWcFgQtxapi51Z8TLu6v6Uq";
      Protocol["PtEdo2Zk"] = "PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA";
      Protocol["PsFLoren"] = "PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i";
      Protocol["PsFLorena"] = "PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i";
      Protocol["PtGRANAD"] = "PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV";
      Protocol["PtGRANADs"] = "PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV";
      Protocol["PtHangzH"] = "PtHangzHogokSuiMHemCuowEavgYTP8J5qQ9fQS793MHYFpCY3r";
      Protocol["PtHangz2"] = "PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx";
      Protocol["PsiThaCa"] = "PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP";
      Protocol["Psithaca2"] = "Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A";
      Protocol["PtJakarta"] = "PtJakartaiDz69SfDDLXJSiuZqTSeSKRDbKVZC8MNzJnvRjvnGw";
      Protocol["PtJakart2"] = "PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY";
      Protocol["PtKathman"] = "PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg";
      Protocol["PtLimaPtL"] = "PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW";
      Protocol["ProtoALpha"] = "ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK";
  })(exports.Protocol || (exports.Protocol = {}));
  const DefaultProtocol = exports.Protocol.Psithaca2;
  const protoLevel = {
      Ps9mPmXaRzmzk35gbAYNCAw6UXdE2qoABTHbN2oEEc1qM7CwT9P: 0,
      PtCJ7pwoxe8JasnHY8YonnLYjcVHmhiARPJvqcC6VfHT5s8k8sY: 1,
      PsYLVpVvgbLhAhoqAkMFUo6gudkJ9weNXhUYCiLDzcUpFpkk8Wt: 2,
      PsddFKi32cMJ2qPjf43Qv5GDWLDPZb3T3bF6fLKiF5HtvHNU7aP: 3,
      Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd: 4,
      PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU: 5,
      PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS: 5,
      PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb: 6,
      PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo: 7,
      PtEdoTezd3RHSC31mpxxo1npxFjoWWcFgQtxapi51Z8TLu6v6Uq: 8,
      PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA: 8,
      PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i: 9,
      PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV: 10,
      PtHangzHogokSuiMHemCuowEavgYTP8J5qQ9fQS793MHYFpCY3r: 11,
      PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx: 11,
      PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP: 12,
      Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A: 12,
      PtJakartaiDz69SfDDLXJSiuZqTSeSKRDbKVZC8MNzJnvRjvnGw: 13,
      PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY: 13,
      PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg: 14,
      PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW: 15,
      ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK: 16,
  };
  function ProtoGreaterOfEqual(a, b) {
      return protoLevel[a] >= protoLevel[b];
  }
  function ProtoInferiorTo(a, b) {
      return protoLevel[a] < protoLevel[b];
  }

  /**
   *  @category Error
   *  @description Indicates that an error has occurred preventing macros from being expanded in a plain Michelson input
   */
  class MacroError extends Error {
      constructor(prim, message) {
          super(message);
          this.prim = prim;
          Object.setPrototypeOf(this, MacroError.prototype);
      }
  }
  function assertArgs$1(ex, n) {
      var _a, _b;
      if ((n === 0 && ex.args === undefined) || ((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === n) {
          return true;
      }
      throw new MacroError(ex, `macro ${ex.prim} expects ${n} arguments, was given ${(_b = ex.args) === null || _b === void 0 ? void 0 : _b.length}`);
  }
  function assertNoAnnots(ex) {
      if (ex.annots === undefined) {
          return true;
      }
      throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${ex.annots}`);
  }
  function assertIntArg(ex, arg) {
      if ('int' in arg) {
          return true;
      }
      throw new MacroError(ex, `macro ${ex.prim} expects int argument`);
  }
  function parsePairUnpairExpr(p, expr, annotations, agg) {
      let i = 0;
      let ai = 0;
      const ann = [null, null];
      // Left expression
      let lexpr;
      if (i === expr.length) {
          throw new MacroError(p, `unexpected end: ${p.prim}`);
      }
      let c = expr[i++];
      switch (c) {
          case 'P': {
              const { r, n, an } = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg);
              lexpr = r;
              i += n;
              ai += an;
              break;
          }
          case 'A':
              if (ai !== annotations.length) {
                  ann[0] = annotations[ai++];
              }
              break;
          default:
              throw new MacroError(p, `${p.prim}: unexpected character: ${c}`);
      }
      // Right expression
      let rexpr;
      if (i === expr.length) {
          throw new MacroError(p, `unexpected end: ${p.prim}`);
      }
      c = expr[i++];
      switch (c) {
          case 'P': {
              const { r, n, an } = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg);
              rexpr = r.map(([v, a]) => [v + 1, a]);
              i += n;
              ai += an;
              break;
          }
          case 'I':
              if (ai !== annotations.length) {
                  ann[1] = annotations[ai++];
              }
              break;
          default:
              throw new MacroError(p, `${p.prim}: unexpected character: ${c}`);
      }
      return { r: agg(lexpr, rexpr, [0, ann]), n: i, an: ai };
  }
  function parseSetMapCadr(p, expr, vann, term) {
      const c = expr[0];
      switch (c) {
          case 'A':
              return expr.length > 1
                  ? [
                      { prim: 'DUP' },
                      {
                          prim: 'DIP',
                          args: [
                              [{ prim: 'CAR', annots: ['@%%'] }, parseSetMapCadr(p, expr.slice(1), [], term)],
                          ],
                      },
                      { prim: 'CDR', annots: ['@%%'] },
                      { prim: 'SWAP' },
                      { prim: 'PAIR', annots: ['%@', '%@', ...vann] },
                  ]
                  : term.a;
          case 'D':
              return expr.length > 1
                  ? [
                      { prim: 'DUP' },
                      {
                          prim: 'DIP',
                          args: [
                              [{ prim: 'CDR', annots: ['@%%'] }, parseSetMapCadr(p, expr.slice(1), [], term)],
                          ],
                      },
                      { prim: 'CAR', annots: ['@%%'] },
                      { prim: 'PAIR', annots: ['%@', '%@', ...vann] },
                  ]
                  : term.d;
          default:
              throw new MacroError(p, `${p.prim}: unexpected character: ${c}`);
      }
  }
  function trimLast(a, v) {
      let l = a.length;
      while (l > 0 && a[l - 1] === v) {
          l--;
      }
      return a.slice(0, l);
  }
  function filterAnnotations(a) {
      const fields = [];
      const rest = [];
      if (a !== undefined) {
          for (const v of a) {
              (v.length !== 0 && v[0] === '%' ? fields : rest).push(v);
          }
      }
      return { fields, rest };
  }
  function mkPrim({ prim, annots, args }) {
      return Object.assign(Object.assign({ prim }, (annots && { annots })), (args && { args }));
  }
  const pairRe = /^P[PAI]{3,}R$/;
  const unpairRe = /^UNP[PAI]{2,}R$/;
  const cadrRe = /^C[AD]{2,}R$/;
  const setCadrRe = /^SET_C[AD]+R$/;
  const mapCadrRe = /^MAP_C[AD]+R$/;
  const diipRe = /^DI{2,}P$/;
  const duupRe = /^DU+P$/;
  function expandMacros(ex, opt) {
      const proto = (opt === null || opt === void 0 ? void 0 : opt.protocol) || DefaultProtocol;
      function mayRename(annots) {
          return annots !== undefined ? [{ prim: 'RENAME', annots }] : [];
      }
      switch (ex.prim) {
          // Compare
          case 'CMPEQ':
          case 'CMPNEQ':
          case 'CMPLT':
          case 'CMPGT':
          case 'CMPLE':
          case 'CMPGE':
              if (assertArgs$1(ex, 0)) {
                  return [{ prim: 'COMPARE' }, mkPrim({ prim: ex.prim.slice(3), annots: ex.annots })];
              }
              break;
          case 'IFEQ':
          case 'IFNEQ':
          case 'IFLT':
          case 'IFGT':
          case 'IFLE':
          case 'IFGE':
              if (assertArgs$1(ex, 2)) {
                  return [
                      { prim: ex.prim.slice(2) },
                      mkPrim({ prim: 'IF', annots: ex.annots, args: ex.args }),
                  ];
              }
              break;
          case 'IFCMPEQ':
          case 'IFCMPNEQ':
          case 'IFCMPLT':
          case 'IFCMPGT':
          case 'IFCMPLE':
          case 'IFCMPGE':
              if (assertArgs$1(ex, 2)) {
                  return [
                      { prim: 'COMPARE' },
                      { prim: ex.prim.slice(5) },
                      mkPrim({ prim: 'IF', annots: ex.annots, args: ex.args }),
                  ];
              }
              break;
          // Fail
          case 'FAIL':
              if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
                  return [{ prim: 'UNIT' }, { prim: 'FAILWITH' }];
              }
              break;
          // Assertion macros
          case 'ASSERT':
              if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
                  return [
                      {
                          prim: 'IF',
                          args: [[], [[{ prim: 'UNIT' }, { prim: 'FAILWITH' }]]],
                      },
                  ];
              }
              break;
          case 'ASSERT_EQ':
          case 'ASSERT_NEQ':
          case 'ASSERT_LT':
          case 'ASSERT_GT':
          case 'ASSERT_LE':
          case 'ASSERT_GE':
              if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
                  return [
                      { prim: ex.prim.slice(7) },
                      {
                          prim: 'IF',
                          args: [[], [[{ prim: 'UNIT' }, { prim: 'FAILWITH' }]]],
                      },
                  ];
              }
              break;
          case 'ASSERT_CMPEQ':
          case 'ASSERT_CMPNEQ':
          case 'ASSERT_CMPLT':
          case 'ASSERT_CMPGT':
          case 'ASSERT_CMPLE':
          case 'ASSERT_CMPGE':
              if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
                  return [
                      [{ prim: 'COMPARE' }, { prim: ex.prim.slice(10) }],
                      {
                          prim: 'IF',
                          args: [[], [[{ prim: 'UNIT' }, { prim: 'FAILWITH' }]]],
                      },
                  ];
              }
              break;
          case 'ASSERT_NONE':
              if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
                  return [
                      {
                          prim: 'IF_NONE',
                          args: [[], [[{ prim: 'UNIT' }, { prim: 'FAILWITH' }]]],
                      },
                  ];
              }
              break;
          case 'ASSERT_SOME':
              if (assertArgs$1(ex, 0)) {
                  return [
                      {
                          prim: 'IF_NONE',
                          args: [[[{ prim: 'UNIT' }, { prim: 'FAILWITH' }]], mayRename(ex.annots)],
                      },
                  ];
              }
              break;
          case 'ASSERT_LEFT':
              if (assertArgs$1(ex, 0)) {
                  return [
                      {
                          prim: 'IF_LEFT',
                          args: [mayRename(ex.annots), [[{ prim: 'UNIT' }, { prim: 'FAILWITH' }]]],
                      },
                  ];
              }
              break;
          case 'ASSERT_RIGHT':
              if (assertArgs$1(ex, 0)) {
                  return [
                      {
                          prim: 'IF_LEFT',
                          args: [[[{ prim: 'UNIT' }, { prim: 'FAILWITH' }]], mayRename(ex.annots)],
                      },
                  ];
              }
              break;
          // Syntactic conveniences
          case 'IF_SOME':
              if (assertArgs$1(ex, 2)) {
                  return [mkPrim({ prim: 'IF_NONE', annots: ex.annots, args: [ex.args[1], ex.args[0]] })];
              }
              break;
          case 'IF_RIGHT':
              if (assertArgs$1(ex, 2)) {
                  return [mkPrim({ prim: 'IF_LEFT', annots: ex.annots, args: [ex.args[1], ex.args[0]] })];
              }
              break;
          // CAR/CDR n
          case 'CAR':
          case 'CDR':
              if (ex.args !== undefined) {
                  if (assertArgs$1(ex, 1) && assertIntArg(ex, ex.args[0])) {
                      const n = parseInt(ex.args[0].int, 10);
                      return mkPrim({
                          prim: 'GET',
                          args: [{ int: ex.prim === 'CAR' ? String(n * 2 + 1) : String(n * 2) }],
                          annots: ex.annots,
                      });
                  }
              }
              else {
                  return ex;
              }
      }
      // More syntactic conveniences
      // PAPPAIIR macro
      if (pairRe.test(ex.prim)) {
          if (assertArgs$1(ex, 0)) {
              const { fields, rest } = filterAnnotations(ex.annots);
              const { r } = parsePairUnpairExpr(ex, ex.prim.slice(1), fields, (l, r, top) => [
                  ...(l || []),
                  ...(r || []),
                  top,
              ]);
              return r.map(([v, a], i) => {
                  const ann = [
                      ...trimLast(a, null).map((v) => (v === null ? '%' : v)),
                      ...(v === 0 && i === r.length - 1 ? rest : []),
                  ];
                  const leaf = mkPrim({ prim: 'PAIR', annots: ann.length !== 0 ? ann : undefined });
                  return v === 0
                      ? leaf
                      : {
                          prim: 'DIP',
                          args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]],
                      };
              });
          }
      }
      // UNPAPPAIIR macro
      if (unpairRe.test(ex.prim)) {
          if (ProtoInferiorTo(proto, exports.Protocol.PtEdo2Zk) && assertArgs$1(ex, 0)) {
              const { r } = parsePairUnpairExpr(ex, ex.prim.slice(3), ex.annots || [], (l, r, top) => [
                  top,
                  ...(r || []),
                  ...(l || []),
              ]);
              return r.map(([v, a]) => {
                  const leaf = [
                      { prim: 'DUP' },
                      mkPrim({ prim: 'CAR', annots: a[0] !== null ? [a[0]] : undefined }),
                      {
                          prim: 'DIP',
                          args: [[mkPrim({ prim: 'CDR', annots: a[1] !== null ? [a[1]] : undefined })]],
                      },
                  ];
                  return v === 0
                      ? leaf
                      : {
                          prim: 'DIP',
                          args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]],
                      };
              });
          }
          else {
              if (ex.prim === 'UNPAIR') {
                  return ex;
              }
              if (assertArgs$1(ex, 0)) {
                  // 008_edo: annotations are deprecated
                  const { r } = parsePairUnpairExpr(ex, ex.prim.slice(3), [], (l, r, top) => [
                      top,
                      ...(r || []),
                      ...(l || []),
                  ]);
                  return r.map(([v]) => {
                      const leaf = mkPrim({
                          prim: 'UNPAIR',
                      });
                      return v === 0
                          ? leaf
                          : {
                              prim: 'DIP',
                              args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]],
                          };
                  });
              }
          }
      }
      // C[AD]+R macro
      if (cadrRe.test(ex.prim)) {
          if (assertArgs$1(ex, 0)) {
              const ch = [...ex.prim.slice(1, ex.prim.length - 1)];
              return ch.map((c, i) => {
                  const ann = i === ch.length - 1 ? ex.annots : undefined;
                  switch (c) {
                      case 'A':
                          return mkPrim({ prim: 'CAR', annots: ann });
                      case 'D':
                          return mkPrim({ prim: 'CDR', annots: ann });
                      default:
                          throw new MacroError(ex, `unexpected character: ${c}`);
                  }
              });
          }
      }
      // SET_C[AD]+R macro
      if (setCadrRe.test(ex.prim)) {
          if (assertArgs$1(ex, 0)) {
              const { fields, rest } = filterAnnotations(ex.annots);
              if (fields.length > 1) {
                  throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${fields}`);
              }
              const term = fields.length !== 0
                  ? {
                      a: [
                          { prim: 'DUP' },
                          { prim: 'CAR', annots: fields },
                          { prim: 'DROP' },
                          { prim: 'CDR', annots: ['@%%'] },
                          { prim: 'SWAP' },
                          { prim: 'PAIR', annots: [fields[0], '%@'] },
                      ],
                      d: [
                          { prim: 'DUP' },
                          { prim: 'CDR', annots: fields },
                          { prim: 'DROP' },
                          { prim: 'CAR', annots: ['@%%'] },
                          { prim: 'PAIR', annots: ['%@', fields[0]] },
                      ],
                  }
                  : {
                      a: [
                          { prim: 'CDR', annots: ['@%%'] },
                          { prim: 'SWAP' },
                          { prim: 'PAIR', annots: ['%', '%@'] },
                      ],
                      d: [
                          { prim: 'CAR', annots: ['@%%'] },
                          { prim: 'PAIR', annots: ['%@', '%'] },
                      ],
                  };
              return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), rest, term);
          }
      }
      // MAP_C[AD]+R macro
      if (mapCadrRe.test(ex.prim)) {
          if (assertArgs$1(ex, 1)) {
              const { fields } = filterAnnotations(ex.annots);
              if (fields.length > 1) {
                  throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${fields}`);
              }
              const term = {
                  a: [
                      { prim: 'DUP' },
                      { prim: 'CDR', annots: ['@%%'] },
                      {
                          prim: 'DIP',
                          args: [
                              [
                                  mkPrim({
                                      prim: 'CAR',
                                      annots: fields.length !== 0 ? ['@' + fields[0].slice(1)] : undefined,
                                  }),
                                  ex.args[0],
                              ],
                          ],
                      },
                      { prim: 'SWAP' },
                      { prim: 'PAIR', annots: [fields.length !== 0 ? fields[0] : '%', '%@'] },
                  ],
                  d: [
                      { prim: 'DUP' },
                      mkPrim({
                          prim: 'CDR',
                          annots: fields.length !== 0 ? ['@' + fields[0].slice(1)] : undefined,
                      }),
                      ex.args[0],
                      { prim: 'SWAP' },
                      { prim: 'CAR', annots: ['@%%'] },
                      { prim: 'PAIR', annots: ['%@', fields.length !== 0 ? fields[0] : '%'] },
                  ],
              };
              return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), [], term);
          }
      }
      // Expand deprecated DI...IP to [DIP n]
      if (diipRe.test(ex.prim)) {
          if (assertArgs$1(ex, 1)) {
              let n = 0;
              while (ex.prim[1 + n] === 'I') {
                  n++;
              }
              return mkPrim({ prim: 'DIP', args: [{ int: String(n) }, ex.args[0]] });
          }
      }
      // Expand DU...UP and DUP n
      if (duupRe.test(ex.prim)) {
          let n = 0;
          while (ex.prim[1 + n] === 'U') {
              n++;
          }
          if (ProtoInferiorTo(proto, exports.Protocol.PtEdo2Zk)) {
              if (n === 1) {
                  if (ex.args === undefined) {
                      return ex; // skip
                  }
                  if (assertArgs$1(ex, 1) && assertIntArg(ex, ex.args[0])) {
                      n = parseInt(ex.args[0].int, 10);
                  }
              }
              else {
                  assertArgs$1(ex, 0);
              }
              if (n === 1) {
                  return [mkPrim({ prim: 'DUP', annots: ex.annots })];
              }
              else if (n === 2) {
                  return [
                      {
                          prim: 'DIP',
                          args: [[mkPrim({ prim: 'DUP', annots: ex.annots })]],
                      },
                      { prim: 'SWAP' },
                  ];
              }
              else {
                  return [
                      {
                          prim: 'DIP',
                          args: [{ int: String(n - 1) }, [mkPrim({ prim: 'DUP', annots: ex.annots })]],
                      },
                      {
                          prim: 'DIG',
                          args: [{ int: String(n) }],
                      },
                  ];
              }
          }
          else {
              if (n === 1) {
                  return ex;
              }
              if (assertArgs$1(ex, 0)) {
                  return mkPrim({ prim: 'DUP', args: [{ int: String(n) }], annots: ex.annots });
              }
          }
      }
      return ex;
  }

  function expandGlobalConstants(ex, hashAndValue) {
      if (ex.args !== undefined &&
          ex.args.length === 1 &&
          'string' in ex.args[0] &&
          ex.args[0].string in hashAndValue) {
          return hashAndValue[ex.args[0].string];
      }
      return ex;
  }

  /**
   *  @category Error
   *  @description Error indicating a failure when parsing Micheline expressions
   */
  class MichelineParseError extends Error {
      /**
       * @param token A token caused the error
       * @param message An error message
       */
      constructor(token, message) {
          super(message);
          this.token = token;
          Object.setPrototypeOf(this, MichelineParseError.prototype);
      }
  }
  /**
   *  @category Error
   *  @description Error that inidicates a failure when parsing Micheline JSON
   */
  class JSONParseError extends Error {
      /**
       * @param node A node caused the error
       * @param message An error message
       */
      constructor(node, message) {
          super(message);
          this.node = node;
          Object.setPrototypeOf(this, JSONParseError.prototype);
      }
  }
  const errEOF = new MichelineParseError(null, 'Unexpected EOF');
  function isAnnotation(tok) {
      return tok.t === Literal.Ident && (tok.v[0] === '@' || tok.v[0] === '%' || tok.v[0] === ':');
  }
  const intRe = new RegExp('^-?[0-9]+$');
  const bytesRe = new RegExp('^([0-9a-fA-F]{2})*$');
  /**
   * Converts and validates Michelson expressions between JSON-based Michelson and Micheline
   *
   * Pretty Print a Michelson Smart Contract:
   * ```
   * const contract = await Tezos.contract.at("KT1Vsw3kh9638gqWoHTjvHCoHLPKvCbMVbCg");
   * const p = new Parser();
   *
   * const michelsonCode = p.parseJSON(contract.script.code);
   * const storage = p.parseJSON(contract.script.storage);
   *
   * console.log("Pretty print Michelson smart contract:");
   * console.log(emitMicheline(michelsonCode, {indent:"    ", newline: "\n",}));
   *
   * console.log("Pretty print Storage:");
   * console.log(emitMicheline(storage, {indent:"    ", newline: "\n",}));
   * ```
   *
   * Encode a Michelson expression for inital storage of a smart contract
   * ```
   * const src = `(Pair (Pair { Elt 1
   *                (Pair (Pair "tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" "tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx")
   *                      0x0501000000026869) }
   *          10000000)
   *    (Pair 2 333))`;
   *
   * const p = new Parser();
   *
   * const exp = p.parseMichelineExpression(src);
   * console.log(JSON.stringify(exp));
   * ```
   */
  class Parser {
      constructor(opt) {
          this.opt = opt;
      }
      expand(ex) {
          var _a, _b, _c;
          if (((_a = this.opt) === null || _a === void 0 ? void 0 : _a.expandGlobalConstant) !== undefined && ex.prim === 'constant') {
              const ret = expandGlobalConstants(ex, this.opt.expandGlobalConstant);
              if (ret !== ex) {
                  ret[sourceReference] = Object.assign(Object.assign({}, (ex[sourceReference] || { first: 0, last: 0 })), { globalConstant: ex });
              }
              return ret;
          }
          if (((_b = this.opt) === null || _b === void 0 ? void 0 : _b.expandMacros) !== undefined ? (_c = this.opt) === null || _c === void 0 ? void 0 : _c.expandMacros : true) {
              const ret = expandMacros(ex, this.opt);
              if (ret !== ex) {
                  ret[sourceReference] = Object.assign(Object.assign({}, (ex[sourceReference] || { first: 0, last: 0 })), { macro: ex });
              }
              return ret;
          }
          else {
              return ex;
          }
      }
      parseListExpr(scanner, start) {
          var _a;
          const ref = {
              first: start.first,
              last: start.last,
          };
          const expectBracket = start.t === '(';
          let tok;
          if (expectBracket) {
              tok = scanner.next();
              if (tok.done) {
                  throw errEOF;
              }
              ref.last = tok.value.last;
          }
          else {
              tok = { value: start };
          }
          if (tok.value.t !== Literal.Ident) {
              throw new MichelineParseError(tok.value, `not an identifier: ${tok.value.v}`);
          }
          const ret = {
              prim: tok.value.v,
              [sourceReference]: ref,
          };
          for (;;) {
              const tok = scanner.next();
              if (tok.done) {
                  if (expectBracket) {
                      throw errEOF;
                  }
                  break;
              }
              else if (tok.value.t === ')') {
                  if (!expectBracket) {
                      throw new MichelineParseError(tok.value, 'unexpected closing bracket');
                  }
                  ref.last = tok.value.last;
                  break;
              }
              else if (isAnnotation(tok.value)) {
                  ret.annots = ret.annots || [];
                  ret.annots.push(tok.value.v);
                  ref.last = tok.value.last;
              }
              else {
                  ret.args = ret.args || [];
                  const arg = this.parseExpr(scanner, tok.value);
                  ref.last = ((_a = arg[sourceReference]) === null || _a === void 0 ? void 0 : _a.last) || ref.last;
                  ret.args.push(arg);
              }
          }
          return this.expand(ret);
      }
      parseArgs(scanner, start) {
          var _a;
          // Identifier with arguments
          const ref = {
              first: start.first,
              last: start.last,
          };
          const p = {
              prim: start.v,
              [sourceReference]: ref,
          };
          for (;;) {
              const t = scanner.next();
              if (t.done || t.value.t === '}' || t.value.t === ';') {
                  return [p, t];
              }
              if (isAnnotation(t.value)) {
                  ref.last = t.value.last;
                  p.annots = p.annots || [];
                  p.annots.push(t.value.v);
              }
              else {
                  const arg = this.parseExpr(scanner, t.value);
                  ref.last = ((_a = arg[sourceReference]) === null || _a === void 0 ? void 0 : _a.last) || ref.last;
                  p.args = p.args || [];
                  p.args.push(arg);
              }
          }
      }
      parseSequenceExpr(scanner, start) {
          var _a, _b;
          const ref = {
              first: start.first,
              last: start.last,
          };
          const seq = [];
          seq[sourceReference] = ref;
          const expectBracket = start.t === '{';
          let tok = start.t === '{' ? null : { value: start };
          for (;;) {
              if (tok === null) {
                  tok = scanner.next();
                  if (!tok.done) {
                      ref.last = tok.value.last;
                  }
              }
              if (tok.done) {
                  if (expectBracket) {
                      throw errEOF;
                  }
                  else {
                      return seq;
                  }
              }
              if (tok.value.t === '}') {
                  if (!expectBracket) {
                      throw new MichelineParseError(tok.value, 'unexpected closing bracket');
                  }
                  else {
                      return seq;
                  }
              }
              else if (tok.value.t === Literal.Ident) {
                  // Identifier with arguments
                  const [itm, n] = this.parseArgs(scanner, tok.value);
                  ref.last = ((_a = itm[sourceReference]) === null || _a === void 0 ? void 0 : _a.last) || ref.last;
                  seq.push(this.expand(itm));
                  tok = n;
              }
              else {
                  // Other
                  const ex = this.parseExpr(scanner, tok.value);
                  ref.last = ((_b = ex[sourceReference]) === null || _b === void 0 ? void 0 : _b.last) || ref.last;
                  seq.push(ex);
                  tok = null;
              }
              if (tok === null) {
                  tok = scanner.next();
                  if (!tok.done) {
                      ref.last = tok.value.last;
                  }
              }
              if (!tok.done && tok.value.t === ';') {
                  tok = null;
              }
          }
      }
      parseExpr(scanner, tok) {
          switch (tok.t) {
              case Literal.Ident:
                  return this.expand({
                      prim: tok.v,
                      [sourceReference]: { first: tok.first, last: tok.last },
                  });
              case Literal.Number:
                  return { int: tok.v, [sourceReference]: { first: tok.first, last: tok.last } };
              case Literal.String:
                  return {
                      string: JSON.parse(tok.v),
                      [sourceReference]: { first: tok.first, last: tok.last },
                  };
              case Literal.Bytes:
                  return { bytes: tok.v.slice(2), [sourceReference]: { first: tok.first, last: tok.last } };
              case '{':
                  return this.parseSequenceExpr(scanner, tok);
              default:
                  return this.parseListExpr(scanner, tok);
          }
      }
      /**
       * Parses a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.
       * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`
       */
      parseSequence(src) {
          if (typeof src !== 'string') {
              throw new TypeError(`string type was expected, got ${typeof src} instead`);
          }
          const scanner = scan(src);
          const tok = scanner.next();
          if (tok.done) {
              return null;
          }
          return this.parseSequenceExpr(scanner, tok.value);
      }
      /**
       * Parse a Micheline sequence expression. Enclosing curly brackets may be omitted.
       * @param src A Michelson list expression such as `(Pair {Elt "0" 0} 0)` or `Pair {Elt "0" 0} 0`
       * @returns An AST node or null for empty document.
       */
      parseList(src) {
          if (typeof src !== 'string') {
              throw new TypeError(`string type was expected, got ${typeof src} instead`);
          }
          const scanner = scan(src);
          const tok = scanner.next();
          if (tok.done) {
              return null;
          }
          return this.parseListExpr(scanner, tok.value);
      }
      /**
       * Parse any Michelson expression
       * @param src A Michelson expression such as `(Pair {Elt "0" 0} 0)` or `{parameter ...; storage int; code { DUP ; ...};}`
       * @returns An AST node or null for empty document.
       */
      parseMichelineExpression(src) {
          if (typeof src !== 'string') {
              throw new TypeError(`string type was expected, got ${typeof src} instead`);
          }
          const scanner = scan(src);
          const tok = scanner.next();
          if (tok.done) {
              return null;
          }
          return this.parseExpr(scanner, tok.value);
      }
      /**
       * Parse a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.
       * An alias for `parseSequence`
       * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`
       */
      parseScript(src) {
          return this.parseSequence(src);
      }
      /**
       * Parse a Micheline sequence expression. Enclosing curly brackets may be omitted.
       * An alias for `parseList`
       * @param src A Michelson list expression such as `(Pair {Elt "0" 0} 0)` or `Pair {Elt "0" 0} 0`
       * @returns An AST node or null for empty document.
       */
      parseData(src) {
          return this.parseList(src);
      }
      /**
       * Takes a JSON-encoded Michelson, validates it, strips away unneeded properties and optionally expands macros (See {@link ParserOptions}).
       * @param src An object containing JSON-encoded Michelson, usually returned by `JSON.parse()`
       */
      parseJSON(src) {
          if (typeof src !== 'object') {
              throw new TypeError(`object type was expected, got ${typeof src} instead`);
          }
          if (Array.isArray(src)) {
              const ret = [];
              for (const n of src) {
                  if (n === null || typeof n !== 'object') {
                      throw new JSONParseError(n, `unexpected sequence element: ${n}`);
                  }
                  ret.push(this.parseJSON(n));
              }
              return ret;
          }
          else if ('prim' in src) {
              const p = src;
              if (typeof p.prim === 'string' &&
                  (p.annots === undefined || Array.isArray(p.annots)) &&
                  (p.args === undefined || Array.isArray(p.args))) {
                  const ret = {
                      prim: p.prim,
                  };
                  if (p.annots !== undefined) {
                      for (const a of p.annots) {
                          if (typeof a !== 'string') {
                              throw new JSONParseError(a, `string expected: ${a}`);
                          }
                      }
                      ret.annots = p.annots;
                  }
                  if (p.args !== undefined) {
                      ret.args = [];
                      for (const a of p.args) {
                          if (a === null || typeof a !== 'object') {
                              throw new JSONParseError(a, `unexpected argument: ${a}`);
                          }
                          ret.args.push(this.parseJSON(a));
                      }
                  }
                  return this.expand(ret);
              }
              throw new JSONParseError(src, `malformed prim expression: ${src}`);
          }
          else if ('string' in src) {
              if (typeof src.string === 'string') {
                  return { string: src.string };
              }
              throw new JSONParseError(src, `malformed string literal: ${src}`);
          }
          else if ('int' in src) {
              if (typeof src.int === 'string' && intRe.test(src.int)) {
                  return { int: src.int };
              }
              throw new JSONParseError(src, `malformed int literal: ${src}`);
          }
          else if ('bytes' in src) {
              if (typeof src.bytes === 'string' &&
                  bytesRe.test(src.bytes)) {
                  return { bytes: src.bytes };
              }
              throw new JSONParseError(src, `malformed bytes literal: ${src}`);
          }
          else {
              throw new JSONParseError(src, `unexpected object: ${src}`);
          }
      }
  }

  class Formatter {
      constructor(opt, lev = 0) {
          this.opt = opt;
          this.lev = lev;
      }
      indent(n = 0) {
          var _a;
          let ret = '';
          if (((_a = this.opt) === null || _a === void 0 ? void 0 : _a.indent) !== undefined) {
              for (let i = this.lev + n; i > 0; i--) {
                  ret += this.opt.indent;
              }
          }
          return ret;
      }
      get lf() {
          var _a;
          return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.newline) || '';
      }
      get lfsp() {
          var _a;
          return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.newline) || ' ';
      }
      down(n) {
          return new Formatter(this.opt, this.lev + n);
      }
  }
  function hasArgs(node) {
      return ('prim' in node &&
          ((node.annots !== undefined && node.annots.length !== 0) ||
              (node.args !== undefined && node.args.length !== 0)));
  }
  function isMultiline(node) {
      if (node.args !== undefined) {
          for (const a of node.args) {
              if (Array.isArray(a) || hasArgs(a)) {
                  return true;
              }
          }
      }
      return false;
  }
  function emitExpr(node, f, foldMacros) {
      var _a;
      const macro = (_a = node[sourceReference]) === null || _a === void 0 ? void 0 : _a.macro;
      if (foldMacros && macro) {
          return emitExpr(macro, f, foldMacros);
      }
      if (Array.isArray(node)) {
          return emitSeq(node, f, foldMacros);
      }
      else if ('string' in node) {
          return JSON.stringify(node.string);
      }
      else if ('int' in node) {
          return node.int;
      }
      else if ('bytes' in node) {
          return '0x' + node.bytes;
      }
      else {
          if ((node.annots === undefined || node.annots.length === 0) &&
              (node.args === undefined || node.args.length === 0)) {
              return node.prim;
          }
          let ret = '(' + node.prim;
          if (node.annots !== undefined) {
              for (const a of node.annots) {
                  ret += ' ' + a;
              }
          }
          if (node.args !== undefined) {
              const multiline = isMultiline(node);
              for (const a of node.args) {
                  if (multiline) {
                      ret += f.lfsp + f.indent(1) + emitExpr(a, f.down(1), foldMacros);
                  }
                  else {
                      ret += ' ' + emitExpr(a, f, foldMacros);
                  }
              }
          }
          return ret + ')';
      }
  }
  function emitSeq(node, f, foldMacros) {
      let ret = '{' + f.lf;
      let i = node.length;
      for (const el of node) {
          ret += f.indent(1);
          if ('prim' in el) {
              ret += el.prim;
              if (el.annots !== undefined) {
                  for (const a of el.annots) {
                      ret += ' ' + a;
                  }
              }
              if (el.args !== undefined) {
                  const multiline = isMultiline(el);
                  for (const a of el.args) {
                      if (multiline) {
                          ret += f.lfsp + f.indent(2) + emitExpr(a, f.down(2), foldMacros);
                      }
                      else {
                          ret += ' ' + emitExpr(a, f, foldMacros);
                      }
                  }
              }
          }
          else {
              ret += emitExpr(el, f.down(1), foldMacros);
          }
          ret += i > 1 ? ';' + f.lfsp : f.lf;
          i--;
      }
      return ret + f.indent() + '}';
  }
  /**
   * Formats Micheline expression
   * @param expr An AST node
   * @param opt Options
   */
  function emitMicheline(expr, opt, foldMacros = false) {
      if (typeof expr !== 'object') {
          throw new TypeError(`object type was expected, got ${typeof expr} instead`);
      }
      return emitExpr(expr, new Formatter(opt), foldMacros);
  }

  const H = [
      0x6a09e667 | 0,
      0xbb67ae85 | 0,
      0x3c6ef372 | 0,
      0xa54ff53a | 0,
      0x510e527f | 0,
      0x9b05688c | 0,
      0x1f83d9ab | 0,
      0x5be0cd19 | 0,
  ];
  const K = [
      0x428a2f98 | 0,
      0x71374491 | 0,
      0xb5c0fbcf | 0,
      0xe9b5dba5 | 0,
      0x3956c25b | 0,
      0x59f111f1 | 0,
      0x923f82a4 | 0,
      0xab1c5ed5 | 0,
      0xd807aa98 | 0,
      0x12835b01 | 0,
      0x243185be | 0,
      0x550c7dc3 | 0,
      0x72be5d74 | 0,
      0x80deb1fe | 0,
      0x9bdc06a7 | 0,
      0xc19bf174 | 0,
      0xe49b69c1 | 0,
      0xefbe4786 | 0,
      0x0fc19dc6 | 0,
      0x240ca1cc | 0,
      0x2de92c6f | 0,
      0x4a7484aa | 0,
      0x5cb0a9dc | 0,
      0x76f988da | 0,
      0x983e5152 | 0,
      0xa831c66d | 0,
      0xb00327c8 | 0,
      0xbf597fc7 | 0,
      0xc6e00bf3 | 0,
      0xd5a79147 | 0,
      0x06ca6351 | 0,
      0x14292967 | 0,
      0x27b70a85 | 0,
      0x2e1b2138 | 0,
      0x4d2c6dfc | 0,
      0x53380d13 | 0,
      0x650a7354 | 0,
      0x766a0abb | 0,
      0x81c2c92e | 0,
      0x92722c85 | 0,
      0xa2bfe8a1 | 0,
      0xa81a664b | 0,
      0xc24b8b70 | 0,
      0xc76c51a3 | 0,
      0xd192e819 | 0,
      0xd6990624 | 0,
      0xf40e3585 | 0,
      0x106aa070 | 0,
      0x19a4c116 | 0,
      0x1e376c08 | 0,
      0x2748774c | 0,
      0x34b0bcb5 | 0,
      0x391c0cb3 | 0,
      0x4ed8aa4a | 0,
      0x5b9cca4f | 0,
      0x682e6ff3 | 0,
      0x748f82ee | 0,
      0x78a5636f | 0,
      0x84c87814 | 0,
      0x8cc70208 | 0,
      0x90befffa | 0,
      0xa4506ceb | 0,
      0xbef9a3f7 | 0,
      0xc67178f2 | 0,
  ];
  /**
   *  @category Error
   *  @description Error that indicates a failure when decoding a base58 encoding
   */
  class Base58DecodingError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'Base58DecodingError';
      }
  }
  /**
   *  @category Error
   *  @description
   */
  class InvalidMessageError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'InvalidMessageError';
      }
  }
  // https://tools.ietf.org/html/rfc6234
  function sha256(msg) {
      // pad the message
      const r = (msg.length + 9) % 64;
      const pad = r === 0 ? 0 : 64 - r;
      if (msg.length > 268435455) {
          throw new InvalidMessageError(`SHA-256 -- message length is too big: ${msg.length}`);
      }
      const l = msg.length << 3;
      const buffer = [
          ...msg,
          0x80,
          ...new Array(pad).fill(0),
          0,
          0,
          0,
          0,
          (l >> 24) & 0xff,
          (l >> 16) & 0xff,
          (l >> 8) & 0xff,
          l & 0xff,
      ];
      function ror(x, n) {
          return (x >>> n) | (x << (32 - n));
      }
      const h = [...H];
      const w = new Array(64);
      const v = new Array(8);
      for (let offset = 0; offset < buffer.length; offset += 64) {
          let q = offset;
          let i = 0;
          while (i < 16) {
              w[i] = (buffer[q] << 24) | (buffer[q + 1] << 16) | (buffer[q + 2] << 8) | buffer[q + 3];
              q += 4;
              i++;
          }
          while (i < 64) {
              const s0 = ror(w[i - 15], 7) ^ ror(w[i - 15], 18) ^ (w[i - 15] >>> 3);
              const s1 = ror(w[i - 2], 17) ^ ror(w[i - 2], 19) ^ (w[i - 2] >>> 10);
              w[i] = ((s1 | 0) + w[i - 7] + s0 + w[i - 16]) | 0;
              i++;
          }
          for (let i = 0; i < 8; i++) {
              v[i] = h[i];
          }
          for (let i = 0; i < 64; i++) {
              const b0 = ror(v[0], 2) ^ ror(v[0], 13) ^ ror(v[0], 22);
              const b1 = ror(v[4], 6) ^ ror(v[4], 11) ^ ror(v[4], 25);
              const t1 = (v[7] + b1 + ((v[4] & v[5]) ^ (~v[4] & v[6])) + K[i] + w[i]) | 0;
              const t2 = (b0 + ((v[0] & v[1]) ^ (v[0] & v[2]) ^ (v[1] & v[2]))) | 0;
              v[7] = v[6];
              v[6] = v[5];
              v[5] = v[4];
              v[4] = (v[3] + t1) | 0;
              v[3] = v[2];
              v[2] = v[1];
              v[1] = v[0];
              v[0] = (t1 + t2) | 0;
          }
          for (let i = 0; i < 8; i++) {
              h[i] = (h[i] + v[i]) | 0;
          }
      }
      const digest = [];
      for (const v of h) {
          digest.push((v >> 24) & 0xff);
          digest.push((v >> 16) & 0xff);
          digest.push((v >> 8) & 0xff);
          digest.push(v & 0xff);
      }
      return digest;
  }
  const base58alphabetFwd = [
      0, 1, 2, 3, 4, 5, 6, 7, 8, -1, -1, -1, -1, -1, -1, -1, 9, 10, 11, 12, 13, 14, 15, 16, -1, 17, 18,
      19, 20, 21, -1, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, -1, -1, -1, -1, -1, -1, 33, 34, 35,
      36, 37, 38, 39, 40, 41, 42, 43, -1, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
  ];
  const base58alphabetBwd = [
      0, 1, 2, 3, 4, 5, 6, 7, 8, 16, 17, 18, 19, 20, 21, 22, 23, 25, 26, 27, 28, 29, 31, 32, 33, 34, 35,
      36, 37, 38, 39, 40, 41, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 61, 62, 63, 64, 65, 66,
      67, 68, 69, 70, 71, 72, 73,
  ];
  function byteAt(src, i) {
      const c = src.charCodeAt(i) - 49;
      if (c >= base58alphabetFwd.length || base58alphabetFwd[c] === -1) {
          throw new Base58DecodingError(`Unexpected character at position ${i}: ${src[i]}`);
      }
      return base58alphabetFwd[c];
  }
  function decodeBase58(src) {
      const acc = [];
      let i = 0;
      // count and skip leading zeros
      while (i < src.length && byteAt(src, i) === 0) {
          i++;
      }
      let zeros = i;
      while (i < src.length) {
          let carry = byteAt(src, i++);
          /*
              for every symbol x
              acc = acc * 58 + x
              where acc is a little endian arbitrary length integer
              */
          let ii = 0;
          while (carry !== 0 || ii < acc.length) {
              const m = (acc[ii] || 0) * 58 + carry;
              acc[ii++] = m % 256;
              carry = Math.floor(m / 256);
          }
      }
      while (zeros-- > 0) {
          acc.push(0);
      }
      return acc.reverse();
  }
  function encodeBase58(src) {
      const acc = [];
      let i = 0;
      // count and skip leading zeros
      while (i < src.length && src[i] === 0) {
          i++;
      }
      let zeros = i;
      while (i < src.length) {
          let carry = src[i++];
          let ii = 0;
          while (carry !== 0 || ii < acc.length) {
              const m = (acc[ii] || 0) * 256 + carry;
              acc[ii++] = m % 58;
              carry = Math.floor(m / 58);
          }
      }
      while (zeros-- > 0) {
          acc.push(0);
      }
      acc.reverse();
      return String.fromCharCode(...acc.map((v) => base58alphabetBwd[v] + 49));
  }
  function decodeBase58Check(src) {
      const buffer = decodeBase58(src);
      if (buffer.length < 4) {
          throw new Base58DecodingError(`Data is too short ${buffer.length}`);
      }
      const data = buffer.slice(0, buffer.length - 4);
      const sum = buffer.slice(buffer.length - 4);
      const computed = sha256(sha256(data));
      if (sum[0] !== computed[0] ||
          sum[1] !== computed[1] ||
          sum[2] !== computed[2] ||
          sum[3] !== computed[3]) {
          throw new Base58DecodingError('Invalid checksum');
      }
      return data;
  }
  function encodeBase58Check(src) {
      const sum = sha256(sha256(src));
      return encodeBase58([...src, ...sum.slice(0, 4)]);
  }

  /**
   *  @category Error
   *  @description Error that indicates an invalid contract being passed or used
   */
  class InvalidContractError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'InvalidContractError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid type expression being passed or used
   */
  class InvalidTypeExpressionError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'InvalidTypeExpressionError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid data expression being passed or used
   */
  class InvalidDataExpressionError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'InvalidDataExpressionError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid contract entrypoint being referenced or passed
   */
  class InvalidEntrypointError extends Error {
      constructor(entrypoint) {
          super(`Contract has no entrypoint named: '${entrypoint}'`);
          this.entrypoint = entrypoint;
          this.name = 'InvalidEntrypointError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates a failure happening when trying to encode Tezos ID
   */
  class TezosIdEncodeError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'TezosIdEncodeError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates a general error happening when trying to create a LongInteger
   */
  class LongIntegerError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'LongIntegerError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates a failure occurring when trying to parse a hex byte
   */
  class HexParseError extends Error {
      constructor(hexByte) {
          super(`Unable to parse hex byte: ${hexByte}`);
          this.hexByte = hexByte;
          this.name = 'HexParseError';
      }
  }

  /**
   *  @category Error
   *  @description Error that indicates a Michelson failure occurring
   */
  class MichelsonError extends Error {
      /**
       * @param val Value of a AST node caused the error
       * @param path Path to a node caused the error
       * @param message An error message
       */
      constructor(val, message) {
          super(message);
          this.val = val;
          Object.setPrototypeOf(this, MichelsonError.prototype);
      }
  }
  function isMichelsonError(err) {
      return err instanceof MichelsonError;
  }
  class MichelsonTypeError extends MichelsonError {
      /**
       * @param val Value of a type node caused the error
       * @param data Value of a data node caused the error
       * @param message An error message
       */
      constructor(val, data, message) {
          super(val, message);
          if (data !== undefined) {
              this.data = data;
          }
          Object.setPrototypeOf(this, MichelsonTypeError.prototype);
      }
  }
  // Ad hoc big integer parser
  class LongInteger {
      constructor(arg) {
          this.neg = false;
          this.buf = [];
          if (arg === undefined) {
              return;
          }
          if (typeof arg === 'string') {
              for (let i = 0; i < arg.length; i++) {
                  const c = arg.charCodeAt(i);
                  if (i === 0 && c === 0x2d) {
                      this.neg = true;
                  }
                  else {
                      if (c < 0x30 || c > 0x39) {
                          throw new LongIntegerError(`unexpected character in integer constant: ${arg[i]}`);
                      }
                      this.append(c - 0x30);
                  }
              }
          }
          else if (arg < 0) {
              this.neg = true;
              this.append(-arg);
          }
          else {
              this.append(arg);
          }
      }
      append(c) {
          let i = 0;
          while (c !== 0 || i < this.buf.length) {
              const m = (this.buf[i] || 0) * 10 + c;
              this.buf[i++] = m % 256;
              c = Math.floor(m / 256);
          }
      }
      cmp(arg) {
          if (this.neg !== arg.neg) {
              return (arg.neg ? 1 : 0) - (this.neg ? 1 : 0);
          }
          else {
              let ret = 0;
              if (this.buf.length !== arg.buf.length) {
                  ret = this.buf.length < arg.buf.length ? -1 : 1;
              }
              else if (this.buf.length !== 0) {
                  let i = arg.buf.length - 1;
                  while (i >= 0 && this.buf[i] === arg.buf[i]) {
                      i--;
                  }
                  ret = i < 0 ? 0 : this.buf[i] < arg.buf[i] ? -1 : 1;
              }
              return !this.neg ? ret : ret === 0 ? 0 : -ret;
          }
      }
      get sign() {
          return this.buf.length === 0 ? 0 : this.neg ? -1 : 1;
      }
  }
  function parseBytes(s) {
      const ret = [];
      for (let i = 0; i < s.length; i += 2) {
          const x = parseInt(s.slice(i, i + 2), 16);
          if (Number.isNaN(x)) {
              return null;
          }
          ret.push(x);
      }
      return ret;
  }
  function isDecimal(x) {
      try {
          new LongInteger(x);
          return true;
      }
      catch (_a) {
          return false;
      }
  }
  function isNatural(x) {
      try {
          return new LongInteger(x).sign >= 0;
      }
      catch (_a) {
          return false;
      }
  }
  const annRe = /^(@%|@%%|%@|[@:%]([_0-9a-zA-Z][_0-9a-zA-Z.%@]*)?)$/;
  function unpackAnnotations(p, opt) {
      if (Array.isArray(p)) {
          return {};
      }
      let field;
      let type;
      let vars;
      if (p.annots !== undefined) {
          for (const v of p.annots) {
              if (v.length !== 0) {
                  if (!annRe.test(v) ||
                      (!(opt === null || opt === void 0 ? void 0 : opt.specialVar) && (v === '@%' || v === '@%%')) ||
                      (!(opt === null || opt === void 0 ? void 0 : opt.specialFields) && v === '%@')) {
                      throw new MichelsonError(p, `${p.prim}: unexpected annotation: ${v}`);
                  }
                  switch (v[0]) {
                      case '%':
                          if ((opt === null || opt === void 0 ? void 0 : opt.emptyFields) || v.length > 1) {
                              field = field || [];
                              field.push(v);
                          }
                          break;
                      case ':':
                          if (v.length > 1) {
                              type = type || [];
                              type.push(v);
                          }
                          break;
                      case '@':
                          if ((opt === null || opt === void 0 ? void 0 : opt.emptyVar) || v.length > 1) {
                              vars = vars || [];
                              vars.push(v);
                          }
                          break;
                  }
              }
          }
      }
      return { f: field, t: type, v: vars };
  }
  const tezosPrefix = {
      BlockHash: [32, [1, 52]],
      OperationHash: [32, [5, 116]],
      OperationListHash: [32, [133, 233]],
      OperationListListHash: [32, [29, 159, 109]],
      ProtocolHash: [32, [2, 170]],
      ContextHash: [32, [79, 199]],
      ED25519PublicKeyHash: [20, [6, 161, 159]],
      SECP256K1PublicKeyHash: [20, [6, 161, 161]],
      P256PublicKeyHash: [20, [6, 161, 164]],
      ContractHash: [20, [2, 90, 121]],
      CryptoboxPublicKeyHash: [16, [153, 103]],
      ED25519Seed: [32, [13, 15, 58, 7]],
      ED25519PublicKey: [32, [13, 15, 37, 217]],
      SECP256K1SecretKey: [32, [17, 162, 224, 201]],
      P256SecretKey: [32, [16, 81, 238, 189]],
      ED25519EncryptedSeed: [56, [7, 90, 60, 179, 41]],
      SECP256K1EncryptedSecretKey: [56, [9, 237, 241, 174, 150]],
      P256EncryptedSecretKey: [56, [9, 48, 57, 115, 171]],
      SECP256K1PublicKey: [33, [3, 254, 226, 86]],
      P256PublicKey: [33, [3, 178, 139, 127]],
      SECP256K1Scalar: [33, [38, 248, 136]],
      SECP256K1Element: [33, [5, 92, 0]],
      ED25519SecretKey: [64, [43, 246, 78, 7]],
      ED25519Signature: [64, [9, 245, 205, 134, 18]],
      SECP256K1Signature: [64, [13, 115, 101, 19, 63]],
      P256Signature: [64, [54, 240, 44, 52]],
      GenericSignature: [64, [4, 130, 43]],
      ChainID: [4, [87, 82, 0]],
      RollupAddress: [20, [1, 128, 120, 31]],
      TxRollupL2Address: [20, [6, 161, 166]],
  };
  function checkDecodeTezosID(id, ...types) {
      const buf = decodeBase58Check(id);
      for (const t of types) {
          const [plen, p] = tezosPrefix[t];
          if (buf.length === plen + p.length) {
              let i = 0;
              while (i < p.length && buf[i] === p[i]) {
                  i++;
              }
              if (i === p.length) {
                  return [t, buf.slice(p.length)];
              }
          }
      }
      return null;
  }
  function encodeTezosID(id, data) {
      const [plen, p] = tezosPrefix[id];
      if (data.length !== plen) {
          throw new TezosIdEncodeError(`Incorrect data length for ${id}: ${data.length}`);
      }
      return encodeBase58Check([...p, ...data]);
  }
  function unpackComb(id, v) {
      const vv = v;
      const args = Array.isArray(vv) ? vv : vv.args;
      if (args.length === 2) {
          // it's a way to make a union of two interfaces not an interface with two independent properties of union types
          const ret = id === 'pair'
              ? {
                  prim: 'pair',
                  args,
              }
              : {
                  prim: 'Pair',
                  args,
              };
          return ret;
      }
      return Object.assign(Object.assign({}, (Array.isArray(vv) ? { prim: id } : vv)), { args: [
              args[0],
              {
                  prim: id,
                  args: args.slice(1),
              },
          ] });
  }
  function isPairType(t) {
      return Array.isArray(t) || t.prim === 'pair';
  }
  function isPairData(d) {
      return Array.isArray(d) || ('prim' in d && d.prim === 'Pair');
  }
  const rfc3339Re = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])[T ]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|[+-]([01][0-9]|2[0-3]):([0-5][0-9]))$/;
  function parseDate(a) {
      if ('string' in a) {
          if (isNatural(a.string)) {
              return new Date(parseInt(a.string, 10));
          }
          else if (rfc3339Re.test(a.string)) {
              const x = new Date(a.string);
              if (!Number.isNaN(x.valueOf)) {
                  return x;
              }
          }
      }
      else if (isDecimal(a.int)) {
          return new Date(parseInt(a.int, 10));
      }
      return null;
  }
  function parseHex(s) {
      const res = [];
      for (let i = 0; i < s.length; i += 2) {
          const ss = s.slice(i, i + 2);
          const x = parseInt(ss, 16);
          if (Number.isNaN(x)) {
              throw new HexParseError(ss);
          }
          res.push(x);
      }
      return res;
  }
  function hexBytes(bytes) {
      return bytes.map((x) => ((x >> 4) & 0xf).toString(16) + (x & 0xf).toString(16)).join('');
  }

  // Michelson validator
  const maxViewNameLength = 31;
  const noArgInstructionIDs = {
      ABS: true,
      ADD: true,
      ADDRESS: true,
      AMOUNT: true,
      AND: true,
      APPLY: true,
      BALANCE: true,
      BLAKE2B: true,
      CAR: true,
      CDR: true,
      CHAIN_ID: true,
      CHECK_SIGNATURE: true,
      COMPARE: true,
      CONCAT: true,
      CONS: true,
      EDIV: true,
      EQ: true,
      EXEC: true,
      FAILWITH: true,
      GE: true,
      GET_AND_UPDATE: true,
      GT: true,
      HASH_KEY: true,
      IMPLICIT_ACCOUNT: true,
      INT: true,
      ISNAT: true,
      JOIN_TICKETS: true,
      KECCAK: true,
      LE: true,
      LEVEL: true,
      LSL: true,
      LSR: true,
      LT: true,
      MEM: true,
      MUL: true,
      NEG: true,
      NEQ: true,
      NEVER: true,
      NOT: true,
      NOW: true,
      OR: true,
      PACK: true,
      PAIRING_CHECK: true,
      READ_TICKET: true,
      SAPLING_VERIFY_UPDATE: true,
      SELF: true,
      SELF_ADDRESS: true,
      SENDER: true,
      SET_DELEGATE: true,
      SHA256: true,
      SHA3: true,
      SHA512: true,
      SIZE: true,
      SLICE: true,
      SOME: true,
      SOURCE: true,
      SPLIT_TICKET: true,
      SUB: true,
      SWAP: true,
      TICKET: true,
      TICKET_DEPRECATED: true,
      TOTAL_VOTING_POWER: true,
      TRANSFER_TOKENS: true,
      UNIT: true,
      VOTING_POWER: true,
      XOR: true,
      RENAME: true,
      OPEN_CHEST: true,
      SUB_MUTEZ: true,
      MIN_BLOCK_TIME: true,
  };
  const instructionIDs = Object.assign({}, noArgInstructionIDs, {
      CONTRACT: true,
      CREATE_CONTRACT: true,
      DIG: true,
      DIP: true,
      DROP: true,
      DUG: true,
      DUP: true,
      EMIT: true,
      EMPTY_BIG_MAP: true,
      EMPTY_MAP: true,
      EMPTY_SET: true,
      GET: true,
      IF: true,
      IF_CONS: true,
      IF_LEFT: true,
      IF_NONE: true,
      ITER: true,
      LAMBDA: true,
      LAMBDA_REC: true,
      LEFT: true,
      LOOP: true,
      LOOP_LEFT: true,
      MAP: true,
      NIL: true,
      NONE: true,
      PAIR: true,
      PUSH: true,
      RIGHT: true,
      SAPLING_EMPTY_STATE: true,
      UNPACK: true,
      UNPAIR: true,
      UPDATE: true,
      CAST: true,
      VIEW: true,
  });
  const simpleComparableTypeIDs = {
      unit: true,
      never: true,
      bool: true,
      int: true,
      nat: true,
      string: true,
      chain_id: true,
      bytes: true,
      mutez: true,
      key_hash: true,
      key: true,
      signature: true,
      timestamp: true,
      address: true,
      tx_rollup_l2_address: true,
  };
  const typeIDs = Object.assign({}, simpleComparableTypeIDs, {
      or: true,
      pair: true,
      set: true,
      big_map: true,
      contract: true,
      lambda: true,
      list: true,
      map: true,
      operation: true,
      option: true,
      bls12_381_g1: true,
      bls12_381_g2: true,
      bls12_381_fr: true,
      sapling_transaction: true,
      sapling_transaction_deprecated: true,
      sapling_state: true,
      ticket: true,
      chest_key: true,
      chest: true,
  });
  class MichelsonValidationError extends MichelsonError {
      /**
       * @param val Value of a node caused the error
       * @param message An error message
       */
      constructor(val, message) {
          super(val, message);
          this.val = val;
          Object.setPrototypeOf(this, MichelsonValidationError.prototype);
      }
  }
  function isPrim(ex) {
      return 'prim' in ex;
  }
  function isPrimOrSeq(ex) {
      return Array.isArray(ex) || 'prim' in ex;
  }
  function assertPrim(ex) {
      if (isPrim(ex)) {
          return true;
      }
      throw new MichelsonValidationError(ex, 'prim expression expected');
  }
  function assertSeq(ex) {
      if (Array.isArray(ex)) {
          return true;
      }
      throw new MichelsonValidationError(ex, 'sequence expression expected');
  }
  function assertPrimOrSeq(ex) {
      if (isPrimOrSeq(ex)) {
          return true;
      }
      throw new MichelsonValidationError(ex, 'prim or sequence expression expected');
  }
  function assertNatural(i) {
      if (i.int[0] === '-') {
          throw new MichelsonValidationError(i, 'natural number expected');
      }
  }
  function assertIntLiteral(ex) {
      if ('int' in ex) {
          return true;
      }
      throw new MichelsonValidationError(ex, 'int literal expected');
  }
  function assertStringLiteral(ex) {
      if ('string' in ex) {
          return true;
      }
      throw new MichelsonValidationError(ex, 'string literal expected');
  }
  function assertArgs(ex, n) {
      var _a;
      if ((n === 0 && ex.args === undefined) || ((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === n) {
          return true;
      }
      throw new MichelsonValidationError(ex, `${n} arguments expected`);
  }
  /**
   * Checks if the node is a valid Michelson code (sequence of instructions).
   * This is a type guard function which either returns true of throws an exception.
   * @param ex An AST node
   */
  function assertMichelsonInstruction(ex) {
      var _a, _b;
      if (Array.isArray(ex)) {
          for (const n of ex) {
              if (!Array.isArray(n) && !isPrim(n)) {
                  throw new MichelsonValidationError(ex, 'sequence or prim expected');
              }
              assertMichelsonInstruction(n);
          }
          return true;
      }
      if (assertPrim(ex)) {
          if (Object.prototype.hasOwnProperty.call(noArgInstructionIDs, ex.prim)) {
              assertArgs(ex, 0);
              return true;
          }
          switch (ex.prim) {
              case 'DROP':
              case 'PAIR':
              case 'UNPAIR':
              case 'DUP':
              case 'UPDATE':
              case 'GET':
                  if (ex.args !== undefined && assertArgs(ex, 1)) {
                      /* istanbul ignore else */
                      if (assertIntLiteral(ex.args[0])) {
                          assertNatural(ex.args[0]);
                      }
                  }
                  break;
              case 'DIG':
              case 'DUG':
              case 'SAPLING_EMPTY_STATE':
                  /* istanbul ignore else */
                  if (assertArgs(ex, 1)) {
                      /* istanbul ignore else */
                      if (assertIntLiteral(ex.args[0])) {
                          assertNatural(ex.args[0]);
                      }
                  }
                  break;
              case 'NONE':
              case 'LEFT':
              case 'RIGHT':
              case 'NIL':
              case 'CAST':
                  /* istanbul ignore else */
                  if (assertArgs(ex, 1)) {
                      assertMichelsonType(ex.args[0]);
                  }
                  break;
              case 'UNPACK':
                  /* istanbul ignore else */
                  if (assertArgs(ex, 1)) {
                      assertMichelsonPackableType(ex.args[0]);
                  }
                  break;
              case 'CONTRACT':
                  /* istanbul ignore else */
                  if (assertArgs(ex, 1)) {
                      assertMichelsonPassableType(ex.args[0]);
                  }
                  break;
              case 'IF_NONE':
              case 'IF_LEFT':
              case 'IF_CONS':
              case 'IF':
                  /* istanbul ignore else */
                  if (assertArgs(ex, 2)) {
                      /* istanbul ignore else */
                      if (assertSeq(ex.args[0])) {
                          assertMichelsonInstruction(ex.args[0]);
                      }
                      /* istanbul ignore else */
                      if (assertSeq(ex.args[1])) {
                          assertMichelsonInstruction(ex.args[1]);
                      }
                  }
                  break;
              case 'MAP':
              case 'ITER':
              case 'LOOP':
              case 'LOOP_LEFT':
                  /* istanbul ignore else */
                  if (assertArgs(ex, 1)) {
                      assertMichelsonInstruction(ex.args[0]);
                  }
                  break;
              case 'CREATE_CONTRACT':
                  /* istanbul ignore else */
                  if (assertArgs(ex, 1)) {
                      assertMichelsonContract(ex.args[0]);
                  }
                  break;
              case 'DIP':
                  if (((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === 2) {
                      /* istanbul ignore else */
                      if (assertIntLiteral(ex.args[0])) {
                          assertNatural(ex.args[0]);
                      }
                      /* istanbul ignore else */
                      if (assertSeq(ex.args[1])) {
                          assertMichelsonInstruction(ex.args[1]);
                      }
                  }
                  else if (((_b = ex.args) === null || _b === void 0 ? void 0 : _b.length) === 1) {
                      /* istanbul ignore else */
                      if (assertSeq(ex.args[0])) {
                          assertMichelsonInstruction(ex.args[0]);
                      }
                  }
                  else {
                      throw new MichelsonValidationError(ex, '1 or 2 arguments expected');
                  }
                  break;
              case 'PUSH':
                  /* istanbul ignore else */
                  if (assertArgs(ex, 2)) {
                      assertMichelsonPushableType(ex.args[0]);
                      assertMichelsonData(ex.args[1]);
                  }
                  break;
              case 'EMPTY_SET':
                  /* istanbul ignore else */
                  if (assertArgs(ex, 1)) {
                      assertMichelsonComparableType(ex.args[0]);
                  }
                  break;
              case 'EMPTY_MAP':
                  /* istanbul ignore else */
                  if (assertArgs(ex, 2)) {
                      assertMichelsonComparableType(ex.args[0]);
                      assertMichelsonType(ex.args[1]);
                  }
                  break;
              case 'EMPTY_BIG_MAP':
                  /* istanbul ignore else */
                  if (assertArgs(ex, 2)) {
                      assertMichelsonComparableType(ex.args[0]);
                      assertMichelsonBigMapStorableType(ex.args[1]);
                  }
                  break;
              case 'LAMBDA_REC':
              case 'LAMBDA':
                  /* istanbul ignore else */
                  if (assertArgs(ex, 3)) {
                      assertMichelsonType(ex.args[0]);
                      assertMichelsonType(ex.args[1]);
                      /* istanbul ignore else */
                      if (assertSeq(ex.args[2])) {
                          assertMichelsonInstruction(ex.args[2]);
                      }
                  }
                  break;
              case 'VIEW':
                  /* istanbul ignore else */
                  if (assertArgs(ex, 2)) {
                      if (assertStringLiteral(ex.args[0])) {
                          assertViewNameValid(ex.args[0]);
                      }
                      if (assertMichelsonType(ex.args[1])) {
                          assertMichelsonPushableType(ex.args[1]);
                      }
                  }
                  break;
              case 'EMIT':
                  if (ex.args && ex.args.length > 0) {
                      assertArgs(ex, 1);
                  }
                  else {
                      assertArgs(ex, 0);
                  }
                  break;
              default:
                  throw new MichelsonValidationError(ex, 'instruction expected');
          }
      }
      return true;
  }
  function assertMichelsonComparableType(ex) {
      /* istanbul ignore else */
      if (assertPrimOrSeq(ex)) {
          if (Array.isArray(ex) || ex.prim === 'pair' || ex.prim === 'or' || ex.prim === 'option') {
              traverseType(ex, (ex) => assertMichelsonComparableType(ex));
          }
          else if (!Object.prototype.hasOwnProperty.call(simpleComparableTypeIDs, ex.prim)) {
              throw new MichelsonValidationError(ex, `${ex.prim}: type is not comparable`);
          }
      }
      return true;
  }
  function assertMichelsonPackableType(ex) {
      /* istanbul ignore else */
      if (assertPrimOrSeq(ex)) {
          if (isPrim(ex)) {
              if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) ||
                  ex.prim === 'big_map' ||
                  ex.prim === 'operation' ||
                  ex.prim === 'sapling_state' ||
                  ex.prim === 'ticket') {
                  throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used inside PACK/UNPACK instructions`);
              }
              traverseType(ex, (ex) => assertMichelsonPackableType(ex));
          }
      }
      return true;
  }
  function assertMichelsonPushableType(ex) {
      /* istanbul ignore else */
      if (assertPrimOrSeq(ex)) {
          if (isPrim(ex)) {
              if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) ||
                  ex.prim === 'big_map' ||
                  ex.prim === 'operation' ||
                  ex.prim === 'sapling_state' ||
                  ex.prim === 'ticket' ||
                  ex.prim === 'contract') {
                  throw new MichelsonValidationError(ex, `${ex.prim}: type can't be pushed`);
              }
              traverseType(ex, (ex) => assertMichelsonPushableType(ex));
          }
      }
      return true;
  }
  function assertMichelsonStorableType(ex) {
      /* istanbul ignore else */
      if (assertPrimOrSeq(ex)) {
          if (isPrim(ex)) {
              if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) ||
                  ex.prim === 'operation' ||
                  ex.prim === 'contract') {
                  throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used as part of a storage`);
              }
              traverseType(ex, (ex) => assertMichelsonStorableType(ex));
          }
      }
      return true;
  }
  function assertMichelsonPassableType(ex) {
      /* istanbul ignore else */
      if (assertPrimOrSeq(ex)) {
          if (isPrim(ex)) {
              if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === 'operation') {
                  throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used as part of a parameter`);
              }
              traverseType(ex, (ex) => assertMichelsonPassableType(ex));
          }
      }
      return true;
  }
  function assertMichelsonBigMapStorableType(ex) {
      /* istanbul ignore else */
      if (assertPrimOrSeq(ex)) {
          if (isPrim(ex)) {
              if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) ||
                  ex.prim === 'big_map' ||
                  ex.prim === 'operation' ||
                  ex.prim === 'sapling_state') {
                  throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used inside a big_map`);
              }
              traverseType(ex, (ex) => assertMichelsonBigMapStorableType(ex));
          }
      }
      return true;
  }
  const viewRe = new RegExp('^[a-zA-Z0-9_.%@]*$');
  function assertViewNameValid(name) {
      if (name.string.length > maxViewNameLength) {
          throw new MichelsonValidationError(name, `view name too long: ${name.string}`);
      }
      if (!viewRe.test(name.string)) {
          throw new MichelsonValidationError(name, `invalid character(s) in view name: ${name.string}`);
      }
  }
  /**
   * Checks if the node is a valid Michelson type expression.
   * This is a type guard function which either returns true of throws an exception.
   * @param ex An AST node
   */
  function assertMichelsonType(ex) {
      /* istanbul ignore else */
      if (assertPrimOrSeq(ex)) {
          if (isPrim(ex)) {
              if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim)) {
                  throw new MichelsonValidationError(ex, 'type expected');
              }
              traverseType(ex, (ex) => assertMichelsonType(ex));
          }
      }
      return true;
  }
  function traverseType(ex, cb) {
      if (Array.isArray(ex) || ex.prim === 'pair') {
          const args = Array.isArray(ex) ? ex : ex.args;
          if (args === undefined || args.length < 2) {
              throw new MichelsonValidationError(ex, 'at least 2 arguments expected');
          }
          args.forEach((a) => {
              if (assertPrimOrSeq(a)) {
                  cb(a);
              }
          });
          return true;
      }
      switch (ex.prim) {
          case 'option':
          case 'list':
              /* istanbul ignore else */
              if (assertArgs(ex, 1) && assertPrimOrSeq(ex.args[0])) {
                  cb(ex.args[0]);
              }
              break;
          case 'contract':
              /* istanbul ignore else */
              if (assertArgs(ex, 1)) {
                  assertMichelsonPassableType(ex.args[0]);
              }
              break;
          case 'or':
              /* istanbul ignore else */
              if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {
                  cb(ex.args[0]);
                  cb(ex.args[1]);
              }
              break;
          case 'lambda':
              /* istanbul ignore else */
              if (assertArgs(ex, 2)) {
                  assertMichelsonType(ex.args[0]);
                  assertMichelsonType(ex.args[1]);
              }
              break;
          case 'set':
              /* istanbul ignore else */
              if (assertArgs(ex, 1)) {
                  assertMichelsonComparableType(ex.args[0]);
              }
              break;
          case 'map':
              /* istanbul ignore else */
              if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {
                  assertMichelsonComparableType(ex.args[0]);
                  cb(ex.args[1]);
              }
              break;
          case 'big_map':
              /* istanbul ignore else */
              if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {
                  assertMichelsonComparableType(ex.args[0]);
                  assertMichelsonBigMapStorableType(ex.args[1]);
                  cb(ex.args[1]);
              }
              break;
          case 'ticket':
              /* istanbul ignore else */
              if (assertArgs(ex, 1) && assertPrimOrSeq(ex.args[0])) {
                  assertMichelsonComparableType(ex.args[0]);
              }
              break;
          case 'sapling_state':
          case 'sapling_transaction':
              if (assertArgs(ex, 1)) {
                  assertIntLiteral(ex.args[0]);
              }
              break;
          default:
              assertArgs(ex, 0);
      }
      return true;
  }
  /**
   * Checks if the node is a valid Michelson data literal such as `(Pair {Elt "0" 0} 0)`.
   * This is a type guard function which either returns true of throws an exception.
   * @param ex An AST node
   */
  function assertMichelsonData(ex) {
      if ('int' in ex || 'string' in ex || 'bytes' in ex) {
          return true;
      }
      if (Array.isArray(ex)) {
          let mapElts = 0;
          for (const n of ex) {
              if (isPrim(n) && n.prim === 'Elt') {
                  /* istanbul ignore else */
                  if (assertArgs(n, 2)) {
                      assertMichelsonData(n.args[0]);
                      assertMichelsonData(n.args[1]);
                  }
                  mapElts++;
              }
              else {
                  assertMichelsonData(n);
              }
          }
          if (mapElts !== 0 && mapElts !== ex.length) {
              throw new MichelsonValidationError(ex, "data entries and map elements can't be intermixed");
          }
          return true;
      }
      if (isPrim(ex)) {
          switch (ex.prim) {
              case 'Unit':
              case 'True':
              case 'False':
              case 'None':
                  assertArgs(ex, 0);
                  break;
              case 'Pair':
                  /* istanbul ignore else */
                  if (ex.args === undefined || ex.args.length < 2) {
                      throw new MichelsonValidationError(ex, 'at least 2 arguments expected');
                  }
                  for (const a of ex.args) {
                      assertMichelsonData(a);
                  }
                  break;
              case 'Left':
              case 'Right':
              case 'Some':
                  /* istanbul ignore else */
                  if (assertArgs(ex, 1)) {
                      assertMichelsonData(ex.args[0]);
                  }
                  break;
              case 'Lambda_rec':
                  if (ex.args) {
                      assertMichelsonInstruction(ex.args);
                  }
                  break;
              default:
                  if (Object.prototype.hasOwnProperty.call(instructionIDs, ex.prim)) {
                      assertMichelsonInstruction(ex);
                  }
                  else {
                      throw new MichelsonValidationError(ex, 'data entry or instruction expected');
                  }
          }
      }
      else {
          throw new MichelsonValidationError(ex, 'data entry expected');
      }
      return true;
  }
  /**
   * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.
   * This is a type guard function which either returns true of throws an exception.
   * @param ex An AST node
   */
  function assertMichelsonContract(ex) {
      /* istanbul ignore else */
      if (assertSeq(ex)) {
          const toplevelSec = {};
          const views = {};
          for (const sec of ex) {
              if (assertPrim(sec)) {
                  if (sec.prim !== 'view') {
                      if (sec.prim in toplevelSec) {
                          throw new MichelsonValidationError(ex, `duplicate contract section: ${sec.prim}`);
                      }
                      toplevelSec[sec.prim] = true;
                  }
                  /* istanbul ignore else */
                  switch (sec.prim) {
                      case 'code':
                          if (assertArgs(sec, 1)) {
                              /* istanbul ignore else */
                              if (assertSeq(sec.args[0])) {
                                  assertMichelsonInstruction(sec.args[0]);
                              }
                          }
                          break;
                      case 'parameter':
                          if (assertArgs(sec, 1)) {
                              assertMichelsonPassableType(sec.args[0]);
                          }
                          if (sec.annots) {
                              throw new MichelsonValidationError(sec, 'Annotation must be part of the parameter type');
                          }
                          break;
                      case 'storage':
                          if (assertArgs(sec, 1)) {
                              assertMichelsonStorableType(sec.args[0]);
                          }
                          break;
                      case 'view':
                          if (assertArgs(sec, 4)) {
                              if (assertStringLiteral(sec.args[0])) {
                                  const name = sec.args[0];
                                  if (name.string in views) {
                                      throw new MichelsonValidationError(ex, `duplicate view name: ${name.string}`);
                                  }
                                  views[name.string] = true;
                                  assertViewNameValid(name);
                              }
                              assertMichelsonPushableType(sec.args[1]);
                              assertMichelsonPushableType(sec.args[2]);
                              if (assertSeq(sec.args[3])) {
                                  assertMichelsonInstruction(sec.args[3]);
                              }
                          }
                          break;
                      default:
                          throw new MichelsonValidationError(ex, `unexpected contract section: ${sec.prim}`);
                  }
              }
          }
      }
      return true;
  }
  /**
   * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.
   * @param ex An AST node
   */
  function isMichelsonScript(ex) {
      try {
          assertMichelsonContract(ex);
          return true;
      }
      catch (_a) {
          return false;
      }
  }
  /**
   * Checks if the node is a valid Michelson data literal such as `(Pair {Elt "0" 0} 0)`.
   * @param ex An AST node
   */
  function isMichelsonData(ex) {
      try {
          assertMichelsonData(ex);
          return true;
      }
      catch (_a) {
          return false;
      }
  }
  /**
   * Checks if the node is a valid Michelson code (sequence of instructions).
   * @param ex An AST node
   */
  function isMichelsonCode(ex) {
      try {
          assertMichelsonInstruction(ex);
          return true;
      }
      catch (_a) {
          return false;
      }
  }
  /**
   * Checks if the node is a valid Michelson type expression.
   * @param ex An AST node
   */
  function isMichelsonType(ex) {
      try {
          assertMichelsonType(ex);
          return true;
      }
      catch (_a) {
          return false;
      }
  }
  function isInstruction(p) {
      return Object.prototype.hasOwnProperty.call(instructionIDs, p.prim);
  }
  function assertDataListIfAny(d) {
      if (!Array.isArray(d)) {
          return false;
      }
      for (const v of d) {
          if ('prim' in v) {
              if (isInstruction(v)) {
                  throw new MichelsonError(d, `Instruction outside of a lambda: ${JSON.stringify(d)}`);
              }
              else if (v.prim === 'Elt') {
                  throw new MichelsonError(d, `Elt item outside of a map literal: ${JSON.stringify(d)}`);
              }
          }
      }
      return true;
  }

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  function __rest(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                  t[p[i]] = s[p[i]];
          }
      return t;
  }

  // The order is important!
  // The position represent the encoding value.
  const primitives = [
      'parameter',
      'storage',
      'code',
      'False',
      'Elt',
      'Left',
      'None',
      'Pair',
      'Right',
      'Some',
      'True',
      'Unit',
      'PACK',
      'UNPACK',
      'BLAKE2B',
      'SHA256',
      'SHA512',
      'ABS',
      'ADD',
      'AMOUNT',
      'AND',
      'BALANCE',
      'CAR',
      'CDR',
      'CHECK_SIGNATURE',
      'COMPARE',
      'CONCAT',
      'CONS',
      'CREATE_ACCOUNT',
      'CREATE_CONTRACT',
      'IMPLICIT_ACCOUNT',
      'DIP',
      'DROP',
      'DUP',
      'EDIV',
      'EMPTY_MAP',
      'EMPTY_SET',
      'EQ',
      'EXEC',
      'FAILWITH',
      'GE',
      'GET',
      'GT',
      'HASH_KEY',
      'IF',
      'IF_CONS',
      'IF_LEFT',
      'IF_NONE',
      'INT',
      'LAMBDA',
      'LE',
      'LEFT',
      'LOOP',
      'LSL',
      'LSR',
      'LT',
      'MAP',
      'MEM',
      'MUL',
      'NEG',
      'NEQ',
      'NIL',
      'NONE',
      'NOT',
      'NOW',
      'OR',
      'PAIR',
      'PUSH',
      'RIGHT',
      'SIZE',
      'SOME',
      'SOURCE',
      'SENDER',
      'SELF',
      'STEPS_TO_QUOTA',
      'SUB',
      'SWAP',
      'TRANSFER_TOKENS',
      'SET_DELEGATE',
      'UNIT',
      'UPDATE',
      'XOR',
      'ITER',
      'LOOP_LEFT',
      'ADDRESS',
      'CONTRACT',
      'ISNAT',
      'CAST',
      'RENAME',
      'bool',
      'contract',
      'int',
      'key',
      'key_hash',
      'lambda',
      'list',
      'map',
      'big_map',
      'nat',
      'option',
      'or',
      'pair',
      'set',
      'signature',
      'string',
      'bytes',
      'mutez',
      'timestamp',
      'unit',
      'operation',
      'address',
      'SLICE',
      'DIG',
      'DUG',
      'EMPTY_BIG_MAP',
      'APPLY',
      'chain_id',
      'CHAIN_ID',
      'LEVEL',
      'SELF_ADDRESS',
      'never',
      'NEVER',
      'UNPAIR',
      'VOTING_POWER',
      'TOTAL_VOTING_POWER',
      'KECCAK',
      'SHA3',
      'PAIRING_CHECK',
      'bls12_381_g1',
      'bls12_381_g2',
      'bls12_381_fr',
      'sapling_state',
      'sapling_transaction_deprecated',
      'SAPLING_EMPTY_STATE',
      'SAPLING_VERIFY_UPDATE',
      'ticket',
      'TICKET_DEPRECATED',
      'READ_TICKET',
      'SPLIT_TICKET',
      'JOIN_TICKETS',
      'GET_AND_UPDATE',
      'chest',
      'chest_key',
      'OPEN_CHEST',
      'VIEW',
      'view',
      'constant',
      'SUB_MUTEZ',
      'tx_rollup_l2_address',
      'MIN_BLOCK_TIME',
      'sapling_transaction',
      'EMIT',
      'Lambda_rec',
      'LAMBDA_REC',
      'TICKET',
  ];
  const primTags = Object.assign({}, ...primitives.map((v, i) => ({ [v]: i })));
  var Tag;
  (function (Tag) {
      Tag[Tag["Int"] = 0] = "Int";
      Tag[Tag["String"] = 1] = "String";
      Tag[Tag["Sequence"] = 2] = "Sequence";
      Tag[Tag["Prim0"] = 3] = "Prim0";
      Tag[Tag["Prim0Annot"] = 4] = "Prim0Annot";
      Tag[Tag["Prim1"] = 5] = "Prim1";
      Tag[Tag["Prim1Annot"] = 6] = "Prim1Annot";
      Tag[Tag["Prim2"] = 7] = "Prim2";
      Tag[Tag["Prim2Annot"] = 8] = "Prim2Annot";
      Tag[Tag["Prim"] = 9] = "Prim";
      Tag[Tag["Bytes"] = 10] = "Bytes";
  })(Tag || (Tag = {}));
  class Writer {
      constructor() {
          this.buffer = [];
      }
      get length() {
          return this.buffer.length;
      }
      writeBytes(val) {
          this.buffer.push(...val.map((v) => v & 0xff));
      }
      writeUint8(val) {
          const v = val | 0;
          this.buffer.push(v & 0xff);
      }
      writeUint16(val) {
          const v = val | 0;
          this.buffer.push((v >> 8) & 0xff);
          this.buffer.push(v & 0xff);
      }
      writeUint32(val) {
          const v = val | 0;
          this.buffer.push((v >> 24) & 0xff);
          this.buffer.push((v >> 16) & 0xff);
          this.buffer.push((v >> 8) & 0xff);
          this.buffer.push(v & 0xff);
      }
      writeInt8(val) {
          this.writeUint8(val);
      }
      writeInt16(val) {
          this.writeUint16(val);
      }
      writeInt32(val) {
          this.writeUint32(val);
      }
  }
  const boundsErr = new Error('bounds out of range');
  class Reader {
      constructor(buffer, idx = 0, cap = buffer.length) {
          this.buffer = buffer;
          this.idx = idx;
          this.cap = cap;
      }
      /** Remaining length */
      get length() {
          return this.cap - this.idx;
      }
      readBytes(len) {
          if (this.cap - this.idx < len) {
              throw boundsErr;
          }
          const ret = this.buffer.slice(this.idx, this.idx + len);
          this.idx += len;
          return ret;
      }
      reader(len) {
          if (this.cap - this.idx < len) {
              throw boundsErr;
          }
          const ret = new Reader(this.buffer, this.idx, this.idx + len);
          this.idx += len;
          return ret;
      }
      copy() {
          return new Reader(this.buffer, this.idx, this.cap);
      }
      readUint8() {
          if (this.cap - this.idx < 1) {
              throw boundsErr;
          }
          return this.buffer[this.idx++] >>> 0;
      }
      readUint16() {
          if (this.cap - this.idx < 2) {
              throw boundsErr;
          }
          const x0 = this.buffer[this.idx++];
          const x1 = this.buffer[this.idx++];
          return ((x0 << 8) | x1) >>> 0;
      }
      readUint32() {
          if (this.cap - this.idx < 4) {
              throw boundsErr;
          }
          const x0 = this.buffer[this.idx++];
          const x1 = this.buffer[this.idx++];
          const x2 = this.buffer[this.idx++];
          const x3 = this.buffer[this.idx++];
          return ((x0 << 24) | (x1 << 16) | (x2 << 8) | x3) >>> 0;
      }
      readInt8() {
          if (this.cap - this.idx < 1) {
              throw boundsErr;
          }
          const x = this.buffer[this.idx++];
          return (x << 24) >> 24;
      }
      readInt16() {
          if (this.cap - this.idx < 2) {
              throw boundsErr;
          }
          const x0 = this.buffer[this.idx++];
          const x1 = this.buffer[this.idx++];
          return (((x0 << 8) | x1) << 16) >> 16;
      }
      readInt32() {
          if (this.cap - this.idx < 4) {
              throw boundsErr;
          }
          const x0 = this.buffer[this.idx++];
          const x1 = this.buffer[this.idx++];
          const x2 = this.buffer[this.idx++];
          const x3 = this.buffer[this.idx++];
          return (x0 << 24) | (x1 << 16) | (x2 << 8) | x3;
      }
  }
  var ContractID;
  (function (ContractID) {
      ContractID[ContractID["Implicit"] = 0] = "Implicit";
      ContractID[ContractID["Originated"] = 1] = "Originated";
  })(ContractID || (ContractID = {}));
  var PublicKeyHashID;
  (function (PublicKeyHashID) {
      PublicKeyHashID[PublicKeyHashID["ED25519"] = 0] = "ED25519";
      PublicKeyHashID[PublicKeyHashID["SECP256K1"] = 1] = "SECP256K1";
      PublicKeyHashID[PublicKeyHashID["P256"] = 2] = "P256";
  })(PublicKeyHashID || (PublicKeyHashID = {}));
  function readPublicKeyHash(rd) {
      let type;
      const tag = rd.readUint8();
      switch (tag) {
          case PublicKeyHashID.ED25519:
              type = 'ED25519PublicKeyHash';
              break;
          case PublicKeyHashID.SECP256K1:
              type = 'SECP256K1PublicKeyHash';
              break;
          case PublicKeyHashID.P256:
              type = 'P256PublicKeyHash';
              break;
          default:
              throw new Error(`unknown public key hash tag: ${tag}`);
      }
      return { type, hash: rd.readBytes(20) };
  }
  function readAddress(rd) {
      let address;
      const tag = rd.readUint8();
      switch (tag) {
          case ContractID.Implicit:
              address = readPublicKeyHash(rd);
              break;
          case ContractID.Originated:
              address = {
                  type: 'ContractHash',
                  hash: rd.readBytes(20),
              };
              rd.readBytes(1);
              break;
          default:
              throw new Error(`unknown address tag: ${tag}`);
      }
      if (rd.length !== 0) {
          // entry point
          const dec = new TextDecoder();
          address.entryPoint = dec.decode(new Uint8Array(rd.readBytes(rd.length)));
      }
      return address;
  }
  function writePublicKeyHash(a, w) {
      let tag;
      switch (a.type) {
          case 'ED25519PublicKeyHash':
              tag = PublicKeyHashID.ED25519;
              break;
          case 'SECP256K1PublicKeyHash':
              tag = PublicKeyHashID.SECP256K1;
              break;
          case 'P256PublicKeyHash':
              tag = PublicKeyHashID.P256;
              break;
          default:
              throw new Error(`unexpected address type: ${a.type}`);
      }
      w.writeUint8(tag);
      w.writeBytes(Array.from(a.hash));
  }
  function writeAddress(a, w) {
      if (a.type === 'ContractHash') {
          w.writeUint8(ContractID.Originated);
          w.writeBytes(Array.from(a.hash));
          w.writeUint8(0);
      }
      else {
          w.writeUint8(ContractID.Implicit);
          writePublicKeyHash(a, w);
      }
      if (a.entryPoint !== undefined && a.entryPoint !== '' && a.entryPoint !== 'default') {
          const enc = new TextEncoder();
          const bytes = enc.encode(a.entryPoint);
          w.writeBytes(Array.from(bytes));
      }
  }
  var PublicKeyID;
  (function (PublicKeyID) {
      PublicKeyID[PublicKeyID["ED25519"] = 0] = "ED25519";
      PublicKeyID[PublicKeyID["SECP256K1"] = 1] = "SECP256K1";
      PublicKeyID[PublicKeyID["P256"] = 2] = "P256";
  })(PublicKeyID || (PublicKeyID = {}));
  function readPublicKey(rd) {
      let ln;
      let type;
      const tag = rd.readUint8();
      switch (tag) {
          case PublicKeyID.ED25519:
              type = 'ED25519PublicKey';
              ln = 32;
              break;
          case PublicKeyID.SECP256K1:
              type = 'SECP256K1PublicKey';
              ln = 33;
              break;
          case PublicKeyID.P256:
              type = 'P256PublicKey';
              ln = 33;
              break;
          default:
              throw new Error(`unknown public key tag: ${tag}`);
      }
      return { type, publicKey: rd.readBytes(ln) };
  }
  function writePublicKey(pk, w) {
      let tag;
      switch (pk.type) {
          case 'ED25519PublicKey':
              tag = PublicKeyID.ED25519;
              break;
          case 'SECP256K1PublicKey':
              tag = PublicKeyID.SECP256K1;
              break;
          case 'P256PublicKey':
              tag = PublicKeyID.P256;
              break;
          default:
              throw new Error(`unexpected public key type: ${pk.type}`);
      }
      w.writeUint8(tag);
      w.writeBytes(Array.from(pk.publicKey));
  }
  function writeExpr(expr, wr, tf) {
      var _a, _b;
      const [e, args] = tf(expr);
      if (Array.isArray(e)) {
          const w = new Writer();
          for (const v of e) {
              const a = args.next();
              if (a.done) {
                  throw new Error('REPORT ME: iterator is done');
              }
              writeExpr(v, w, a.value);
          }
          wr.writeUint8(Tag.Sequence);
          wr.writeUint32(w.length);
          wr.writeBytes(w.buffer);
          return;
      }
      if ('string' in e) {
          const enc = new TextEncoder();
          const bytes = enc.encode(e.string);
          wr.writeUint8(Tag.String);
          wr.writeUint32(bytes.length);
          wr.writeBytes(Array.from(bytes));
          return;
      }
      if ('int' in e) {
          wr.writeUint8(Tag.Int);
          let val = BigInt(e.int);
          const sign = val < 0;
          if (sign) {
              val = -val;
          }
          let i = 0;
          do {
              const bits = i === 0 ? BigInt(6) : BigInt(7);
              let byte = val & ((BigInt(1) << bits) - BigInt(1));
              val >>= bits;
              if (val) {
                  byte |= BigInt(0x80);
              }
              if (i === 0 && sign) {
                  byte |= BigInt(0x40);
              }
              wr.writeUint8(Number(byte));
              i++;
          } while (val);
          return;
      }
      if ('bytes' in e) {
          const bytes = parseHex(e.bytes);
          wr.writeUint8(Tag.Bytes);
          wr.writeUint32(bytes.length);
          wr.writeBytes(bytes);
          return;
      }
      const prim = primTags[e.prim];
      if (prim === undefined) {
          throw new TypeError(`Can't encode primary: ${e.prim}`);
      }
      const tag = (((_a = e.args) === null || _a === void 0 ? void 0 : _a.length) || 0) < 3
          ? Tag.Prim0 +
              (((_b = e.args) === null || _b === void 0 ? void 0 : _b.length) || 0) * 2 +
              (e.annots === undefined || e.annots.length === 0 ? 0 : 1)
          : Tag.Prim;
      wr.writeUint8(tag);
      wr.writeUint8(prim);
      if (e.args !== undefined) {
          if (e.args.length < 3) {
              for (const v of e.args) {
                  const a = args.next();
                  if (a.done) {
                      throw new Error('REPORT ME: iterator is done');
                  }
                  writeExpr(v, wr, a.value);
              }
          }
          else {
              const w = new Writer();
              for (const v of e.args) {
                  const a = args.next();
                  if (a.done) {
                      throw new Error('REPORT ME: iterator is done');
                  }
                  writeExpr(v, w, a.value);
              }
              wr.writeUint32(w.length);
              wr.writeBytes(w.buffer);
          }
      }
      if (e.annots !== undefined && e.annots.length !== 0) {
          const enc = new TextEncoder();
          const bytes = enc.encode(e.annots.join(' '));
          wr.writeUint32(bytes.length);
          wr.writeBytes(Array.from(bytes));
      }
      else if (e.args !== undefined && e.args.length >= 3) {
          wr.writeUint32(0);
      }
  }
  function readExpr(rd, tf) {
      function* passThrough() {
          while (true) {
              yield readPassThrough;
          }
      }
      const [args, tr] = tf;
      const tag = rd.readUint8();
      switch (tag) {
          case Tag.Int: {
              const buf = [];
              let byte;
              do {
                  byte = rd.readInt8();
                  buf.push(byte);
              } while ((byte & 0x80) !== 0);
              let val = BigInt(0);
              let sign = false;
              for (let i = buf.length - 1; i >= 0; i--) {
                  const bits = i === 0 ? BigInt(6) : BigInt(7);
                  const byte = BigInt(buf[i]);
                  val <<= bits;
                  val |= byte & ((BigInt(1) << bits) - BigInt(1));
                  if (i === 0) {
                      sign = !!(byte & BigInt(0x40));
                  }
              }
              if (sign) {
                  val = -val;
              }
              return tr({ int: String(val) });
          }
          case Tag.String: {
              const length = rd.readUint32();
              const bytes = rd.readBytes(length);
              const dec = new TextDecoder();
              return tr({ string: dec.decode(new Uint8Array(bytes)) });
          }
          case Tag.Bytes: {
              const length = rd.readUint32();
              const bytes = rd.readBytes(length);
              const hex = hexBytes(Array.from(bytes));
              return tr({ bytes: hex });
          }
          case Tag.Sequence: {
              const length = rd.readUint32();
              let res = [];
              let savedrd = rd.copy();
              // make two passes
              let it = passThrough();
              for (let n = 0; n < 2; n++) {
                  const r = savedrd.reader(length);
                  res = [];
                  while (r.length > 0) {
                      const a = it.next();
                      if (a.done) {
                          throw new Error('REPORT ME: iterator is done');
                      }
                      res.push(readExpr(r, a.value));
                  }
                  // make a second pass with injected side effects
                  it = args(res);
                  savedrd = rd;
              }
              return tr(res);
          }
          default: {
              if (tag > 9) {
                  throw new Error(`Unknown tag: ${tag}`);
              }
              const p = rd.readUint8();
              if (p >= primitives.length) {
                  throw new Error(`Unknown primitive tag: ${p}`);
              }
              const prim = primitives[p];
              const argn = (tag - 3) >> 1;
              let res = { prim };
              // make two passes
              let it = passThrough();
              let savedrd = rd.copy();
              for (let n = 0; n < 2; n++) {
                  res = { prim };
                  if (argn < 3) {
                      for (let i = 0; i < argn; i++) {
                          const a = it.next();
                          if (a.done) {
                              throw new Error('REPORT ME: iterator is done');
                          }
                          res.args = res.args || [];
                          res.args.push(readExpr(savedrd, a.value));
                      }
                  }
                  else {
                      res.args = res.args || [];
                      const length = savedrd.readUint32();
                      const r = savedrd.reader(length);
                      while (r.length > 0) {
                          const a = it.next();
                          if (a.done) {
                              throw new Error('REPORT ME: iterator is done');
                          }
                          res.args.push(readExpr(r, a.value));
                      }
                  }
                  // make a second pass with injected side effects
                  it = args(res);
                  savedrd = rd;
              }
              if (((tag - 3) & 1) === 1 || argn === 3) {
                  // read annotations
                  const length = rd.readUint32();
                  if (length !== 0) {
                      const bytes = rd.readBytes(length);
                      const dec = new TextDecoder();
                      res.annots = dec.decode(new Uint8Array(bytes)).split(' ');
                  }
              }
              return tr(res);
          }
      }
  }
  const isOrData = (e) => 'prim' in e && (e.prim === 'Left' || e.prim === 'Right');
  const isOptionData = (e) => 'prim' in e && (e.prim === 'Some' || e.prim === 'None');
  const getWriteTransformFunc = (t) => {
      if (isPairType(t)) {
          return (d) => {
              if (!isPairData(d)) {
                  throw new MichelsonTypeError(t, d, `pair expected: ${JSON.stringify(d)}`);
              }
              assertDataListIfAny(d);
              // combs aren't used in pack format
              const tc = unpackComb('pair', t);
              const dc = unpackComb('Pair', d);
              return [
                  dc,
                  (function* () {
                      for (const a of tc.args) {
                          yield getWriteTransformFunc(a);
                      }
                  })(),
              ];
          };
      }
      switch (t.prim) {
          case 'or':
              return (d) => {
                  if (!isOrData(d)) {
                      throw new MichelsonTypeError(t, d, `or expected: ${JSON.stringify(d)}`);
                  }
                  return [
                      d,
                      (function* () {
                          yield getWriteTransformFunc(t.args[d.prim === 'Left' ? 0 : 1]);
                      })(),
                  ];
              };
          case 'option':
              return (d) => {
                  if (!isOptionData(d)) {
                      throw new MichelsonTypeError(t, d, `option expected: ${JSON.stringify(d)}`);
                  }
                  return [
                      d,
                      (function* () {
                          const dd = d;
                          if (dd.prim === 'Some') {
                              yield getWriteTransformFunc(t.args[0]);
                          }
                      })(),
                  ];
              };
          case 'list':
          case 'set':
              return (d) => {
                  if (!Array.isArray(d)) {
                      throw new MichelsonTypeError(t, d, `${t.prim} expected: ${JSON.stringify(d)}`);
                  }
                  return [
                      d,
                      (function* () {
                          for (const _v of d) {
                              yield getWriteTransformFunc(t.args[0]);
                          }
                      })(),
                  ];
              };
          case 'map':
              return (d) => {
                  if (!Array.isArray(d)) {
                      throw new MichelsonTypeError(t, d, `map expected: ${JSON.stringify(d)}`);
                  }
                  return [
                      d,
                      (function* () {
                          for (const _elt of d) {
                              yield (elt) => {
                                  if (!('prim' in elt) || elt.prim !== 'Elt') {
                                      throw new MichelsonTypeError(t, elt, `map element expected: ${JSON.stringify(elt)}`);
                                  }
                                  return [
                                      elt,
                                      (function* () {
                                          for (const a of t.args) {
                                              yield getWriteTransformFunc(a);
                                          }
                                      })(),
                                  ];
                              };
                          }
                      })(),
                  ];
              };
          case 'chain_id':
              return (d) => {
                  if (!('bytes' in d) && !('string' in d)) {
                      throw new MichelsonTypeError(t, d, `chain id expected: ${JSON.stringify(d)}`);
                  }
                  let bytes;
                  if ('string' in d) {
                      const id = checkDecodeTezosID(d.string, 'ChainID');
                      if (id === null) {
                          throw new MichelsonTypeError(t, d, `chain id base58 expected: ${d.string}`);
                      }
                      bytes = { bytes: hexBytes(id[1]) };
                  }
                  else {
                      bytes = d;
                  }
                  return [bytes, [][Symbol.iterator]()];
              };
          case 'signature':
              return (d) => {
                  if (!('bytes' in d) && !('string' in d)) {
                      throw new MichelsonTypeError(t, d, `signature expected: ${JSON.stringify(d)}`);
                  }
                  let bytes;
                  if ('string' in d) {
                      const sig = checkDecodeTezosID(d.string, 'ED25519Signature', 'SECP256K1Signature', 'P256Signature', 'GenericSignature');
                      if (sig === null) {
                          throw new MichelsonTypeError(t, d, `signature base58 expected: ${d.string}`);
                      }
                      bytes = { bytes: hexBytes(sig[1]) };
                  }
                  else {
                      bytes = d;
                  }
                  return [bytes, [][Symbol.iterator]()];
              };
          case 'key_hash':
              return (d) => {
                  if (!('bytes' in d) && !('string' in d)) {
                      throw new MichelsonTypeError(t, d, `key hash expected: ${JSON.stringify(d)}`);
                  }
                  let bytes;
                  if ('string' in d) {
                      const pkh = checkDecodeTezosID(d.string, 'ED25519PublicKeyHash', 'SECP256K1PublicKeyHash', 'P256PublicKeyHash');
                      if (pkh === null) {
                          throw new MichelsonTypeError(t, d, `key hash base58 expected: ${d.string}`);
                      }
                      const w = new Writer();
                      writePublicKeyHash({ type: pkh[0], hash: pkh[1] }, w);
                      bytes = { bytes: hexBytes(w.buffer) };
                  }
                  else {
                      bytes = d;
                  }
                  return [bytes, [][Symbol.iterator]()];
              };
          case 'key':
              return (d) => {
                  if (!('bytes' in d) && !('string' in d)) {
                      throw new MichelsonTypeError(t, d, `public key expected: ${JSON.stringify(d)}`);
                  }
                  let bytes;
                  if ('string' in d) {
                      const key = checkDecodeTezosID(d.string, 'ED25519PublicKey', 'SECP256K1PublicKey', 'P256PublicKey');
                      if (key === null) {
                          throw new MichelsonTypeError(t, d, `public key base58 expected: ${d.string}`);
                      }
                      const w = new Writer();
                      writePublicKey({ type: key[0], publicKey: key[1] }, w);
                      bytes = { bytes: hexBytes(w.buffer) };
                  }
                  else {
                      bytes = d;
                  }
                  return [bytes, [][Symbol.iterator]()];
              };
          case 'address':
              return (d) => {
                  if (!('bytes' in d) && !('string' in d)) {
                      throw new MichelsonTypeError(t, d, `address expected: ${JSON.stringify(d)}`);
                  }
                  let bytes;
                  if ('string' in d) {
                      const s = d.string.split('%');
                      const address = checkDecodeTezosID(s[0], 'ED25519PublicKeyHash', 'SECP256K1PublicKeyHash', 'P256PublicKeyHash', 'ContractHash');
                      if (address === null) {
                          throw new MichelsonTypeError(t, d, `address base58 expected: ${d.string}`);
                      }
                      const w = new Writer();
                      writeAddress({ type: address[0], hash: address[1], entryPoint: s.length > 1 ? s[1] : undefined }, w);
                      bytes = { bytes: hexBytes(w.buffer) };
                  }
                  else {
                      bytes = d;
                  }
                  return [bytes, [][Symbol.iterator]()];
              };
          case 'timestamp':
              return (d) => {
                  if (!('string' in d) && !('int' in d)) {
                      throw new MichelsonTypeError(t, d, `timestamp expected: ${JSON.stringify(d)}`);
                  }
                  let int;
                  if ('string' in d) {
                      const p = parseDate(d);
                      if (p === null) {
                          throw new MichelsonTypeError(t, d, `can't parse date: ${d.string}`);
                      }
                      int = { int: String(Math.floor(p.getTime() / 1000)) };
                  }
                  else {
                      int = d;
                  }
                  return [int, [][Symbol.iterator]()];
              };
          default:
              return writePassThrough;
      }
  };
  const isPushInstruction = (e) => 'prim' in e && e.prim === 'PUSH';
  const writePassThrough = (e) => {
      if (isPushInstruction(e)) {
          assertMichelsonInstruction(e);
          // capture inlined type definition
          return [
              e,
              (function* () {
                  yield writePassThrough;
                  yield getWriteTransformFunc(e.args[0]);
              })(),
          ];
      }
      return [
          e,
          (function* () {
              while (true) {
                  yield writePassThrough;
              }
          })(),
      ];
  };
  /**
   * Serializes any value of packable type to its optimized binary representation
   * identical to the one used by PACK and UNPACK Michelson instructions.
   * Without a type definition (not recommended) the data will be encoded as a binary form of a generic Michelson expression.
   * Type definition allows some types like `timestamp` and `address` and other base58 representable types to be encoded to
   * corresponding optimized binary forms borrowed from the Tezos protocol
   *
   * ```typescript
   * const data: MichelsonData = {
   *     string: "KT1RvkwF4F7pz1gCoxkyZrG1RkrxQy3gmFTv%foo"
   * };
   *
   * const typ: MichelsonType = {
   *     prim: "address"
   * };
   *
   * const packed = packData(data, typ);
   *
   * // 050a0000001901be41ee922ddd2cf33201e49d32da0afec571dce300666f6f
   * ```
   *
   * Without a type definition the base58 encoded address will be treated as a string
   * ```typescript
   * const data: MichelsonData = {
   *     string: "KT1RvkwF4F7pz1gCoxkyZrG1RkrxQy3gmFTv%foo"
   * };
   *
   * const packed = packData(data);
   *
   * // 0501000000284b543152766b7746344637707a3167436f786b795a724731526b7278517933676d46547625666f6f
   * ```
   * @param d Data object
   * @param t Optional type definition
   * @returns Binary representation as numeric array
   */
  function packData(d, t) {
      const w = new Writer();
      w.writeUint8(5);
      writeExpr(d, w, t !== undefined ? getWriteTransformFunc(t) : writePassThrough);
      return w.buffer;
  }
  /**
   * Serializes any value of packable type to its optimized binary representation
   * identical to the one used by PACK and UNPACK Michelson instructions.
   * Same as {@link packData} but returns a `bytes` Michelson data literal instead of an array
   *
   * ```typescript
   * const data: MichelsonData = {
   *     string: "2019-09-26T10:59:51Z"
   * };
   *
   * const typ: MichelsonType = {
   *     prim: "timestamp"
   * };
   *
   * const packed = packDataBytes(data, typ);
   *
   * // { bytes: "0500a7e8e4d80b" }
   * ```
   * @param d Data object
   * @param t Optional type definition
   * @returns Binary representation as a bytes literal
   */
  function packDataBytes(d, t) {
      return { bytes: hexBytes(packData(d, t)) };
  }
  const getReadTransformFuncs = (t) => {
      if (isPairType(t)) {
          return [
              (d) => {
                  if (!isPairData(d)) {
                      throw new MichelsonTypeError(t, d, `pair expected: ${JSON.stringify(d)}`);
                  }
                  const tc = unpackComb('pair', t);
                  return (function* () {
                      for (const a of tc.args) {
                          yield getReadTransformFuncs(a);
                      }
                  })();
              },
              (d) => d,
          ];
      }
      switch (t.prim) {
          case 'or':
              return [
                  (d) => {
                      if (!isOrData(d)) {
                          throw new MichelsonTypeError(t, d, `or expected: ${JSON.stringify(d)}`);
                      }
                      return (function* () {
                          yield getReadTransformFuncs(t.args[d.prim === 'Left' ? 0 : 1]);
                      })();
                  },
                  (d) => d,
              ];
          case 'option':
              return [
                  (d) => {
                      if (!isOptionData(d)) {
                          throw new MichelsonTypeError(t, d, `option expected: ${JSON.stringify(d)}`);
                      }
                      return (function* () {
                          if (d.prim === 'Some') {
                              yield getReadTransformFuncs(t.args[0]);
                          }
                      })();
                  },
                  (d) => d,
              ];
          case 'list':
          case 'set':
              return [
                  (d) => {
                      if (!Array.isArray(d)) {
                          throw new MichelsonTypeError(t, d, `${t.prim} expected: ${JSON.stringify(d)}`);
                      }
                      return (function* () {
                          while (true) {
                              yield getReadTransformFuncs(t.args[0]);
                          }
                      })();
                  },
                  (d) => d,
              ];
          case 'map':
              return [
                  (d) => {
                      if (!Array.isArray(d)) {
                          throw new MichelsonTypeError(t, d, `map expected: ${JSON.stringify(d)}`);
                      }
                      return (function* () {
                          while (true) {
                              yield [
                                  (elt) => {
                                      if (!('prim' in elt) || elt.prim !== 'Elt') {
                                          throw new MichelsonTypeError(t, elt, `map element expected: ${JSON.stringify(elt)}`);
                                      }
                                      return (function* () {
                                          for (const a of t.args) {
                                              yield getReadTransformFuncs(a);
                                          }
                                      })();
                                  },
                                  (elt) => elt,
                              ];
                          }
                      })();
                  },
                  (d) => d,
              ];
          case 'chain_id':
              return [
                  () => [][Symbol.iterator](),
                  (d) => {
                      if (!('bytes' in d) && !('string' in d)) {
                          throw new MichelsonTypeError(t, d, `chain id expected: ${JSON.stringify(d)}`);
                      }
                      if ('string' in d) {
                          return d;
                      }
                      const bytes = parseBytes(d.bytes);
                      if (bytes === null) {
                          throw new MichelsonTypeError(t, d, `can't parse bytes: ${d.bytes}`);
                      }
                      return { string: encodeTezosID('ChainID', bytes) };
                  },
              ];
          case 'signature':
              return [
                  () => [][Symbol.iterator](),
                  (d) => {
                      if (!('bytes' in d) && !('string' in d)) {
                          throw new MichelsonTypeError(t, d, `signature expected: ${JSON.stringify(d)}`);
                      }
                      if ('string' in d) {
                          return d;
                      }
                      const bytes = parseBytes(d.bytes);
                      if (bytes === null) {
                          throw new MichelsonTypeError(t, d, `can't parse bytes: ${d.bytes}`);
                      }
                      return { string: encodeTezosID('GenericSignature', bytes) };
                  },
              ];
          case 'key_hash':
              return [
                  () => [][Symbol.iterator](),
                  (d) => {
                      if (!('bytes' in d) && !('string' in d)) {
                          throw new MichelsonTypeError(t, d, `key hash expected: ${JSON.stringify(d)}`);
                      }
                      if ('string' in d) {
                          return d;
                      }
                      const bytes = parseBytes(d.bytes);
                      if (bytes === null) {
                          throw new MichelsonTypeError(t, d, `can't parse bytes: ${d.bytes}`);
                      }
                      const rd = new Reader(new Uint8Array(bytes));
                      const addr = readPublicKeyHash(rd);
                      return {
                          string: encodeTezosID(addr.type, addr.hash) + (addr.entryPoint ? '%' + addr.entryPoint : ''),
                      };
                  },
              ];
          case 'key':
              return [
                  () => [][Symbol.iterator](),
                  (d) => {
                      if (!('bytes' in d) && !('string' in d)) {
                          throw new MichelsonTypeError(t, d, `public key expected: ${JSON.stringify(d)}`);
                      }
                      if ('string' in d) {
                          return d;
                      }
                      const bytes = parseBytes(d.bytes);
                      if (bytes === null) {
                          throw new MichelsonTypeError(t, d, `can't parse bytes: ${d.bytes}`);
                      }
                      const rd = new Reader(new Uint8Array(bytes));
                      const pk = readPublicKey(rd);
                      return { string: encodeTezosID(pk.type, pk.publicKey) };
                  },
              ];
          case 'address':
              return [
                  () => [][Symbol.iterator](),
                  (d) => {
                      if (!('bytes' in d) && !('string' in d)) {
                          throw new MichelsonTypeError(t, d, `address expected: ${JSON.stringify(d)}`);
                      }
                      if ('string' in d) {
                          return d;
                      }
                      const bytes = parseBytes(d.bytes);
                      if (bytes === null) {
                          throw new MichelsonTypeError(t, d, `can't parse bytes: ${d.bytes}`);
                      }
                      const rd = new Reader(new Uint8Array(bytes));
                      const addr = readAddress(rd);
                      return {
                          string: encodeTezosID(addr.type, addr.hash) + (addr.entryPoint ? '%' + addr.entryPoint : ''),
                      };
                  },
              ];
          case 'timestamp':
              return [
                  () => [][Symbol.iterator](),
                  (d) => {
                      if (!('int' in d) && !('string' in d)) {
                          throw new MichelsonTypeError(t, d, `address expected: ${JSON.stringify(d)}`);
                      }
                      if ('string' in d) {
                          return d;
                      }
                      const date = new Date(parseInt(d.int, 10) * 1000);
                      return { string: date.toISOString().slice(0, 19) + 'Z' };
                  },
              ];
          default:
              return readPassThrough;
      }
  };
  const readPassThrough = [
      (e) => {
          if (isPushInstruction(e)) {
              assertMichelsonInstruction(e);
              // capture inlined type definition
              return (function* () {
                  yield readPassThrough;
                  yield getReadTransformFuncs(e.args[0]);
              })();
          }
          return (function* () {
              while (true) {
                  yield readPassThrough;
              }
          })();
      },
      (e) => e,
  ];
  /**
   * Deserialize a byte array into the corresponding Michelson value.
   * Without a type definition (not recommended) the binary data will be treated as a binary form of a generic Michelson expression and returned as is.
   * Type definition allows some types like `timestamp` and `address` and other types usually encoded in optimized binary forms to be transformed
   * back to their string representations like base58 and ISO timestamps.
   *
   * ```typescript
   * const src = [0x05, 0x00, 0xa7, 0xe8, 0xe4, 0xd8, 0x0b];
   *
   * const typ: MichelsonType = {
   *     prim: "timestamp"
   * };
   *
   * const data = unpackData(src, typ);
   *
   * // { string: "2019-09-26T10:59:51Z" }
   * ```
   *
   * Same binary data without a type definition
   * ```typescript
   * const src = [0x05, 0x00, 0xa7, 0xe8, 0xe4, 0xd8, 0x0b];
   *
   * const data = unpackData(src);
   *
   * // { int: "1569495591" }
   * ```
   * @param src Byte array
   * @param t Optional type definition
   * @returns Deserialized data
   */
  function unpackData(src, t) {
      const r = new Reader(src);
      if (r.readUint8() !== 5) {
          throw new Error('incorrect packed data magic number');
      }
      const ex = readExpr(r, t !== undefined ? getReadTransformFuncs(t) : readPassThrough);
      if (assertMichelsonData(ex)) {
          return ex;
      }
      throw new Error(); // never
  }
  /**
   * Deserialize a byte array into the corresponding Michelson value.
   * Same as {@link unpackData} but takes a `bytes` Michelson data literal instead of an array
   *
   * ```typescript
   * const src = { bytes: "0500a7e8e4d80b" };
   *
   * const typ: MichelsonType = {
   *     prim: "timestamp"
   * };
   *
   * const data = unpackDataBytes(src, typ);
   *
   * // { string: "2019-09-26T10:59:51Z" }
   * ```
   * @param src Bytes object
   * @param t Optional type definition
   * @returns Deserialized data
   */
  function unpackDataBytes(src, t) {
      const bytes = parseBytes(src.bytes);
      if (bytes === null) {
          throw new Error(`can't parse bytes: "${src.bytes}"`);
      }
      return unpackData(bytes, t);
  }
  // helper functions also used by validator
  function decodeAddressBytes(b) {
      const bytes = parseBytes(b.bytes);
      if (bytes === null) {
          throw new Error(`can't parse bytes: "${b.bytes}"`);
      }
      const rd = new Reader(new Uint8Array(bytes));
      return readAddress(rd);
  }
  function decodePublicKeyHashBytes(b) {
      const bytes = parseBytes(b.bytes);
      if (bytes === null) {
          throw new Error(`can't parse bytes: "${b.bytes}"`);
      }
      const rd = new Reader(new Uint8Array(bytes));
      return readPublicKeyHash(rd);
  }
  function decodePublicKeyBytes(b) {
      const bytes = parseBytes(b.bytes);
      if (bytes === null) {
          throw new Error(`can't parse bytes: "${b.bytes}"`);
      }
      const rd = new Reader(new Uint8Array(bytes));
      return readPublicKey(rd);
  }

  class MichelsonInstructionError extends MichelsonError {
      /**
       * @param val Value of a type node caused the error
       * @param stackState Current stack state
       * @param message An error message
       */
      constructor(val, stackState, message) {
          super(val, message);
          this.stackState = stackState;
          Object.setPrototypeOf(this, MichelsonInstructionError.prototype);
      }
  }
  // 'sequence as a pair' edo syntax helpers
  function typeID(t) {
      return Array.isArray(t) ? 'pair' : t.prim;
  }
  function typeArgs(t) {
      return ('prim' in t ? t.args : t);
  }
  function assertScalarTypesEqual(a, b, field = false) {
      if (typeID(a) !== typeID(b)) {
          throw new MichelsonTypeError(a, undefined, `types mismatch: ${typeID(a)} != ${typeID(b)}`);
      }
      const ann = [unpackAnnotations(a), unpackAnnotations(b)];
      if (ann[0].t && ann[1].t && ann[0].t[0] !== ann[1].t[0]) {
          throw new MichelsonTypeError(a, undefined, `${typeID(a)}: type names mismatch: ${ann[0].t[0]} != ${ann[1].t[0]}`);
      }
      if (field && ann[0].f && ann[1].f && ann[0].f[0] !== ann[1].f[0]) {
          throw new MichelsonTypeError(a, undefined, `${typeID(a)}: field names mismatch: ${ann[0].f[0]} != ${ann[1].f}`);
      }
      if (isPairType(a)) {
          const aArgs = unpackComb('pair', a);
          const bArgs = unpackComb('pair', b);
          assertScalarTypesEqual(aArgs.args[0], bArgs.args[0], true);
          assertScalarTypesEqual(aArgs.args[1], bArgs.args[1], true);
          return;
      }
      switch (a.prim) {
          case 'option':
          case 'list':
          case 'contract':
          case 'set':
          case 'ticket':
              assertScalarTypesEqual(a.args[0], b.args[0]);
              break;
          case 'or':
              assertScalarTypesEqual(a.args[0], b.args[0], true);
              assertScalarTypesEqual(a.args[1], b.args[1], true);
              break;
          case 'lambda':
          case 'map':
          case 'big_map':
              assertScalarTypesEqual(a.args[0], b.args[0]);
              assertScalarTypesEqual(a.args[1], b.args[1]);
              break;
          case 'sapling_state':
          case 'sapling_transaction':
              if (parseInt(a.args[0].int, 10) !== parseInt(b.args[0].int, 10)) {
                  throw new MichelsonTypeError(a, undefined, `${typeID(a)}: type argument mismatch: ${a.args[0].int} != ${b.args[0].int}`);
              }
      }
  }
  function assertStacksEqual(a, b) {
      if (a.length !== b.length) {
          throw new MichelsonTypeError(a, undefined, `stack length mismatch: ${a.length} != ${b.length}`);
      }
      for (let i = 0; i < a.length; i++) {
          assertScalarTypesEqual(a[i], b[i]);
      }
  }
  function assertTypeAnnotationsValid(t, field = false) {
      var _a, _b, _c;
      if (!Array.isArray(t)) {
          const ann = unpackAnnotations(t);
          if ((((_a = ann.t) === null || _a === void 0 ? void 0 : _a.length) || 0) > 1) {
              throw new MichelsonTypeError(t, undefined, `${t.prim}: at most one type annotation allowed: ${t.annots}`);
          }
          if (field) {
              if ((((_b = ann.f) === null || _b === void 0 ? void 0 : _b.length) || 0) > 1) {
                  throw new MichelsonTypeError(t, undefined, `${t.prim}: at most one field annotation allowed: ${t.annots}`);
              }
          }
          else {
              if ((((_c = ann.f) === null || _c === void 0 ? void 0 : _c.length) || 0) > 0) {
                  throw new MichelsonTypeError(t, undefined, `${t.prim}: field annotations aren't allowed: ${t.annots}`);
              }
          }
      }
      if (isPairType(t)) {
          const args = typeArgs(t);
          for (const a of args) {
              assertTypeAnnotationsValid(a, true);
          }
          return;
      }
      switch (t.prim) {
          case 'option':
          case 'list':
          case 'contract':
          case 'set':
              assertTypeAnnotationsValid(t.args[0]);
              break;
          case 'or':
              for (const a of t.args) {
                  assertTypeAnnotationsValid(a, true);
              }
              break;
          case 'lambda':
          case 'map':
          case 'big_map':
              assertTypeAnnotationsValid(t.args[0]);
              assertTypeAnnotationsValid(t.args[1]);
      }
  }
  // Simplified version of assertMichelsonInstruction() for previously validated data
  function isFunction(d) {
      if (!Array.isArray(d)) {
          return false;
      }
      for (const v of d) {
          if (!((Array.isArray(v) && isFunction(v)) || ('prim' in v && isInstruction(v)))) {
              return false;
          }
      }
      return true;
  }
  function assertDataValidInternal(d, t, ctx) {
      if (isPairType(t)) {
          if (isPairData(d)) {
              assertDataListIfAny(d);
              const dc = unpackComb('Pair', d);
              const tc = unpackComb('pair', t);
              assertDataValidInternal(dc.args[0], tc.args[0], ctx);
              assertDataValidInternal(dc.args[1], tc.args[1], ctx);
              return;
          }
          throw new MichelsonTypeError(t, d, `pair expected: ${JSON.stringify(d)}`);
      }
      switch (t.prim) {
          // Atomic literals
          case 'int':
              if ('int' in d && isDecimal(d.int)) {
                  return;
              }
              throw new MichelsonTypeError(t, d, `integer value expected: ${JSON.stringify(d)}`);
          case 'nat':
          case 'mutez':
              if ('int' in d && isNatural(d.int)) {
                  return;
              }
              throw new MichelsonTypeError(t, d, `natural value expected: ${JSON.stringify(d)}`);
          case 'string':
              if ('string' in d) {
                  return;
              }
              throw new MichelsonTypeError(t, d, `string value expected: ${JSON.stringify(d)}`);
          case 'bytes':
          case 'bls12_381_g1':
          case 'bls12_381_g2':
              if ('bytes' in d && parseBytes(d.bytes) !== null) {
                  return;
              }
              throw new MichelsonTypeError(t, d, `bytes value expected: ${JSON.stringify(d)}`);
          case 'bool':
              if ('prim' in d && (d.prim === 'True' || d.prim === 'False')) {
                  return;
              }
              throw new MichelsonTypeError(t, d, `boolean value expected: ${JSON.stringify(d)}`);
          case 'key_hash':
              if ('string' in d &&
                  checkDecodeTezosID(d.string, 'ED25519PublicKeyHash', 'SECP256K1PublicKeyHash', 'P256PublicKeyHash') !== null) {
                  return;
              }
              else if ('bytes' in d) {
                  try {
                      decodePublicKeyHashBytes(d);
                      return;
                  }
                  catch (err) {
                      // ignore message
                  }
              }
              throw new MichelsonTypeError(t, d, `key hash expected: ${JSON.stringify(d)}`);
          case 'timestamp':
              if (('string' in d || 'int' in d) && parseDate(d) !== null) {
                  return;
              }
              throw new MichelsonTypeError(t, d, `timestamp expected: ${JSON.stringify(d)}`);
          case 'address':
              if ('string' in d) {
                  let address = d.string;
                  const ep = d.string.indexOf('%');
                  if (ep >= 0) {
                      // trim entry point
                      address = d.string.slice(0, ep);
                  }
                  if (checkDecodeTezosID(address, 'ED25519PublicKeyHash', 'SECP256K1PublicKeyHash', 'P256PublicKeyHash', 'ContractHash', 'TxRollupL2Address', 'RollupAddress') !== null) {
                      return;
                  }
              }
              else if ('bytes' in d) {
                  try {
                      decodeAddressBytes(d);
                      return;
                  }
                  catch (err) {
                      // ignore message
                  }
              }
              throw new MichelsonTypeError(t, d, `address expected: ${JSON.stringify(d)}`);
          case 'key':
              if ('string' in d &&
                  checkDecodeTezosID(d.string, 'ED25519PublicKey', 'SECP256K1PublicKey', 'P256PublicKey') !==
                      null) {
                  return;
              }
              else if ('bytes' in d) {
                  try {
                      decodePublicKeyBytes(d);
                      return;
                  }
                  catch (err) {
                      // ignore message
                  }
              }
              throw new MichelsonTypeError(t, d, `public key expected: ${JSON.stringify(d)}`);
          case 'unit':
              if ('prim' in d && d.prim === 'Unit') {
                  return;
              }
              throw new MichelsonTypeError(t, d, `unit value expected: ${JSON.stringify(d)}`);
          case 'signature':
              if ('bytes' in d ||
                  ('string' in d &&
                      checkDecodeTezosID(d.string, 'ED25519Signature', 'SECP256K1Signature', 'P256Signature', 'GenericSignature') !== null)) {
                  return;
              }
              throw new MichelsonTypeError(t, d, `signature expected: ${JSON.stringify(d)}`);
          case 'chain_id':
              if ('bytes' in d || 'string' in d) {
                  const x = 'string' in d ? decodeBase58Check(d.string) : parseBytes(d.bytes);
                  if (x !== null) {
                      return;
                  }
              }
              throw new MichelsonTypeError(t, d, `chain id expected: ${JSON.stringify(d)}`);
          // Complex types
          case 'option':
              if ('prim' in d) {
                  if (d.prim === 'None') {
                      return;
                  }
                  else if (d.prim === 'Some') {
                      assertDataValidInternal(d.args[0], t.args[0], ctx);
                      return;
                  }
              }
              throw new MichelsonTypeError(t, d, `option expected: ${JSON.stringify(d)}`);
          case 'list':
          case 'set':
              if (assertDataListIfAny(d)) {
                  //let prev: MichelsonData | undefined;
                  for (const v of d) {
                      assertDataValidInternal(v, t.args[0], ctx);
                  }
                  return;
              }
              throw new MichelsonTypeError(t, d, `${t.prim} expected: ${JSON.stringify(d)}`);
          case 'or':
              if ('prim' in d) {
                  if (d.prim === 'Left') {
                      assertDataValidInternal(d.args[0], t.args[0], ctx);
                      return;
                  }
                  else if (d.prim === 'Right') {
                      assertDataValidInternal(d.args[0], t.args[1], ctx);
                      return;
                  }
              }
              throw new MichelsonTypeError(t, d, `union (or) expected: ${JSON.stringify(d)}`);
          case 'lambda':
              if (isFunction(d)) {
                  const ret = functionTypeInternal(d, [t.args[0]], ctx);
                  if ('failed' in ret) {
                      throw new MichelsonTypeError(t, d, `function is failed with error type: ${ret.failed}`);
                  }
                  if (ret.length !== 1) {
                      throw new MichelsonTypeError(t, d, 'function must return a value');
                  }
                  assertScalarTypesEqual(t.args[1], ret[0]);
                  return;
              }
              throw new MichelsonTypeError(t, d, `function expected: ${JSON.stringify(d)}`);
          case 'map':
          case 'big_map':
              if (Array.isArray(d)) {
                  //let prev: MichelsonMapElt | undefined;
                  for (const v of d) {
                      if (!('prim' in v) || v.prim !== 'Elt') {
                          throw new MichelsonTypeError(t, d, `map elements expected: ${JSON.stringify(d)}`);
                      }
                      assertDataValidInternal(v.args[0], t.args[0], ctx);
                      assertDataValidInternal(v.args[1], t.args[1], ctx);
                  }
                  return;
              }
              throw new MichelsonTypeError(t, d, `${t.prim} expected: ${JSON.stringify(d)}`);
          case 'bls12_381_fr':
              if (('int' in d && isDecimal(d.int)) || ('bytes' in d && parseBytes(d.bytes) !== null)) {
                  return;
              }
              throw new MichelsonTypeError(t, d, `BLS12-381 element expected: ${JSON.stringify(d)}`);
          case 'sapling_state':
              if (Array.isArray(d)) {
                  return;
              }
              throw new MichelsonTypeError(t, d, `sapling state expected: ${JSON.stringify(d)}`);
          case 'ticket':
              assertDataValidInternal(d, {
                  prim: 'pair',
                  args: [{ prim: 'address' }, t.args[0], { prim: 'nat' }],
              }, ctx);
              return;
          default:
              throw new MichelsonTypeError(t, d, `type ${typeID(t)} don't have Michelson literal representation`);
      }
  }
  function instructionListType(inst, stack, ctx) {
      let ret = stack;
      let s = stack;
      let i = 0;
      for (const op of inst) {
          const ft = functionTypeInternal(op, s, ctx);
          ret = ft;
          if ('failed' in ft) {
              break;
          }
          s = ft;
          i++;
      }
      if ('failed' in ret &&
          ret.level == 0 &&
          (!('prim' in ret.failed) || ret.failed.prim !== 'never') &&
          i !== inst.length - 1) {
          throw new MichelsonInstructionError(inst, ret, 'FAIL must appear in a tail position');
      }
      if ((ctx === null || ctx === void 0 ? void 0 : ctx.traceCallback) !== undefined) {
          const trace = {
              op: inst,
              in: stack,
              out: ret,
          };
          ctx.traceCallback(trace);
      }
      return 'failed' in ret ? { failed: ret.failed, level: ret.level + 1 } : ret;
  }
  function functionTypeInternal(inst, stack, ctx) {
      const proto = (ctx === null || ctx === void 0 ? void 0 : ctx.protocol) || DefaultProtocol;
      if (Array.isArray(inst)) {
          return instructionListType(inst, stack, ctx);
      }
      const instruction = inst; // Make it const for type guarding
      // make sure the stack has enough number of arguments of specific types
      function args(n, ...typeIds) {
          if (stack.length < typeIds.length + n) {
              throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: stack must have at least ${typeIds.length} element(s)`);
          }
          let i = n;
          for (const ids of typeIds) {
              if (ids !== null && ids.length !== 0) {
                  let ii = 0;
                  while (ii < ids.length && ids[ii] !== typeID(stack[i])) {
                      ii++;
                  }
                  if (ii === ids.length) {
                      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: stack type mismatch: [${i}] expected to be ${ids}, got ${typeID(stack[i])} instead`);
                  }
              }
              i++;
          }
          return stack.slice(n, typeIds.length + n);
      }
      function rethrow(fn) {
          return (...args) => {
              try {
                  return fn(...args);
              }
              catch (err) {
                  if (err instanceof MichelsonError) {
                      throw new MichelsonInstructionError(instruction, stack, err.message);
                  }
                  else {
                      throw err;
                  }
              }
          };
      }
      function rethrowTypeGuard(fn) {
          return (arg) => {
              try {
                  return fn(arg);
              }
              catch (err) {
                  if (err instanceof MichelsonError) {
                      throw new MichelsonInstructionError(instruction, stack, err.message);
                  }
                  else {
                      throw err;
                  }
              }
          };
      }
      const argAnn = rethrow(unpackAnnotations);
      const ensureStacksEqual = rethrow(assertStacksEqual);
      const ensureTypesEqual = rethrow(assertScalarTypesEqual);
      const ensureComparableType = rethrowTypeGuard(assertMichelsonComparableType);
      const ensurePackableType = rethrowTypeGuard(assertMichelsonPackableType);
      const ensureStorableType = rethrowTypeGuard(assertMichelsonStorableType);
      const ensurePushableType = rethrowTypeGuard(assertMichelsonPushableType);
      const ensureBigMapStorableType = rethrowTypeGuard(assertMichelsonBigMapStorableType);
      // unpack instruction annotations and assert their maximum number
      function instructionAnn(num, opt) {
          const a = argAnn(instruction, Object.assign(Object.assign({}, opt), { emptyFields: num.f !== undefined && num.f > 1, emptyVar: num.v !== undefined && num.v > 1 }));
          const assertNum = (a, n, type) => {
              if (a && a.length > (n || 0)) {
                  throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at most ${n || 0} ${type} annotations allowed`);
              }
          };
          assertNum(a.f, num.f, 'field');
          assertNum(a.t, num.t, 'type');
          assertNum(a.v, num.v, 'variable');
          return a;
      }
      // also keeps annotation class if null is provided
      function annotate(tt, a) {
          const tx = tt;
          const t = Array.isArray(tx) ? { prim: 'pair', args: tx } : tx;
          const src = argAnn(t);
          const ann = a.v !== undefined || a.t !== undefined || a.f !== undefined
              ? [
                  ...((a.v === null ? src.v : a.v) || []),
                  ...((a.t === null ? src.t : a.t) || []),
                  ...((a.f === null ? src.f : a.f) || []),
              ]
              : undefined;
          const rest = __rest(t, ["annots"]);
          return Object.assign(Object.assign({}, rest), (ann && ann.length !== 0 && { annots: ann }));
      }
      // shortcut to copy at most one variable annotation from the instruction to the type
      function annotateVar(t, def) {
          const ia = instructionAnn({ v: 1 });
          return annotate(t, {
              v: ia.v !== undefined ? ia.v : def !== undefined ? [def] : null,
              t: null,
          });
      }
      // annotate CAR/CDR/UNPAIR/GET
      function annotateField(arg, field, insAnn, n, defField) {
          var _a, _b, _c, _d;
          const fieldAnn = (_a = argAnn(field).f) === null || _a === void 0 ? void 0 : _a[0]; // field's field annotation
          const insFieldAnn = (_b = insAnn.f) === null || _b === void 0 ? void 0 : _b[n];
          if (insFieldAnn !== undefined &&
              insFieldAnn !== '%' &&
              fieldAnn !== undefined &&
              insFieldAnn !== fieldAnn) {
              throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: field names doesn't match: ${insFieldAnn} !== ${fieldAnn}`);
          }
          const insVarAnn = (_c = insAnn.v) === null || _c === void 0 ? void 0 : _c[n]; // nth instruction's variable annotation
          const varAnn = (_d = argAnn(arg).v) === null || _d === void 0 ? void 0 : _d[0]; // instruction argument's variable annotation
          return annotate(field, {
              t: null,
              v: insVarAnn
                  ? insVarAnn === '@%'
                      ? fieldAnn
                          ? ['@' + fieldAnn.slice(1)]
                          : undefined
                      : insVarAnn === '@%%'
                          ? varAnn
                              ? ['@' + varAnn.slice(1) + '.' + (fieldAnn ? fieldAnn.slice(1) : defField)]
                              : fieldAnn
                                  ? ['@' + fieldAnn.slice(1)]
                                  : undefined
                          : [insVarAnn]
                  : null,
          });
      }
      // comb helper functions
      function getN(src, n, i = n) {
          const p = unpackComb('pair', src);
          if (i === 1) {
              return [p.args[0]];
          }
          else if (i === 2) {
              return p.args;
          }
          const right = p.args[1];
          if (isPairType(right)) {
              return [p.args[0], ...getN(right, n, i - 1)];
          }
          else {
              throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at least ${n} fields are expected`);
          }
      }
      function getNth(src, n, i = n) {
          if (i === 0) {
              return src;
          }
          const p = unpackComb('pair', src);
          if (i === 1) {
              return p.args[0];
          }
          const right = p.args[1];
          if (isPairType(right)) {
              return getNth(right, n, i - 2);
          }
          else if (i === 2) {
              return right;
          }
          throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at least ${n + 1} fields are expected`);
      }
      function updateNth(src, x, n, i = n) {
          if (i === 0) {
              return x;
          }
          const p = unpackComb('pair', src);
          if (i === 1) {
              return Object.assign(Object.assign({}, p), { args: [x, p.args[1]] });
          }
          const right = p.args[1];
          if (isPairType(right)) {
              return Object.assign(Object.assign({}, p), { args: [p.args[0], updateNth(right, x, n, i - 2)] });
          }
          else if (i === 2) {
              return Object.assign(Object.assign({}, p), { args: [p.args[0], x] });
          }
          throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at least ${n + 1} fields are expected`);
      }
      const varSuffix = (a, suffix) => [
          '@' + (a.v ? a.v[0].slice(1) + '.' : '') + suffix,
      ];
      function branchType(br0, br1) {
          if ('failed' in br0 || 'failed' in br1) {
              return 'failed' in br0 ? br1 : br0;
          }
          else {
              ensureStacksEqual(br0, br1);
              return br0;
          }
      }
      const retStack = ((instruction) => {
          var _a, _b, _c, _d, _e;
          switch (instruction.prim) {
              case 'DUP': {
                  const n = instruction.args ? parseInt(instruction.args[0].int, 10) : 1;
                  if (n === 0) {
                      throw new MichelsonInstructionError(instruction, stack, 'DUP 0 is forbidden');
                  }
                  const s = args(n - 1, null)[0];
                  if (typeID(s) === 'ticket') {
                      throw new MichelsonInstructionError(instruction, stack, "ticket can't be DUPed");
                  }
                  return [s, ...stack];
              }
              case 'SWAP': {
                  const s = args(0, null, null);
                  instructionAnn({});
                  return [s[1], s[0], ...stack.slice(2)];
              }
              case 'SOME':
                  return [
                      annotate({ prim: 'option', args: [args(0, null)[0]] }, instructionAnn({ t: 1, v: 1 })),
                      ...stack.slice(1),
                  ];
              case 'UNIT':
                  return [annotate({ prim: 'unit' }, instructionAnn({ v: 1, t: 1 })), ...stack];
              case 'PAIR': {
                  const n = instruction.args ? parseInt(instruction.args[0].int, 10) : 2;
                  if (n < 2) {
                      throw new MichelsonInstructionError(instruction, stack, `PAIR ${n} is forbidden`);
                  }
                  const s = args(0, ...new Array(n).fill(null));
                  const ia = instructionAnn({ f: n, t: 1, v: 1 }, { specialFields: true });
                  const trim = (s) => {
                      const i = s.lastIndexOf('.');
                      return s.slice(i > 0 ? i + 1 : 1);
                  };
                  const retArgs = s.map((v, i) => {
                      var _a;
                      const va = argAnn(v);
                      const f = ia.f && ia.f.length > i && ia.f[i] !== '%'
                          ? ia.f[i] === '%@'
                              ? va.v
                                  ? ['%' + trim(((_a = va.v) === null || _a === void 0 ? void 0 : _a[0]) || '')]
                                  : undefined
                              : [ia.f[i]]
                          : undefined;
                      return annotate(v, { v: null, t: null, f });
                  });
                  return [
                      annotate({
                          prim: 'pair',
                          args: retArgs,
                      }, { t: ia.t, v: ia.v }),
                      ...stack.slice(n),
                  ];
              }
              case 'UNPAIR': {
                  const n = instruction.args ? parseInt(instruction.args[0].int, 10) : 2;
                  if (n < 2) {
                      throw new MichelsonInstructionError(instruction, stack, `UNPAIR ${n} is forbidden`);
                  }
                  const s = args(0, ['pair'])[0];
                  const ia = instructionAnn({ f: 2, v: 2 }, { specialVar: true });
                  const fields = getN(s, n);
                  return [
                      ...fields.map((field, i) => annotateField(s, field, ia, i, i === 0 ? 'car' : 'cdr')),
                      ...stack.slice(1),
                  ];
              }
              case 'CAR':
              case 'CDR': {
                  const s = unpackComb('pair', args(0, ['pair'])[0]);
                  const field = s.args[instruction.prim === 'CAR' ? 0 : 1];
                  const ia = instructionAnn({ f: 1, v: 1 }, { specialVar: true });
                  return [
                      annotateField(s, field, ia, 0, instruction.prim.toLocaleLowerCase()),
                      ...stack.slice(1),
                  ];
              }
              case 'CONS': {
                  const s = args(0, null, ['list']);
                  ensureTypesEqual(s[0], s[1].args[0]);
                  return [annotateVar({ prim: 'list', args: [s[1].args[0]] }), ...stack.slice(2)];
              }
              case 'SIZE':
                  args(0, ['string', 'list', 'set', 'map', 'bytes']);
                  return [annotateVar({ prim: 'nat' }), ...stack.slice(1)];
              case 'MEM': {
                  const s = args(0, null, ['set', 'map', 'big_map']);
                  ensureComparableType(s[0]);
                  ensureTypesEqual(s[0], s[1].args[0]);
                  return [annotateVar({ prim: 'bool' }), ...stack.slice(2)];
              }
              case 'GET':
                  if (instruction.args) {
                      // comb operation
                      const n = parseInt(instruction.args[0].int, 10);
                      const s = args(0, ['pair'])[0];
                      return [annotateVar(getNth(s, n)), ...stack.slice(1)];
                  }
                  else {
                      // map operation
                      const s = args(0, null, ['map', 'big_map']);
                      ensureComparableType(s[0]);
                      ensureTypesEqual(s[0], s[1].args[0]);
                      return [annotateVar({ prim: 'option', args: [s[1].args[1]] }), ...stack.slice(2)];
                  }
              case 'UPDATE':
                  if (instruction.args) {
                      // comb operation
                      const n = parseInt(instruction.args[0].int, 10);
                      const s = args(0, null, ['pair']);
                      return [annotateVar(updateNth(s[1], s[0], n)), ...stack.slice(2)];
                  }
                  else {
                      // map operation
                      const s0 = args(0, null, ['bool', 'option']);
                      ensureComparableType(s0[0]);
                      if (s0[1].prim === 'bool') {
                          const s1 = args(2, ['set']);
                          ensureTypesEqual(s0[0], s1[0].args[0]);
                          return [
                              annotateVar({
                                  prim: 'set',
                                  args: [annotate(s0[0], { t: null })],
                              }),
                              ...stack.slice(3),
                          ];
                      }
                      const s1 = args(2, ['map', 'big_map']);
                      ensureTypesEqual(s0[0], s1[0].args[0]);
                      if (s1[0].prim === 'map') {
                          return [
                              annotateVar({
                                  prim: 'map',
                                  args: [annotate(s0[0], { t: null }), annotate(s0[1].args[0], { t: null })],
                              }),
                              ...stack.slice(3),
                          ];
                      }
                      ensureBigMapStorableType(s0[1].args[0]);
                      return [
                          annotateVar({
                              prim: 'big_map',
                              args: [annotate(s0[0], { t: null }), annotate(s0[1].args[0], { t: null })],
                          }),
                          ...stack.slice(3),
                      ];
                  }
              case 'GET_AND_UPDATE': {
                  const ia = instructionAnn({ v: 2 });
                  const s = args(0, null, ['option'], ['map', 'big_map']);
                  ensureComparableType(s[0]);
                  ensureTypesEqual(s[0], s[2].args[0]);
                  ensureTypesEqual(s[1].args[0], s[2].args[1]);
                  const va = (_a = ia.v) === null || _a === void 0 ? void 0 : _a.map((v) => (v !== '@' ? [v] : undefined));
                  if (s[2].prim === 'map') {
                      return [
                          annotate({ prim: 'option', args: [s[2].args[1]] }, { v: va === null || va === void 0 ? void 0 : va[0] }),
                          annotate({
                              prim: 'map',
                              args: [annotate(s[0], { t: null }), annotate(s[1].args[0], { t: null })],
                          }, { v: va === null || va === void 0 ? void 0 : va[1] }),
                          ...stack.slice(3),
                      ];
                  }
                  ensureBigMapStorableType(s[1].args[0]);
                  return [
                      annotate({ prim: 'option', args: [s[2].args[1]] }, { v: va === null || va === void 0 ? void 0 : va[0] }),
                      annotate({
                          prim: 'big_map',
                          args: [annotate(s[0], { t: null }), annotate(s[1].args[0], { t: null })],
                      }, { v: va === null || va === void 0 ? void 0 : va[1] }),
                      ...stack.slice(3),
                  ];
              }
              case 'EXEC': {
                  const s = args(0, null, ['lambda']);
                  ensureTypesEqual(s[0], s[1].args[0]);
                  return [annotateVar(s[1].args[1]), ...stack.slice(2)];
              }
              case 'APPLY': {
                  const s = args(0, null, ['lambda']);
                  ensureStorableType(s[0]);
                  ensurePushableType(s[0]);
                  if (!isPairType(s[1].args[0])) {
                      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: function's argument must be a pair: ${typeID(s[1].args[0])}`);
                  }
                  const pt = s[1].args[0];
                  ensureTypesEqual(s[0], typeArgs(pt)[0]);
                  return [
                      annotateVar({ prim: 'lambda', args: [typeArgs(pt)[1], s[1].args[1]] }),
                      ...stack.slice(2),
                  ];
              }
              case 'FAILWITH': {
                  const s = args(0, null)[0];
                  if (!ProtoInferiorTo(proto, exports.Protocol.PtEdo2Zk)) {
                      ensurePackableType(s);
                  }
                  return { failed: s, level: 0 };
              }
              case 'NEVER':
                  args(0, ['never']);
                  return { failed: { prim: 'never' }, level: 0 };
              case 'RENAME':
                  return [annotateVar(args(0, null)[0]), ...stack.slice(1)];
              case 'CONCAT': {
                  const s0 = args(0, ['string', 'list', 'bytes']);
                  if (s0[0].prim === 'list') {
                      if (typeID(s0[0].args[0]) !== 'string' && typeID(s0[0].args[0]) !== 'bytes') {
                          throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: can't concatenate list of ${typeID(s0[0].args[0])}'s`);
                      }
                      return [annotateVar(s0[0].args[0]), ...stack.slice(1)];
                  }
                  const s1 = args(1, ['string', 'bytes']);
                  if (s0[0].prim !== s1[0].prim) {
                      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: can't concatenate ${s0[0].prim} with ${s1[0].prim}`);
                  }
                  return [annotateVar(s1[0]), ...stack.slice(2)];
              }
              case 'SLICE':
                  return [
                      annotateVar({ prim: 'option', args: [args(0, ['nat'], ['nat'], ['string', 'bytes'])[2]] }, '@slice'),
                      ...stack.slice(3),
                  ];
              case 'PACK': {
                  const s = args(0, null)[0];
                  ensurePackableType(s);
                  return [annotateVar({ prim: 'bytes' }, '@packed'), ...stack.slice(1)];
              }
              case 'ADD': {
                  const s = args(0, ['nat', 'int', 'timestamp', 'mutez', 'bls12_381_g1', 'bls12_381_g2', 'bls12_381_fr'], ['nat', 'int', 'timestamp', 'mutez', 'bls12_381_g1', 'bls12_381_g2', 'bls12_381_fr']);
                  if ((s[0].prim === 'nat' && s[1].prim === 'int') ||
                      (s[0].prim === 'int' && s[1].prim === 'nat')) {
                      return [annotateVar({ prim: 'int' }), ...stack.slice(2)];
                  }
                  else if ((s[0].prim === 'int' && s[1].prim === 'timestamp') ||
                      (s[0].prim === 'timestamp' && s[1].prim === 'int')) {
                      return [annotateVar({ prim: 'timestamp' }), ...stack.slice(2)];
                  }
                  else if ((s[0].prim === 'int' ||
                      s[0].prim === 'nat' ||
                      s[0].prim === 'mutez' ||
                      s[0].prim === 'bls12_381_g1' ||
                      s[0].prim === 'bls12_381_g2' ||
                      s[0].prim === 'bls12_381_fr') &&
                      s[0].prim === s[1].prim) {
                      return [annotateVar(s[0]), ...stack.slice(2)];
                  }
                  throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: can't add ${s[0].prim} to ${s[1].prim}`);
              }
              case 'SUB': {
                  const s = ProtoInferiorTo(proto, exports.Protocol.PsiThaCa)
                      ? args(0, ['nat', 'int', 'timestamp', 'mutez'], ['nat', 'int', 'timestamp', 'mutez'])
                      : args(0, ['nat', 'int', 'timestamp'], ['nat', 'int', 'timestamp']);
                  if (((s[0].prim === 'nat' || s[0].prim === 'int') &&
                      (s[1].prim === 'nat' || s[1].prim === 'int')) ||
                      (s[0].prim === 'timestamp' && s[1].prim === 'timestamp')) {
                      return [annotateVar({ prim: 'int' }), ...stack.slice(2)];
                  }
                  else if (s[0].prim === 'timestamp' && s[1].prim === 'int') {
                      return [annotateVar({ prim: 'timestamp' }), ...stack.slice(2)];
                  }
                  else if (s[0].prim === 'mutez' && s[1].prim === 'mutez') {
                      return [annotateVar({ prim: 'mutez' }), ...stack.slice(2)];
                  }
                  throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: can't subtract ${s[0].prim} from ${s[1].prim}`);
              }
              case 'SUB_MUTEZ': {
                  args(0, ['mutez'], ['mutez']);
                  return [annotateVar({ prim: 'option', args: [{ prim: 'mutez' }] }), ...stack.slice(2)];
              }
              case 'MUL': {
                  const s = args(0, ['nat', 'int', 'mutez', 'bls12_381_g1', 'bls12_381_g2', 'bls12_381_fr'], ['nat', 'int', 'mutez', 'bls12_381_g1', 'bls12_381_g2', 'bls12_381_fr']);
                  if ((s[0].prim === 'nat' && s[1].prim === 'int') ||
                      (s[0].prim === 'int' && s[1].prim === 'nat')) {
                      return [annotateVar({ prim: 'int' }), ...stack.slice(2)];
                  }
                  else if ((s[0].prim === 'nat' && s[1].prim === 'mutez') ||
                      (s[0].prim === 'mutez' && s[1].prim === 'nat')) {
                      return [annotateVar({ prim: 'mutez' }), ...stack.slice(2)];
                  }
                  else if (((s[0].prim === 'bls12_381_g1' ||
                      s[0].prim === 'bls12_381_g2' ||
                      s[0].prim === 'bls12_381_fr') &&
                      s[1].prim === 'bls12_381_fr') ||
                      ((s[0].prim === 'nat' || s[0].prim === 'int') && s[0].prim === s[1].prim)) {
                      return [annotateVar(s[0]), ...stack.slice(2)];
                  }
                  else if (((s[0].prim === 'nat' || s[0].prim === 'int') && s[1].prim === 'bls12_381_fr') ||
                      ((s[1].prim === 'nat' || s[1].prim === 'int') && s[0].prim === 'bls12_381_fr')) {
                      return [annotateVar({ prim: 'bls12_381_fr' }), ...stack.slice(2)];
                  }
                  throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: can't multiply ${s[0].prim} by ${s[1].prim}`);
              }
              case 'EDIV': {
                  const res = (a, b) => ({
                      prim: 'option',
                      args: [{ prim: 'pair', args: [{ prim: a }, { prim: b }] }],
                  });
                  const s = args(0, ['nat', 'int', 'mutez'], ['nat', 'int', 'mutez']);
                  if (s[0].prim === 'nat' && s[1].prim === 'nat') {
                      return [annotateVar(res('nat', 'nat')), ...stack.slice(2)];
                  }
                  else if ((s[0].prim === 'nat' || s[0].prim === 'int') &&
                      (s[1].prim === 'nat' || s[1].prim === 'int')) {
                      return [annotateVar(res('int', 'nat')), ...stack.slice(2)];
                  }
                  else if (s[0].prim === 'mutez' && s[1].prim === 'nat') {
                      return [annotateVar(res('mutez', 'mutez')), ...stack.slice(2)];
                  }
                  else if (s[0].prim === 'mutez' && s[1].prim === 'mutez') {
                      return [annotateVar(res('nat', 'mutez')), ...stack.slice(2)];
                  }
                  throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: can't euclideally divide ${s[0].prim} by ${s[1].prim}`);
              }
              case 'ABS':
                  args(0, ['int']);
                  return [annotateVar({ prim: 'nat' }), ...stack.slice(1)];
              case 'ISNAT':
                  args(0, ['int']);
                  return [annotateVar({ prim: 'option', args: [{ prim: 'nat' }] }), ...stack.slice(1)];
              case 'INT':
                  args(0, ['nat', 'bls12_381_fr']);
                  return [annotateVar({ prim: 'int' }), ...stack.slice(1)];
              case 'NEG': {
                  const s = args(0, ['nat', 'int', 'bls12_381_g1', 'bls12_381_g2', 'bls12_381_fr'])[0];
                  if (s.prim === 'nat' || s.prim === 'int') {
                      return [annotateVar({ prim: 'int' }), ...stack.slice(1)];
                  }
                  return [annotateVar(s), ...stack.slice(1)];
              }
              case 'LSL':
              case 'LSR':
                  args(0, ['nat'], ['nat']);
                  return [annotateVar({ prim: 'nat' }), ...stack.slice(2)];
              case 'OR':
              case 'XOR': {
                  const s = args(0, ['nat', 'bool'], ['nat', 'bool']);
                  if (s[0].prim !== s[1].prim) {
                      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: both arguments must be of the same type: ${s[0].prim}, ${s[1].prim}`);
                  }
                  return [annotateVar(s[1]), ...stack.slice(2)];
              }
              case 'AND': {
                  const s = args(0, ['nat', 'bool', 'int'], ['nat', 'bool']);
                  if ((s[0].prim !== 'int' || s[1].prim !== 'nat') && s[0].prim !== s[1].prim) {
                      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: both arguments must be of the same type: ${s[0].prim}, ${s[1].prim}`);
                  }
                  return [annotateVar(s[1]), ...stack.slice(2)];
              }
              case 'NOT': {
                  const s = args(0, ['nat', 'bool', 'int'])[0];
                  if (s.prim === 'bool') {
                      return [annotateVar({ prim: 'bool' }), ...stack.slice(1)];
                  }
                  return [annotateVar({ prim: 'int' }), ...stack.slice(1)];
              }
              case 'COMPARE': {
                  const s = args(0, null, null);
                  ensureComparableType(s[0]);
                  ensureComparableType(s[1]);
                  return [annotateVar({ prim: 'int' }), ...stack.slice(2)];
              }
              case 'EQ':
              case 'NEQ':
              case 'LT':
              case 'GT':
              case 'LE':
              case 'GE':
                  args(0, ['int']);
                  return [annotateVar({ prim: 'bool' }), ...stack.slice(1)];
              case 'SELF': {
                  if ((ctx === null || ctx === void 0 ? void 0 : ctx.contract) === undefined) {
                      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: contract required`);
                  }
                  const ia = instructionAnn({ f: 1, v: 1 });
                  const ep = contractEntryPoint(ctx.contract, (_b = ia.f) === null || _b === void 0 ? void 0 : _b[0]);
                  if (ep === null) {
                      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: contract has no entrypoint ${ep}`);
                  }
                  return [
                      annotate({ prim: 'contract', args: [ep] }, { v: ia.v ? ia.v : ['@self'] }),
                      ...stack,
                  ];
              }
              case 'TRANSFER_TOKENS': {
                  const s = args(0, null, ['mutez'], ['contract']);
                  ensureTypesEqual(s[0], s[2].args[0]);
                  return [annotateVar({ prim: 'operation' }), ...stack.slice(3)];
              }
              case 'SET_DELEGATE': {
                  const s = args(0, ['option'])[0];
                  if (typeID(s.args[0]) !== 'key_hash') {
                      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: key hash expected: ${typeID(s.args[0])}`);
                  }
                  return [annotateVar({ prim: 'operation' }), ...stack.slice(1)];
              }
              case 'IMPLICIT_ACCOUNT':
                  args(0, ['key_hash']);
                  return [annotateVar({ prim: 'contract', args: [{ prim: 'unit' }] }), ...stack.slice(1)];
              case 'NOW':
                  return [annotateVar({ prim: 'timestamp' }, '@now'), ...stack];
              case 'AMOUNT':
                  return [annotateVar({ prim: 'mutez' }, '@amount'), ...stack];
              case 'BALANCE':
                  return [annotateVar({ prim: 'mutez' }, '@balance'), ...stack];
              case 'CHECK_SIGNATURE':
                  args(0, ['key'], ['signature'], ['bytes']);
                  return [annotateVar({ prim: 'bool' }), ...stack.slice(3)];
              case 'BLAKE2B':
              case 'SHA256':
              case 'SHA512':
              case 'KECCAK':
              case 'SHA3':
                  args(0, ['bytes']);
                  return [annotateVar({ prim: 'bytes' }), ...stack.slice(1)];
              case 'HASH_KEY':
                  args(0, ['key']);
                  return [annotateVar({ prim: 'key_hash' }), ...stack.slice(1)];
              case 'SOURCE':
                  return [annotateVar({ prim: 'address' }, '@source'), ...stack];
              case 'SENDER':
                  return [annotateVar({ prim: 'address' }, '@sender'), ...stack];
              case 'ADDRESS': {
                  const s = args(0, ['contract'])[0];
                  const ia = instructionAnn({ v: 1 });
                  return [
                      annotate({ prim: 'address', [refContract]: s }, { v: ia.v ? ia.v : varSuffix(argAnn(s), 'address') }),
                      ...stack.slice(1),
                  ];
              }
              case 'SELF_ADDRESS': {
                  const addr = { prim: 'address' };
                  if ((ctx === null || ctx === void 0 ? void 0 : ctx.contract) !== undefined) {
                      addr[refContract] = {
                          prim: 'contract',
                          args: [contractSection(ctx.contract, 'parameter').args[0]],
                      };
                  }
                  return [annotateVar(addr, '@address'), ...stack];
              }
              case 'CHAIN_ID':
                  return [annotateVar({ prim: 'chain_id' }), ...stack];
              case 'DROP': {
                  instructionAnn({});
                  const n = instruction.args !== undefined ? parseInt(instruction.args[0].int, 10) : 1;
                  args(n - 1, null);
                  return stack.slice(n);
              }
              case 'DIG': {
                  instructionAnn({});
                  const n = parseInt(instruction.args[0].int, 10);
                  return [args(n, null)[0], ...stack.slice(0, n), ...stack.slice(n + 1)];
              }
              case 'DUG': {
                  instructionAnn({});
                  const n = parseInt(instruction.args[0].int, 10);
                  return [...stack.slice(1, n + 1), args(0, null)[0], ...stack.slice(n + 1)];
              }
              case 'NONE':
                  assertTypeAnnotationsValid(instruction.args[0]);
                  return [
                      annotate({ prim: 'option', args: [instruction.args[0]] }, instructionAnn({ t: 1, v: 1 })),
                      ...stack,
                  ];
              case 'LEFT':
              case 'RIGHT': {
                  const s = args(0, null)[0];
                  const ia = instructionAnn({ f: 2, t: 1, v: 1 }, { specialFields: true });
                  const va = argAnn(s);
                  const children = [
                      annotate(s, {
                          t: null,
                          v: null,
                          f: ia.f && ia.f.length > 0 && ia.f[0] !== '%'
                              ? ia.f[0] === '%@'
                                  ? va.v
                                      ? ['%' + va.v[0].slice(1)]
                                      : undefined
                                  : ia.f
                              : undefined,
                      }),
                      annotate(instruction.args[0], {
                          t: null,
                          f: ia.f && ia.f.length > 1 && ia.f[1] !== '%' ? ia.f : undefined,
                      }),
                  ];
                  return [
                      annotate({
                          prim: 'or',
                          args: instruction.prim === 'LEFT' ? children : [children[1], children[0]],
                      }, { t: ia.t, v: ia.v }),
                      ...stack.slice(1),
                  ];
              }
              case 'NIL':
                  assertTypeAnnotationsValid(instruction.args[0]);
                  return [
                      annotate({ prim: 'list', args: [instruction.args[0]] }, instructionAnn({ t: 1, v: 1 })),
                      ...stack,
                  ];
              case 'UNPACK':
                  args(0, ['bytes']);
                  assertTypeAnnotationsValid(instruction.args[0]);
                  return [
                      annotateVar({ prim: 'option', args: [instruction.args[0]] }, '@unpacked'),
                      ...stack.slice(1),
                  ];
              case 'CONTRACT': {
                  const s = args(0, ['address'])[0];
                  assertTypeAnnotationsValid(instruction.args[0]);
                  const ia = instructionAnn({ v: 1, f: 1 });
                  const contract = s[refContract];
                  if (contract !== undefined) {
                      const ep = contractEntryPoint(contract, (_c = ia.f) === null || _c === void 0 ? void 0 : _c[0]);
                      if (ep === null) {
                          throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: contract has no entrypoint ${ep}`);
                      }
                      ensureTypesEqual(ep, instruction.args[0]);
                  }
                  return [
                      annotate({ prim: 'option', args: [{ prim: 'contract', args: [instruction.args[0]] }] }, { v: ia.v ? ia.v : varSuffix(argAnn(s), 'contract') }),
                      ...stack.slice(1),
                  ];
              }
              case 'CAST': {
                  instructionAnn({});
                  const s = args(0, null)[0];
                  assertTypeAnnotationsValid(instruction.args[0]);
                  ensureTypesEqual(instruction.args[0], s);
                  return [instruction.args[0], ...stack.slice(1)];
              }
              case 'IF_NONE': {
                  instructionAnn({});
                  const s = args(0, ['option'])[0];
                  const tail = stack.slice(1);
                  const br0 = functionTypeInternal(instruction.args[0], tail, ctx);
                  const br1 = functionTypeInternal(instruction.args[1], [annotate(s.args[0], { t: null, v: varSuffix(argAnn(s), 'some') }), ...tail], ctx);
                  return branchType(br0, br1);
              }
              case 'IF_LEFT': {
                  instructionAnn({});
                  const s = args(0, ['or'])[0];
                  const va = argAnn(s);
                  const lefta = argAnn(s.args[0]);
                  const righta = argAnn(s.args[1]);
                  const tail = stack.slice(1);
                  const br0 = functionTypeInternal(instruction.args[0], [
                      annotate(s.args[0], {
                          t: null,
                          v: varSuffix(va, lefta.f ? lefta.f[0].slice(1) : 'left'),
                      }),
                      ...tail,
                  ], ctx);
                  const br1 = functionTypeInternal(instruction.args[1], [
                      annotate(s.args[1], {
                          t: null,
                          v: varSuffix(va, righta.f ? righta.f[0].slice(1) : 'right'),
                      }),
                      ...tail,
                  ], ctx);
                  return branchType(br0, br1);
              }
              case 'IF_CONS': {
                  instructionAnn({});
                  const s = args(0, ['list'])[0];
                  const va = argAnn(s);
                  const tail = stack.slice(1);
                  const br0 = functionTypeInternal(instruction.args[0], [
                      annotate(s.args[0], { t: null, v: varSuffix(va, 'hd') }),
                      annotate(s, { t: null, v: varSuffix(va, 'tl') }),
                      ...tail,
                  ], ctx);
                  const br1 = functionTypeInternal(instruction.args[1], tail, ctx);
                  return branchType(br0, br1);
              }
              case 'IF': {
                  instructionAnn({});
                  args(0, ['bool']);
                  const tail = stack.slice(1);
                  const br0 = functionTypeInternal(instruction.args[0], tail, ctx);
                  const br1 = functionTypeInternal(instruction.args[1], tail, ctx);
                  return branchType(br0, br1);
              }
              case 'MAP': {
                  const s = args(0, ['list', 'map', 'option'])[0];
                  const tail = stack.slice(1);
                  const elt = s.prim === 'map' ? { prim: 'pair', args: s.args } : s.args[0];
                  const body = functionTypeInternal(instruction.args[0], [annotate(elt, { t: null, v: varSuffix(argAnn(s), 'elt') }), ...tail], ctx);
                  if ('failed' in body) {
                      if (!('prim' in body.failed) || body.failed.prim !== 'never') {
                          throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: FAIL is not allowed in MAP`);
                      }
                      return { failed: body.failed, level: body.level + 1 };
                  }
                  if (body.length < 1) {
                      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: function must return a value`);
                  }
                  ensureStacksEqual(body.slice(1), tail);
                  return s.prim === 'list'
                      ? [annotateVar({ prim: 'list', args: [body[0]] }), ...tail]
                      : s.prim === 'map'
                          ? [annotateVar({ prim: 'map', args: [s.args[0], body[0]] }), ...tail]
                          : [annotateVar({ prim: 'option', args: [body[0]] }), ...tail];
              }
              case 'ITER': {
                  instructionAnn({});
                  const s = args(0, ['set', 'list', 'map'])[0];
                  const tail = stack.slice(1);
                  const elt = s.prim === 'map' ? { prim: 'pair', args: s.args } : s.args[0];
                  const body = functionTypeInternal(instruction.args[0], [annotate(elt, { t: null, v: varSuffix(argAnn(s), 'elt') }), ...tail], ctx);
                  if ('failed' in body) {
                      return { failed: body.failed, level: body.level + 1 };
                  }
                  ensureStacksEqual(body, tail);
                  return tail;
              }
              case 'LOOP': {
                  instructionAnn({});
                  args(0, ['bool']);
                  const tail = stack.slice(1);
                  const body = functionTypeInternal(instruction.args[0], tail, ctx);
                  if ('failed' in body) {
                      return { failed: body.failed, level: body.level + 1 };
                  }
                  ensureStacksEqual(body, [{ prim: 'bool' }, ...tail]);
                  return tail;
              }
              case 'LOOP_LEFT': {
                  instructionAnn({});
                  const s = args(0, ['or'])[0];
                  const tail = stack.slice(1);
                  const body = functionTypeInternal(instruction.args[0], [annotate(s.args[0], { t: null, v: varSuffix(argAnn(s), 'left') }), ...tail], ctx);
                  if ('failed' in body) {
                      return { failed: body.failed, level: body.level + 1 };
                  }
                  ensureStacksEqual(body, [s, ...tail]);
                  return [annotate(s.args[1], { t: null, v: instructionAnn({ v: 1 }).v }), ...tail];
              }
              case 'DIP': {
                  instructionAnn({});
                  const n = instruction.args.length === 2 ? parseInt(instruction.args[0].int, 10) : 1;
                  args(n - 1, null);
                  const head = stack.slice(0, n);
                  const tail = stack.slice(n);
                  // ternary operator is a type guard so use it instead of just `instruction.args.length - 1`
                  const body = instruction.args.length === 2
                      ? functionTypeInternal(instruction.args[1], tail, ctx)
                      : functionTypeInternal(instruction.args[0], tail, ctx);
                  if ('failed' in body) {
                      return { failed: body.failed, level: body.level + 1 };
                  }
                  return [...head, ...body];
              }
              case 'CREATE_CONTRACT': {
                  const ia = instructionAnn({ v: 2 });
                  const s = args(0, ['option'], ['mutez'], null);
                  if (typeID(s[0].args[0]) !== 'key_hash') {
                      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: key hash expected: ${typeID(s[0].args[0])}`);
                  }
                  if (ensureStorableType(s[2])) {
                      assertContractValid(instruction.args[0]);
                      assertScalarTypesEqual(contractSection(instruction.args[0], 'storage').args[0], s[2]);
                  }
                  const va = (_d = ia.v) === null || _d === void 0 ? void 0 : _d.map((v) => (v !== '@' ? [v] : undefined));
                  return [
                      annotate({ prim: 'operation' }, { v: va === null || va === void 0 ? void 0 : va[0] }),
                      annotate({
                          prim: 'address',
                          [refContract]: {
                              prim: 'contract',
                              args: [contractSection(instruction.args[0], 'parameter').args[0]],
                          },
                      }, { v: va === null || va === void 0 ? void 0 : va[1] }),
                      ...stack.slice(3),
                  ];
              }
              case 'PUSH':
                  assertTypeAnnotationsValid(instruction.args[0]);
                  assertDataValidInternal(instruction.args[1], instruction.args[0], Object.assign(Object.assign({}, ctx), { contract: undefined }));
                  return [annotateVar(instruction.args[0]), ...stack];
              case 'EMPTY_SET':
                  assertTypeAnnotationsValid(instruction.args[0]);
                  ensureComparableType(instruction.args[0]);
                  return [
                      annotate({ prim: 'set', args: instruction.args }, instructionAnn({ t: 1, v: 1 })),
                      ...stack,
                  ];
              case 'EMPTY_MAP':
                  assertTypeAnnotationsValid(instruction.args[0]);
                  ensureComparableType(instruction.args[0]);
                  assertTypeAnnotationsValid(instruction.args[1]);
                  return [
                      annotate({ prim: 'map', args: instruction.args }, instructionAnn({ t: 1, v: 1 })),
                      ...stack,
                  ];
              case 'EMPTY_BIG_MAP':
                  assertTypeAnnotationsValid(instruction.args[0]);
                  ensureComparableType(instruction.args[0]);
                  assertTypeAnnotationsValid(instruction.args[1]);
                  ensureBigMapStorableType(instruction.args[0]);
                  return [
                      annotate({ prim: 'big_map', args: instruction.args }, instructionAnn({ t: 1, v: 1 })),
                      ...stack,
                  ];
              case 'LAMBDA_REC':
              case 'LAMBDA': {
                  assertTypeAnnotationsValid(instruction.args[0]);
                  assertTypeAnnotationsValid(instruction.args[1]);
                  const s = [instruction.args[0]];
                  if (instruction.prim === "LAMBDA_REC") {
                      s.push({ prim: 'lambda', args: [instruction.args[0], instruction.args[1]] });
                  }
                  const body = functionTypeInternal(instruction.args[2], s, Object.assign(Object.assign({}, ctx), { contract: undefined }));
                  if ('failed' in body) {
                      return { failed: body.failed, level: body.level + 1 };
                  }
                  if (body.length !== 1) {
                      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: function must return a value`);
                  }
                  ensureTypesEqual(instruction.args[1], body[0]);
                  return [
                      annotateVar({ prim: 'lambda', args: [instruction.args[0], instruction.args[1]] }),
                      ...stack,
                  ];
              }
              case 'LEVEL':
                  return [annotateVar({ prim: 'nat' }, '@level'), ...stack];
              case 'TOTAL_VOTING_POWER':
                  return [annotateVar({ prim: 'nat' }), ...stack];
              case 'VOTING_POWER':
                  args(0, ['key_hash']);
                  return [annotateVar({ prim: 'nat' }), ...stack.slice(1)];
              case 'TICKET': {
                  const s = args(0, null, ['nat'])[0];
                  ensureComparableType(s);
                  if (ProtoInferiorTo(proto, exports.Protocol.PtLimaPtL)) {
                      return [
                          annotate({ prim: 'ticket', args: [s] }, instructionAnn({ t: 1, v: 1 })),
                          ...stack.slice(2),
                      ];
                  }
                  else {
                      return [
                          annotateVar({
                              prim: 'option',
                              args: [
                                  annotate({ prim: 'ticket', args: [s] }, instructionAnn({ t: 1, v: 1 }))
                              ]
                          }),
                          ...stack.slice(2)
                      ];
                  }
              }
              case 'JOIN_TICKETS': {
                  const s = unpackComb('pair', args(0, ['pair'])[0]);
                  if (typeID(s.args[0]) !== 'ticket') {
                      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: ticket expected: ${typeID(s.args[0])}`);
                  }
                  ensureTypesEqual(s.args[0], s.args[1]);
                  return [
                      annotateVar({
                          prim: 'option',
                          args: [annotate(s.args[0], { t: null })],
                      }),
                      ...stack.slice(1),
                  ];
              }
              case 'SPLIT_TICKET': {
                  const s = args(0, ['ticket'], ['pair']);
                  const p = unpackComb('pair', s[1]);
                  if (typeID(p.args[0]) !== 'nat') {
                      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: nat expected: ${typeID(p.args[0])}`);
                  }
                  ensureTypesEqual(p.args[0], p.args[1]);
                  return [
                      annotateVar({
                          prim: 'option',
                          args: [
                              {
                                  prim: 'pair',
                                  args: [annotate(s[0], { t: null }), annotate(s[0], { t: null })],
                              },
                          ],
                      }),
                      ...stack.slice(2),
                  ];
              }
              case 'READ_TICKET': {
                  const ia = instructionAnn({ v: 2 });
                  const s = args(0, ['ticket'])[0];
                  const va = (_e = ia.v) === null || _e === void 0 ? void 0 : _e.map((v) => (v !== '@' ? [v] : undefined));
                  return [
                      annotate({
                          prim: 'pair',
                          args: [{ prim: 'address' }, annotate(s.args[0], { t: null }), { prim: 'nat' }],
                      }, { v: va === null || va === void 0 ? void 0 : va[0] }),
                      annotate(s, { v: va === null || va === void 0 ? void 0 : va[1], t: null }),
                      ...stack.slice(1),
                  ];
              }
              case 'PAIRING_CHECK': {
                  const p = args(0, ['list'])[0].args[0];
                  if (!isPairType(p)) {
                      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: pair expected: ${typeID(p)}`);
                  }
                  const c = unpackComb('pair', p);
                  if (typeID(c.args[0]) !== 'bls12_381_g1') {
                      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: bls12_381_g1 expected: ${typeID(c.args[0])}`);
                  }
                  if (typeID(c.args[1]) !== 'bls12_381_g2') {
                      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: bls12_381_g2 expected: ${typeID(c.args[1])}`);
                  }
                  return [annotateVar({ prim: 'bool' }), ...stack.slice(1)];
              }
              case 'SAPLING_EMPTY_STATE':
                  return [
                      annotate({ prim: 'sapling_state', args: [instruction.args[0]] }, instructionAnn({ v: 1, t: 1 })),
                      ...stack,
                  ];
              case 'SAPLING_VERIFY_UPDATE': {
                  const s = args(0, ['sapling_transaction'], ['sapling_state']);
                  if (parseInt(s[0].args[0].int, 10) !== parseInt(s[1].args[0].int, 10)) {
                      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: sapling memo size mismatch: ${s[0].args[0].int} != ${s[1].args[0].int}`);
                  }
                  return ProtoInferiorTo(proto, exports.Protocol.PtJakarta)
                      ? [
                          annotateVar({
                              prim: 'option',
                              args: [
                                  {
                                      prim: 'pair',
                                      args: [{ prim: 'int' }, annotate(s[1], { t: null })],
                                  },
                              ],
                          }),
                          ...stack.slice(2),
                      ]
                      : [
                          annotateVar({
                              prim: 'option',
                              args: [
                                  {
                                      prim: 'pair',
                                      args: [
                                          { prim: 'bytes' },
                                          {
                                              prim: 'pair',
                                              args: [{ prim: 'int' }, annotate(s[1], { t: null })],
                                          },
                                      ],
                                  },
                              ],
                          }),
                          ...stack.slice(2),
                      ];
              }
              case 'OPEN_CHEST':
                  args(0, ['chest_key'], ['chest'], ['nat']);
                  return [
                      annotateVar({ prim: 'or', args: [{ prim: 'bytes' }, { prim: 'bool' }] }),
                      ...stack.slice(3),
                  ];
              case 'VIEW': {
                  const s = args(0, null, ['address']);
                  ensurePushableType(s[0]);
                  return [annotateVar({ prim: 'option', args: [instruction.args[1]] }), ...stack.slice(2)];
              }
              case 'MIN_BLOCK_TIME':
                  return [annotateVar({ prim: 'nat' }), ...stack];
              case 'EMIT': {
                  const ia = instructionAnn({ f: 1, t: 1 });
                  if (instruction.args) {
                      const s = args(0, null);
                      ensureTypesEqual(s[0], instruction.args[0]);
                      return [annotate({ prim: 'operation' }, ia), ...stack.slice(1)];
                  }
                  return [annotate({ prim: 'operation' }, ia), ...stack.slice(1)];
              }
              default:
                  throw new MichelsonError(instruction, `unexpected instruction: ${instruction.prim}`);
          }
      })(instruction);
      if ((ctx === null || ctx === void 0 ? void 0 : ctx.traceCallback) !== undefined) {
          const trace = {
              op: instruction,
              in: stack,
              out: retStack,
          };
          ctx.traceCallback(trace);
      }
      return retStack;
  }
  function contractSection(contract, section) {
      for (const s of contract) {
          if (s.prim === section) {
              return s;
          }
      }
      throw new MichelsonError(contract, `missing contract section: ${section}`);
  }
  function contractViews(contract) {
      const views = {};
      for (const s of contract) {
          if (s.prim === 'view') {
              views[s.args[0].string] = s;
          }
      }
      return views;
  }
  function isContract(v) {
      if (Array.isArray(v)) {
          for (const s of v) {
              if ('prim' in s && (s.prim === 'parameter' || s.prim === 'storage' || s.prim === 'code')) {
                  return true;
              }
          }
      }
      return false;
  }
  function contractEntryPoint(src, ep) {
      ep = ep || '%default';
      const entryPoint = contractEntryPoints(src).find((x) => x[0] === ep);
      if (entryPoint !== undefined) {
          return entryPoint[1];
      }
      else if (ep === '%default') {
          return isContract(src) ? contractSection(src, 'parameter').args[0] : src;
      }
      return null;
  }
  function isOrType(t) {
      return Array.isArray(t) || t.prim === 'or';
  }
  function contractEntryPoints(src) {
      if (isContract(src)) {
          const param = contractSection(src, 'parameter');
          const ch = contractEntryPoints(param.args[0]);
          const a = unpackAnnotations(param);
          return a.f ? [[a.f[0], param.args[0]], ...ch] : ch;
      }
      if (isOrType(src)) {
          const args = typeArgs(src);
          const getArg = (n) => {
              const a = unpackAnnotations(args[n]);
              if (typeID(args[n]) === 'or') {
                  const ch = contractEntryPoints(args[n]);
                  return a.f ? [[a.f[0], args[n]], ...ch] : ch;
              }
              return a.f ? [[a.f[0], args[n]]] : [];
          };
          return [...getArg(0), ...getArg(1)];
      }
      return [];
  }
  // Contract validation
  function assertContractValid(contract, ctx) {
      const assertSection = (parameter, storage, ret, code) => {
          assertTypeAnnotationsValid(parameter, true);
          assertTypeAnnotationsValid(storage);
          const arg = {
              prim: 'pair',
              args: [
                  Object.assign(Object.assign({}, parameter), { annots: ['@parameter'] }),
                  Object.assign(Object.assign({}, storage), { annots: ['@storage'] }),
              ],
          };
          const out = functionTypeInternal(code, [arg], Object.assign(Object.assign({}, ctx), { contract }));
          if ('failed' in out) {
              return out;
          }
          try {
              assertStacksEqual(out, [ret]);
          }
          catch (err) {
              if (err instanceof MichelsonError) {
                  throw new MichelsonInstructionError(code, out, err.message);
              }
              else {
                  throw err;
              }
          }
          return out;
      };
      const parameter = contractSection(contract, 'parameter').args[0];
      const storage = contractSection(contract, 'storage').args[0];
      const code = contractSection(contract, 'code').args[0];
      const expected = {
          prim: 'pair',
          args: [{ prim: 'list', args: [{ prim: 'operation' }] }, storage],
      };
      const ret = assertSection(parameter, storage, expected, code);
      for (const view of Object.values(contractViews(contract))) {
          assertSection(view.args[1], storage, view.args[2], view.args[3]);
      }
      return ret;
  }
  // Exported wrapper functions
  function assertDataValid(d, t, ctx) {
      assertTypeAnnotationsValid(t);
      assertDataValidInternal(d, t, ctx || null);
  }
  function functionType(inst, stack, ctx) {
      for (const t of stack) {
          assertTypeAnnotationsValid(t);
      }
      if ((ctx === null || ctx === void 0 ? void 0 : ctx.contract) !== undefined) {
          for (const typesec of ['parameter', 'storage']) {
              const sec = contractSection(ctx.contract, typesec).args[0];
              assertTypeAnnotationsValid(sec);
          }
      }
      return functionTypeInternal(inst, stack, ctx || null);
  }
  function assertTypesEqual(a, b, field = false) {
      if (Array.isArray(a)) {
          // type guards don't work for parametrized generic types
          for (const v of a) {
              assertTypeAnnotationsValid(v);
          }
          for (const v of b) {
              assertTypeAnnotationsValid(v);
          }
      }
      else {
          assertTypeAnnotationsValid(a);
          assertTypeAnnotationsValid(b);
      }
      assertScalarTypesEqual(a, b, field);
  }
  function isTypeAnnotationsValid(t, field = false) {
      try {
          assertTypeAnnotationsValid(t, field);
          return true;
      }
      catch (_a) {
          return false;
      }
  }
  function isContractValid(contract, ctx) {
      try {
          return assertContractValid(contract, ctx);
      }
      catch (_a) {
          return null;
      }
  }
  function isDataValid(d, t, ctx) {
      try {
          assertDataValid(d, t, ctx);
          return true;
      }
      catch (_a) {
          return false;
      }
  }
  function isTypeEqual(a, b, field = false) {
      try {
          assertTypesEqual(a, b, field);
          return true;
      }
      catch (_a) {
          return false;
      }
  }

  class Contract {
      constructor(contract, opt) {
          this.contract = contract;
          this.ctx = Object.assign({ contract }, opt);
          this.output = assertContractValid(contract, this.ctx);
      }
      static parse(src, opt) {
          const p = new Parser(opt);
          const expr = typeof src === 'string' ? p.parseScript(src) : p.parseJSON(src);
          if (expr === null) {
              throw new InvalidContractError('empty contract');
          }
          if (assertMichelsonContract(expr)) {
              return new Contract(expr, opt);
          }
      }
      static parseTypeExpression(src, opt) {
          const p = new Parser(opt);
          const expr = typeof src === 'string' ? p.parseScript(src) : p.parseJSON(src);
          if (expr === null) {
              throw new InvalidTypeExpressionError('empty type expression');
          }
          // remove assertTypeAnnotationsValid from if block because: () => void || throw error
          if (assertMichelsonType(expr)) {
              assertTypeAnnotationsValid(expr);
              return expr;
          }
      }
      static parseDataExpression(src, opt) {
          const p = new Parser(opt);
          const expr = typeof src === 'string' ? p.parseScript(src) : p.parseJSON(src);
          if (expr === null) {
              throw new InvalidDataExpressionError('empty data expression');
          }
          if (assertMichelsonData(expr)) {
              return expr;
          }
          throw undefined;
      }
      section(section) {
          return contractSection(this.contract, section);
      }
      entryPoints() {
          return contractEntryPoints(this.contract);
      }
      entryPoint(ep) {
          return contractEntryPoint(this.contract, ep);
      }
      assertDataValid(d, t) {
          assertDataValid(d, t, this.ctx);
      }
      isDataValid(d, t) {
          return isDataValid(d, t, this.ctx);
      }
      assertParameterValid(ep, d) {
          const t = this.entryPoint(ep || undefined);
          if (t === null) {
              throw new InvalidEntrypointError(ep === null || ep === void 0 ? void 0 : ep.toString());
          }
          this.assertDataValid(d, t);
      }
      isParameterValid(ep, d) {
          try {
              this.assertParameterValid(ep, d);
              return true;
          }
          catch (_a) {
              return false;
          }
      }
      functionType(inst, stack) {
          return functionType(inst, stack, this.ctx);
      }
  }
  const dummyContract = new Contract([
      { prim: 'parameter', args: [{ prim: 'unit' }] },
      { prim: 'storage', args: [{ prim: 'unit' }] },
      {
          prim: 'code',
          args: [[{ prim: 'CAR' }, { prim: 'NIL', args: [{ prim: 'operation' }] }, { prim: 'PAIR' }]],
      },
  ]);

  function formatStack(s) {
      if ('failed' in s) {
          return `[FAILED: ${emitMicheline(s.failed)}]`;
      }
      return s
          .map((v, i) => {
          const ann = unpackAnnotations(v);
          return `[${i}${ann.v ? '/' + ann.v[0] : ''}]: ${emitMicheline(v)}`;
      })
          .join('\n');
  }
  function traceDumpFunc(blocks, cb) {
      return (v) => {
          var _a;
          if (Array.isArray(v) && !blocks) {
              return;
          }
          const macro = (_a = v.op[sourceReference]) === null || _a === void 0 ? void 0 : _a.macro;
          const msg = `${macro ? 'Macro' : 'Op'}: ${macro ? emitMicheline(macro, undefined, true) + ' / ' : ''}${emitMicheline(v.op)}
Input:
${formatStack(v.in)}
Output:
${formatStack(v.out)}
`;
          cb(msg);
      };
  }
  function formatError(err) {
      var _a;
      if (err instanceof MichelsonInstructionError) {
          const macro = (_a = err.val[sourceReference]) === null || _a === void 0 ? void 0 : _a.macro;
          return `${macro ? 'Macro' : 'Op'}: ${macro ? emitMicheline(macro, undefined, true) + ' / ' : ''}${emitMicheline(err.val)}
Stack:
${formatStack(err.stackState)}
`;
      }
      else if (err instanceof MichelsonTypeError) {
          const type = Array.isArray(err.val)
              ? '[' + err.val.map((v, i) => `[${i}]: ${emitMicheline(v)}`).join('; ') + ']'
              : emitMicheline(err.val);
          return `Type: ${type}
${err.data
            ? `Data: ${emitMicheline(err.data)}
`
            : ''}
`;
      }
      else {
          return `Value: ${emitMicheline(err.val)}`;
      }
  }

  // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
  const VERSION = {
      "commitHash": "178bea7c6a3b3c58f23163fcc72e28aa5f08702a",
      "version": "15.1.0"
  };

  exports.Contract = Contract;
  exports.DefaultProtocol = DefaultProtocol;
  exports.JSONParseError = JSONParseError;
  exports.MacroError = MacroError;
  exports.MichelineParseError = MichelineParseError;
  exports.MichelsonError = MichelsonError;
  exports.MichelsonInstructionError = MichelsonInstructionError;
  exports.MichelsonTypeError = MichelsonTypeError;
  exports.MichelsonValidationError = MichelsonValidationError;
  exports.Parser = Parser;
  exports.ProtoGreaterOfEqual = ProtoGreaterOfEqual;
  exports.ProtoInferiorTo = ProtoInferiorTo;
  exports.VERSION = VERSION;
  exports.assertContractValid = assertContractValid;
  exports.assertDataListIfAny = assertDataListIfAny;
  exports.assertDataValid = assertDataValid;
  exports.assertMichelsonBigMapStorableType = assertMichelsonBigMapStorableType;
  exports.assertMichelsonComparableType = assertMichelsonComparableType;
  exports.assertMichelsonContract = assertMichelsonContract;
  exports.assertMichelsonData = assertMichelsonData;
  exports.assertMichelsonInstruction = assertMichelsonInstruction;
  exports.assertMichelsonPackableType = assertMichelsonPackableType;
  exports.assertMichelsonPassableType = assertMichelsonPassableType;
  exports.assertMichelsonPushableType = assertMichelsonPushableType;
  exports.assertMichelsonStorableType = assertMichelsonStorableType;
  exports.assertMichelsonType = assertMichelsonType;
  exports.assertTypeAnnotationsValid = assertTypeAnnotationsValid;
  exports.assertTypesEqual = assertTypesEqual;
  exports.assertViewNameValid = assertViewNameValid;
  exports.contractEntryPoint = contractEntryPoint;
  exports.contractEntryPoints = contractEntryPoints;
  exports.contractSection = contractSection;
  exports.contractViews = contractViews;
  exports.decodeAddressBytes = decodeAddressBytes;
  exports.decodePublicKeyBytes = decodePublicKeyBytes;
  exports.decodePublicKeyHashBytes = decodePublicKeyHashBytes;
  exports.dummyContract = dummyContract;
  exports.emitMicheline = emitMicheline;
  exports.formatError = formatError;
  exports.formatStack = formatStack;
  exports.functionType = functionType;
  exports.instructionIDs = instructionIDs;
  exports.isContractValid = isContractValid;
  exports.isDataValid = isDataValid;
  exports.isInstruction = isInstruction;
  exports.isMichelsonCode = isMichelsonCode;
  exports.isMichelsonData = isMichelsonData;
  exports.isMichelsonError = isMichelsonError;
  exports.isMichelsonScript = isMichelsonScript;
  exports.isMichelsonType = isMichelsonType;
  exports.isTypeAnnotationsValid = isTypeAnnotationsValid;
  exports.isTypeEqual = isTypeEqual;
  exports.packData = packData;
  exports.packDataBytes = packDataBytes;
  exports.refContract = refContract;
  exports.sourceReference = sourceReference;
  exports.traceDumpFunc = traceDumpFunc;
  exports.unpackData = unpackData;
  exports.unpackDataBytes = unpackDataBytes;

  Object.defineProperty(exports, '__esModule', { value: true });

}));


},{}],202:[function(require,module,exports){
(function (Buffer){(function (){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('fast-json-stable-stringify'), require('bignumber.js'), require('@taquito/utils')) :
  typeof define === 'function' && define.amd ? define(['exports', 'fast-json-stable-stringify', 'bignumber.js', '@taquito/utils'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.taquitoMichelsonEncoder = {}, global.stringify, global.BigNumber, global.utils));
})(this, (function (exports, stringify, BigNumber, utils) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var stringify__default = /*#__PURE__*/_interopDefaultLegacy(stringify);
  var BigNumber__default = /*#__PURE__*/_interopDefaultLegacy(BigNumber);

  var _a$1;
  /**
   *  @category Error
   *  @description Error that indicates an invalid map type being passed or used
   */
  class InvalidMapTypeError extends Error {
      constructor(mapType) {
          super(`The map type '${mapType}' is invalid`);
          this.mapType = mapType;
          this.name = 'InvalidMapTypeError';
      }
  }
  // Retrieve a unique symbol associated with the key from the environment
  // Used in order to identify all object that are of type MichelsonMap even if they come from different module
  const michelsonMapTypeSymbol = Symbol.for('taquito-michelson-map-type-symbol');
  const isMapType = (value) => {
      return 'args' in value && Array.isArray(value.args) && value.args.length === 2;
  };
  /**
   *  @category Error
   *  @description Error that indicates a map type mismatch, where an attempt to set a key or value in a Map doesn't match the defined type of the Map
   */
  class MapTypecheckError extends Error {
      constructor(value, type, errorType) {
          super(`${errorType} not compliant with underlying michelson type`);
          this.value = value;
          this.type = type;
          this.name = 'MapTypecheckError';
      }
  }
  /**
   * @description Michelson Map is an abstraction over the michelson native map. It supports complex Pair as key
   */
  class MichelsonMap {
      /**
       * @param mapType If specified key and value will be type-checked before being added to the map
       *
       * @example new MichelsonMap({ prim: "map", args: [{prim: "string"}, {prim: "int"}]})
       */
      constructor(mapType) {
          this.valueMap = new Map();
          this.keyMap = new Map();
          this[_a$1] = true;
          if (mapType) {
              this.setType(mapType);
          }
      }
      // Used to check if an object is a michelson map.
      // Using instanceof was not working for project that had multiple instance of taquito dependencies
      // as the class constructor is different
      static isMichelsonMap(obj) {
          return obj && obj[michelsonMapTypeSymbol] === true;
      }
      setType(mapType) {
          if (!isMapType(mapType)) {
              throw new InvalidMapTypeError(mapType.toString());
          }
          this.keySchema = new Schema(mapType.args[0]);
          this.valueSchema = new Schema(mapType.args[1]);
      }
      removeType() {
          this.keySchema = undefined;
          this.valueSchema = undefined;
      }
      static fromLiteral(obj, mapType) {
          const map = new MichelsonMap(mapType);
          Object.keys(obj).forEach((key) => {
              map.set(key, obj[key]);
          });
          return map;
      }
      typecheckKey(key) {
          if (this.keySchema) {
              return this.keySchema.Typecheck(key);
          }
          return true;
      }
      typecheckValue(value) {
          if (this.valueSchema) {
              return this.valueSchema.Typecheck(value);
          }
          return true;
      }
      assertTypecheckValue(value) {
          if (!this.typecheckValue(value)) {
              throw new MapTypecheckError(value, this.valueSchema, 'value');
          }
      }
      assertTypecheckKey(key) {
          if (!this.typecheckKey(key)) {
              throw new MapTypecheckError(key, this.keySchema, 'key');
          }
      }
      serializeDeterministically(key) {
          return stringify__default["default"](key);
      }
      *keys() {
          for (const [key] of this.entries()) {
              yield key;
          }
      }
      *values() {
          for (const [, value] of this.entries()) {
              yield value;
          }
      }
      *entries() {
          for (const key of this.valueMap.keys()) {
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              yield [this.keyMap.get(key), this.valueMap.get(key)];
          }
      }
      get(key) {
          this.assertTypecheckKey(key);
          const strKey = this.serializeDeterministically(key);
          return this.valueMap.get(strKey);
      }
      /**
       *
       * @description Set a key and a value in the MichelsonMap. If the key already exists, override the current value.
       *
       * @example map.set("myKey", "myValue") // Using a string as key
       *
       * @example map.set({0: "test", 1: "test1"}, "myValue") // Using a pair as key
       *
       * @warn The same key can be represented in multiple ways, depending on the type of the key. This duplicate key situation will cause a runtime error (duplicate key) when sending the map data to the Tezos RPC node.
       *
       * For example, consider a contract with a map whose key is of type boolean.  If you set the following values in MichelsonMap: map.set(false, "myValue") and map.set(null, "myValue").
       *
       * You will get two unique entries in the MichelsonMap. These values will both be evaluated as falsy by the MichelsonEncoder and ultimately rejected by the Tezos RPC.
       */
      set(key, value) {
          this.assertTypecheckKey(key);
          this.assertTypecheckValue(value);
          const strKey = this.serializeDeterministically(key);
          this.keyMap.set(strKey, key);
          this.valueMap.set(strKey, value);
      }
      delete(key) {
          this.assertTypecheckKey(key);
          this.keyMap.delete(this.serializeDeterministically(key));
          this.valueMap.delete(this.serializeDeterministically(key));
      }
      has(key) {
          this.assertTypecheckKey(key);
          const strKey = this.serializeDeterministically(key);
          return this.keyMap.has(strKey) && this.valueMap.has(strKey);
      }
      clear() {
          this.keyMap.clear();
          this.valueMap.clear();
      }
      get size() {
          return this.keyMap.size;
      }
      forEach(cb) {
          for (const [key, value] of this.entries()) {
              cb(value, key, this);
          }
      }
  }
  _a$1 = michelsonMapTypeSymbol;

  /**
   *  @category Error
   *  @description Error that indicates a failure when encoding invalid or incorrect data (e.g. if an address is expected but a number is received)
   */
  class TokenValidationError extends Error {
      constructor(value, token, baseMessage) {
          super();
          this.value = value;
          this.token = token;
          this.name = 'ValidationError';
          const annot = this.token.annot();
          const annotText = annot ? `[${annot}] ` : '';
          this.message = `${annotText}${baseMessage}`;
      }
  }
  class Token {
      constructor(val, idx, fac) {
          this.val = val;
          this.idx = idx;
          this.fac = fac;
          this.createToken = this.fac;
      }
      typeWithoutAnnotations() {
          const handleMichelsonExpression = (val) => {
              if (typeof val === 'object') {
                  if (Array.isArray(val)) {
                      const array = val;
                      return array.map((item) => handleMichelsonExpression(item));
                  }
                  const extended = val;
                  if (extended.args) {
                      return {
                          prim: extended.prim,
                          args: extended.args.map((x) => handleMichelsonExpression(x)),
                      };
                  }
                  else {
                      return {
                          prim: extended.prim,
                      };
                  }
              }
              return val;
          };
          const handleMichelsonExtended = (val) => {
              if (val.args) {
                  return {
                      prim: val.prim,
                      args: val.args.map((x) => handleMichelsonExpression(x)),
                  };
              }
              else {
                  return {
                      prim: val.prim,
                  };
              }
          };
          return handleMichelsonExtended(this.val);
      }
      annot() {
          return (Array.isArray(this.val.annots) && this.val.annots.length > 0
              ? this.val.annots[0]
              : String(this.idx)).replace(/(%|:)(_Liq_entry_)?/, '');
      }
      hasAnnotations() {
          return Array.isArray(this.val.annots) && this.val.annots.length;
      }
      get tokenVal() {
          return this.val;
      }
      ExtractSignature() {
          return [[this.ExtractSchema()]];
      }
  }
  class ComparableToken extends Token {
      compare(o1, o2) {
          if (o1 === o2) {
              return 0;
          }
          return o1 < o2 ? -1 : 1;
      }
  }

  /**
   *  @category Error
   *  @description Error that indicates a failure happening when parsing encoding/executing Big Map types
   */
  class BigMapValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'BigMapValidationError';
      }
  }
  class BigMapToken extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      get ValueSchema() {
          return this.createToken(this.val.args[1], 0);
      }
      get KeySchema() {
          return this.createToken(this.val.args[0], 0);
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return {
              big_map: {
                  key: this.KeySchema.ExtractSchema(),
                  value: this.ValueSchema.ExtractSchema(),
              },
          };
      }
      generateSchema() {
          return {
              __michelsonType: BigMapToken.prim,
              schema: {
                  key: this.KeySchema.generateSchema(),
                  value: this.ValueSchema.generateSchema(),
              },
          };
      }
      isValid(value) {
          if (MichelsonMap.isMichelsonMap(value)) {
              return null;
          }
          return new BigMapValidationError(value, this, 'Value must be a MichelsonMap');
      }
      objLitToMichelsonMap(val) {
          if (val instanceof MichelsonMap)
              return val;
          if (typeof val === 'object') {
              if (Object.keys(val).length === 0) {
                  return new MichelsonMap();
              }
              else {
                  return MichelsonMap.fromLiteral(val);
              }
          }
          return val;
      }
      Encode(args) {
          const val = this.objLitToMichelsonMap(args.pop());
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          return Array.from(val.keys())
              .sort((a, b) => this.KeySchema.compare(a, b))
              .map((key) => {
              return {
                  prim: 'Elt',
                  args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))],
              };
          });
      }
      EncodeObject(args, semantic) {
          const val = this.objLitToMichelsonMap(args);
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          if (semantic && semantic[BigMapToken.prim]) {
              return semantic[BigMapToken.prim](val, this.val);
          }
          return Array.from(val.keys())
              .sort((a, b) => this.KeySchema.compare(a, b))
              .map((key) => {
              return {
                  prim: 'Elt',
                  args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))],
              };
          });
      }
      Execute(val, semantic) {
          if (semantic && semantic[BigMapToken.prim]) {
              return semantic[BigMapToken.prim](val, this.val);
          }
          if (Array.isArray(val)) {
              // Athens is returning an empty array for big map in storage
              // Internal: In taquito v5 it is still used to decode big map diff (as if they were a regular map)
              const map = new MichelsonMap(this.val);
              val.forEach((current) => {
                  map.set(this.KeySchema.ToKey(current.args[0]), this.ValueSchema.Execute(current.args[1]));
              });
              return map;
          }
          else if ('int' in val) {
              // Babylon is returning an int with the big map id in contract storage
              return val.int;
          }
          else {
              throw new BigMapValidationError(val, this, `Big map is expecting either an array (Athens) or an object with an int property (Babylon). Got ${JSON.stringify(val)}`);
          }
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (BigMapToken.prim === tokenToFind) {
              tokens.push(this);
          }
          this.KeySchema.findAndReturnTokens(tokenToFind, tokens);
          this.ValueSchema.findAndReturnTokens(tokenToFind, tokens);
          return tokens;
      }
  }
  BigMapToken.prim = 'big_map';

  /**
   *  @category Error
   *  @description Error that indicates a failure when decoding OR Token methods
   */
  class OrTokenDecodingError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'OrTokenDecodingError';
      }
  }
  class OrToken extends ComparableToken {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      Encode(args) {
          const label = args[args.length - 1];
          const leftToken = this.createToken(this.val.args[0], this.idx);
          let keyCount = 1;
          if (leftToken instanceof OrToken) {
              keyCount = Object.keys(leftToken.ExtractSchema()).length;
          }
          const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
          if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken)) {
              args.pop();
              return { prim: 'Left', args: [leftToken.Encode(args)] };
          }
          else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof OrToken)) {
              args.pop();
              return { prim: 'Right', args: [rightToken.Encode(args)] };
          }
          else {
              if (leftToken instanceof OrToken) {
                  const val = leftToken.Encode(args);
                  if (val) {
                      return { prim: 'Left', args: [val] };
                  }
              }
              if (rightToken instanceof OrToken) {
                  const val = rightToken.Encode(args);
                  if (val) {
                      return { prim: 'Right', args: [val] };
                  }
              }
              return null;
          }
      }
      ExtractSignature() {
          const leftToken = this.createToken(this.val.args[0], this.idx);
          let keyCount = 1;
          if (leftToken instanceof OrToken) {
              keyCount = Object.keys(leftToken.ExtractSchema()).length;
          }
          const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
          const newSig = [];
          if (leftToken instanceof OrToken) {
              newSig.push(...leftToken.ExtractSignature());
          }
          else {
              for (const sig of leftToken.ExtractSignature()) {
                  newSig.push([leftToken.annot(), ...sig]);
              }
          }
          if (rightToken instanceof OrToken) {
              newSig.push(...rightToken.ExtractSignature());
          }
          else {
              for (const sig of rightToken.ExtractSignature()) {
                  newSig.push([rightToken.annot(), ...sig]);
              }
          }
          return newSig;
      }
      EncodeObject(args, semantic) {
          const label = Object.keys(args)[0];
          const leftToken = this.createToken(this.val.args[0], this.idx);
          let keyCount = 1;
          if (leftToken instanceof OrToken) {
              keyCount = Object.keys(leftToken.ExtractSchema()).length;
          }
          const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
          if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken)) {
              return { prim: 'Left', args: [leftToken.EncodeObject(args[label], semantic)] };
          }
          else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof OrToken)) {
              return { prim: 'Right', args: [rightToken.EncodeObject(args[label], semantic)] };
          }
          else {
              if (leftToken instanceof OrToken) {
                  const val = leftToken.EncodeObject(args, semantic);
                  if (val) {
                      return { prim: 'Left', args: [val] };
                  }
              }
              if (rightToken instanceof OrToken) {
                  const val = rightToken.EncodeObject(args, semantic);
                  if (val) {
                      return { prim: 'Right', args: [val] };
                  }
              }
              return null;
          }
      }
      Execute(val, semantics) {
          const leftToken = this.createToken(this.val.args[0], this.idx);
          let keyCount = 1;
          if (leftToken instanceof OrToken) {
              keyCount = Object.keys(leftToken.ExtractSchema()).length;
          }
          const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
          if (val.prim === 'Right') {
              if (rightToken instanceof OrToken) {
                  return rightToken.Execute(val.args[0], semantics);
              }
              else {
                  return {
                      [rightToken.annot()]: rightToken.Execute(val.args[0], semantics),
                  };
              }
          }
          else if (val.prim === 'Left') {
              if (leftToken instanceof OrToken) {
                  return leftToken.Execute(val.args[0], semantics);
              }
              return {
                  [leftToken.annot()]: leftToken.Execute(val.args[0], semantics),
              };
          }
          else {
              throw new OrTokenDecodingError(`Was expecting Left or Right prim but got: ${val.prim}`);
          }
      }
      traversal(getLeftValue, getRightValue, concat) {
          const leftToken = this.createToken(this.val.args[0], this.idx);
          let keyCount = 1;
          let leftValue;
          if (leftToken instanceof OrToken && !leftToken.hasAnnotations()) {
              leftValue = getLeftValue(leftToken);
              keyCount = Object.keys(leftToken.ExtractSchema()).length;
          }
          else {
              leftValue = { [leftToken.annot()]: getLeftValue(leftToken) };
          }
          const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
          let rightValue;
          if (rightToken instanceof OrToken && !rightToken.hasAnnotations()) {
              rightValue = getRightValue(rightToken);
          }
          else {
              rightValue = { [rightToken.annot()]: getRightValue(rightToken) };
          }
          const res = concat(leftValue, rightValue);
          return res;
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return this.traversal((leftToken) => leftToken.ExtractSchema(), (rightToken) => rightToken.ExtractSchema(), (leftValue, rightValue) => (Object.assign(Object.assign({}, leftValue), rightValue)));
      }
      generateSchema() {
          return {
              __michelsonType: OrToken.prim,
              schema: this.traversal((leftToken) => {
                  if (leftToken instanceof OrToken && !leftToken.hasAnnotations()) {
                      return leftToken.generateSchema().schema;
                  }
                  else {
                      return leftToken.generateSchema();
                  }
              }, (rightToken) => {
                  if (rightToken instanceof OrToken && !rightToken.hasAnnotations()) {
                      return rightToken.generateSchema().schema;
                  }
                  else {
                      return rightToken.generateSchema();
                  }
              }, (leftValue, rightValue) => (Object.assign(Object.assign({}, leftValue), rightValue))),
          };
      }
      findToken(label) {
          const leftToken = this.createToken(this.val.args[0], this.idx);
          let keyCount = 1;
          if (leftToken instanceof OrToken) {
              keyCount = Object.keys(leftToken.ExtractSchema()).length;
          }
          const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
          if (String(leftToken.annot()) === String(label) &&
              !(leftToken instanceof OrToken) &&
              leftToken instanceof ComparableToken) {
              return leftToken;
          }
          else if (String(rightToken.annot()) === String(label) &&
              !(rightToken instanceof OrToken) &&
              rightToken instanceof ComparableToken) {
              return rightToken;
          }
          else {
              if (leftToken instanceof OrToken) {
                  const tok = leftToken.findToken(label);
                  if (tok) {
                      return tok;
                  }
              }
              if (rightToken instanceof OrToken) {
                  const tok = rightToken.findToken(label);
                  if (tok) {
                      return tok;
                  }
              }
              return null;
          }
      }
      compare(val1, val2) {
          const labelVal1 = Object.keys(val1)[0];
          const labelVal2 = Object.keys(val2)[0];
          if (labelVal1 === labelVal2) {
              const token = this.findToken(labelVal1);
              if (token instanceof ComparableToken) {
                  return token.compare(val1[labelVal1], val2[labelVal1]);
              }
          }
          else {
              const encoded1 = JSON.stringify(this.EncodeObject(val1));
              const encoded2 = JSON.stringify(this.EncodeObject(val2));
              return encoded1 < encoded2 ? -1 : 1;
          }
      }
      ToKey(val) {
          return this.Execute(val);
      }
      ToBigMapKey(val) {
          return {
              key: this.EncodeObject(val),
              type: this.typeWithoutAnnotations(),
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (OrToken.prim === tokenToFind) {
              tokens.push(this);
          }
          this.traversal((leftToken) => leftToken.findAndReturnTokens(tokenToFind, tokens), (rightToken) => rightToken.findAndReturnTokens(tokenToFind, tokens), (leftValue, rightValue) => (Object.assign(Object.assign({}, leftValue), rightValue)));
          return tokens;
      }
  }
  OrToken.prim = 'or';

  /**
   *  @category Error
   *  @description Error that indicates in invalid token argument being passed
   */
  class TokenArgumentValidationError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'TokenArgumentValidationError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates a failure occurring when doing a comparison of tokens
   */
  class TokenComparisonError extends Error {
      constructor(val1, val2) {
          super(`Tokens ${val1} and ${val2} are not comparable`);
          this.val1 = val1;
          this.val2 = val2;
          this.name = 'TokenComparisonError';
      }
  }
  // collapse comb pair
  function collapse$1(val, prim = PairToken.prim) {
      if (Array.isArray(val)) {
          return collapse$1({
              prim: prim,
              args: val,
          }, prim);
      }
      if (val.args === undefined) {
          throw new TokenArgumentValidationError('Encountered an invalid PairToken with no arguments, a pair must have two or more arguments');
      }
      if (val.args.length > 2) {
          return [
              val.args[0],
              {
                  prim: prim,
                  args: val.args.slice(1),
              },
          ];
      }
      return [val.args[0], val.args[1]];
  }
  class PairToken extends ComparableToken {
      constructor(val, idx, fac) {
          super(Array.isArray(val)
              ? {
                  prim: PairToken.prim,
                  args: val,
              }
              : val.prim
                  ? val
                  : {
                      prim: PairToken.prim,
                      args: val,
                  }, idx, fac);
      }
      args() {
          // collapse comb pair
          return collapse$1(this.val);
      }
      tokens() {
          let cnt = 0;
          return this.args().map((a) => {
              const tok = this.createToken(a, this.idx + cnt);
              if (tok instanceof PairToken) {
                  cnt += Object.keys(tok.ExtractSchema()).length;
              }
              else {
                  cnt++;
              }
              return tok;
          });
      }
      Encode(args) {
          return {
              prim: 'Pair',
              args: this.tokens().map((t) => t.Encode(args)),
          };
      }
      ExtractSignature() {
          const args = this.args();
          const leftToken = this.createToken(args[0], this.idx);
          let keyCount = 1;
          if (leftToken instanceof OrToken) {
              keyCount = Object.keys(leftToken.ExtractSchema()).length;
          }
          const rightToken = this.createToken(args[1], this.idx + keyCount);
          const newSig = [];
          for (const leftSig of leftToken.ExtractSignature()) {
              for (const rightSig of rightToken.ExtractSignature()) {
                  newSig.push([...leftSig, ...rightSig]);
              }
          }
          return newSig;
      }
      ToBigMapKey(val) {
          return {
              key: this.EncodeObject(val),
              type: this.typeWithoutAnnotations(),
          };
      }
      ToKey(val) {
          return this.Execute(val);
      }
      EncodeObject(args, semantic) {
          const [leftToken, rightToken] = this.tokens();
          let leftValue;
          if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {
              leftValue = args;
          }
          else {
              leftValue = args[leftToken.annot()];
          }
          let rightValue;
          if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {
              rightValue = args;
          }
          else {
              rightValue = args[rightToken.annot()];
          }
          return {
              prim: 'Pair',
              args: [
                  leftToken.EncodeObject(leftValue, semantic),
                  rightToken.EncodeObject(rightValue, semantic),
              ],
          };
      }
      traversal(getLeftValue, getRightValue) {
          const args = this.args();
          const leftToken = this.createToken(args[0], this.idx);
          let keyCount = 1;
          let leftValue;
          if (leftToken instanceof PairToken) {
              keyCount = Object.keys(leftToken.ExtractSchema()).length;
          }
          if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {
              leftValue = getLeftValue(leftToken);
          }
          else {
              leftValue = { [leftToken.annot()]: getLeftValue(leftToken) };
          }
          const rightToken = this.createToken(args[1], this.idx + keyCount);
          let rightValue;
          if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {
              rightValue = getRightValue(rightToken);
          }
          else {
              rightValue = { [rightToken.annot()]: getRightValue(rightToken) };
          }
          const res = Object.assign(Object.assign({}, leftValue), rightValue);
          return res;
      }
      Execute(val, semantics) {
          const args = collapse$1(val, 'Pair');
          return this.traversal((leftToken) => leftToken.Execute(args[0], semantics), (rightToken) => rightToken.Execute(args[1], semantics));
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return this.traversal((leftToken) => leftToken.ExtractSchema(), (rightToken) => rightToken.ExtractSchema());
      }
      generateSchema() {
          return {
              __michelsonType: PairToken.prim,
              schema: this.traversal((leftToken) => {
                  if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {
                      return leftToken.generateSchema().schema;
                  }
                  else {
                      return leftToken.generateSchema();
                  }
              }, (rightToken) => {
                  if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {
                      return rightToken.generateSchema().schema;
                  }
                  else {
                      return rightToken.generateSchema();
                  }
              }),
          };
      }
      compare(val1, val2) {
          const [leftToken, rightToken] = this.tokens();
          const getValue = (token, args) => {
              if (token instanceof PairToken && !token.hasAnnotations()) {
                  return args;
              }
              else {
                  return args[token.annot()];
              }
          };
          if (leftToken instanceof ComparableToken && rightToken instanceof ComparableToken) {
              const result = leftToken.compare(getValue(leftToken, val1), getValue(leftToken, val2));
              if (result === 0) {
                  return rightToken.compare(getValue(rightToken, val1), getValue(rightToken, val2));
              }
              return result;
          }
          throw new TokenComparisonError(val1, val2);
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (PairToken.prim === tokenToFind) {
              tokens.push(this);
          }
          this.tokens().map((t) => t.findAndReturnTokens(tokenToFind, tokens));
          return tokens;
      }
  }
  PairToken.prim = 'pair';

  class NatValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'NatValidationError';
      }
  }
  class NatToken extends ComparableToken {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      Execute(val) {
          return new BigNumber__default["default"](val[Object.keys(val)[0]]);
      }
      Encode(args) {
          const val = args.pop();
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          return { int: new BigNumber__default["default"](val).toFixed() };
      }
      isValid(val) {
          const bigNumber = new BigNumber__default["default"](val);
          if (bigNumber.isNaN()) {
              return new NatValidationError(val, this, `Value is not a number: ${val}`);
          }
          else if (bigNumber.isNegative()) {
              return new NatValidationError(val, this, `Value cannot be negative: ${val}`);
          }
          else {
              return null;
          }
      }
      EncodeObject(val, semantic) {
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          if (semantic && semantic[NatToken.prim]) {
              return semantic[NatToken.prim](val);
          }
          return { int: new BigNumber__default["default"](val).toFixed() };
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return NatToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: NatToken.prim,
              schema: NatToken.prim,
          };
      }
      ToBigMapKey(val) {
          return {
              key: { int: String(val) },
              type: { prim: NatToken.prim },
          };
      }
      ToKey({ int }) {
          return new BigNumber__default["default"](int);
      }
      compare(nat1, nat2) {
          const o1 = Number(nat1);
          const o2 = Number(nat2);
          if (o1 === o2) {
              return 0;
          }
          return o1 < o2 ? -1 : 1;
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (NatToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  NatToken.prim = 'nat';

  class StringToken extends ComparableToken {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      Execute(val) {
          return val[Object.keys(val)[0]];
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return StringToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: StringToken.prim,
              schema: StringToken.prim,
          };
      }
      Encode(args) {
          const val = args.pop();
          return { string: val };
      }
      EncodeObject(val, semantic) {
          if (semantic && semantic[StringToken.prim]) {
              return semantic[StringToken.prim](val);
          }
          return { string: val };
      }
      ToKey({ string }) {
          return string;
      }
      ToBigMapKey(val) {
          return {
              key: { string: val },
              type: { prim: StringToken.prim },
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (StringToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  StringToken.prim = 'string';

  class AddressValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'AddressValidationError';
      }
  }
  class AddressToken extends ComparableToken {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      ToBigMapKey(val) {
          const decoded = utils.b58decode(val);
          return {
              key: { bytes: decoded },
              type: { prim: 'bytes' },
          };
      }
      isValid(value) {
          if (utils.validateAddress(value) !== utils.ValidationResult.VALID) {
              return new AddressValidationError(value, this, `Address is not valid: ${value}`);
          }
          return null;
      }
      Encode(args) {
          const val = args.pop();
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          return { string: val };
      }
      EncodeObject(val, semantic) {
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          if (semantic && semantic[AddressToken.prim]) {
              return semantic[AddressToken.prim](val);
          }
          return { string: val };
      }
      Execute(val) {
          if (val.string) {
              return val.string;
          }
          if (!val.bytes) {
              throw new AddressValidationError(val, this, `cannot be missing both string and bytes: ${val}`);
          }
          return utils.encodePubKey(val.bytes);
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return AddressToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: AddressToken.prim,
              schema: AddressToken.prim,
          };
      }
      ToKey({ bytes, string }) {
          if (string) {
              return string;
          }
          if (!bytes) {
              throw new AddressValidationError({ bytes, string }, this, `cannot be missing both string and bytes ${{ string, bytes }}`);
          }
          return utils.encodePubKey(bytes);
      }
      compare(address1, address2) {
          const isImplicit = (address) => {
              return address.startsWith('tz');
          };
          const implicit1 = isImplicit(address1);
          const implicit2 = isImplicit(address2);
          if (implicit1 && !implicit2) {
              return -1;
          }
          else if (implicit2 && !implicit1) {
              return 1;
          }
          return super.compare(address1, address2);
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (AddressToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  AddressToken.prim = 'address';

  class MapValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'MapValidationError';
      }
  }
  class MapToken extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      get ValueSchema() {
          return this.createToken(this.val.args[1], 0);
      }
      get KeySchema() {
          return this.createToken(this.val.args[0], 0);
      }
      isValid(value) {
          if (MichelsonMap.isMichelsonMap(value)) {
              return null;
          }
          return new MapValidationError(value, this, 'Value must be a MichelsonMap');
      }
      Execute(val, semantics) {
          const map = new MichelsonMap(this.val);
          val.forEach((current) => {
              map.set(this.KeySchema.ToKey(current.args[0]), this.ValueSchema.Execute(current.args[1], semantics));
          });
          return map;
      }
      objLitToMichelsonMap(val) {
          if (val instanceof MichelsonMap)
              return val;
          if (typeof val === 'object') {
              if (Object.keys(val).length === 0) {
                  return new MichelsonMap();
              }
              else {
                  return MichelsonMap.fromLiteral(val);
              }
          }
          return val;
      }
      Encode(args) {
          const val = this.objLitToMichelsonMap(args.pop());
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          return Array.from(val.keys())
              .sort((a, b) => this.KeySchema.compare(a, b))
              .map((key) => {
              return {
                  prim: 'Elt',
                  args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))],
              };
          });
      }
      EncodeObject(args, semantic) {
          const val = this.objLitToMichelsonMap(args);
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          if (semantic && semantic[MapToken.prim]) {
              return semantic[MapToken.prim](val);
          }
          return Array.from(val.keys())
              .sort((a, b) => this.KeySchema.compare(a, b))
              .map((key) => {
              return {
                  prim: 'Elt',
                  args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))],
              };
          });
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return {
              map: {
                  key: this.KeySchema.ExtractSchema(),
                  value: this.ValueSchema.ExtractSchema(),
              },
          };
      }
      generateSchema() {
          return {
              __michelsonType: MapToken.prim,
              schema: {
                  key: this.KeySchema.generateSchema(),
                  value: this.ValueSchema.generateSchema(),
              },
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (MapToken.prim === tokenToFind) {
              tokens.push(this);
          }
          this.KeySchema.findAndReturnTokens(tokenToFind, tokens);
          this.ValueSchema.findAndReturnTokens(tokenToFind, tokens);
          return tokens;
      }
  }
  MapToken.prim = 'map';

  class BoolToken extends ComparableToken {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      Execute(val) {
          return String(val.prim).toLowerCase() === 'true' ? true : false;
      }
      Encode(args) {
          const val = args.pop();
          return { prim: val ? 'True' : 'False' };
      }
      EncodeObject(val, semantic) {
          if (semantic && semantic[BoolToken.prim]) {
              return semantic[BoolToken.prim](val);
          }
          return { prim: val ? 'True' : 'False' };
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return BoolToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: BoolToken.prim,
              schema: BoolToken.prim,
          };
      }
      ToBigMapKey(val) {
          return {
              key: this.EncodeObject(val),
              type: { prim: BoolToken.prim },
          };
      }
      ToKey(val) {
          return this.EncodeObject(val);
      }
      compare(val1, val2) {
          if ((val1 && val2) || (!val1 && !val2)) {
              return 0;
          }
          else if (val1) {
              return 1;
          }
          else {
              return -1;
          }
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (BoolToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  BoolToken.prim = 'bool';

  class TxRollupL2AddressValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'TxRollupL2AddressValidationError';
      }
  }
  class TxRollupL2AddressToken extends ComparableToken {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      ToBigMapKey(val) {
          const decoded = utils.b58decodeL2Address(val);
          return {
              key: { bytes: decoded },
              type: { prim: 'bytes' },
          };
      }
      isValid(value) {
          if (utils.validateAddress(value) !== utils.ValidationResult.VALID) {
              throw new TxRollupL2AddressValidationError(value, this, `tx_rollup_l2_address is not valid: ${value}`);
          }
          return null;
      }
      Encode(args) {
          const val = args.pop();
          if (!val) {
              throw new TxRollupL2AddressValidationError(val, this, `arg missing to encode: this -> "${val}"`);
          }
          // no need to test since method throws
          this.isValid(val);
          return { string: val };
      }
      EncodeObject(val, semantic) {
          // no need to test since method throws
          this.isValid(val);
          if (semantic && semantic[TxRollupL2AddressToken.prim]) {
              return semantic[TxRollupL2AddressToken.prim](val);
          }
          return { string: val };
      }
      Execute(val) {
          if (val.string) {
              return val.string;
          }
          if (!val.bytes) {
              throw new TxRollupL2AddressValidationError(val, this, `value cannot be missing string and byte value. must have one ${JSON.stringify(val)}`);
          }
          return utils.encodeL2Address(val.bytes);
      }
      ExtractSchema() {
          return TxRollupL2AddressToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: TxRollupL2AddressToken.prim,
              schema: TxRollupL2AddressToken.prim,
          };
      }
      ToKey({ bytes, string }) {
          if (string) {
              return string;
          }
          if (!bytes) {
              throw new TxRollupL2AddressValidationError(bytes, this, `value cannot be missing string and byte value. must have one: bytes = ${bytes}`);
          }
          return utils.encodeL2Address(bytes);
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (TxRollupL2AddressToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  TxRollupL2AddressToken.prim = 'tx_rollup_l2_address';

  class ContractValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'ContractValidationError';
      }
  }
  class ContractToken extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      isValid(value) {
          // tz1,tz2 and tz3 seems to be valid contract values (for Unit contract)
          if (utils.validateAddress(value) !== utils.ValidationResult.VALID) {
              return new ContractValidationError(value, this, 'Contract address is not valid');
          }
          return null;
      }
      Execute(val) {
          if (val.string) {
              return val.string;
          }
          if (!val.bytes) {
              throw new ContractValidationError(val, this, 'must contain bytes or string');
          }
          return utils.encodePubKey(val.bytes);
      }
      Encode(args) {
          const val = args.pop();
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          return { string: val };
      }
      EncodeObject(val, semantic) {
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          if (semantic && semantic[ContractToken.prim]) {
              return semantic[ContractToken.prim](val);
          }
          return { string: val };
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return ContractToken.prim;
      }
      generateSchema() {
          const valueSchema = this.createToken(this.val.args[0], 0);
          return {
              __michelsonType: ContractToken.prim,
              schema: {
                  parameter: this.val.args[0] ? valueSchema.generateSchema() : {},
              },
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (ContractToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  ContractToken.prim = 'contract';

  class ListValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'ListValidationError';
      }
  }
  class ListToken extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      get valueSchema() {
          return this.createToken(this.val.args[0], this.idx);
      }
      isValid(value) {
          if (Array.isArray(value)) {
              return null;
          }
          return new ListValidationError(value, this, 'Value must be an array');
      }
      Encode(args) {
          const val = args.pop();
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          const schema = this.createToken(this.val.args[0], 0);
          return val.reduce((prev, current) => {
              return [...prev, schema.EncodeObject(current)];
          }, []);
      }
      Execute(val, semantics) {
          const schema = this.createToken(this.val.args[0], 0);
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          return val.reduce((prev, current) => {
              return [...prev, schema.Execute(current, semantics)];
          }, []);
      }
      EncodeObject(args, semantic) {
          const schema = this.createToken(this.val.args[0], 0);
          const err = this.isValid(args);
          if (err) {
              throw err;
          }
          if (semantic && semantic[ListToken.prim]) {
              return semantic[ListToken.prim](args);
          }
          return args.reduce((prev, current) => {
              return [...prev, schema.EncodeObject(current)];
          }, []);
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return {
              [ListToken.prim]: this.valueSchema.ExtractSchema(),
          };
      }
      generateSchema() {
          return {
              __michelsonType: ListToken.prim,
              schema: this.valueSchema.generateSchema(),
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (ListToken.prim === tokenToFind) {
              tokens.push(this);
          }
          this.createToken(this.val.args[0], this.idx).findAndReturnTokens(tokenToFind, tokens);
          return tokens;
      }
  }
  ListToken.prim = 'list';

  class MutezValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'MutezValidationError';
      }
  }
  class MutezToken extends ComparableToken {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      Execute(val) {
          return new BigNumber__default["default"](val[Object.keys(val)[0]]);
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return MutezToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: MutezToken.prim,
              schema: MutezToken.prim,
          };
      }
      isValid(val) {
          const bigNumber = new BigNumber__default["default"](val);
          if (bigNumber.isNaN()) {
              return new MutezValidationError(val, this, `Value is not a number: ${val}`);
          }
          else {
              return null;
          }
      }
      Encode(args) {
          const val = args.pop();
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          return { int: String(val).toString() };
      }
      EncodeObject(val, semantic) {
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          if (semantic && semantic[MutezToken.prim]) {
              return semantic[MutezToken.prim](val);
          }
          return { int: String(val).toString() };
      }
      ToBigMapKey(val) {
          return {
              key: { int: String(val) },
              type: { prim: MutezToken.prim },
          };
      }
      ToKey({ int }) {
          return int;
      }
      compare(mutez1, mutez2) {
          const o1 = Number(mutez1);
          const o2 = Number(mutez2);
          if (o1 === o2) {
              return 0;
          }
          return o1 < o2 ? -1 : 1;
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (MutezToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  MutezToken.prim = 'mutez';

  class BytesValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'BytesValidationError';
      }
  }
  class BytesToken extends ComparableToken {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      ToBigMapKey(val) {
          return {
              key: { bytes: val },
              type: { prim: BytesToken.prim },
          };
      }
      isValid(val) {
          if (typeof val === 'string' && /^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
              return null;
          }
          else {
              return new BytesValidationError(val, this, `Invalid bytes: ${val}`);
          }
      }
      convertUint8ArrayToHexString(val) {
          return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;
      }
      Encode(args) {
          let val = args.pop();
          val = utils.stripHexPrefix(this.convertUint8ArrayToHexString(val));
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          return { bytes: String(val).toString() };
      }
      EncodeObject(val, semantic) {
          val = this.convertUint8ArrayToHexString(val);
          if (typeof val === 'string') {
              val = utils.stripHexPrefix(val);
          }
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          if (semantic && semantic[BytesToken.prim]) {
              return semantic[BytesToken.prim](val);
          }
          return { bytes: String(val).toString() };
      }
      Execute(val) {
          return val.bytes;
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return BytesToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: BytesToken.prim,
              schema: BytesToken.prim,
          };
      }
      ToKey({ bytes, string }) {
          if (string) {
              return string;
          }
          return bytes;
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (BytesToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  BytesToken.prim = 'bytes';

  class OptionToken extends ComparableToken {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      subToken() {
          return this.createToken(this.val.args[0], this.idx);
      }
      schema() {
          return this.createToken(this.val.args[0], 0);
      }
      annot() {
          return Array.isArray(this.val.annots)
              ? super.annot()
              : this.createToken(this.val.args[0], this.idx).annot();
      }
      Encode(args) {
          const value = args;
          if (value === undefined || value === null) {
              return { prim: 'None' };
          }
          else if (Array.isArray(value) &&
              (value[value.length - 1] === undefined || value[value.length - 1] === null)) {
              value.pop();
              return { prim: 'None' };
          }
          return { prim: 'Some', args: [this.schema().Encode(args)] };
      }
      EncodeObject(args, semantic) {
          const value = args;
          if (value === undefined || value === null) {
              return { prim: 'None' };
          }
          return { prim: 'Some', args: [this.schema().EncodeObject(value, semantic)] };
      }
      Execute(val, semantics) {
          if (val.prim === 'None') {
              return null;
          }
          return this.schema().Execute(val.args[0], semantics);
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return this.schema().ExtractSchema();
      }
      generateSchema() {
          return {
              __michelsonType: OptionToken.prim,
              schema: this.schema().generateSchema(),
          };
      }
      ExtractSignature() {
          return [...this.schema().ExtractSignature(), []];
      }
      get KeySchema() {
          return this.schema();
      }
      compare(val1, val2) {
          if (!val1) {
              return -1;
          }
          else if (!val2) {
              return 1;
          }
          return this.KeySchema.compare(val1, val2);
      }
      ToKey(val) {
          return this.Execute(val);
      }
      ToBigMapKey(val) {
          return {
              key: this.EncodeObject(val),
              type: this.typeWithoutAnnotations(),
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (OptionToken.prim === tokenToFind) {
              tokens.push(this);
          }
          this.subToken().findAndReturnTokens(tokenToFind, tokens);
          return tokens;
      }
  }
  OptionToken.prim = 'option';

  class TimestampToken extends ComparableToken {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      Execute(val) {
          if (val.string && /^\d+$/.test(val.string)) {
              return new Date(Number(val.string) * 1000).toISOString();
          }
          else if (val.string) {
              return new Date(val.string).toISOString();
          }
          else if (val.int) {
              return new Date(Number(val.int) * 1000).toISOString();
          }
      }
      Encode(args) {
          const val = args.pop();
          if (typeof val === 'number') {
              return { int: String(val) };
          }
          else {
              return { string: val };
          }
      }
      EncodeObject(val, semantic) {
          if (semantic && semantic[TimestampToken.prim]) {
              return semantic[TimestampToken.prim](val);
          }
          if (typeof val === 'number') {
              return { int: String(val) };
          }
          else {
              return { string: val };
          }
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return TimestampToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: TimestampToken.prim,
              schema: TimestampToken.prim,
          };
      }
      ToKey({ string }) {
          return string;
      }
      ToBigMapKey(val) {
          return {
              key: { string: val },
              type: { prim: TimestampToken.prim },
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (TimestampToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  TimestampToken.prim = 'timestamp';

  class IntValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'IntValidationError';
      }
  }
  class IntToken extends ComparableToken {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      Execute(val) {
          return new BigNumber__default["default"](val[Object.keys(val)[0]]);
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return IntToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: IntToken.prim,
              schema: IntToken.prim,
          };
      }
      isValid(val) {
          const bigNumber = new BigNumber__default["default"](val);
          if (bigNumber.isNaN()) {
              return new IntValidationError(val, this, `Value is not a number: ${val}`);
          }
          else {
              return null;
          }
      }
      Encode(args) {
          const val = args.pop();
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          return { int: new BigNumber__default["default"](val).toFixed() };
      }
      EncodeObject(val, semantic) {
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          if (semantic && semantic[IntToken.prim]) {
              return semantic[IntToken.prim](val);
          }
          return { int: new BigNumber__default["default"](val).toFixed() };
      }
      ToBigMapKey(val) {
          return {
              key: { int: String(val) },
              type: { prim: IntToken.prim },
          };
      }
      ToKey({ int }) {
          return int;
      }
      compare(int1, int2) {
          const o1 = Number(int1);
          const o2 = Number(int2);
          if (o1 === o2) {
              return 0;
          }
          return o1 < o2 ? -1 : 1;
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (IntToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  IntToken.prim = 'int';

  class UnitToken extends ComparableToken {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      Encode(args) {
          args.pop();
          return { prim: 'Unit' };
      }
      EncodeObject(val, semantic) {
          if (semantic && semantic[UnitToken.prim]) {
              return semantic[UnitToken.prim](val);
          }
          return { prim: 'Unit' };
      }
      Execute(_val) {
          return UnitValue;
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return UnitToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: UnitToken.prim,
              schema: UnitToken.prim,
          };
      }
      compare(_val1, _val2) {
          return 0;
      }
      ToKey(_val) {
          return UnitValue;
      }
      ToBigMapKey(_val) {
          return {
              key: { prim: 'Unit' },
              type: { prim: UnitToken.prim },
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (UnitToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  UnitToken.prim = 'unit';

  const publicKeyPrefixLength = 4;
  class KeyValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'KeyValidationError';
      }
  }
  class KeyToken extends ComparableToken {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      Execute(val) {
          if (val.string) {
              return val.string;
          }
          return utils.encodeKey(val.bytes);
      }
      isValid(value) {
          if (utils.validatePublicKey(value) !== utils.ValidationResult.VALID) {
              return new KeyValidationError(value, this, 'Key is not valid');
          }
          return null;
      }
      Encode(args) {
          const val = args.pop();
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          return { string: val };
      }
      EncodeObject(val, semantic) {
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          if (semantic && semantic[KeyToken.prim]) {
              return semantic[KeyToken.prim](val);
          }
          return { string: val };
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return KeyToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: KeyToken.prim,
              schema: KeyToken.prim,
          };
      }
      ToKey(val) {
          return this.Execute(val);
      }
      ToBigMapKey(val) {
          return {
              key: { string: val },
              type: { prim: KeyToken.prim },
          };
      }
      compare(key1, key2) {
          const keyPrefix1 = this.getPrefix(key1);
          const keyPrefix2 = this.getPrefix(key2);
          if (keyPrefix1 === utils.Prefix.EDPK && keyPrefix2 !== utils.Prefix.EDPK) {
              return -1;
          }
          else if (keyPrefix1 === utils.Prefix.SPPK && keyPrefix2 !== utils.Prefix.SPPK) {
              return keyPrefix2 === utils.Prefix.EDPK ? 1 : -1;
          }
          else if (keyPrefix1 === utils.Prefix.P2PK) {
              if (keyPrefix2 !== utils.Prefix.P2PK) {
                  return 1;
              }
              const keyBytes1 = this.getP256PublicKeyComparableBytes(key1);
              const keyBytes2 = this.getP256PublicKeyComparableBytes(key2);
              return Buffer.compare(keyBytes1, keyBytes2);
          }
          return super.compare(key1, key2);
      }
      getPrefix(val) {
          return val.substring(0, publicKeyPrefixLength);
      }
      getP256PublicKeyComparableBytes(p2pk) {
          return utils.b58cdecode(p2pk, utils.prefix[utils.Prefix.P2PK]).slice(1);
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (KeyToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  KeyToken.prim = 'key';

  class KeyHashValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'KeyHashValidationError';
      }
  }
  class KeyHashToken extends ComparableToken {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      Execute(val) {
          if (val.string) {
              return val.string;
          }
          return utils.encodeKeyHash(val.bytes);
      }
      isValid(value) {
          if (utils.validateKeyHash(value) !== utils.ValidationResult.VALID) {
              return new KeyHashValidationError(value, this, `KeyHash is not valid: ${value}`);
          }
          return null;
      }
      Encode(args) {
          const val = args.pop();
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          return { string: val };
      }
      EncodeObject(val, semantic) {
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          if (semantic && semantic[KeyHashToken.prim]) {
              return semantic[KeyHashToken.prim](val);
          }
          return { string: val };
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return KeyHashToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: KeyHashToken.prim,
              schema: KeyHashToken.prim,
          };
      }
      ToKey({ string, bytes }) {
          if (string) {
              return string;
          }
          return utils.encodeKeyHash(bytes);
      }
      ToBigMapKey(val) {
          return {
              key: { string: val },
              type: { prim: KeyHashToken.prim },
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (KeyHashToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  KeyHashToken.prim = 'key_hash';

  class SignatureValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'SignatureValidationError';
      }
  }
  class SignatureToken extends ComparableToken {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      Execute(val) {
          if (val.string) {
              return val.string;
          }
          // TODO decode the signature
          return val.bytes;
      }
      isValid(value) {
          if (utils.validateSignature(value) !== utils.ValidationResult.VALID) {
              return new SignatureValidationError(value, this, 'Signature is not valid');
          }
          return null;
      }
      Encode(args) {
          const val = args.pop();
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          return { string: val };
      }
      EncodeObject(val, semantic) {
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          if (semantic && semantic[SignatureToken.prim]) {
              return semantic[SignatureToken.prim](val);
          }
          return { string: val };
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return SignatureToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: SignatureToken.prim,
              schema: SignatureToken.prim,
          };
      }
      ToKey(val) {
          return this.Execute(val);
      }
      ToBigMapKey(val) {
          return {
              key: { string: val },
              type: { prim: SignatureToken.prim },
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (SignatureToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  SignatureToken.prim = 'signature';

  class LambdaToken extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      get paramSchema() {
          return this.createToken(this.val.args[0], this.idx);
      }
      get returnSchema() {
          return this.createToken(this.val.args[1], this.idx + 1);
      }
      Execute(val) {
          if (val.string) {
              return val.string;
          }
          else {
              return val;
          }
      }
      Encode(args) {
          const val = args.pop();
          return val;
      }
      EncodeObject(val, semantic) {
          if (semantic && semantic[LambdaToken.prim]) {
              return semantic[LambdaToken.prim](val);
          }
          return val;
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return {
              [LambdaToken.prim]: {
                  parameters: this.paramSchema.ExtractSchema(),
                  returns: this.returnSchema.ExtractSchema(),
              },
          };
      }
      generateSchema() {
          return {
              __michelsonType: LambdaToken.prim,
              schema: {
                  parameters: this.paramSchema.generateSchema(),
                  returns: this.returnSchema.generateSchema(),
              },
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (LambdaToken.prim === tokenToFind) {
              tokens.push(this);
          }
          this.createToken(this.val.args[0], this.idx).findAndReturnTokens(tokenToFind, tokens);
          this.createToken(this.val.args[1], this.idx).findAndReturnTokens(tokenToFind, tokens);
          return tokens;
      }
  }
  LambdaToken.prim = 'lambda';

  class OperationToken extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      Execute(val) {
          return val.string;
      }
      Encode(...args) {
          const val = args.pop();
          return { string: val };
      }
      EncodeObject(val, semantic) {
          if (semantic && semantic[OperationToken.prim]) {
              return semantic[OperationToken.prim](val);
          }
          return { string: val };
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return OperationToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: OperationToken.prim,
              schema: OperationToken.prim,
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (OperationToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  OperationToken.prim = 'operation';

  class SetValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'SetValidationError';
      }
  }
  class SetToken extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      get KeySchema() {
          return this.createToken(this.val.args[0], 0);
      }
      isValid(value) {
          if (Array.isArray(value)) {
              return null;
          }
          return new SetValidationError(value, this, 'Value must be an array');
      }
      Encode(args) {
          const val = args.pop();
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          return val
              .sort((a, b) => this.KeySchema.compare(a, b))
              .reduce((prev, current) => {
              return [...prev, this.KeySchema.EncodeObject(current)];
          }, []);
      }
      Execute(val, semantics) {
          return val.reduce((prev, current) => {
              return [...prev, this.KeySchema.Execute(current, semantics)];
          }, []);
      }
      EncodeObject(args, semantic) {
          const err = this.isValid(args);
          if (err) {
              throw err;
          }
          if (semantic && semantic[SetToken.prim]) {
              return semantic[SetToken.prim](args);
          }
          return args
              .sort((a, b) => this.KeySchema.compare(a, b))
              .reduce((prev, current) => {
              return [...prev, this.KeySchema.EncodeObject(current)];
          }, []);
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return SetToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: SetToken.prim,
              schema: this.KeySchema.generateSchema(),
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (SetToken.prim === tokenToFind) {
              tokens.push(this);
          }
          this.KeySchema.findAndReturnTokens(tokenToFind, tokens);
          return tokens;
      }
  }
  SetToken.prim = 'set';

  class ChainIDValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'ChainIDValidationError';
      }
  }
  class ChainIDToken extends ComparableToken {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      isValid(value) {
          if (utils.validateChain(value) !== utils.ValidationResult.VALID) {
              return new ChainIDValidationError(value, this, 'ChainID is not valid');
          }
          return null;
      }
      Execute(val) {
          return val[Object.keys(val)[0]];
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return ChainIDToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: ChainIDToken.prim,
              schema: ChainIDToken.prim,
          };
      }
      Encode(args) {
          const val = args.pop();
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          return { string: val };
      }
      EncodeObject(val, semantic) {
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          if (semantic && semantic[ChainIDToken.prim]) {
              return semantic[ChainIDToken.prim](val);
          }
          return { string: val };
      }
      ToKey({ string }) {
          return string;
      }
      ToBigMapKey(val) {
          return {
              key: { string: val },
              type: { prim: ChainIDToken.prim },
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (ChainIDToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  ChainIDToken.prim = 'chain_id';

  /**
   *  @category Error
   *  @description Error that indicates a failure when encoding and sending a ticket to the blockchain
   */
  class EncodeTicketError extends Error {
      constructor() {
          super('Tickets cannot be sent to the blockchain; they are created on-chain');
          this.name = 'TicketEncodeError';
      }
  }
  const ticketerType$1 = { prim: 'contract' };
  const amountType$1 = { prim: 'int' };
  class TicketToken extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      get valueToken() {
          return this.createToken(this.val.args[0], this.idx);
      }
      Encode(_args) {
          throw new EncodeTicketError();
      }
      EncodeObject(args, semantic) {
          if (semantic && semantic[TicketToken.prim]) {
              return semantic[TicketToken.prim](args, this.val);
          }
          throw new EncodeTicketError();
      }
      Execute(val, semantics) {
          if (semantics && semantics[TicketToken.prim]) {
              return semantics[TicketToken.prim](val, this.val);
          }
          const ticketer = this.createToken(ticketerType$1, this.idx);
          const value = this.valueToken;
          const amount = this.createToken(amountType$1, this.idx);
          if (undefined === val.args[2] && undefined !== val.args[1].args) {
              return {
                  ticketer: ticketer.Execute(val.args[0], semantics),
                  value: value.Execute(val.args[1].args[0], semantics),
                  amount: amount.Execute(val.args[1].args[1], semantics),
              };
          }
          return {
              ticketer: ticketer.Execute(val.args[0], semantics),
              value: value.Execute(val.args[1], semantics),
              amount: amount.Execute(val.args[2], semantics),
          };
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return {
              ticketer: ContractToken.prim,
              value: this.valueToken.ExtractSchema(),
              amount: IntToken.prim,
          };
      }
      generateSchema() {
          return {
              __michelsonType: TicketToken.prim,
              schema: {
                  value: this.valueToken.generateSchema(),
                  ticketer: {
                      __michelsonType: ContractToken.prim,
                      schema: ContractToken.prim,
                  },
                  amount: {
                      __michelsonType: IntToken.prim,
                      schema: IntToken.prim,
                  },
              },
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (TicketToken.prim === tokenToFind) {
              tokens.push(this);
          }
          this.valueToken.findAndReturnTokens(tokenToFind, tokens);
          return tokens;
      }
  }
  TicketToken.prim = 'ticket';

  /**
   *  @category Error
   *  @description Error that indicates a failure when encoding and sending a ticket to the blockchain
   */
  class EncodeTicketDeprecatedError extends Error {
      constructor() {
          super('Ticket_deprecated cannot be sent to the blockchain; they are created on-chain');
          this.name = 'TicketDeprecatedEncodeError';
      }
  }
  const ticketerType = { prim: 'contract' };
  const amountType = { prim: 'int' };
  class TicketDeprecatedToken extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      get valueToken() {
          return this.createToken(this.val.args[0], this.idx);
      }
      Encode(_args) {
          throw new EncodeTicketDeprecatedError();
      }
      EncodeObject(args, semantic) {
          if (semantic && semantic[TicketDeprecatedToken.prim]) {
              return semantic[TicketDeprecatedToken.prim](args, this.val);
          }
          throw new EncodeTicketDeprecatedError();
      }
      Execute(val, semantics) {
          if (semantics && semantics[TicketDeprecatedToken.prim]) {
              return semantics[TicketDeprecatedToken.prim](val, this.val);
          }
          const ticketer = this.createToken(ticketerType, this.idx);
          const value = this.valueToken;
          const amount = this.createToken(amountType, this.idx);
          if (undefined === val.args[2] && undefined !== val.args[1].args) {
              return {
                  ticketer: ticketer.Execute(val.args[0], semantics),
                  value: value.Execute(val.args[1].args[0], semantics),
                  amount: amount.Execute(val.args[1].args[1], semantics),
              };
          }
          return {
              ticketer: ticketer.Execute(val.args[0], semantics),
              value: value.Execute(val.args[1], semantics),
              amount: amount.Execute(val.args[2], semantics),
          };
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return {
              ticketer: ContractToken.prim,
              value: this.valueToken.ExtractSchema(),
              amount: IntToken.prim,
          };
      }
      generateSchema() {
          return {
              __michelsonType: TicketDeprecatedToken.prim,
              schema: {
                  value: this.valueToken.generateSchema(),
                  ticketer: {
                      __michelsonType: ContractToken.prim,
                      schema: ContractToken.prim,
                  },
                  amount: {
                      __michelsonType: IntToken.prim,
                      schema: IntToken.prim,
                  },
              },
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (TicketDeprecatedToken.prim === tokenToFind) {
              tokens.push(this);
          }
          this.valueToken.findAndReturnTokens(tokenToFind, tokens);
          return tokens;
      }
  }
  TicketDeprecatedToken.prim = 'ticket_deprecated';

  class NeverTokenError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'NeverTokenError';
      }
  }
  class NeverToken extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      Encode(args) {
          const val = args.pop();
          throw new NeverTokenError(val, this, 'Assigning a value to the type never is forbidden.');
      }
      EncodeObject(val, semantic) {
          if (semantic && semantic[NeverToken.prim]) {
              return semantic[NeverToken.prim](val);
          }
          throw new NeverTokenError(val, this, 'Assigning a value to the type never is forbidden.');
      }
      Execute(val) {
          throw new NeverTokenError(val, this, 'There is no literal value for the type never.');
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return NeverToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: NeverToken.prim,
              schema: NeverToken.prim,
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (NeverToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  NeverToken.prim = 'never';

  class SaplingStateValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'SaplingStateValidationError';
      }
  }
  class SaplingStateToken extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      isValid(val) {
          return typeof val === 'object' && Object.keys(val).length === 0;
      }
      Execute(val, semantic) {
          if (semantic && semantic[SaplingStateToken.prim]) {
              return semantic[SaplingStateToken.prim](val, this.val);
          }
          if ('int' in val) {
              return val.int;
          }
          else {
              throw new SaplingStateValidationError(val, this, `Sapling state is expecting an object with an int property. Got ${JSON.stringify(val)}`);
          }
      }
      Encode(args) {
          const val = args.pop();
          if (this.isValid(val)) {
              return [];
          }
          else {
              throw new SaplingStateValidationError(val, this, `Invalid sapling_state. Received: ${val} while expecting: {}`);
          }
      }
      EncodeObject(val, semantic) {
          if (semantic && semantic[SaplingStateToken.prim]) {
              return semantic[SaplingStateToken.prim](val);
          }
          if (this.isValid(val)) {
              return [];
          }
          else {
              throw new SaplingStateValidationError(val, this, `Invalid sapling_state. Received: ${val} while expecting: {}`);
          }
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return {
              [SaplingStateToken.prim]: {
                  'memo-size': Number(this.val.args[0]['int']),
              },
          };
      }
      generateSchema() {
          return {
              __michelsonType: SaplingStateToken.prim,
              schema: {
                  memoSize: this.val.args[0]['int'],
              },
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (SaplingStateToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  SaplingStateToken.prim = 'sapling_state';

  class SaplingTransactionValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'SaplingTransactionValidationError';
      }
  }
  class SaplingTransactionToken extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      Execute(_val) {
          throw new SaplingTransactionValidationError(_val, this, 'There is no literal value for the sapling_transaction type.');
      }
      validateBytes(val) {
          const bytes = /^(0x|0X)?([0-9a-fA-F]*$)/.exec(val);
          if (bytes && bytes[2].length % 2 === 0) {
              return bytes[2];
          }
          else {
              throw new SaplingTransactionValidationError(val, this, `Invalid bytes: ${val}`);
          }
      }
      convertUint8ArrayToHexString(val) {
          return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;
      }
      Encode(args) {
          let val = args.pop();
          val = this.validateBytes(this.convertUint8ArrayToHexString(val));
          return { bytes: String(val).toString() };
      }
      EncodeObject(val, semantic) {
          val = this.validateBytes(this.convertUint8ArrayToHexString(val));
          if (semantic && semantic[SaplingTransactionToken.prim]) {
              return semantic[SaplingTransactionToken.prim](val);
          }
          return { bytes: String(val).toString() };
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return {
              [SaplingTransactionToken.prim]: {
                  'memo-size': Number(this.val.args[0]['int']),
              },
          };
      }
      generateSchema() {
          return {
              __michelsonType: SaplingTransactionToken.prim,
              schema: {
                  memoSize: this.val.args[0]['int'],
              },
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (SaplingTransactionToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  SaplingTransactionToken.prim = 'sapling_transaction';

  class SaplingTransactionDeprecatedValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'SaplingTransactionDeprecatedValidationError';
      }
  }
  class SaplingTransactionDeprecatedToken extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      Execute(_val) {
          throw new SaplingTransactionDeprecatedValidationError(_val, this, 'There is no literal value for the sapling_transaction_deprecated type.');
      }
      validateBytes(val) {
          const bytes = /^(0x|0X)?([0-9a-fA-F]*$)/.exec(val);
          if (bytes && bytes[2].length % 2 === 0) {
              return bytes[2];
          }
          else {
              throw new SaplingTransactionDeprecatedValidationError(val, this, `Invalid bytes: ${val}`);
          }
      }
      convertUint8ArrayToHexString(val) {
          return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;
      }
      Encode(args) {
          let val = args.pop();
          val = this.validateBytes(this.convertUint8ArrayToHexString(val));
          return { bytes: String(val).toString() };
      }
      EncodeObject(val, semantic) {
          val = this.validateBytes(this.convertUint8ArrayToHexString(val));
          if (semantic && semantic[SaplingTransactionDeprecatedToken.prim]) {
              return semantic[SaplingTransactionDeprecatedToken.prim](val);
          }
          return { bytes: String(val).toString() };
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return {
              [SaplingTransactionDeprecatedToken.prim]: {
                  'memo-size': Number(this.val.args[0]['int']),
              },
          };
      }
      generateSchema() {
          return {
              __michelsonType: SaplingTransactionDeprecatedToken.prim,
              schema: {
                  memoSize: this.val.args[0]['int'],
              },
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (SaplingTransactionDeprecatedToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  SaplingTransactionDeprecatedToken.prim = 'sapling_transaction_deprecated';

  class Bls12381frValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'Bls12381frValidationError';
      }
  }
  class Bls12381frToken extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      isValid(val) {
          if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
              return null;
          }
          else {
              return new Bls12381frValidationError(val, this, `Invalid bytes: ${val}`);
          }
      }
      convertUint8ArrayToHexString(val) {
          return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;
      }
      Encode(args) {
          let val = args.pop();
          if (typeof val === 'number') {
              return { int: val.toString() };
          }
          else {
              val = this.convertUint8ArrayToHexString(val);
              const err = this.isValid(val);
              if (err) {
                  throw err;
              }
              return { bytes: val };
          }
      }
      EncodeObject(val, semantic) {
          if (semantic && semantic[Bls12381frToken.prim]) {
              return semantic[Bls12381frToken.prim](val);
          }
          if (typeof val === 'number') {
              return { int: val.toString() };
          }
          else {
              val = this.convertUint8ArrayToHexString(val);
              const err = this.isValid(val);
              if (err) {
                  throw err;
              }
              return { bytes: val };
          }
      }
      Execute(val) {
          return val.bytes;
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return Bls12381frToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: Bls12381frToken.prim,
              schema: Bls12381frToken.prim,
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (Bls12381frToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  // An element of the BLS12-381 scalar field Fr
  // see https://tezos.gitlab.io/michelson-reference/#type-bls12_381_fr
  Bls12381frToken.prim = 'bls12_381_fr';

  class Bls12381g1ValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'Bls12381g1ValidationError';
      }
  }
  class Bls12381g1Token extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      isValid(val) {
          if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
              return null;
          }
          else {
              return new Bls12381g1ValidationError(val, this, `Invalid bytes: ${val}`);
          }
      }
      convertUint8ArrayToHexString(val) {
          return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;
      }
      Encode(args) {
          let val = args.pop();
          val = this.convertUint8ArrayToHexString(val);
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          return { bytes: val };
      }
      EncodeObject(val, semantic) {
          val = this.convertUint8ArrayToHexString(val);
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          if (semantic && semantic[Bls12381g1Token.prim]) {
              return semantic[Bls12381g1Token.prim](val);
          }
          return { bytes: val };
      }
      Execute(val) {
          return val.bytes;
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return Bls12381g1Token.prim;
      }
      generateSchema() {
          return {
              __michelsonType: Bls12381g1Token.prim,
              schema: Bls12381g1Token.prim,
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (Bls12381g1Token.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  // A point on the BLS12-381 curve G1
  // See https://tezos.gitlab.io/michelson-reference/#type-bls12_381_g1
  Bls12381g1Token.prim = 'bls12_381_g1';

  class Bls12381g2ValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'Bls12381g2ValidationError';
      }
  }
  class Bls12381g2Token extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      isValid(val) {
          if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
              return null;
          }
          else {
              return new Bls12381g2ValidationError(val, this, `Invalid bytes: ${val}`);
          }
      }
      convertUint8ArrayToHexString(val) {
          return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;
      }
      Encode(args) {
          let val = args.pop();
          val = this.convertUint8ArrayToHexString(val);
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          return { bytes: val };
      }
      EncodeObject(val, semantic) {
          val = this.convertUint8ArrayToHexString(val);
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          if (semantic && semantic[Bls12381g2Token.prim]) {
              return semantic[Bls12381g2Token.prim](val);
          }
          return { bytes: val };
      }
      Execute(val) {
          return val.bytes;
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return Bls12381g2Token.prim;
      }
      generateSchema() {
          return {
              __michelsonType: Bls12381g2Token.prim,
              schema: Bls12381g2Token.prim,
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (Bls12381g2Token.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  // A point on the BLS12-381 curve G2
  // See https://tezos.gitlab.io/michelson-reference/#type-bls12_381_g2
  Bls12381g2Token.prim = 'bls12_381_g2';

  class ChestValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'ChestValidationError';
      }
  }
  class ChestToken extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      isValid(val) {
          if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
              return null;
          }
          else {
              return new ChestValidationError(val, this, `Invalid bytes: ${val}`);
          }
      }
      convertUint8ArrayToHexString(val) {
          return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;
      }
      Encode(args) {
          let val = args.pop();
          val = this.convertUint8ArrayToHexString(val);
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          return { bytes: val };
      }
      EncodeObject(val, semantic) {
          val = this.convertUint8ArrayToHexString(val);
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          if (semantic && semantic[ChestToken.prim]) {
              return semantic[ChestToken.prim](val);
          }
          return { bytes: val };
      }
      Execute(val) {
          return val.bytes;
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return ChestToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: ChestToken.prim,
              schema: ChestToken.prim,
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (ChestToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  ChestToken.prim = 'chest';

  class ChestKeyValidationError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'ChestKeyValidationError';
      }
  }
  class ChestKeyToken extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      isValid(val) {
          if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
              return null;
          }
          else {
              return new ChestKeyValidationError(val, this, `Invalid bytes: ${val}`);
          }
      }
      convertUint8ArrayToHexString(val) {
          return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;
      }
      Encode(args) {
          let val = args.pop();
          val = this.convertUint8ArrayToHexString(val);
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          return { bytes: val };
      }
      EncodeObject(val, semantic) {
          val = this.convertUint8ArrayToHexString(val);
          const err = this.isValid(val);
          if (err) {
              throw err;
          }
          if (semantic && semantic[ChestKeyToken.prim]) {
              return semantic[ChestKeyToken.prim](val);
          }
          return { bytes: val };
      }
      Execute(val) {
          return val.bytes;
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return ChestKeyToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: ChestKeyToken.prim,
              schema: ChestKeyToken.prim,
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (ChestKeyToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  ChestKeyToken.prim = 'chest_key';

  class GlobalConstantEncodingError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'GlobalConstantEncodingError';
      }
  }
  class GlobalConstantDecodingError extends TokenValidationError {
      constructor(value, token, message) {
          super(value, token, message);
          this.value = value;
          this.token = token;
          this.name = 'GlobalConstantDecodingError';
      }
  }
  class GlobalConstantToken extends Token {
      constructor(val, idx, fac) {
          super(val, idx, fac);
          this.val = val;
          this.idx = idx;
          this.fac = fac;
      }
      Execute(val, semantic) {
          if (semantic && semantic[GlobalConstantToken.prim]) {
              return semantic[GlobalConstantToken.prim](val, this.val);
          }
          else {
              throw new GlobalConstantDecodingError(val, this, `Unable to decode a value represented by a global constants. Please provide an expanded script to the Michelson-Encoder or semantics for the decoding. The following global constant hash was encountered: ${this.val.args[0]['string']}.`);
          }
      }
      Encode(args) {
          throw new GlobalConstantEncodingError(args, this, `Unable to encode a script containing global constants. Please provide an expanded script to the Michelson-Encoder. The following global constant hash was encountered: ${this.val.args[0]['string']}.`);
      }
      EncodeObject(val, semantic) {
          if (semantic && semantic[GlobalConstantToken.prim]) {
              return semantic[GlobalConstantToken.prim](val);
          }
          throw new GlobalConstantEncodingError(val, this, `Unable to encode a script containing global constants. Please provide an expanded script to the Michelson-Encoder. The following global constant hash was encountered: ${this.val.args[0]['string']}.`);
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return GlobalConstantToken.prim;
      }
      generateSchema() {
          return {
              __michelsonType: GlobalConstantToken.prim,
              schema: {
                  hash: this.val.args[0]['string'],
              },
          };
      }
      findAndReturnTokens(tokenToFind, tokens) {
          if (GlobalConstantToken.prim === tokenToFind) {
              tokens.push(this);
          }
          return tokens;
      }
  }
  GlobalConstantToken.prim = 'constant';

  const tokens = [
      PairToken,
      NatToken,
      StringToken,
      BigMapToken,
      AddressToken,
      TxRollupL2AddressToken,
      MapToken,
      BoolToken,
      OrToken,
      ContractToken,
      ListToken,
      MutezToken,
      BytesToken,
      OptionToken,
      TimestampToken,
      IntToken,
      UnitToken,
      KeyToken,
      KeyHashToken,
      SignatureToken,
      LambdaToken,
      OperationToken,
      SetToken,
      ChainIDToken,
      TicketToken,
      TicketDeprecatedToken,
      NeverToken,
      SaplingStateToken,
      SaplingTransactionToken,
      SaplingTransactionDeprecatedToken,
      Bls12381frToken,
      Bls12381g1Token,
      Bls12381g2Token,
      ChestToken,
      ChestKeyToken,
      GlobalConstantToken,
  ];

  /**
   *  @category Error
   *  @description Error that indicates a script having an invalid type or it being unsupported by the Michelson Encoder. Note some protocol changes might affect this, we encourage users to open an issue so we can look into implementing support for said types.
   */
  class InvalidTokenError extends Error {
      constructor(message, data) {
          super(message);
          this.message = message;
          this.data = data;
          this.name = 'Invalid token error';
      }
  }
  function createToken(val, idx) {
      if (Array.isArray(val)) {
          return new PairToken(val, idx, createToken);
      }
      const t = tokens.find((x) => x.prim === val.prim);
      if (!t) {
          throw new InvalidTokenError('Malformed data expected a value with a valid prim property', val);
      }
      return new t(val, idx, createToken);
  }

  /**
   *  @category Error
   *  @description Error that indicates a failure when encoding (transforming JS parameter into JSON Michelson)the parameter of the view
   */
  class ViewEncodingError extends Error {
      constructor(smartContractViewName, originalError) {
          super(`Unable to encode the parameter of the view: ${smartContractViewName}.`);
          this.smartContractViewName = smartContractViewName;
          this.originalError = originalError;
          this.name = 'ViewEncodingError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid on-chain view found on the script
   */
  class InvalidScriptError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'InvalidScriptError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid RPC response being passed or used
   */
  class InvalidRpcResponseError extends Error {
      constructor(script) {
          super(`Invalid RPC response passed as argument(s)`);
          this.script = script;
          this.name = 'InvalidRpcResponseError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates a failure that occurred during encoding
   */
  class ParameterEncodingError extends Error {
      constructor(message, args, originalError) {
          super(`
      ${message}. Error encountered when trying to encode arguments: \n
      [${args}]
    `);
          this.message = message;
          this.args = args;
          this.originalError = originalError;
          this.name = 'ParameterEncodingError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid big map schema being passed or used
   */
  class InvalidBigMapSchema extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'InvalidBigMapSchema';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid big map diff being passed or used
   */
  class InvalidBigMapDiff extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'InvalidBigMapDiff';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates a failure when trying to encode big maps
   */
  class BigMapEncodingError extends Error {
      constructor(obj, details) {
          super(`Unable to encode ${obj}. ${details}`);
          this.obj = obj;
          this.details = details;
          this.name = 'BigMapEncodingError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates a failure when trying to encode storage
   */
  class StorageEncodingError extends Error {
      constructor(obj, details) {
          super(`Unable to encode ${obj}. ${details}`);
          this.obj = obj;
          this.details = details;
          this.name = 'StorageEncodingError';
      }
  }
  /**
   *  @category Error
   *  @description General error that indicates a function not being passed a necessary argument
   */
  class MissingArgumentError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'MissingArgumentError';
      }
  }

  var _a;
  const schemaTypeSymbol = Symbol.for('taquito-schema-type-symbol');
  // collapse comb pair
  function collapse(val, prim = PairToken.prim) {
      var _b, _c;
      if (Array.isArray(val)) {
          return collapse({
              prim: prim,
              args: val,
          }, prim);
      }
      const extended = val;
      if (extended.prim === prim && extended.args && extended.args.length > 2) {
          return Object.assign(Object.assign({}, extended), { args: [
                  (_b = extended.args) === null || _b === void 0 ? void 0 : _b[0],
                  {
                      prim: prim,
                      args: (_c = extended.args) === null || _c === void 0 ? void 0 : _c.slice(1),
                  },
              ] });
      }
      return extended;
  }
  function deepEqual(a, b) {
      const ac = collapse(a);
      const bc = collapse(b);
      return (ac.prim === bc.prim &&
          ((ac.args === undefined && bc.args === undefined) ||
              (ac.args !== undefined &&
                  bc.args !== undefined &&
                  ac.args.length === bc.args.length &&
                  ac.args.every((v, i) => { var _b, _c; return deepEqual(v, (_c = (_b = bc.args) === null || _b === void 0 ? void 0 : _b[i]) !== null && _c !== void 0 ? _c : {}); }))) &&
          ((ac.annots === undefined && bc.annots === undefined) ||
              (ac.annots !== undefined &&
                  bc.annots !== undefined &&
                  ac.annots.length === bc.annots.length &&
                  ac.annots.every((v, i) => { var _b; return v === ((_b = bc.annots) === null || _b === void 0 ? void 0 : _b[i]); }))));
  }
  /**
   * @warn Our current smart contract abstraction feature is currently in preview. It's API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.
   */
  class Schema {
      constructor(val) {
          this.val = val;
          this[_a] = true;
          this.root = createToken(val, 0);
          if (this.root instanceof BigMapToken) {
              this.bigMap = this.root;
          }
          else if (this.isExpressionExtended(val) && val.prim === 'pair') {
              const exp = val.args[0];
              if (this.isExpressionExtended(exp) && exp.prim === 'big_map') {
                  this.bigMap = new BigMapToken(exp, 0, createToken);
              }
          }
      }
      static isSchema(obj) {
          return obj && obj[schemaTypeSymbol] === true;
      }
      static fromRPCResponse(val) {
          const storage = val &&
              val.script &&
              Array.isArray(val.script.code) &&
              val.script.code.find((x) => {
                  if (!Array.isArray(x)) {
                      const checkExtended = x;
                      if (checkExtended.prim) {
                          return checkExtended.prim === 'storage';
                      }
                      else {
                          return false;
                      }
                  }
                  else {
                      // storage passed along as original storage value
                      this.fromRPCResponse({ script: { code: x, storage: val.script.storage } });
                  }
              });
          if (!storage || !Array.isArray(storage.args)) {
              throw new InvalidRpcResponseError(val.script);
          }
          return new Schema(storage.args[0]);
      }
      isExpressionExtended(val) {
          return 'prim' in val && Array.isArray(val.args);
      }
      removeTopLevelAnnotation(obj) {
          // PairToken and OrToken can have redundant top level annotation in their storage
          if (this.root instanceof PairToken || this.root instanceof OrToken) {
              if (this.root.hasAnnotations() && typeof obj === 'object' && Object.keys(obj).length === 1) {
                  return obj[Object.keys(obj)[0]];
              }
          }
          return obj;
      }
      Execute(val, semantics) {
          const storage = this.root.Execute(val, semantics);
          return this.removeTopLevelAnnotation(storage);
      }
      Typecheck(val) {
          if (this.root instanceof BigMapToken && Number.isInteger(Number(val))) {
              return true;
          }
          if (this.root instanceof TicketToken && val.ticketer && val.value && val.amount) {
              return true;
          }
          if (this.root instanceof TicketDeprecatedToken && val.ticketer && val.value && val.amount) {
              return true;
          }
          if (this.root instanceof MapToken && this.root.ValueSchema instanceof BigMapToken) {
              return true;
          }
          try {
              this.root.EncodeObject(val);
              return true;
          }
          catch (ex) {
              return false;
          }
      }
      ExecuteOnBigMapDiff(diff, semantics) {
          if (!this.bigMap) {
              throw new InvalidBigMapSchema('Big map schema is undefined');
          }
          if (!Array.isArray(diff)) {
              throw new InvalidBigMapDiff('Big map diff must be an array');
          }
          const eltFormat = diff.map(({ key, value }) => ({ args: [key, value] }));
          return this.bigMap.Execute(eltFormat, semantics);
      }
      ExecuteOnBigMapValue(key, semantics) {
          if (!this.bigMap) {
              throw new InvalidBigMapSchema('No big map schema');
          }
          return this.bigMap.ValueSchema.Execute(key, semantics);
      }
      EncodeBigMapKey(key) {
          if (!this.bigMap) {
              throw new InvalidBigMapSchema('Big map schema is undefined');
          }
          try {
              return this.bigMap.KeySchema.ToBigMapKey(key);
          }
          catch (ex) {
              throw new BigMapEncodingError('big map key', ex);
          }
      }
      Encode(value, semantics) {
          try {
              return this.root.EncodeObject(value, semantics);
          }
          catch (ex) {
              if (ex instanceof TokenValidationError) {
                  throw ex;
              }
              throw new StorageEncodingError('storage object', ex);
          }
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return this.removeTopLevelAnnotation(this.root.ExtractSchema());
      }
      /**
       * @description Produce a representation of the storage schema.
       * Note: Provide guidance on how to write the storage object for the origination operation with Taquito.
       */
      generateSchema() {
          return this.removeTopLevelAnnotation(this.root.generateSchema());
      }
      /**
       * @deprecated
       */
      ComputeState(tx, state) {
          if (!this.bigMap) {
              throw new InvalidBigMapSchema('Big map schema is undefined');
          }
          const bigMap = tx.reduce((prev, current) => {
              return Object.assign(Object.assign({}, prev), this.ExecuteOnBigMapDiff(current.contents[0].metadata.operation_result.big_map_diff));
          }, {});
          return Object.assign(Object.assign({}, this.Execute(state)), { [this.bigMap.annot()]: bigMap });
      }
      /**
       * @description Look up in top-level pairs of the storage to find a value matching the specified type
       *
       * @returns The first value found that match the type or `undefined` if no value is found
       *
       * @param storage storage to parse to find the value
       * @param valueType type of value to look for
       *
       */
      FindFirstInTopLevelPair(storage, valueType) {
          return this.findValue(this.root['val'], storage, valueType);
      }
      // TODO check these type casts
      findValue(schema, storage, valueToFind) {
          if (deepEqual(valueToFind, schema)) {
              return storage;
          }
          if (Array.isArray(schema) || schema.prim === 'pair') {
              const sch = collapse(schema);
              const strg = collapse(storage, 'Pair');
              if (sch.args === undefined || strg.args === undefined) {
                  throw new MissingArgumentError('Tokens have no arguments'); // unlikely
              }
              if (sch.args[0])
                  return (
                  // unsafe
                  this.findValue(sch.args[0], strg.args[0], valueToFind) ||
                      this.findValue(sch.args[1], strg.args[1], valueToFind));
          }
      }
      /**
       * @description Look up the schema to find any occurrence of a particular token.
       *
       * @returns an array of tokens of the specified kind or an empty array if no token was found
       *
       * @param tokenToFind string representing the prim property of the token to find
       *
       * @example
       * ```
       * Useful to find all global constants in a script, an array of GlobalConstantToken is returned:
       *
       * const schema = new Schema(script);
       * const allGlobalConstantTokens = schema.findToken('constant');
       * ```
       *
       */
      findToken(tokenToFind) {
          const tokens = [];
          return this.root.findAndReturnTokens(tokenToFind, tokens);
      }
  }
  _a = schemaTypeSymbol;

  /**
   * @warn Our current smart contract abstraction feature is currently in preview. It's API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.
   */
  class ParameterSchema {
      constructor(val) {
          this.root = createToken(val, 0);
      }
      static fromRPCResponse(val) {
          const parameter = val &&
              val.script &&
              Array.isArray(val.script.code) &&
              val.script.code.find((x) => x.prim === 'parameter');
          if (!parameter || !Array.isArray(parameter.args)) {
              throw new InvalidRpcResponseError(val.script);
          }
          return new ParameterSchema(parameter.args[0]);
      }
      get isMultipleEntryPoint() {
          return (this.root instanceof OrToken ||
              (this.root instanceof OptionToken && this.root.subToken() instanceof OrToken));
      }
      get hasAnnotation() {
          if (this.isMultipleEntryPoint) {
              return Object.keys(this.ExtractSchema())[0] !== '0';
          }
          else {
              return true;
          }
      }
      Execute(val, semantics) {
          return this.root.Execute(val, semantics);
      }
      Encode(...args) {
          try {
              return this.root.Encode(args.reverse());
          }
          catch (ex) {
              if (ex instanceof TokenValidationError) {
                  throw ex;
              }
              throw new ParameterEncodingError('Unable to encode parameter', args.toString(), ex);
          }
      }
      EncodeObject(value, semantics) {
          try {
              return this.root.EncodeObject(value, semantics);
          }
          catch (ex) {
              if (ex instanceof TokenValidationError) {
                  throw ex;
              }
              throw new ParameterEncodingError('Unable to encode parameter object', value, ex);
          }
      }
      /**
       * @deprecated ExtractSchema has been deprecated in favor of generateSchema
       *
       */
      ExtractSchema() {
          return this.root.ExtractSchema();
      }
      /**
       * @description Produce a schema grouping together all the entry points of a contract.
       */
      generateSchema() {
          return this.root.generateSchema();
      }
      ExtractSignatures() {
          return this.root.ExtractSignature();
      }
  }

  class ViewSchema {
      constructor(val) {
          if (val.length !== 4 || !('string' in val[0])) {
              throw new InvalidScriptError(`Invalid on-chain view: ${JSON.stringify(val)}`);
          }
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          this.viewName = val[0]['string'];
          this.viewArgsType = val[1];
          this.viewReturnType = val[2];
          this.instructions = val[3];
          this.rootArgsType = createToken(this.viewArgsType, 0);
          this.rootReturnType = createToken(this.viewReturnType, 0);
      }
      /**
       *
       * @description Create an instance of ViewSchema for each view in a script
       *
       * @param val contract script obtained from the RPC
       * @returns array of ViewSchema or empty array if there is no view in the contract
       */
      static fromRPCResponse(val) {
          const allViewSchema = [];
          const views = val &&
              val.script &&
              Array.isArray(val.script.code) &&
              val.script.code.filter((x) => x.prim === 'view');
          if (views) {
              views.forEach((view) => {
                  if (!view.args || view.args.length !== 4) {
                      throw new InvalidScriptError(`Invalid on-chain view found in the script: ${JSON.stringify(view)}`);
                  }
                  allViewSchema.push(new ViewSchema(view.args));
              });
          }
          return allViewSchema;
      }
      /**
       *
       * @description Transform the view parameter into Michelson
       *
       * @param args parameter of the view in js format
       * @returns parameter of the view in Michelson
       */
      encodeViewArgs(args) {
          try {
              return this.rootArgsType.EncodeObject(args);
          }
          catch (ex) {
              throw new ViewEncodingError(this.viewName, ex);
          }
      }
      /**
       *
       * @description Transform the view result from Michelson to readable data
       *
       * @param val result of the view in JSON Michelson
       * @param semantics optional semantics to override the default decoding behavior
       * @returns result of the view in a readable format
       */
      decodeViewResult(val, semantics) {
          return this.rootReturnType.Execute(val, semantics);
      }
      /**
       *
       * @description Return the signature of the view parameter
       */
      extractArgsSchema() {
          return this.rootArgsType.ExtractSchema();
      }
      /**
       *
       * @description Return the format of the view result
       */
      extractResultSchema() {
          return this.rootReturnType.ExtractSchema();
      }
  }

  // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
  const VERSION = {
      "commitHash": "178bea7c6a3b3c58f23163fcc72e28aa5f08702a",
      "version": "15.1.0"
  };

  /**
   * @packageDocumentation
   * @module @taquito/michelson-encoder
   */
  const UnitValue = Symbol();
  const SaplingStateValue = {};

  exports.AddressValidationError = AddressValidationError;
  exports.BigMapEncodingError = BigMapEncodingError;
  exports.BigMapValidationError = BigMapValidationError;
  exports.BytesValidationError = BytesValidationError;
  exports.ChainIDValidationError = ChainIDValidationError;
  exports.ContractValidationError = ContractValidationError;
  exports.EncodeTicketError = EncodeTicketError;
  exports.IntValidationError = IntValidationError;
  exports.InvalidBigMapDiff = InvalidBigMapDiff;
  exports.InvalidBigMapSchema = InvalidBigMapSchema;
  exports.InvalidMapTypeError = InvalidMapTypeError;
  exports.InvalidRpcResponseError = InvalidRpcResponseError;
  exports.InvalidScriptError = InvalidScriptError;
  exports.KeyHashValidationError = KeyHashValidationError;
  exports.KeyValidationError = KeyValidationError;
  exports.ListValidationError = ListValidationError;
  exports.MapTypecheckError = MapTypecheckError;
  exports.MapValidationError = MapValidationError;
  exports.MichelsonMap = MichelsonMap;
  exports.MissingArgumentError = MissingArgumentError;
  exports.MutezValidationError = MutezValidationError;
  exports.NatValidationError = NatValidationError;
  exports.OrTokenDecodingError = OrTokenDecodingError;
  exports.ParameterEncodingError = ParameterEncodingError;
  exports.ParameterSchema = ParameterSchema;
  exports.SaplingStateValue = SaplingStateValue;
  exports.Schema = Schema;
  exports.SetValidationError = SetValidationError;
  exports.SignatureValidationError = SignatureValidationError;
  exports.StorageEncodingError = StorageEncodingError;
  exports.Token = Token;
  exports.TokenArgumentValidationError = TokenArgumentValidationError;
  exports.TokenComparisonError = TokenComparisonError;
  exports.UnitValue = UnitValue;
  exports.VERSION = VERSION;
  exports.ViewEncodingError = ViewEncodingError;
  exports.ViewSchema = ViewSchema;

  Object.defineProperty(exports, '__esModule', { value: true });

}));


}).call(this)}).call(this,require("buffer").Buffer)
},{"@taquito/utils":205,"bignumber.js":242,"buffer":3,"fast-json-stable-stringify":270}],203:[function(require,module,exports){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taquito/http-utils'), require('bignumber.js'), require('@taquito/utils')) :
    typeof define === 'function' && define.amd ? define(['exports', '@taquito/http-utils', 'bignumber.js', '@taquito/utils'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.taquitoRpc = {}, global.httpUtils, global.BigNumber, global.utils));
})(this, (function (exports, httpUtils, BigNumber, utils) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var BigNumber__default = /*#__PURE__*/_interopDefaultLegacy(BigNumber);

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    const defaultChain = 'main';
    const defaultRPCOptions = { block: 'head' };
    var RPCMethodName;
    (function (RPCMethodName) {
        RPCMethodName["GET_BAKING_RIGHTS"] = "getBakingRights";
        RPCMethodName["GET_BALLOTS"] = "getBallots";
        RPCMethodName["GET_BALLOT_LIST"] = "getBallotList";
        RPCMethodName["GET_BIG_MAP_KEY"] = "getBigMapKey";
        RPCMethodName["GET_BIG_MAP_EXPR"] = "getBigMapExpr";
        RPCMethodName["GET_BLOCK_HASH"] = "getBlockHash";
        RPCMethodName["GET_BLOCK"] = "getBlock";
        RPCMethodName["GET_BLOCK_HEADER"] = "getBlockHeader";
        RPCMethodName["GET_BLOCK_METADATA"] = "getBlockMetadata";
        RPCMethodName["GET_BALANCE"] = "getBalance";
        RPCMethodName["GET_CHAIN_ID"] = "getChainId";
        RPCMethodName["GET_CONSTANTS"] = "getConstants";
        RPCMethodName["GET_CONTRACT"] = "getContract";
        RPCMethodName["GET_CURRENT_PERIOD"] = "getCurrentPeriod";
        RPCMethodName["GET_CURRENT_PROPOSAL"] = "getCurrentProposal";
        RPCMethodName["GET_CURRENT_QUORUM"] = "getCurrentQuorum";
        RPCMethodName["GET_DELEGATE"] = "getDelegate";
        RPCMethodName["GET_DELEGATES"] = "getDelegates";
        RPCMethodName["GET_VOTING_INFO"] = "getVotingInfo";
        RPCMethodName["GET_ENDORSING_RIGHTS"] = "getEndorsingRights";
        RPCMethodName["GET_ENTRYPOINTS"] = "getEntrypoints";
        RPCMethodName["GET_LIVE_BLOCKS"] = "getLiveBlocks";
        RPCMethodName["GET_MANAGER_KEY"] = "getManagerKey";
        RPCMethodName["GET_NORMALIZED_SCRIPT"] = "getNormalizedScript";
        RPCMethodName["GET_PROPOSALS"] = "getProposals";
        RPCMethodName["GET_PROTOCOLS"] = "getProtocols";
        RPCMethodName["GET_SAPLING_DIFF_BY_CONTRACT"] = "getSaplingDiffByContract";
        RPCMethodName["GET_SAPLING_DIFF_BY_ID"] = "getSaplingDiffById";
        RPCMethodName["GET_SCRIPT"] = "getScript";
        RPCMethodName["GET_STORAGE"] = "getStorage";
        RPCMethodName["GET_SUCCESSOR_PERIOD"] = "getSuccessorPeriod";
        RPCMethodName["GET_TX_ROLLUP_INBOX"] = "getTxRollupInbox";
        RPCMethodName["GET_TX_ROLLUP_STATE"] = "getTxRollupState";
        RPCMethodName["GET_VOTES_LISTINGS"] = "getVotesListings";
        RPCMethodName["PACK_DATA"] = "packData";
        RPCMethodName["GET_STORAGE_USED_SPACE"] = "getStorageUsedSpace";
        RPCMethodName["GET_STORAGE_PAID_SPACE"] = "getStoragePaidSpace";
    })(RPCMethodName || (RPCMethodName = {}));

    /**
     * Casts object/array items to BigNumber
     * @param data input object or array
     * @param keys keys for processing or all items if not defined
     *
     */
    function castToBigNumber(data, keys) {
        const returnArray = Array.isArray(data);
        if (typeof keys === 'undefined') {
            keys = Object.keys(data);
        }
        const response = returnArray ? [] : {};
        keys.forEach((key) => {
            const item = data[key];
            let res;
            if (typeof item === 'undefined') {
                return;
            }
            if (Array.isArray(item)) {
                res = castToBigNumber(item);
                response[key] = res;
                return;
            }
            res = new BigNumber__default["default"](item);
            response[key] = res;
        });
        return response;
    }

    const defaultTtl = 1000;
    /***
     * @description RpcClientCache acts as a decorator over the RpcClient instance by caching responses for the period defined by the ttl.
     */
    class RpcClientCache {
        /**
         *
         * @param rpcClient rpcClient responsible of the interaction with Tezos network through an rpc node
         * @param ttl number representing the time to live (default 1000 milliseconds)
         *
         * @example new RpcClientCache(new RpcClient('https://mainnet.api.tez.ie/'))
         */
        constructor(rpcClient, ttl = defaultTtl) {
            this.rpcClient = rpcClient;
            this.ttl = ttl;
            this._cache = {};
        }
        getAllCachedData() {
            return this._cache;
        }
        /**
         * @description Remove all the data in the cache.
         *
         */
        deleteAllCachedData() {
            for (const key in this._cache) {
                delete this._cache[key];
            }
        }
        formatCacheKey(rpcUrl, rpcMethodName, rpcMethodParams, rpcMethodData) {
            let paramsToString = '';
            rpcMethodParams.forEach((param) => {
                paramsToString =
                    typeof param === 'object'
                        ? paramsToString + JSON.stringify(param) + '/'
                        : paramsToString + param + '/';
            });
            return rpcMethodData
                ? `${rpcUrl}/${rpcMethodName}/${paramsToString}/${JSON.stringify(rpcMethodData)}`
                : `${rpcUrl}/${rpcMethodName}/${paramsToString}`;
        }
        has(key) {
            return key in this._cache;
        }
        get(key) {
            return this._cache[key].response;
        }
        put(key, response) {
            const handle = setTimeout(() => {
                return this.remove(key);
            }, this.ttl);
            Object.assign(this._cache, { [key]: { handle, response } });
        }
        remove(key) {
            if (key in this._cache) {
                delete this._cache[key];
            }
        }
        validateAddress(address) {
            if (utils.validateAddress(address) !== utils.ValidationResult.VALID) {
                throw new utils.InvalidAddressError(address);
            }
        }
        validateContract(address) {
            if (utils.validateContractAddress(address) !== utils.ValidationResult.VALID) {
                throw new utils.InvalidContractAddressError(address);
            }
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description Get the block's hash, its unique identifier.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-hash
         */
        getBlockHash({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BLOCK_HASH, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getBlockHash({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description List the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-live-blocks
         */
        getLiveBlocks({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_LIVE_BLOCKS, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getLiveBlocks({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param address address from which we want to retrieve the balance
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the balance of a contract.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-balance
         */
        getBalance(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BALANCE, [
                    block,
                    address,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getBalance(address, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param address contract address from which we want to retrieve the storage
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the data of the contract.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-storage
         */
        getStorage(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateContract(address);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_STORAGE, [
                    block,
                    address,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getStorage(address, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param address contract address from which we want to retrieve the script
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the code and data of the contract.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script
         */
        getScript(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateContract(address);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_SCRIPT, [
                    block,
                    address,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getScript(address, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param address contract address from which we want to retrieve the script
         * @param unparsingMode default is { unparsing_mode: "Readable" }
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the script of the contract and normalize it using the requested unparsing mode.
         *
         */
        getNormalizedScript(address, unparsingMode = { unparsing_mode: 'Readable' }, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateContract(address);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_NORMALIZED_SCRIPT, [block, address, unparsingMode]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getNormalizedScript(address, unparsingMode, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param address contract address from which we want to retrieve
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the complete status of a contract.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id
         */
        getContract(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_CONTRACT, [
                    block,
                    address,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getContract(address, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param address contract address from which we want to retrieve the manager
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the manager key of a contract.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-manager-key
         */
        getManagerKey(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_MANAGER_KEY, [
                    block,
                    address,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getManagerKey(address, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param address contract address from which we want to retrieve the delegate (baker)
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the delegate of a contract, if any.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-delegate
         */
        getDelegate(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_DELEGATE, [
                    block,
                    address,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getDelegate(address, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param address contract address from which we want to retrieve the big map key
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the value associated with a key in the big map storage of the contract.
         *
         * @deprecated Deprecated in favor of getBigMapKeyByID
         *
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
         */
        getBigMapKey(address, key, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const keyUrl = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BIG_MAP_KEY, [
                    block,
                    address,
                    key,
                ]);
                if (this.has(keyUrl)) {
                    return this.get(keyUrl);
                }
                else {
                    const response = this.rpcClient.getBigMapKey(address, key, { block });
                    this.put(keyUrl, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param id Big Map ID
         * @param expr Expression hash to query (A b58check encoded Blake2b hash of the expression (The expression can be packed using the pack_data method))
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the value associated with a key in a big map.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr
         */
        getBigMapExpr(id, expr, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BIG_MAP_EXPR, [
                    block,
                    id,
                    expr,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getBigMapExpr(id, expr, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param address delegate address which we want to retrieve
         * @param options contains generic configuration for rpc calls
         *
         * @description Fetches information about a delegate from RPC.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-delegates-pkh
         */
        getDelegates(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_DELEGATES, [
                    block,
                    address,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getDelegates(address, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param address delegate address which we want to retrieve
         * @param options contains generic configuration for rpc calls
         *
         * @description Returns the delegate info (e.g. voting power) found in the listings of the current voting period.
         *
         * @see https://tezos.gitlab.io/kathmandu/rpc.html#get-block-id-context-delegates-pkh-voting-info
         */
        getVotingInfo(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_VOTING_INFO, [
                    block,
                    address,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getVotingInfo(address, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description All constants
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-constants
         */
        getConstants({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_CONSTANTS, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getConstants({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls. See examples for various available sytaxes.
         *
         * @description All the information about a block
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id
         * @example getBlock() will default to /main/chains/block/head.
         * @example getBlock({ block: head~2 }) will return an offset of 2 blocks.
         * @example getBlock({ block: BL8fTiWcSxWCjiMVnDkbh6EuhqVPZzgWheJ2dqwrxYRm9AephXh~2 }) will return an offset of 2 blocks from given block hash..
         */
        getBlock({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BLOCK, [block]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getBlock({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description The whole block header
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-header
         */
        getBlockHeader({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BLOCK_HEADER, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getBlockHeader({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description All the metadata associated to the block
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-metadata
         */
        getBlockMetadata({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BLOCK_METADATA, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getBlockMetadata({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param args contains optional query arguments
         * @param options contains generic configuration for rpc calls
         *
         * @description Retrieves the list of delegates allowed to bake a block.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-baking-rights
         */
        getBakingRights(args = {}, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BAKING_RIGHTS, [
                    block,
                    args,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getBakingRights(args, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param args contains optional query arguments
         * @param options contains generic configuration for rpc calls
         *
         * @description Retrieves the list of delegates allowed to bake a block.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-endorsing-rights
         */
        getEndorsingRights(args = {}, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_ENDORSING_RIGHTS, [block, args]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getEndorsingRights(args, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param options contains generic configuration for rpc calls
         *
         * @description Ballots casted so far during a voting period
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballot-list
         */
        getBallotList({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BALLOT_LIST, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getBallotList({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description Sum of ballots casted so far during a voting period.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballots
         */
        getBallots({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BALLOTS, [block]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getBallots({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description Current proposal under evaluation.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-proposal
         */
        getCurrentProposal({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_CURRENT_PROPOSAL, [block]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getCurrentProposal({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description Current expected quorum.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-quorum
         */
        getCurrentQuorum({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_CURRENT_QUORUM, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getCurrentQuorum({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description List of delegates with their voting weight, in number of rolls.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-listings
         */
        getVotesListings({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_VOTES_LISTINGS, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getVotesListings({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description List of proposals with number of supporters.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-proposals
         */
        getProposals({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_PROPOSALS, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getProposals({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param data operation contents to forge
         * @param options contains generic configuration for rpc calls
         *
         * @description Forge an operation returning the unsigned bytes
         *
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-forge-operations
         */
        forgeOperations(data, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpcClient.forgeOperations(data, { block });
            });
        }
        /**
         *
         * @param signedOpBytes signed bytes to inject
         *
         * @description Inject an operation in node and broadcast it. Returns the ID of the operation. The `signedOperationContents` should be constructed using a contextual RPCs from the latest block and signed by the client. By default, the RPC will wait for the operation to be (pre-)validated before answering. See RPCs under /blocks/prevalidation for more details on the prevalidation context.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#post-injection-operation
         */
        injectOperation(signedOpBytes) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpcClient.injectOperation(signedOpBytes);
            });
        }
        /**
         *
         * @param ops Operations to apply
         * @param options contains generic configuration for rpc calls
         *
         * @description Simulate the validation of an operation
         *
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-preapply-operations
         */
        preapplyOperations(ops, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpcClient.preapplyOperations(ops, { block });
            });
        }
        /**
         *
         * @param contract address of the contract we want to get the entrypoints of
         *
         * @description Return the list of entrypoints of the contract
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-entrypoints
         *
         * @version 005_PsBABY5H
         */
        getEntrypoints(contract, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateContract(contract);
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_ENTRYPOINTS, [
                    block,
                    contract,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getEntrypoints(contract, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         * @param op Operation to run
         * @param options contains generic configuration for rpc calls
         *
         * @description Run an operation without signature checks
         *
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-operation
         */
        runOperation(op, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpcClient.runOperation(op, { block });
            });
        }
        /**
         * @param code Code to run
         * @param options contains generic configuration for rpc calls
         *
         * @description Run a piece of code in the current context
         *
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-code
         */
        runCode(code, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpcClient.runCode(code, { block });
            });
        }
        /**
         * @param viewScriptParams Parameters of the script view to run
         * @param options contains generic configuration for rpc calls
         *
         * @description Simulate a call to a michelson view
         *
         */
        runScriptView(_a, { block } = defaultRPCOptions) {
            var { unparsing_mode = 'Readable' } = _a, rest = __rest(_a, ["unparsing_mode"]);
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpcClient.runScriptView(Object.assign({ unparsing_mode }, rest), { block });
            });
        }
        /**
         * @param viewParams Parameters of the view to run
         * @param options contains generic configuration for rpc calls
         *
         * @description Simulate a call to a view following the TZIP-4 standard. See https://gitlab.com/tzip/tzip/-/blob/master/proposals/tzip-4/tzip-4.md#view-entrypoints.
         *
         */
        runView(_a, { block } = defaultRPCOptions) {
            var { unparsing_mode = 'Readable' } = _a, rest = __rest(_a, ["unparsing_mode"]);
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpcClient.runView(Object.assign({ unparsing_mode }, rest), { block });
            });
        }
        getChainId() {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_CHAIN_ID, []);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getChainId();
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param data Data to pack
         * @param options contains generic configuration for rpc calls
         *
         * @description Computes the serialized version of a data expression using the same algorithm as script instruction PACK
         *
         * @example packData({ data: { string: "test" }, type: { prim: "string" } })
         *
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-pack-data
         */
        packData(data, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.PACK_DATA, [
                    block,
                    data,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.packData(data, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @description Return rpc root url
         */
        getRpcUrl() {
            return this.rpcClient.getRpcUrl();
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description Voting period of current block.
         *
         * @example getCurrentPeriod() will default to current voting period for /main/chains/block/head.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-period
         */
        getCurrentPeriod({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_CURRENT_PERIOD, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getCurrentPeriod({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description Voting period of next block.
         *
         * @example getSuccessorPeriod() will default to successor voting period for /main/chains/block/head.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-successor-period
         */
        getSuccessorPeriod({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_SUCCESSOR_PERIOD, [block]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getSuccessorPeriod({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param id Sapling state ID
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the value associated with a sapling state ID.
         *
         * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-sapling-sapling-state-id-get-diff
         */
        getSaplingDiffById(id, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_SAPLING_DIFF_BY_ID, [block, id]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getSaplingDiffById(id, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param contract address of the contract we want to get the sapling diff
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the value associated with a sapling state.
         *
         * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-single-sapling-get-diff
         */
        getSaplingDiffByContract(contract, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_SAPLING_DIFF_BY_CONTRACT, [block, contract]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getSaplingDiffByContract(contract, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        getProtocols({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_PROTOCOLS, [
                    block,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getProtocols({ block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        getTxRollupState(txRollupId, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_TX_ROLLUP_STATE, [
                    block,
                    txRollupId,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getTxRollupState(txRollupId, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        getTxRollupInbox(txRollupId, blockLevel, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_TX_ROLLUP_INBOX, [
                    block,
                    txRollupId,
                    blockLevel,
                ]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getTxRollupInbox(txRollupId, blockLevel, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param contract address of the contract we want to retrieve storage information of
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the amount of used space used in a contract's storage
         *
         * @see https://tezos.gitlab.io/lima/rpc.html#get-block-id-context-contracts-contract-id-storage
         */
        getStorageUsedSpace(contract, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_STORAGE_USED_SPACE, [block, contract]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getStorageUsedSpace(contract, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
        /**
         *
         * @param contract address of the contract we want to retrieve storage information of
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the amount of paid space in a contract's storage
         *
         * @see https://tezos.gitlab.io/lima/rpc.html#get-block-id-context-contracts-contract-id-storage
         */
        getStoragePaidSpace(contract, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_STORAGE_PAID_SPACE, [block, contract]);
                if (this.has(key)) {
                    return this.get(key);
                }
                else {
                    const response = this.rpcClient.getStoragePaidSpace(contract, { block });
                    this.put(key, response);
                    return response;
                }
            });
        }
    }

    exports.OPERATION_METADATA = void 0;
    (function (OPERATION_METADATA) {
        OPERATION_METADATA["TOO_LARGE"] = "too large";
    })(exports.OPERATION_METADATA || (exports.OPERATION_METADATA = {}));
    exports.METADATA_BALANCE_UPDATES_CATEGORY = void 0;
    (function (METADATA_BALANCE_UPDATES_CATEGORY) {
        METADATA_BALANCE_UPDATES_CATEGORY["BAKING_REWARDS"] = "baking rewards";
        METADATA_BALANCE_UPDATES_CATEGORY["REWARDS"] = "rewards";
        METADATA_BALANCE_UPDATES_CATEGORY["FEES"] = "fees";
        METADATA_BALANCE_UPDATES_CATEGORY["DEPOSITS"] = "deposits";
        METADATA_BALANCE_UPDATES_CATEGORY["LEGACY_REWARDS"] = "legacy_rewards";
        METADATA_BALANCE_UPDATES_CATEGORY["LEGACY_FEES"] = "legacy_fees";
        METADATA_BALANCE_UPDATES_CATEGORY["LEGACY_DEPOSITS"] = "legacy_deposits";
        METADATA_BALANCE_UPDATES_CATEGORY["BLOCK_FEES"] = "block fees";
        METADATA_BALANCE_UPDATES_CATEGORY["NONCE_REVELATION_REWARDS"] = "nonce revelation rewards";
        METADATA_BALANCE_UPDATES_CATEGORY["DOUBLE_SIGNING_EVIDENCE_REWARDS"] = "double signing evidence rewards";
        METADATA_BALANCE_UPDATES_CATEGORY["ENDORSING_REWARDS"] = "endorsing rewards";
        METADATA_BALANCE_UPDATES_CATEGORY["BAKING_BONUSES"] = "baking bonuses";
        METADATA_BALANCE_UPDATES_CATEGORY["STORAGE_FEES"] = "storage fees";
        METADATA_BALANCE_UPDATES_CATEGORY["PUNISHMENTS"] = "punishments";
        METADATA_BALANCE_UPDATES_CATEGORY["LOST_ENDORSING_REWARDS"] = "lost endorsing rewards";
        METADATA_BALANCE_UPDATES_CATEGORY["SUBSIDY"] = "subsidy";
        METADATA_BALANCE_UPDATES_CATEGORY["BURNED"] = "burned";
        METADATA_BALANCE_UPDATES_CATEGORY["COMMITMENT"] = "commitment";
        METADATA_BALANCE_UPDATES_CATEGORY["BOOTSTRAP"] = "bootstrap";
        METADATA_BALANCE_UPDATES_CATEGORY["INVOICE"] = "invoice";
        METADATA_BALANCE_UPDATES_CATEGORY["MINTED"] = "minted";
        METADATA_BALANCE_UPDATES_CATEGORY["TX_ROLLUP_REJECTION_REWARDS"] = "tx_rollup_rejection_rewards";
        METADATA_BALANCE_UPDATES_CATEGORY["TX_ROLLUP_REJECTION_PUNISHMENTS"] = "tx_rollup_rejection_punishments";
        METADATA_BALANCE_UPDATES_CATEGORY["BONDS"] = "bonds";
    })(exports.METADATA_BALANCE_UPDATES_CATEGORY || (exports.METADATA_BALANCE_UPDATES_CATEGORY = {}));

    exports.OpKind = void 0;
    (function (OpKind) {
        OpKind["ORIGINATION"] = "origination";
        OpKind["DELEGATION"] = "delegation";
        OpKind["REVEAL"] = "reveal";
        OpKind["TRANSACTION"] = "transaction";
        OpKind["ACTIVATION"] = "activate_account";
        OpKind["ENDORSEMENT"] = "endorsement";
        OpKind["PREENDORSEMENT"] = "preendorsement";
        OpKind["SET_DEPOSITS_LIMIT"] = "set_deposits_limit";
        OpKind["DOUBLE_PREENDORSEMENT_EVIDENCE"] = "double_preendorsement_evidence";
        OpKind["ENDORSEMENT_WITH_SLOT"] = "endorsement_with_slot";
        OpKind["SEED_NONCE_REVELATION"] = "seed_nonce_revelation";
        OpKind["DOUBLE_ENDORSEMENT_EVIDENCE"] = "double_endorsement_evidence";
        OpKind["DOUBLE_BAKING_EVIDENCE"] = "double_baking_evidence";
        OpKind["PROPOSALS"] = "proposals";
        OpKind["BALLOT"] = "ballot";
        OpKind["FAILING_NOOP"] = "failing_noop";
        OpKind["REGISTER_GLOBAL_CONSTANT"] = "register_global_constant";
        OpKind["TX_ROLLUP_ORIGINATION"] = "tx_rollup_origination";
        OpKind["TX_ROLLUP_SUBMIT_BATCH"] = "tx_rollup_submit_batch";
        OpKind["TX_ROLLUP_COMMIT"] = "tx_rollup_commit";
        OpKind["TX_ROLLUP_RETURN_BOND"] = "tx_rollup_return_bond";
        OpKind["TX_ROLLUP_FINALIZE_COMMITMENT"] = "tx_rollup_finalize_commitment";
        OpKind["TX_ROLLUP_REMOVE_COMMITMENT"] = "tx_rollup_remove_commitment";
        OpKind["TX_ROLLUP_REJECTION"] = "tx_rollup_rejection";
        OpKind["TX_ROLLUP_DISPATCH_TICKETS"] = "tx_rollup_dispatch_tickets";
        OpKind["TRANSFER_TICKET"] = "transfer_ticket";
        OpKind["INCREASE_PAID_STORAGE"] = "increase_paid_storage";
        OpKind["UPDATE_CONSENSUS_KEY"] = "update_consensus_key";
        OpKind["DRAIN_DELEGATE"] = "drain_delegate";
        OpKind["VDF_REVELATION"] = "vdf_revelation";
        OpKind["EVENT"] = "event";
        OpKind["TICKET_UPDATES"] = "ticket_updates";
    })(exports.OpKind || (exports.OpKind = {}));

    // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
    const VERSION = {
        "commitHash": "178bea7c6a3b3c58f23163fcc72e28aa5f08702a",
        "version": "15.1.0"
    };

    /***
     * @description RpcClient allows interaction with Tezos network through an rpc node
     */
    class RpcClient {
        /**
         *
         * @param url rpc root url
         * @param chain chain (default main)
         * @param httpBackend Http backend that issue http request.
         * You can override it by providing your own if you which to hook in the request/response
         *
         * @example new RpcClient('https://mainnet.api.tez.ie/', 'main') this will use https://mainnet.api.tez.ie//chains/main
         */
        constructor(url, chain = defaultChain, httpBackend = new httpUtils.HttpBackend()) {
            this.url = url;
            this.chain = chain;
            this.httpBackend = httpBackend;
        }
        createURL(path) {
            // Trim trailing slashes because it is assumed to be included in path
            return `${this.url.replace(/\/+$/g, '')}${path}`;
        }
        validateAddress(address) {
            if (utils.validateAddress(address) !== utils.ValidationResult.VALID) {
                throw new utils.InvalidAddressError(address);
            }
        }
        validateContract(address) {
            if (utils.validateContractAddress(address) !== utils.ValidationResult.VALID) {
                throw new utils.InvalidAddressError(address);
            }
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description Get the block's hash, its unique identifier.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-hash
         */
        getBlockHash({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const hash = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/hash`),
                    method: 'GET',
                });
                return hash;
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description List the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-live-blocks
         */
        getLiveBlocks({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const blocks = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/live_blocks`),
                    method: 'GET',
                });
                return blocks;
            });
        }
        /**
         *
         * @param address address from which we want to retrieve the balance
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the balance of a contract.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-balance
         */
        getBalance(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const balance = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/balance`),
                    method: 'GET',
                });
                return new BigNumber__default["default"](balance);
            });
        }
        /**
         *
         * @param address contract address from which we want to retrieve the storage
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the data of the contract.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-storage
         */
        getStorage(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateContract(address);
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/storage`),
                    method: 'GET',
                });
            });
        }
        /**
         *
         * @param address contract address from which we want to retrieve the script
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the code and data of the contract.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script
         */
        getScript(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateContract(address);
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/script`),
                    method: 'GET',
                });
            });
        }
        /**
         *
         * @param address contract address from which we want to retrieve the script
         * @param unparsingMode default is { unparsing_mode: "Readable" }
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the script of the contract and normalize it using the requested unparsing mode.
         *
         */
        getNormalizedScript(address, unparsingMode = { unparsing_mode: 'Readable' }, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateContract(address);
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/script/normalized`),
                    method: 'POST',
                }, unparsingMode);
            });
        }
        /**
         *
         * @param address contract address from which we want to retrieve
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the complete status of a contract.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id
         */
        getContract(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const contractResponse = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}`),
                    method: 'GET',
                });
                return Object.assign(Object.assign({}, contractResponse), { balance: new BigNumber__default["default"](contractResponse.balance) });
            });
        }
        /**
         *
         * @param address contract address from which we want to retrieve the manager
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the manager key of a contract.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-manager-key
         */
        getManagerKey(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/manager_key`),
                    method: 'GET',
                });
            });
        }
        /**
         *
         * @param address contract address from which we want to retrieve the delegate (baker)
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the delegate of a contract, if any.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-delegate
         */
        getDelegate(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                let delegate;
                try {
                    delegate = yield this.httpBackend.createRequest({
                        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/delegate`),
                        method: 'GET',
                    });
                }
                catch (ex) {
                    if (ex instanceof httpUtils.HttpResponseError && ex.status === httpUtils.STATUS_CODE.NOT_FOUND) {
                        delegate = null;
                    }
                    else {
                        throw ex;
                    }
                }
                return delegate;
            });
        }
        /**
         *
         * @param address contract address from which we want to retrieve the big map key
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the value associated with a key in the big map storage of the contract.
         *
         * @deprecated Deprecated in favor of getBigMapKeyByID
         *
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
         */
        getBigMapKey(address, key, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/big_map_get`),
                    method: 'POST',
                }, key);
            });
        }
        /**
         *
         * @param id Big Map ID
         * @param expr Expression hash to query (A b58check encoded Blake2b hash of the expression (The expression can be packed using the pack_data method))
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the value associated with a key in a big map.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr
         */
        getBigMapExpr(id, expr, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/big_maps/${id}/${expr}`),
                    method: 'GET',
                });
            });
        }
        /**
         *
         * @param address delegate address which we want to retrieve
         * @param options contains generic configuration for rpc calls
         *
         * @description Fetches information about a delegate from RPC.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-delegates-pkh
         */
        getDelegates(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/delegates/${address}`),
                    method: 'GET',
                });
                const castedResponse = castToBigNumber(response, [
                    'balance',
                    'full_balance',
                    'current_frozen_deposits',
                    'frozen_deposits',
                    'frozen_balance',
                    'frozen_deposits_limit',
                    'staking_balance',
                    'delegated_balance',
                    'voting_power',
                ]);
                return Object.assign(Object.assign(Object.assign({}, response), castedResponse), { frozen_balance_by_cycle: response.frozen_balance_by_cycle
                        ? response.frozen_balance_by_cycle.map((_a) => {
                            var { deposit, deposits, fees, rewards } = _a, rest = __rest(_a, ["deposit", "deposits", "fees", "rewards"]);
                            const castedToBigNumber = castToBigNumber({ deposit, deposits, fees, rewards }, [
                                'deposit',
                                'deposits',
                                'fees',
                                'rewards',
                            ]);
                            return Object.assign(Object.assign({}, rest), { deposit: castedToBigNumber.deposit, deposits: castedToBigNumber.deposits, fees: castedToBigNumber.fees, rewards: castedToBigNumber.rewards });
                        })
                        : undefined });
            });
        }
        /**
         *
         * @param address delegate address which we want to retrieve
         * @param options contains generic configuration for rpc calls
         *
         * @description Returns the delegate info (e.g. voting power) found in the listings of the current voting period.
         *
         * @see https://tezos.gitlab.io/kathmandu/rpc.html#get-block-id-context-delegates-pkh-voting-info
         */
        getVotingInfo(address, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateAddress(address);
                return yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/delegates/${address}/voting_info`),
                    method: 'GET',
                });
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description All constants
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-constants
         */
        getConstants({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/constants`),
                    method: 'GET',
                });
                const castedResponse = castToBigNumber(response, [
                    'time_between_blocks',
                    'hard_gas_limit_per_operation',
                    'hard_gas_limit_per_block',
                    'proof_of_work_threshold',
                    'tokens_per_roll',
                    'seed_nonce_revelation_tip',
                    'block_security_deposit',
                    'endorsement_security_deposit',
                    'block_reward',
                    'endorsement_reward',
                    'cost_per_byte',
                    'hard_storage_limit_per_operation',
                    'test_chain_duration',
                    'baking_reward_per_endorsement',
                    'delay_per_missing_endorsement',
                    'minimal_block_delay',
                    'liquidity_baking_subsidy',
                    'cache_layout',
                    'baking_reward_fixed_portion',
                    'baking_reward_bonus_per_slot',
                    'endorsing_reward_per_slot',
                    'double_baking_punishment',
                    'delay_increment_per_round',
                    'tx_rollup_commitment_bond',
                    'vdf_difficulty',
                    'sc_rollup_stake_amount',
                    'minimal_stake',
                ]);
                return Object.assign(Object.assign({}, response), castedResponse);
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls. See examples for various available sytaxes.
         *
         * @description All the information about a block
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id
         * @example getBlock() will default to /main/chains/block/head.
         * @example getBlock({ block: head~2 }) will return an offset of 2 blocks.
         * @example getBlock({ block: BL8fTiWcSxWCjiMVnDkbh6EuhqVPZzgWheJ2dqwrxYRm9AephXh~2 }) will return an offset of 2 blocks from given block hash..
         */
        getBlock({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}`),
                    method: 'GET',
                });
                return response;
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description The whole block header
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-header
         */
        getBlockHeader({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/header`),
                    method: 'GET',
                });
                return response;
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description All the metadata associated to the block
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-metadata
         */
        getBlockMetadata({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/metadata`),
                    method: 'GET',
                });
                return response;
            });
        }
        /**
         *
         * @param args contains optional query arguments
         * @param options contains generic configuration for rpc calls
         *
         * @description Retrieves the list of delegates allowed to bake a block.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-baking-rights
         */
        getBakingRights(args = {}, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/baking_rights`),
                    method: 'GET',
                    query: args,
                });
                return response;
            });
        }
        /**
         *
         * @param args contains optional query arguments
         * @param options contains generic configuration for rpc calls
         *
         * @description Retrieves the list of delegates allowed to bake a block.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-endorsing-rights
         */
        getEndorsingRights(args = {}, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/endorsing_rights`),
                    method: 'GET',
                    query: args,
                });
                return response;
            });
        }
        /**
         * @param options contains generic configuration for rpc calls
         *
         * @description Ballots casted so far during a voting period
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballot-list
         */
        getBallotList({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/ballot_list`),
                    method: 'GET',
                });
                return response;
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description Sum of ballots casted so far during a voting period.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballots
         */
        getBallots({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/ballots`),
                    method: 'GET',
                });
                const casted = castToBigNumber(response, ['yay', 'nay', 'pass']);
                return casted;
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description Current proposal under evaluation.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-proposal
         */
        getCurrentProposal({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/current_proposal`),
                    method: 'GET',
                });
                return response;
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description Current expected quorum.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-quorum
         */
        getCurrentQuorum({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/current_quorum`),
                    method: 'GET',
                });
                return response;
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description List of delegates with their voting weight, in number of rolls.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-listings
         */
        getVotesListings({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/listings`),
                    method: 'GET',
                });
                response.map((item) => {
                    if (item.voting_power) {
                        item.voting_power = new BigNumber__default["default"](item.voting_power);
                    }
                    return item;
                });
                return response;
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description List of proposals with number of supporters.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-proposals
         */
        getProposals({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/proposals`),
                    method: 'GET',
                });
                response.map((item) => {
                    return (item[1] = new BigNumber__default["default"](item[1]));
                });
                return response;
            });
        }
        /**
         *
         * @param data operation contents to forge
         * @param options contains generic configuration for rpc calls
         *
         * @description Forge an operation returning the unsigned bytes
         *
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-forge-operations
         */
        forgeOperations(data, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/forge/operations`),
                    method: 'POST',
                }, data);
            });
        }
        /**
         *
         * @param signedOpBytes signed bytes to inject
         *
         * @description Inject an operation in node and broadcast it. Returns the ID of the operation. The `signedOperationContents` should be constructed using a contextual RPCs from the latest block and signed by the client. By default, the RPC will wait for the operation to be (pre-)validated before answering. See RPCs under /blocks/prevalidation for more details on the prevalidation context.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#post-injection-operation
         */
        injectOperation(signedOpBytes) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/injection/operation`),
                    method: 'POST',
                }, signedOpBytes);
            });
        }
        /**
         *
         * @param ops Operations to apply
         * @param options contains generic configuration for rpc calls
         *
         * @description Simulate the validation of an operation
         *
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-preapply-operations
         */
        preapplyOperations(ops, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/preapply/operations`),
                    method: 'POST',
                }, ops);
                return response;
            });
        }
        /**
         *
         * @param contract address of the contract we want to get the entrypoints of
         *
         * @description Return the list of entrypoints of the contract
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-entrypoints
         *
         * @version 005_PsBABY5H
         */
        getEntrypoints(contract, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.validateContract(contract);
                const contractResponse = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/entrypoints`),
                    method: 'GET',
                });
                return contractResponse;
            });
        }
        /**
         * @param op Operation to run
         * @param options contains generic configuration for rpc calls
         *
         * @description Run an operation without signature checks
         *
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-operation
         */
        runOperation(op, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_operation`),
                    method: 'POST',
                }, op);
                return response;
            });
        }
        /**
         * @param code Code to run
         * @param options contains generic configuration for rpc calls
         *
         * @description Run a piece of code in the current context
         *
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-code
         */
        runCode(code, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_code`),
                    method: 'POST',
                }, code);
                return response;
            });
        }
        /**
         * @param viewScriptParams Parameters of the script view to run
         * @param options contains generic configuration for rpc calls
         *
         * @description Simulate a call to a michelson view
         *
         */
        runScriptView(_a, { block } = defaultRPCOptions) {
            var { unparsing_mode = 'Readable' } = _a, rest = __rest(_a, ["unparsing_mode"]);
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_script_view`),
                    method: 'POST',
                }, Object.assign({ unparsing_mode }, rest));
            });
        }
        /**
         * @param viewParams Parameters of the view to run
         * @param options contains generic configuration for rpc calls
         *
         * @description Simulate a call to a view following the TZIP-4 standard. See https://gitlab.com/tzip/tzip/-/blob/master/proposals/tzip-4/tzip-4.md#view-entrypoints.
         *
         */
        runView(_a, { block } = defaultRPCOptions) {
            var { unparsing_mode = 'Readable' } = _a, rest = __rest(_a, ["unparsing_mode"]);
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_view`),
                    method: 'POST',
                }, Object.assign({ unparsing_mode }, rest));
            });
        }
        getChainId() {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/chain_id`),
                    method: 'GET',
                });
            });
        }
        /**
         *
         * @param data Data to pack
         * @param options contains generic configuration for rpc calls
         *
         * @description Computes the serialized version of a data expression using the same algorithm as script instruction PACK
         * Note: You should always verify the packed bytes before signing or requesting that they be signed when using the the RPC to pack.
         * This precaution helps protect you and your applications users from RPC nodes that have been compromised.
         * A node that is operated by a bad actor, or compromised by a bad actor could return a fully formed operation that does not correspond to the input provided to the RPC endpoint.
         * A safer solution to pack and sign data would be to use the `packDataBytes` function available in the `@taquito/michel-codec` package.
         *
         * @example packData({ data: { string: "test" }, type: { prim: "string" } })
         *
         *
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-pack-data
         */
        packData(data, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const _a = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/pack_data`),
                    method: 'POST',
                }, data), { gas } = _a, rest = __rest(_a, ["gas"]);
                let formattedGas = gas;
                const tryBigNumber = new BigNumber__default["default"](gas || '');
                if (!tryBigNumber.isNaN()) {
                    formattedGas = tryBigNumber;
                }
                return Object.assign({ gas: formattedGas }, rest);
            });
        }
        /**
         *
         * @description Return rpc root url
         */
        getRpcUrl() {
            return this.url;
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description Voting period of current block.
         *
         * @example getCurrentPeriod() will default to current voting period for /main/chains/block/head.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-period
         */
        getCurrentPeriod({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/current_period`),
                    method: 'GET',
                });
                return response;
            });
        }
        /**
         *
         * @param options contains generic configuration for rpc calls
         *
         * @description Voting period of next block.
         *
         * @example getSuccessorPeriod() will default to successor voting period for /main/chains/block/head.
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-successor-period
         */
        getSuccessorPeriod({ block, } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/successor_period`),
                    method: 'GET',
                });
                return response;
            });
        }
        /**
         *
         * @param id Sapling state ID
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the value associated with a sapling state ID.
         *
         * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-sapling-sapling-state-id-get-diff
         */
        getSaplingDiffById(id, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/sapling/${id}/get_diff`),
                    method: 'GET',
                });
            });
        }
        /**
         *
         * @param contract address of the contract we want to get the sapling diff
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the value associated with a sapling state.
         *
         * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-single-sapling-get-diff
         */
        getSaplingDiffByContract(contract, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/single_sapling_get_diff`),
                    method: 'GET',
                });
            });
        }
        getProtocols({ block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/protocols`),
                    method: 'GET',
                });
            });
        }
        /**
         *
         * @param tx_rollup_id the transaction rollup ID
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the state of a rollup
         *
         * @see https://tezos.gitlab.io/jakarta/rpc.html#get-block-id-context-tx-rollup-tx-rollup-id-state
         */
        getTxRollupState(txRollupId, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/tx_rollup/${txRollupId}/state`),
                    method: 'GET',
                });
            });
        }
        /**
         *
         * @param tx_rollup_id the transaction rollup ID
         * @param block_level the block level
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the inbox of a transaction rollup
         *
         * @see https://tezos.gitlab.io/jakarta/rpc.html#get-block-id-context-tx-rollup-tx-rollup-id-inbox-block-level
         */
        getTxRollupInbox(txRollupId, blockLevel, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/tx_rollup/${txRollupId}/inbox/${blockLevel}`),
                    method: 'GET',
                });
            });
        }
        /**
         *
         * @param contract address of the contract we want to retrieve storage information of
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the amount of used space in a contract's storage
         *
         * @see https://tezos.gitlab.io/lima/rpc.html#get-block-id-context-contracts-contract-id-storage
         */
        getStorageUsedSpace(contract, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/storage/used_space`),
                    method: 'GET',
                });
            });
        }
        /**
         *
         * @param contract address of the contract we want to retrieve storage information of
         * @param options contains generic configuration for rpc calls
         *
         * @description Access the amount of paid space in a contract's storage
         *
         * @see https://tezos.gitlab.io/lima/rpc.html#get-block-id-context-contracts-contract-id-storage
         */
        getStoragePaidSpace(contract, { block } = defaultRPCOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/storage/paid_space`),
                    method: 'GET',
                });
            });
        }
    }

    exports.RpcClient = RpcClient;
    exports.RpcClientCache = RpcClientCache;
    exports.VERSION = VERSION;
    exports.castToBigNumber = castToBigNumber;
    exports.defaultChain = defaultChain;
    exports.defaultRPCOptions = defaultRPCOptions;

    Object.defineProperty(exports, '__esModule', { value: true });

}));


},{"@taquito/http-utils":169,"@taquito/utils":205,"bignumber.js":242}],204:[function(require,module,exports){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taquito/rpc'), require('@taquito/http-utils'), require('rxjs'), require('rxjs/operators'), require('@taquito/michelson-encoder'), require('@taquito/utils'), require('bignumber.js'), require('@taquito/michel-codec'), require('@taquito/local-forging')) :
    typeof define === 'function' && define.amd ? define(['exports', '@taquito/rpc', '@taquito/http-utils', 'rxjs', 'rxjs/operators', '@taquito/michelson-encoder', '@taquito/utils', 'bignumber.js', '@taquito/michel-codec', '@taquito/local-forging'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.taquito = {}, global.rpc, global.httpUtils, global.rxjs, global.operators, global.michelsonEncoder, global.utils, global.BigNumber, global.michelCodec, global.localForging));
})(this, (function (exports, rpc, httpUtils, rxjs, operators, michelsonEncoder, utils, BigNumber, michelCodec, localForging) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var BigNumber__default = /*#__PURE__*/_interopDefaultLegacy(BigNumber);

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }

    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    function formatErrorMessage(error, stringToReplace) {
        const body = JSON.parse(error.body);
        if (body[0] && body[0].kind && body[0].msg) {
            const newBody = JSON.stringify({
                kind: body[0].kind,
                id: body[0].id,
                msg: body[0].msg.replace(stringToReplace, ''),
            });
            return new httpUtils.HttpResponseError(`Http error response: (${error.status}) ${newBody}`, error.status, error.statusText, newBody, error.url);
        }
        else {
            return error;
        }
    }

    class RpcInjector {
        constructor(context) {
            this.context = context;
        }
        inject(signedOperationBytes) {
            return __awaiter(this, void 0, void 0, function* () {
                let hash;
                try {
                    hash = yield this.context.rpc.injectOperation(signedOperationBytes);
                }
                catch (error) {
                    const stringToStrip = '. You may want to use --replace to provide adequate fee and replace it';
                    if (error instanceof httpUtils.HttpResponseError && error.message.includes(stringToStrip)) {
                        throw formatErrorMessage(error, stringToStrip);
                    }
                    else {
                        throw error;
                    }
                }
                return hash;
            });
        }
    }

    /**
     *  @category Error
     *  @description Error that indicates the signer has been unconfigured in the TezosToolkit instance
     */
    class UnconfiguredSignerError extends Error {
        constructor() {
            super('No signer has been configured. Please configure one by calling setProvider({signer}) on your TezosToolkit instance.');
            this.name = 'UnconfiguredSignerError';
        }
    }
    /**
     * @description Default signer implementation which does nothing and produce invalid signature
     */
    class NoopSigner {
        publicKey() {
            return __awaiter(this, void 0, void 0, function* () {
                throw new UnconfiguredSignerError();
            });
        }
        publicKeyHash() {
            return __awaiter(this, void 0, void 0, function* () {
                throw new UnconfiguredSignerError();
            });
        }
        secretKey() {
            return __awaiter(this, void 0, void 0, function* () {
                throw new UnconfiguredSignerError();
            });
        }
        sign(_bytes, _watermark) {
            return __awaiter(this, void 0, void 0, function* () {
                throw new UnconfiguredSignerError();
            });
        }
    }

    function createObservableFromSubscription(sub) {
        return new rxjs.Observable((subscriber) => {
            sub.on('data', (data) => {
                subscriber.next(data);
            });
            sub.on('error', (error) => {
                subscriber.error(error);
            });
            sub.on('close', () => {
                subscriber.complete();
            });
            return () => {
                sub.close();
            };
        });
    }

    exports.DEFAULT_GAS_LIMIT = void 0;
    (function (DEFAULT_GAS_LIMIT) {
        DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT["DELEGATION"] = 10600] = "DELEGATION";
        DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT["ORIGINATION"] = 10600] = "ORIGINATION";
        DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT["TRANSFER"] = 10600] = "TRANSFER";
        DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT["REVEAL"] = 1100] = "REVEAL";
    })(exports.DEFAULT_GAS_LIMIT || (exports.DEFAULT_GAS_LIMIT = {}));
    exports.DEFAULT_FEE = void 0;
    (function (DEFAULT_FEE) {
        DEFAULT_FEE[DEFAULT_FEE["DELEGATION"] = 1257] = "DELEGATION";
        DEFAULT_FEE[DEFAULT_FEE["ORIGINATION"] = 10000] = "ORIGINATION";
        DEFAULT_FEE[DEFAULT_FEE["TRANSFER"] = 10000] = "TRANSFER";
        DEFAULT_FEE[DEFAULT_FEE["REVEAL"] = 374] = "REVEAL";
    })(exports.DEFAULT_FEE || (exports.DEFAULT_FEE = {}));
    exports.DEFAULT_STORAGE_LIMIT = void 0;
    (function (DEFAULT_STORAGE_LIMIT) {
        DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT["DELEGATION"] = 0] = "DELEGATION";
        DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT["ORIGINATION"] = 257] = "ORIGINATION";
        DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT["TRANSFER"] = 257] = "TRANSFER";
        DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT["REVEAL"] = 0] = "REVEAL";
    })(exports.DEFAULT_STORAGE_LIMIT || (exports.DEFAULT_STORAGE_LIMIT = {}));
    const COST_PER_BYTE = 250;
    exports.Protocols = void 0;
    (function (Protocols) {
        Protocols["Pt24m4xi"] = "Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd";
        Protocols["PsBABY5H"] = "PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU";
        Protocols["PsBabyM1"] = "PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS";
        Protocols["PsCARTHA"] = "PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb";
        Protocols["PsDELPH1"] = "PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo";
        Protocols["PtEdo2Zk"] = "PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA";
        Protocols["PsFLorena"] = "PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i";
        Protocols["PtGRANADs"] = "PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV";
        Protocols["PtHangz2"] = "PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx";
        Protocols["PsiThaCa"] = "PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP";
        Protocols["Psithaca2"] = "Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A";
        Protocols["PtJakart2"] = "PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY";
        Protocols["PtKathman"] = "PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg";
        Protocols["PtLimaPtL"] = "PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW";
        Protocols["ProtoALpha"] = "ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK";
    })(exports.Protocols || (exports.Protocols = {}));
    const protocols = {
        '004': [exports.Protocols.Pt24m4xi],
        '005': [exports.Protocols.PsBABY5H, exports.Protocols.PsBabyM1],
        '006': [exports.Protocols.PsCARTHA],
        '007': [exports.Protocols.PsDELPH1],
        '008': [exports.Protocols.PtEdo2Zk],
        '009': [exports.Protocols.PsFLorena],
        '010': [exports.Protocols.PtGRANADs],
        '011': [exports.Protocols.PtHangz2],
        '012': [exports.Protocols.PsiThaCa, exports.Protocols.Psithaca2],
        '013': [exports.Protocols.PtJakart2],
        '014': [exports.Protocols.PtKathman],
        '015': [exports.Protocols.PtLimaPtL],
        '016': [exports.Protocols.ProtoALpha]
    };
    exports.ChainIds = void 0;
    (function (ChainIds) {
        ChainIds["MAINNET"] = "NetXdQprcVkpaWU";
        ChainIds["CARTHAGENET"] = "NetXjD3HPJJjmcd";
        ChainIds["DELPHINET"] = "NetXm8tYqnMWky1";
        ChainIds["EDONET"] = "NetXSgo1ZT2DRUG";
        ChainIds["FLORENCENET"] = "NetXxkAx4woPLyu";
        ChainIds["GRANADANET"] = "NetXz969SFaFn8k";
        ChainIds["HANGZHOUNET"] = "NetXZSsxBpMQeAT";
        ChainIds["ITHACANET"] = "NetXbhmtAbMukLc";
        ChainIds["ITHACANET2"] = "NetXnHfVqm9iesp";
        ChainIds["JAKARTANET2"] = "NetXLH1uAxK7CCh";
        ChainIds["KATHMANDUNET"] = "NetXazhm4yetmff";
        ChainIds["LIMANET"] = "NetXizpkH94bocH";
    })(exports.ChainIds || (exports.ChainIds = {}));

    /**
     *  @category Error
     *  @description Error that indicates invalid smart contract parameters being passed or used
     */
    class InvalidParameterError extends Error {
        constructor(smartContractMethodName, sigs, args) {
            super(`${smartContractMethodName} Received ${args.length} arguments while expecting one of the following signatures (${JSON.stringify(sigs)})`);
            this.smartContractMethodName = smartContractMethodName;
            this.sigs = sigs;
            this.args = args;
            this.name = 'Invalid parameters error';
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates an invalid delegation source contract address being passed or used
     */
    class InvalidDelegationSource extends Error {
        constructor(source) {
            super(`Since Babylon delegation source can no longer be a contract address ${source}. Please use the smart contract abstraction to set your delegate.`);
            this.source = source;
            this.name = 'Invalid delegation source error';
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates an invalid smart contract code parameter being passed or used
     */
    class InvalidCodeParameter extends Error {
        constructor(message, data) {
            super(message);
            this.message = message;
            this.data = data;
            this.name = 'InvalidCodeParameter';
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates invalid smart contract init parameter being passed or used
     */
    class InvalidInitParameter extends Error {
        constructor(message, data) {
            super(message);
            this.message = message;
            this.data = data;
            this.name = 'InvalidInitParameter';
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates invalid view parameter of a smart contract
     */
    class InvalidViewParameterError extends Error {
        constructor(smartContractViewName, sigs, args, originalError) {
            super(`Unable to encode the parameter of the view: ${smartContractViewName}. Received ${args} as parameter while expecting one of the following signatures (${JSON.stringify(sigs)})`);
            this.smartContractViewName = smartContractViewName;
            this.sigs = sigs;
            this.args = args;
            this.originalError = originalError;
            this.name = 'Invalid view parameters error';
            this.cause = originalError;
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates a failure when conducting a view simulation
     */
    class ViewSimulationError extends Error {
        constructor(message, viewName, failWith, originalError) {
            super(message);
            this.message = message;
            this.viewName = viewName;
            this.failWith = failWith;
            this.originalError = originalError;
            this.name = 'ViewSimulationError';
        }
    }
    const validateAndExtractFailwith = (error) => {
        if (isJsonString(error.body)) {
            const parsedError = JSON.parse(error.body);
            if (Array.isArray(parsedError) && 'with' in parsedError[parsedError.length - 1]) {
                return parsedError[parsedError.length - 1].with;
            }
        }
    };
    const isJsonString = (str) => {
        try {
            JSON.parse(str);
        }
        catch (e) {
            return false;
        }
        return true;
    };
    /**
     *  @category Error
     *  @description Error that indicates invalid or unconfigured context when executing a view
     */
    class InvalidViewSimulationContext extends Error {
        constructor(info) {
            super(`${info} Please configure the context of the view execution in the executeView method.`);
            this.info = info;
            this.name = 'InvalidViewSimulationContext';
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates a mistake happening during the reveal operation
     */
    class RevealOperationError extends Error {
        constructor(message) {
            super(message);
            this.message = message;
            this.name = 'RevealOperationError';
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates a mistake in the parameters in the preparation of an Origination operation
     */
    class OriginationParameterError extends Error {
        constructor(message) {
            super(message);
            this.message = message;
            this.name = 'OriginationParameterError';
        }
    }
    class IntegerError extends Error {
        constructor(message) {
            super(message);
            this.message = message;
            this.name = 'IntegerError';
        }
    }

    const createOriginationOperation = ({ code, init, balance = '0', delegate, storage, fee = exports.DEFAULT_FEE.ORIGINATION, gasLimit = exports.DEFAULT_GAS_LIMIT.ORIGINATION, storageLimit = exports.DEFAULT_STORAGE_LIMIT.ORIGINATION, mutez = false, }) => __awaiter(void 0, void 0, void 0, function* () {
        if (storage !== undefined && init !== undefined) {
            throw new OriginationParameterError('Storage and Init cannot be set a the same time. Please either use storage or init but not both.');
        }
        if (!Array.isArray(code)) {
            throw new InvalidCodeParameter('Wrong code parameter type, expected an array', code);
        }
        let contractStorage;
        if (storage !== undefined) {
            const storageType = code.find((p) => 'prim' in p && p.prim === 'storage');
            if ((storageType === null || storageType === void 0 ? void 0 : storageType.args) === undefined) {
                throw new InvalidCodeParameter('The storage section is missing from the script', code);
            }
            const schema = new michelsonEncoder.Schema(storageType.args[0]); // TODO
            contractStorage = schema.Encode(storage);
        }
        else if (init !== undefined && typeof init === 'object') {
            contractStorage = init;
        }
        else {
            throw new InvalidInitParameter('Wrong init parameter type, expected JSON Michelson', init);
        }
        const script = {
            code,
            storage: contractStorage,
        };
        if (isNaN(Number(balance))) {
            throw new IntegerError(`Unexpected Invalid Integer ${balance}`);
        }
        const operation = {
            kind: rpc.OpKind.ORIGINATION,
            fee,
            gas_limit: gasLimit,
            storage_limit: storageLimit,
            balance: mutez ? balance.toString() : utils.format('tz', 'mutez', balance).toString(),
            script,
        };
        if (delegate) {
            operation.delegate = delegate;
        }
        return operation;
    });
    const createTransferOperation = ({ to, amount, parameter, fee = exports.DEFAULT_FEE.TRANSFER, gasLimit = exports.DEFAULT_GAS_LIMIT.TRANSFER, storageLimit = exports.DEFAULT_STORAGE_LIMIT.TRANSFER, mutez = false, }) => __awaiter(void 0, void 0, void 0, function* () {
        const operation = {
            kind: rpc.OpKind.TRANSACTION,
            fee,
            gas_limit: gasLimit,
            storage_limit: storageLimit,
            amount: mutez ? amount.toString() : utils.format('tz', 'mutez', amount).toString(),
            destination: to,
            parameters: parameter,
        };
        return operation;
    });
    const createSetDelegateOperation = ({ delegate, source, fee = exports.DEFAULT_FEE.DELEGATION, gasLimit = exports.DEFAULT_GAS_LIMIT.DELEGATION, storageLimit = exports.DEFAULT_STORAGE_LIMIT.DELEGATION, }) => __awaiter(void 0, void 0, void 0, function* () {
        const operation = {
            kind: rpc.OpKind.DELEGATION,
            source,
            fee,
            gas_limit: gasLimit,
            storage_limit: storageLimit,
            delegate,
        };
        return operation;
    });
    const createRegisterDelegateOperation = ({ fee = exports.DEFAULT_FEE.DELEGATION, gasLimit = exports.DEFAULT_GAS_LIMIT.DELEGATION, storageLimit = exports.DEFAULT_STORAGE_LIMIT.DELEGATION, }, source) => __awaiter(void 0, void 0, void 0, function* () {
        return {
            kind: rpc.OpKind.DELEGATION,
            fee,
            gas_limit: gasLimit,
            storage_limit: storageLimit,
            delegate: source,
        };
    });
    const createRevealOperation = ({ fee = exports.DEFAULT_FEE.REVEAL, gasLimit = exports.DEFAULT_GAS_LIMIT.REVEAL, storageLimit = exports.DEFAULT_STORAGE_LIMIT.REVEAL, }, source, publicKey) => __awaiter(void 0, void 0, void 0, function* () {
        return {
            kind: rpc.OpKind.REVEAL,
            fee,
            public_key: publicKey,
            source,
            gas_limit: gasLimit,
            storage_limit: storageLimit,
        };
    });
    const createRegisterGlobalConstantOperation = ({ value, source, fee, gasLimit, storageLimit, }) => __awaiter(void 0, void 0, void 0, function* () {
        return {
            kind: rpc.OpKind.REGISTER_GLOBAL_CONSTANT,
            value,
            fee,
            gas_limit: gasLimit,
            storage_limit: storageLimit,
            source,
        };
    });
    const createTxRollupOriginationOperation = ({ source, fee, gasLimit, storageLimit, }) => __awaiter(void 0, void 0, void 0, function* () {
        return {
            kind: rpc.OpKind.TX_ROLLUP_ORIGINATION,
            fee,
            gas_limit: gasLimit,
            storage_limit: storageLimit,
            source,
            tx_rollup_origination: {},
        };
    });
    const createTxRollupBatchOperation = ({ content, rollup, source, fee, gasLimit, storageLimit, }) => __awaiter(void 0, void 0, void 0, function* () {
        return {
            kind: rpc.OpKind.TX_ROLLUP_SUBMIT_BATCH,
            fee,
            gas_limit: gasLimit,
            storage_limit: storageLimit,
            source,
            content,
            rollup,
        };
    });
    const createTransferTicketOperation = ({ ticketContents, ticketTy, ticketTicketer, ticketAmount, destination, entrypoint, source, fee, gasLimit, storageLimit, }) => __awaiter(void 0, void 0, void 0, function* () {
        return {
            kind: rpc.OpKind.TRANSFER_TICKET,
            fee,
            gas_limit: gasLimit,
            storage_limit: storageLimit,
            source,
            ticket_contents: ticketContents,
            ticket_ty: ticketTy,
            ticket_ticketer: ticketTicketer,
            ticket_amount: ticketAmount,
            destination,
            entrypoint,
        };
    });
    const createIncreasePaidStorageOperation = ({ source, fee, gasLimit, storageLimit, amount, destination, }) => __awaiter(void 0, void 0, void 0, function* () {
        return {
            kind: rpc.OpKind.INCREASE_PAID_STORAGE,
            source,
            fee,
            gas_limit: gasLimit,
            storage_limit: storageLimit,
            amount,
            destination,
        };
    });
    const createDrainDelegateOperation = ({ consensus_key, delegate, destination, }) => __awaiter(void 0, void 0, void 0, function* () {
        return {
            kind: rpc.OpKind.DRAIN_DELEGATE,
            consensus_key,
            delegate,
            destination,
        };
    });
    const createBallotOperation = ({ source, proposal, ballot }) => __awaiter(void 0, void 0, void 0, function* () {
        return {
            kind: rpc.OpKind.BALLOT,
            source,
            proposal,
            ballot,
        };
    });
    const createProposalsOperation = ({ source, proposals }) => __awaiter(void 0, void 0, void 0, function* () {
        return {
            kind: rpc.OpKind.PROPOSALS,
            source,
            proposals,
        };
    });
    const createUpdateConsensusKeyOperation = ({ source, fee, gasLimit, storageLimit, pk, }) => __awaiter(void 0, void 0, void 0, function* () {
        return {
            kind: rpc.OpKind.UPDATE_CONSENSUS_KEY,
            source,
            fee,
            gas_limit: gasLimit,
            storage_limit: storageLimit,
            pk,
        };
    });

    const attachKind = (op, kind) => {
        return Object.assign(Object.assign({}, op), { kind });
    };
    const findWithKind = (arr, kind) => {
        if (Array.isArray(arr)) {
            const found = arr.find((op) => op.kind === kind);
            if (found && isKind(found, kind)) {
                return found;
            }
        }
    };
    const isKind = (op, kind) => {
        return op.kind === kind;
    };
    const isOpWithFee = (op) => {
        return ([
            'transaction',
            'delegation',
            'origination',
            'reveal',
            'register_global_constant',
            'increase_paid_storage',
            'tx_rollup_origination',
            'tx_rollup_submit_batch',
            'transfer_ticket',
            'update_consensus_key',
        ].indexOf(op.kind) !== -1);
    };
    const isOpRequireReveal = (op) => {
        return ([
            'transaction',
            'delegation',
            'origination',
            'register_global_constant',
            'increase_paid_storage',
            'tx_rollup_origination',
            'tx_rollup_submit_batch',
            'transfer_ticket',
            'update_consensus_key',
        ].indexOf(op.kind) !== -1);
    };
    const hasMetadata = (op) => {
        return 'metadata' in op;
    };
    const hasMetadataWithResult = (op) => {
        return hasMetadata(op) && 'operation_result' in op.metadata;
    };
    const hasMetadataWithInternalOperationResult = (op) => {
        return hasMetadata(op) && 'internal_operation_results' in op.metadata;
    };

    const isErrorWithMessage = (error) => {
        return 'with' in error;
    };
    /**
     *  @category Error
     *  @description Generic tezos error that will be thrown when a mistake occurs when doing an operation; more details here https://tezos.gitlab.io/api/errors.html
     */
    class TezosOperationError extends Error {
        constructor(errors, errorDetails) {
            super();
            this.errors = errors;
            this.errorDetails = errorDetails;
            this.name = 'TezosOperationError';
            // Last error is 'often' the one with more detail
            const lastError = errors[errors.length - 1];
            this.id = lastError.id;
            this.kind = lastError.kind;
            this.message = `(${this.kind}) ${this.id}`;
            if (isErrorWithMessage(lastError)) {
                if (lastError.with.string) {
                    this.message = lastError.with.string;
                }
                else if (lastError.with.int) {
                    this.message = lastError.with.int;
                }
                else {
                    this.message = JSON.stringify(lastError.with);
                }
            }
        }
    }
    /**
     *  @category Error
     *  @description Tezos error that will be thrown when a mistake happens during the preapply stage
     */
    class TezosPreapplyFailureError extends Error {
        constructor(result) {
            super('Preapply returned an unexpected result');
            this.result = result;
            this.name = 'TezosPreapplyFailureError';
        }
    }
    // Flatten all operation content results and internal operation results into a single array
    // Some cases where we can have multiple operation results or internal operation results are:
    // - When an operation includes a reveal operation
    // - When an operation is made using the batch API
    // - Smart contract call can contains internal operation results when they call other smart contract internally or originate contracts
    const flattenOperationResult = (response) => {
        const results = Array.isArray(response) ? response : [response];
        const returnedResults = [];
        for (let i = 0; i < results.length; i++) {
            for (let j = 0; j < results[i].contents.length; j++) {
                const content = results[i].contents[j];
                if (hasMetadataWithResult(content)) {
                    returnedResults.push(Object.assign({ fee: content.fee }, content.metadata.operation_result));
                    if (Array.isArray(content.metadata.internal_operation_results)) {
                        content.metadata.internal_operation_results.forEach((x) => returnedResults.push(x.result));
                    }
                }
            }
        }
        return returnedResults;
    };
    /***
     * @description Flatten all error from preapply response (including internal error)
     */
    const flattenErrors = (response, status = 'failed') => {
        const results = Array.isArray(response) ? response : [response];
        let errors = [];
        // Transaction that do not fail will be backtracked in case one failure occur
        for (let i = 0; i < results.length; i++) {
            for (let j = 0; j < results[i].contents.length; j++) {
                const content = results[i].contents[j];
                if (hasMetadata(content)) {
                    if (hasMetadataWithResult(content) && content.metadata.operation_result.status === status) {
                        errors = errors.concat(content.metadata.operation_result.errors || []);
                    }
                    if (hasMetadataWithInternalOperationResult(content) &&
                        Array.isArray(content.metadata.internal_operation_results)) {
                        for (const internalResult of content.metadata.internal_operation_results) {
                            if ('result' in internalResult && internalResult.result.status === status) {
                                errors = errors.concat(internalResult.result.errors || []);
                            }
                        }
                    }
                }
            }
        }
        return errors;
    };
    /**
     *  @category Error
     *  @description Error that indicates a general failure happening during an origination operation
     */
    class OriginationOperationError extends Error {
        constructor(message) {
            super(message);
            this.message = message;
            this.name = 'OriginationOperationError';
        }
    }

    /**
     *  @category Error
     *  @description Error that indicates invalid confirmation count has been passed or configured
     */
    class InvalidConfirmationCountError extends Error {
        constructor(message) {
            super(message);
            this.message = message;
            this.name = 'InvalidConfirmationCountError';
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates undefined confirmation has not been specified or configured
     */
    class ConfirmationUndefinedError extends Error {
        constructor(message) {
            super(message);
            this.message = message;
            this.name = 'ConfirmationUndefinedError';
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates an invalid filter expression being passed or used
     */
    class InvalidFilterExpressionError extends Error {
        constructor(message) {
            super(message);
            this.message = message;
            this.name = 'InvalidFilterExpressionError';
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates an error being returned from the RPC response
     */
    class RPCResponseError extends Error {
        constructor(message) {
            super(message);
            this.message = message;
            this.name = 'RPCResponseError';
        }
    }

    /**
     * @description Utility class to interact with Tezos operations
     */
    class Operation {
        /**
         *
         * @param hash Operation hash
         * @param raw Raw operation that was injected
         * @param context Taquito context allowing access to rpc and signer
         */
        constructor(hash, raw, results, context) {
            this.hash = hash;
            this.raw = raw;
            this.results = results;
            this.context = context;
            this._pollingConfig$ = new rxjs.ReplaySubject(1);
            this.currentHead$ = this._pollingConfig$.pipe(operators.switchMap((config) => {
                return new rxjs.BehaviorSubject(config).pipe(operators.timeoutWith(config.timeout * 1000, rxjs.throwError(new Error('Confirmation polling timed out'))));
            }), operators.switchMap(() => {
                return rxjs.defer(() => createObservableFromSubscription(this.context.stream.subscribeBlock('head'))).pipe(operators.switchMap((newHead) => {
                    var _a, _b;
                    const prevHead = (_b = (_a = this.lastHead) === null || _a === void 0 ? void 0 : _a.header.level) !== null && _b !== void 0 ? _b : newHead.header.level - 1;
                    return rxjs.range(prevHead + 1, newHead.header.level - prevHead - 1).pipe(operators.concatMap((level) => this.context.readProvider.getBlock(level)), operators.endWith(newHead));
                }), operators.tap((newHead) => (this.lastHead = newHead)));
            }), operators.shareReplay({ refCount: true }));
            // Observable that emit once operation is seen in a block
            this.confirmed$ = this.currentHead$.pipe(operators.map((head) => {
                for (let i = 3; i >= 0; i--) {
                    head.operations[i].forEach((op) => {
                        if (op.hash === this.hash) {
                            this._foundAt = head.header.level;
                        }
                    });
                }
                if (head.header.level - this._foundAt >= 0) {
                    return this._foundAt;
                }
            }), operators.filter((x) => x !== undefined), operators.first(), operators.shareReplay());
            this._foundAt = Number.POSITIVE_INFINITY;
            if (utils.validateOperation(this.hash) !== utils.ValidationResult.VALID) {
                throw new utils.InvalidOperationHashError(this.hash);
            }
            this.confirmed$
                .pipe(operators.first(), operators.catchError(() => {
                return rxjs.of(rxjs.EMPTY);
            }))
                .subscribe();
        }
        get includedInBlock() {
            return this._foundAt;
        }
        get revealOperation() {
            return (Array.isArray(this.results) &&
                this.results.find((op) => op.kind === 'reveal'));
        }
        get revealStatus() {
            if (this.revealOperation) {
                return this.revealOperation.metadata.operation_result.status;
            }
            else {
                return 'unknown';
            }
        }
        get status() {
            return (this.results.map((result) => {
                if (hasMetadataWithResult(result)) {
                    return result.metadata.operation_result.status;
                }
                else {
                    return 'unknown';
                }
            })[0] || 'unknown');
        }
        /**
         *
         * @param confirmations [0] Number of confirmation to wait for
         * @param timeout [180] Timeout
         */
        confirmation(confirmations, timeout) {
            return __awaiter(this, void 0, void 0, function* () {
                if (typeof confirmations !== 'undefined' && confirmations < 1) {
                    throw new InvalidConfirmationCountError('Confirmation count must be at least 1');
                }
                const { defaultConfirmationCount, confirmationPollingTimeoutSecond } = this.context.config;
                this._pollingConfig$.next({
                    timeout: timeout || confirmationPollingTimeoutSecond,
                });
                const conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;
                return new Promise((resolve, reject) => {
                    this.confirmed$
                        .pipe(operators.switchMap(() => this.currentHead$), operators.filter((head) => head.header.level - this._foundAt >= conf - 1), operators.first())
                        .subscribe((_) => {
                        resolve(this._foundAt + (conf - 1));
                    }, reject);
                });
            });
        }
    }

    class BatchOperation extends Operation {
        constructor(hash, params, source, raw, results, context) {
            super(hash, raw, results, context);
            this.params = params;
            this.source = source;
        }
        sumProp(arr, prop) {
            return arr.reduce((prev, current) => {
                return prop in current ? Number(current[prop]) + prev : prev;
            }, 0);
        }
        getOriginatedContractAddresses() {
            const originationOpResults = this.results.filter((x) => x.kind === 'origination');
            let addresses = [];
            for (const res of originationOpResults) {
                if (res.metadata.operation_result.originated_contracts) {
                    addresses = [...addresses, ...res.metadata.operation_result.originated_contracts];
                }
            }
            return addresses;
        }
        get status() {
            return (this.results
                .filter((result) => BATCH_KINDS.indexOf(result.kind) !== -1)
                .map((result) => {
                if (hasMetadataWithResult(result)) {
                    return result.metadata.operation_result.status;
                }
                else {
                    return 'unknown';
                }
            })[0] || 'unknown');
        }
        get fee() {
            return this.sumProp(this.params, 'fee');
        }
        get gasLimit() {
            return this.sumProp(this.params, 'gas_limit');
        }
        get storageLimit() {
            return this.sumProp(this.params, 'storage_limit');
        }
        get consumedGas() {
            BigNumber__default["default"].config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber__default["default"].ROUND_UP });
            return new BigNumber__default["default"](this.consumedMilliGas).dividedBy(1000).toString();
        }
        get consumedMilliGas() {
            return String(this.sumProp(flattenOperationResult({ contents: this.results }), 'consumed_milligas'));
        }
        get storageDiff() {
            return String(this.sumProp(flattenOperationResult({ contents: this.results }), 'paid_storage_size_diff'));
        }
        get errors() {
            return flattenErrors({ contents: this.results });
        }
    }

    class OperationEmitter {
        constructor(context) {
            this.context = context;
        }
        get rpc() {
            return this.context.rpc;
        }
        get signer() {
            return this.context.signer;
        }
        isRevealOpNeeded(op, pkh) {
            return __awaiter(this, void 0, void 0, function* () {
                return !(yield this.isAccountRevealRequired(pkh)) || !this.isRevealRequiredForOpType(op)
                    ? false
                    : true;
            });
        }
        isAccountRevealRequired(publicKeyHash) {
            return __awaiter(this, void 0, void 0, function* () {
                return !(yield this.context.readProvider.isAccountRevealed(publicKeyHash, 'head'));
            });
        }
        isRevealRequiredForOpType(op) {
            let opRequireReveal = false;
            for (const operation of op) {
                if (isOpRequireReveal(operation)) {
                    opRequireReveal = true;
                }
            }
            return opRequireReveal;
        }
        // Originally from sotez (Copyright (c) 2018 Andrew Kishino)
        prepareOperation({ operation, source }, pkh) {
            return __awaiter(this, void 0, void 0, function* () {
                const counters = {};
                let ops = [];
                const blockHashPromise = this.context.readProvider.getBlockHash('head~2');
                const blockProtoPromise = this.context.readProvider.getNextProtocol('head');
                if (Array.isArray(operation)) {
                    ops = [...operation];
                }
                else {
                    ops = [operation];
                }
                // Implicit account who emit the operation
                const publicKeyHash = pkh ? pkh : yield this.signer.publicKeyHash();
                let counterPromise = Promise.resolve(undefined);
                // initializes a currentVotingPeriod if the operation is a ballot op
                let currentVotingPeriodPromise = Promise.resolve(undefined);
                ops.find((op) => __awaiter(this, void 0, void 0, function* () {
                    if (op.kind === 'ballot' || op.kind === 'proposals') {
                        try {
                            currentVotingPeriodPromise = this.rpc.getCurrentPeriod();
                        }
                        catch (e) {
                            throw new RPCResponseError(`Failed to get the current voting period index: ${JSON.stringify(e)}`);
                        }
                    }
                }));
                for (let i = 0; i < ops.length; i++) {
                    if (isOpRequireReveal(ops[i]) || ops[i].kind === 'reveal') {
                        counterPromise = this.context.readProvider.getCounter(publicKeyHash, 'head');
                        break;
                    }
                }
                const [hash, protocol, headCounter, currentVotingPeriod] = yield Promise.all([
                    blockHashPromise,
                    blockProtoPromise,
                    counterPromise,
                    currentVotingPeriodPromise,
                ]);
                const counter = parseInt(headCounter || '0', 10);
                if (!counters[publicKeyHash] || counters[publicKeyHash] < counter) {
                    counters[publicKeyHash] = counter;
                }
                const getFee = (op) => {
                    const opCounter = ++counters[publicKeyHash];
                    return {
                        counter: `${opCounter}`,
                        fee: typeof op.fee === 'undefined' ? '0' : `${op.fee}`,
                        gas_limit: typeof op.gas_limit === 'undefined' ? '0' : `${op.gas_limit}`,
                        storage_limit: typeof op.storage_limit === 'undefined' ? '0' : `${op.storage_limit}`,
                    };
                };
                const getSource = (op) => {
                    return {
                        source: typeof op.source === 'undefined' ? source || publicKeyHash : op.source,
                    };
                };
                const constructOps = (cOps) => cOps.map((op) => {
                    switch (op.kind) {
                        case rpc.OpKind.ACTIVATION:
                        case rpc.OpKind.DRAIN_DELEGATE:
                            return Object.assign({}, op);
                        case rpc.OpKind.ORIGINATION:
                            return Object.assign(Object.assign(Object.assign(Object.assign({}, op), { balance: typeof op.balance !== 'undefined' ? `${op.balance}` : '0' }), getSource(op)), getFee(op));
                        case rpc.OpKind.TRANSACTION: {
                            const cops = Object.assign(Object.assign(Object.assign(Object.assign({}, op), { amount: typeof op.amount !== 'undefined' ? `${op.amount}` : '0' }), getSource(op)), getFee(op));
                            if (cops.source.toLowerCase().startsWith('kt1')) {
                                throw new utils.DeprecationError(`KT1 addresses are not supported as source since ${exports.Protocols.PsBabyM1}`);
                            }
                            return cops;
                        }
                        case rpc.OpKind.REVEAL:
                        case rpc.OpKind.DELEGATION:
                        case rpc.OpKind.REGISTER_GLOBAL_CONSTANT:
                        case rpc.OpKind.TX_ROLLUP_ORIGINATION:
                        case rpc.OpKind.TX_ROLLUP_SUBMIT_BATCH:
                        case rpc.OpKind.UPDATE_CONSENSUS_KEY:
                            return Object.assign(Object.assign(Object.assign({}, op), getSource(op)), getFee(op));
                        case rpc.OpKind.TRANSFER_TICKET:
                            return Object.assign(Object.assign(Object.assign(Object.assign({}, op), { ticket_amount: `${op.ticket_amount}` }), getSource(op)), getFee(op));
                        case rpc.OpKind.INCREASE_PAID_STORAGE:
                            return Object.assign(Object.assign(Object.assign(Object.assign({}, op), { amount: `${op.amount}` }), getSource(op)), getFee(op));
                        case rpc.OpKind.BALLOT:
                            if (currentVotingPeriod === undefined) {
                                throw new RPCResponseError(`Failed to get the current voting period index`);
                            }
                            return Object.assign(Object.assign({}, op), { period: currentVotingPeriod === null || currentVotingPeriod === void 0 ? void 0 : currentVotingPeriod.voting_period.index });
                        case rpc.OpKind.PROPOSALS:
                            if (currentVotingPeriod === undefined) {
                                throw new RPCResponseError(`Failed to get the current voting period index`);
                            }
                            return Object.assign(Object.assign({}, op), { period: currentVotingPeriod === null || currentVotingPeriod === void 0 ? void 0 : currentVotingPeriod.voting_period.index });
                        default:
                            throw new utils.InvalidOperationKindError(op.kind);
                    }
                });
                const contents = constructOps(ops);
                return {
                    opOb: {
                        branch: hash,
                        contents,
                        protocol,
                    },
                    counter,
                };
            });
        }
        forge({ opOb: { branch, contents, protocol }, counter }) {
            return __awaiter(this, void 0, void 0, function* () {
                const forgedBytes = yield this.context.forger.forge({ branch, contents });
                return {
                    opbytes: forgedBytes,
                    opOb: {
                        branch,
                        contents,
                        protocol,
                    },
                    counter,
                };
            });
        }
        simulate(op) {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    opResponse: yield this.rpc.runOperation(op),
                    op,
                    context: this.context.clone(),
                };
            });
        }
        estimate(_a, estimator) {
            var { fee, gasLimit, storageLimit } = _a, rest = __rest(_a, ["fee", "gasLimit", "storageLimit"]);
            return __awaiter(this, void 0, void 0, function* () {
                let calculatedFee = fee;
                let calculatedGas = gasLimit;
                let calculatedStorage = storageLimit;
                if (fee === undefined || gasLimit === undefined || storageLimit === undefined) {
                    const estimation = yield estimator(Object.assign({ fee, gasLimit, storageLimit }, rest));
                    if (calculatedFee === undefined) {
                        calculatedFee = estimation.suggestedFeeMutez;
                    }
                    if (calculatedGas === undefined) {
                        calculatedGas = estimation.gasLimit;
                    }
                    if (calculatedStorage === undefined) {
                        calculatedStorage = estimation.storageLimit;
                    }
                }
                return {
                    fee: calculatedFee,
                    gasLimit: calculatedGas,
                    storageLimit: calculatedStorage,
                };
            });
        }
        signAndInject(forgedBytes) {
            return __awaiter(this, void 0, void 0, function* () {
                const signed = yield this.signer.sign(forgedBytes.opbytes, new Uint8Array([3]));
                forgedBytes.opbytes = signed.sbytes;
                forgedBytes.opOb.signature = signed.prefixSig;
                const opResponse = [];
                const results = yield this.rpc.preapplyOperations([forgedBytes.opOb]);
                if (!Array.isArray(results)) {
                    throw new TezosPreapplyFailureError(results);
                }
                for (let i = 0; i < results.length; i++) {
                    for (let j = 0; j < results[i].contents.length; j++) {
                        opResponse.push(results[i].contents[j]);
                    }
                }
                const errors = flattenErrors(results);
                if (errors.length) {
                    throw new TezosOperationError(errors, 'Error occurred during validation simulation of operation');
                }
                return {
                    hash: yield this.context.injector.inject(forgedBytes.opbytes),
                    forgedBytes,
                    opResponse,
                    context: this.context.clone(),
                };
            });
        }
    }

    const BATCH_KINDS = [
        rpc.OpKind.ACTIVATION,
        rpc.OpKind.ORIGINATION,
        rpc.OpKind.TRANSACTION,
        rpc.OpKind.DELEGATION,
    ];
    class OperationBatch extends OperationEmitter {
        constructor(context, estimator) {
            super(context);
            this.estimator = estimator;
            this.operations = [];
        }
        /**
         *
         * @description Add a transaction operation to the batch
         *
         * @param params Transfer operation parameter
         */
        withTransfer(params) {
            if (utils.validateAddress(params.to) !== utils.ValidationResult.VALID) {
                throw new utils.InvalidAddressError(params.to);
            }
            this.operations.push(Object.assign({ kind: rpc.OpKind.TRANSACTION }, params));
            return this;
        }
        /**
         *
         * @description Transfer tickets from a Tezos address (tz1,tz2 or tz3) to a smart contract address( KT1)
         *
         * @param params Transfer operation parameter
         */
        withTransferTicket(params) {
            if (utils.validateContractAddress(params.destination) !== utils.ValidationResult.VALID) {
                throw new utils.InvalidContractAddressError(params.destination);
            }
            this.operations.push(Object.assign({ kind: rpc.OpKind.TRANSFER_TICKET }, params));
            return this;
        }
        /**
         *
         * @description Add a contract call to the batch
         *
         * @param params Call a contract method
         * @param options Generic operation parameters
         */
        withContractCall(params, options = {}) {
            return this.withTransfer(params.toTransferParams(options));
        }
        /**
         *
         * @description Add a delegation operation to the batch
         *
         * @param params Delegation operation parameter
         */
        withDelegation(params) {
            if (params.source && utils.validateAddress(params.source) !== utils.ValidationResult.VALID) {
                throw new utils.InvalidAddressError(params.source);
            }
            if (params.delegate && utils.validateAddress(params.delegate) !== utils.ValidationResult.VALID) {
                throw new utils.InvalidAddressError(params.delegate);
            }
            this.operations.push(Object.assign({ kind: rpc.OpKind.DELEGATION }, params));
            return this;
        }
        /**
         *
         * @description Add an activation operation to the batch
         *
         * @param params Activation operation parameter
         */
        withActivation({ pkh, secret }) {
            if (utils.validateKeyHash(pkh) !== utils.ValidationResult.VALID) {
                throw new utils.InvalidKeyHashError(pkh);
            }
            this.operations.push({ kind: rpc.OpKind.ACTIVATION, pkh, secret });
            return this;
        }
        /**
         *
         * @description Add an origination operation to the batch
         *
         * @param params Origination operation parameter
         */
        withOrigination(params) {
            this.operations.push(Object.assign({ kind: rpc.OpKind.ORIGINATION }, params));
            return this;
        }
        /**
         *
         * @description Add an operation to register a global constant to the batch
         *
         * @param params RegisterGlobalConstant operation parameter
         */
        withRegisterGlobalConstant(params) {
            this.operations.push(Object.assign({ kind: rpc.OpKind.REGISTER_GLOBAL_CONSTANT }, params));
            return this;
        }
        /**
         *
         * @description Add an operation to increase paid storage to the batch
         *
         * @param params IncreasePaidStorage operation parameter
         */
        withIncreasePaidStorage(params) {
            this.operations.push(Object.assign({ kind: rpc.OpKind.INCREASE_PAID_STORAGE }, params));
            return this;
        }
        /**
         *
         * @description Add an operation to originate a rollup to the batch
         *
         * @param params Rollup origination operation parameter
         */
        withTxRollupOrigination(params) {
            this.operations.push(Object.assign({ kind: rpc.OpKind.TX_ROLLUP_ORIGINATION }, params));
            return this;
        }
        /**
         *
         * @description Add an operation to submit a tx rollup batch to the batch
         *
         * @param params Tx rollup batch operation parameter
         */
        withTxRollupSubmitBatch(params) {
            this.operations.push(Object.assign({ kind: rpc.OpKind.TX_ROLLUP_SUBMIT_BATCH }, params));
            return this;
        }
        getRPCOp(param) {
            return __awaiter(this, void 0, void 0, function* () {
                switch (param.kind) {
                    case rpc.OpKind.TRANSACTION:
                        return createTransferOperation(Object.assign({}, param));
                    case rpc.OpKind.ORIGINATION:
                        return createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign({}, param)));
                    case rpc.OpKind.DELEGATION:
                        return createSetDelegateOperation(Object.assign({}, param));
                    case rpc.OpKind.ACTIVATION:
                        return Object.assign({}, param);
                    case rpc.OpKind.REGISTER_GLOBAL_CONSTANT:
                        return createRegisterGlobalConstantOperation(Object.assign({}, param));
                    case rpc.OpKind.INCREASE_PAID_STORAGE:
                        return createIncreasePaidStorageOperation(Object.assign({}, param));
                    case rpc.OpKind.TX_ROLLUP_ORIGINATION:
                        return createTxRollupOriginationOperation(Object.assign({}, param));
                    case rpc.OpKind.TX_ROLLUP_SUBMIT_BATCH:
                        return createTxRollupBatchOperation(Object.assign({}, param));
                    case rpc.OpKind.TRANSFER_TICKET:
                        return createTransferTicketOperation(Object.assign({}, param));
                    default:
                        throw new utils.InvalidOperationKindError(param.kind);
                }
            });
        }
        /**
         *
         * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array
         *
         * @param params Operations parameter
         */
        with(params) {
            for (const param of params) {
                switch (param.kind) {
                    case rpc.OpKind.TRANSACTION:
                        this.withTransfer(param);
                        break;
                    case rpc.OpKind.ORIGINATION:
                        this.withOrigination(param);
                        break;
                    case rpc.OpKind.DELEGATION:
                        this.withDelegation(param);
                        break;
                    case rpc.OpKind.ACTIVATION:
                        this.withActivation(param);
                        break;
                    case rpc.OpKind.REGISTER_GLOBAL_CONSTANT:
                        this.withRegisterGlobalConstant(param);
                        break;
                    case rpc.OpKind.INCREASE_PAID_STORAGE:
                        this.withIncreasePaidStorage(param);
                        break;
                    case rpc.OpKind.TX_ROLLUP_ORIGINATION:
                        this.withTxRollupOrigination(param);
                        break;
                    case rpc.OpKind.TX_ROLLUP_SUBMIT_BATCH:
                        this.withTxRollupSubmitBatch(param);
                        break;
                    case rpc.OpKind.TRANSFER_TICKET:
                        this.withTransferTicket(param);
                        break;
                    default:
                        throw new utils.InvalidOperationKindError(param.kind);
                }
            }
            return this;
        }
        toPrepare() {
            return __awaiter(this, void 0, void 0, function* () {
                const publicKeyHash = yield this.signer.publicKeyHash();
                const publicKey = yield this.signer.publicKey();
                const estimates = yield this.estimator.batch(this.operations);
                const revealNeeded = yield this.isRevealOpNeeded(this.operations, publicKeyHash);
                let i = revealNeeded ? 1 : 0;
                const ops = [];
                for (const op of this.operations) {
                    if (isOpWithFee(op)) {
                        const estimated = yield this.estimate(op, () => __awaiter(this, void 0, void 0, function* () { return estimates[i]; }));
                        ops.push(yield this.getRPCOp(Object.assign(Object.assign({}, op), estimated)));
                    }
                    else {
                        ops.push(Object.assign({}, op));
                    }
                    i++;
                }
                if (revealNeeded) {
                    const reveal = { kind: rpc.OpKind.REVEAL };
                    const estimatedReveal = yield this.estimate(reveal, () => __awaiter(this, void 0, void 0, function* () { return estimates[0]; }));
                    ops.unshift(yield createRevealOperation(Object.assign({}, estimatedReveal), publicKeyHash, publicKey));
                }
                return ops;
            });
        }
        /**
         *
         * @description Forge and Inject the operation batch
         *
         * @param params Optionally specify the source of the operation
         */
        send(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const publicKeyHash = yield this.signer.publicKeyHash();
                const publicKey = yield this.signer.publicKey();
                const estimates = yield this.estimator.batch(this.operations);
                const revealNeeded = yield this.isRevealOpNeeded(this.operations, publicKeyHash);
                let i = revealNeeded ? 1 : 0;
                const ops = [];
                for (const op of this.operations) {
                    if (isOpWithFee(op)) {
                        const estimated = yield this.estimate(op, () => __awaiter(this, void 0, void 0, function* () { return estimates[i]; }));
                        ops.push(yield this.getRPCOp(Object.assign(Object.assign({}, op), estimated)));
                    }
                    else {
                        ops.push(Object.assign({}, op));
                    }
                    i++;
                }
                if (revealNeeded) {
                    const reveal = { kind: rpc.OpKind.REVEAL };
                    const estimatedReveal = yield this.estimate(reveal, () => __awaiter(this, void 0, void 0, function* () { return estimates[0]; }));
                    ops.unshift(yield createRevealOperation(Object.assign({}, estimatedReveal), publicKeyHash, publicKey));
                }
                const source = (params && params.source) || publicKeyHash;
                const prepared = yield this.prepareOperation({
                    operation: ops,
                    source,
                });
                const opBytes = yield this.forge(prepared);
                const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
                return new BatchOperation(hash, ops, source, forgedBytes, opResponse, context);
            });
        }
    }
    class RPCBatchProvider {
        constructor(context, estimator) {
            this.context = context;
            this.estimator = estimator;
        }
        /***
         *
         * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch
         *
         * @param params List of operation to batch together
         */
        batch(params) {
            const batch = new OperationBatch(this.context, this.estimator);
            if (Array.isArray(params)) {
                batch.with(params);
            }
            return batch;
        }
    }

    const receiptFromOperation = (op, { ALLOCATION_BURN, ORIGINATION_BURN } = {
        ALLOCATION_BURN: 257,
        ORIGINATION_BURN: 257,
    }) => {
        BigNumber__default["default"].config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber__default["default"].ROUND_UP });
        const operationResults = flattenOperationResult({ contents: op });
        let totalMilliGas = new BigNumber__default["default"](0);
        let totalStorage = new BigNumber__default["default"](0);
        let totalFee = new BigNumber__default["default"](0);
        let totalOriginationBurn = new BigNumber__default["default"](0);
        let totalAllocationBurn = new BigNumber__default["default"](0);
        let totalPaidStorageDiff = new BigNumber__default["default"](0);
        operationResults.forEach((result) => {
            totalFee = totalFee.plus(result.fee || 0);
            totalOriginationBurn = totalOriginationBurn.plus(Array.isArray(result.originated_contracts)
                ? result.originated_contracts.length * ORIGINATION_BURN
                : 0);
            totalAllocationBurn = totalAllocationBurn.plus('allocated_destination_contract' in result ? ALLOCATION_BURN : 0);
            totalMilliGas = totalMilliGas.plus(result.consumed_milligas || 0);
            totalPaidStorageDiff = totalPaidStorageDiff.plus('paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0);
        });
        totalStorage = totalStorage
            .plus(totalAllocationBurn)
            .plus(totalOriginationBurn)
            .plus(totalPaidStorageDiff);
        return {
            totalFee,
            totalMilliGas,
            totalGas: totalMilliGas.dividedBy(1000),
            totalStorage,
            totalAllocationBurn,
            totalOriginationBurn,
            totalPaidStorageDiff,
            totalStorageBurn: new BigNumber__default["default"](totalStorage.multipliedBy(COST_PER_BYTE)),
        };
    };

    const MAX_BRANCH_ANCESTORS = 60;
    /**
     * @description WalletOperation allows to monitor operation inclusion on chains and surface information related to the operation
     */
    class WalletOperation {
        /**
         *
         * @param opHash Operation hash
         * @param raw Raw operation that was injected
         * @param context Taquito context allowing access to rpc and signer
         */
        constructor(opHash, context, _newHead$) {
            this.opHash = opHash;
            this.context = context;
            this._newHead$ = _newHead$;
            this._operationResult = new rxjs.ReplaySubject(1);
            this._includedInBlock = new rxjs.ReplaySubject(1);
            this._included = false;
            this.newHead$ = this._newHead$.pipe(operators.switchMap((newHead) => {
                var _a, _b;
                const prevHead = (_b = (_a = this.lastHead) === null || _a === void 0 ? void 0 : _a.header.level) !== null && _b !== void 0 ? _b : newHead.header.level - 1;
                return rxjs.range(prevHead + 1, newHead.header.level - prevHead - 1).pipe(operators.concatMap((level) => this.context.readProvider.getBlock(level)), operators.endWith(newHead));
            }), operators.tap((newHead) => (this.lastHead = newHead)), operators.publishReplay(1), operators.refCount());
            // Observable that emit once operation is seen in a block
            this.confirmed$ = this.newHead$.pipe(operators.map((head) => {
                for (const opGroup of head.operations) {
                    for (const op of opGroup) {
                        if (op.hash === this.opHash) {
                            this._included = true;
                            this._includedInBlock.next(head);
                            this._operationResult.next(op.contents);
                            // Return the block where the operation was found
                            return head;
                        }
                    }
                }
            }), operators.filter((x) => {
                return typeof x !== 'undefined';
            }), operators.first(), operators.publishReplay(1), operators.refCount());
            if (utils.validateOperation(this.opHash) !== utils.ValidationResult.VALID) {
                throw new utils.InvalidOperationHashError(this.opHash);
            }
            this.confirmed$
                .pipe(operators.first(), operators.catchError(() => rxjs.of(undefined)))
                .subscribe();
        }
        operationResults() {
            return __awaiter(this, void 0, void 0, function* () {
                return this._operationResult.pipe(operators.first()).toPromise();
            });
        }
        /**
         * @description Receipt expose the total amount of tezos token burn and spent on fees
         * The promise returned by receipt will resolve only once the transaction is included
         */
        receipt() {
            return __awaiter(this, void 0, void 0, function* () {
                return receiptFromOperation(yield this.operationResults());
            });
        }
        getCurrentConfirmation() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._included) {
                    return 0;
                }
                return rxjs.combineLatest([this._includedInBlock, rxjs.from(this.context.readProvider.getBlock('head'))])
                    .pipe(operators.map(([foundAtBlock, head]) => {
                    return head.header.level - foundAtBlock.header.level + 1;
                }), operators.first())
                    .toPromise();
            });
        }
        isInCurrentBranch(tipBlockIdentifier = 'head') {
            return __awaiter(this, void 0, void 0, function* () {
                // By default it is assumed that the operation is in the current branch
                if (!this._included) {
                    return true;
                }
                const tipBlockHeaderLevel = yield this.context.readProvider.getBlockLevel(tipBlockIdentifier);
                const inclusionBlock = yield this._includedInBlock.pipe(operators.first()).toPromise();
                const levelDiff = tipBlockHeaderLevel - inclusionBlock.header.level;
                // Block produced before the operation is included are assumed to be part of the current branch
                if (levelDiff <= 0) {
                    return true;
                }
                const tipBlockLevel = Math.min(inclusionBlock.header.level + levelDiff, inclusionBlock.header.level + MAX_BRANCH_ANCESTORS);
                const blocks = new Set(yield this.context.readProvider.getLiveBlocks(tipBlockLevel));
                return blocks.has(inclusionBlock.hash);
            });
        }
        confirmationObservable(confirmations) {
            if (typeof confirmations !== 'undefined' && confirmations < 1) {
                throw new InvalidConfirmationCountError('Confirmation count must be at least 1');
            }
            const { defaultConfirmationCount } = this.context.config;
            const conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;
            if (conf === undefined) {
                throw new ConfirmationUndefinedError('Default confirmation count can not be undefined!');
            }
            return rxjs.combineLatest([this._includedInBlock, this.newHead$]).pipe(operators.distinctUntilChanged(([, previousHead], [, newHead]) => {
                return previousHead.hash === newHead.hash;
            }), operators.map(([foundAtBlock, head]) => {
                return {
                    block: head,
                    expectedConfirmation: conf,
                    currentConfirmation: head.header.level - foundAtBlock.header.level + 1,
                    completed: head.header.level - foundAtBlock.header.level >= conf - 1,
                    isInCurrentBranch: () => this.isInCurrentBranch(head.hash),
                };
            }), operators.takeWhile(({ completed }) => !completed, true));
        }
        /**
         *
         * @param confirmations [0] Number of confirmation to wait for
         */
        confirmation(confirmations) {
            return this.confirmationObservable(confirmations).toPromise();
        }
    }

    class BatchWalletOperation extends WalletOperation {
        constructor(opHash, context, newHead$) {
            super(opHash, context, newHead$);
            this.opHash = opHash;
            this.context = context;
            this.getOriginatedContractAddresses = () => __awaiter(this, void 0, void 0, function* () {
                const opResult = yield this.operationResults();
                const originationOpResults = opResult.filter((x) => x.kind === 'origination');
                let addresses = [];
                for (const res of originationOpResults) {
                    if (res.metadata.operation_result.originated_contracts) {
                        addresses = [...addresses, ...res.metadata.operation_result.originated_contracts];
                    }
                }
                return addresses;
            });
        }
        revealOperation() {
            return __awaiter(this, void 0, void 0, function* () {
                const operationResult = yield this.operationResults();
                return operationResult.find((x) => x.kind === rpc.OpKind.REVEAL);
            });
        }
        status() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._included) {
                    return 'pending';
                }
                const op = yield this.operationResults();
                return (op
                    .filter((result) => BATCH_KINDS.indexOf(result.kind) !== -1)
                    .map((result) => {
                    if (hasMetadataWithResult(result)) {
                        return result.metadata.operation_result.status;
                    }
                    else {
                        return 'unknown';
                    }
                })[0] || 'unknown');
            });
        }
    }

    class DelegationWalletOperation extends WalletOperation {
        constructor(opHash, context, newHead$) {
            super(opHash, context, newHead$);
            this.opHash = opHash;
            this.context = context;
        }
        revealOperation() {
            return __awaiter(this, void 0, void 0, function* () {
                const operationResult = yield this.operationResults();
                return operationResult.find((x) => x.kind === rpc.OpKind.REVEAL);
            });
        }
        delegationOperation() {
            return __awaiter(this, void 0, void 0, function* () {
                const operationResult = yield this.operationResults();
                return operationResult.find((x) => x.kind === rpc.OpKind.DELEGATION);
            });
        }
        status() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._included) {
                    return 'pending';
                }
                const op = yield this.delegationOperation();
                if (!op) {
                    return 'unknown';
                }
                return op.metadata.operation_result.status;
            });
        }
    }

    class IncreasePaidStorageWalletOperation extends WalletOperation {
        constructor(opHash, context, newHead$) {
            super(opHash, context, newHead$);
            this.opHash = opHash;
            this.context = context;
        }
        revealOperation() {
            return __awaiter(this, void 0, void 0, function* () {
                const operationResult = yield this.operationResults();
                return operationResult.find(x => x.kind === rpc.OpKind.REVEAL);
            });
        }
        increasePaidStorageOperation() {
            return __awaiter(this, void 0, void 0, function* () {
                const operationResult = yield this.operationResults();
                return operationResult.find(x => x.kind === rpc.OpKind.INCREASE_PAID_STORAGE);
            });
        }
        status() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._included) {
                    return 'pending';
                }
                const op = yield this.increasePaidStorageOperation();
                if (!op) {
                    return 'unknown';
                }
                return op.metadata.operation_result.status;
            });
        }
    }

    class OriginationWalletOperation extends WalletOperation {
        constructor(opHash, context, newHead$) {
            super(opHash, context, newHead$);
            this.opHash = opHash;
            this.context = context;
        }
        originationOperation() {
            return __awaiter(this, void 0, void 0, function* () {
                const operationResult = yield this.operationResults();
                return findWithKind(operationResult, rpc.OpKind.ORIGINATION);
            });
        }
        revealOperation() {
            return __awaiter(this, void 0, void 0, function* () {
                const operationResult = yield this.operationResults();
                return findWithKind(operationResult, rpc.OpKind.REVEAL);
            });
        }
        status() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._included) {
                    return 'pending';
                }
                const op = yield this.originationOperation();
                if (!op) {
                    return 'unknown';
                }
                return op.metadata.operation_result.status;
            });
        }
        contract() {
            return __awaiter(this, void 0, void 0, function* () {
                const op = yield this.originationOperation();
                const address = ((op === null || op === void 0 ? void 0 : op.metadata.operation_result.originated_contracts) || [])[0];
                return this.context.wallet.at(address);
            });
        }
    }

    class TransactionWalletOperation extends WalletOperation {
        constructor(opHash, context, newHead$) {
            super(opHash, context, newHead$);
            this.opHash = opHash;
            this.context = context;
        }
        revealOperation() {
            return __awaiter(this, void 0, void 0, function* () {
                const operationResult = yield this.operationResults();
                return operationResult.find(x => x.kind === rpc.OpKind.REVEAL);
            });
        }
        transactionOperation() {
            return __awaiter(this, void 0, void 0, function* () {
                const operationResult = yield this.operationResults();
                return operationResult.find(x => x.kind === rpc.OpKind.TRANSACTION);
            });
        }
        status() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._included) {
                    return 'pending';
                }
                const op = yield this.transactionOperation();
                if (!op) {
                    return 'unknown';
                }
                return op.metadata.operation_result.status;
            });
        }
    }

    function timeoutAfter(timeoutMillisec) {
        return function inner(source) {
            return new rxjs.BehaviorSubject(null).pipe(operators.timeoutWith(timeoutMillisec, rxjs.throwError(new Error('Confirmation polling timed out'))), operators.mergeMap(() => source));
        };
    }
    const createNewPollingBasedHeadObservable = (sharedHeadOb, context, _scheduler) => {
        return sharedHeadOb.pipe(timeoutAfter(context.config.confirmationPollingTimeoutSecond * 1000), operators.publishReplay(1), operators.refCount());
    };
    class OperationFactory {
        constructor(context) {
            this.context = context;
            // Cache the last block for one second across all operations
            this.sharedHeadObs = rxjs.defer(() => {
                return createObservableFromSubscription(this.context.stream.subscribeBlock('head'));
            });
        }
        createNewHeadObservable() {
            return __awaiter(this, void 0, void 0, function* () {
                return createNewPollingBasedHeadObservable(this.sharedHeadObs, this.context);
            });
        }
        createPastBlockWalker(startBlock, count = 1) {
            return rxjs.from(this.context.readProvider.getBlock(startBlock)).pipe(operators.switchMap((block) => {
                if (count === 1) {
                    return rxjs.of(block);
                }
                return rxjs.range(block.header.level, count - 1).pipe(operators.startWith(block), operators.concatMap((level) => __awaiter(this, void 0, void 0, function* () {
                    return this.context.readProvider.getBlock(typeof level === 'number' ? level : level.header.level);
                })));
            }));
        }
        createHeadObservableFromConfig({ blockIdentifier }) {
            return __awaiter(this, void 0, void 0, function* () {
                const observableSequence = [];
                if (blockIdentifier) {
                    observableSequence.push(this.createPastBlockWalker(blockIdentifier));
                }
                observableSequence.push(yield this.createNewHeadObservable());
                return rxjs.concat(...observableSequence);
            });
        }
        createOperation(hash, config = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                return new WalletOperation(hash, this.context.clone(), yield this.createHeadObservableFromConfig(config));
            });
        }
        createBatchOperation(hash, config = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                return new BatchWalletOperation(hash, this.context.clone(), yield this.createHeadObservableFromConfig(config));
            });
        }
        createTransactionOperation(hash, config = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                return new TransactionWalletOperation(hash, this.context.clone(), yield this.createHeadObservableFromConfig(config));
            });
        }
        createDelegationOperation(hash, config = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                return new DelegationWalletOperation(hash, this.context.clone(), yield this.createHeadObservableFromConfig(config));
            });
        }
        createOriginationOperation(hash, config = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                return new OriginationWalletOperation(hash, this.context.clone(), yield this.createHeadObservableFromConfig(config));
            });
        }
        createIncreasePaidStorageOperation(hash, config = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                return new IncreasePaidStorageWalletOperation(hash, this.context.clone(), yield this.createHeadObservableFromConfig(config));
            });
        }
    }

    class RpcTzProvider extends OperationEmitter {
        constructor(context) {
            super(context);
        }
        getBalance(address) {
            return __awaiter(this, void 0, void 0, function* () {
                if (utils.validateAddress(address) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidAddressError(address);
                }
                return this.context.readProvider.getBalance(address, 'head');
            });
        }
        getDelegate(address) {
            return __awaiter(this, void 0, void 0, function* () {
                if (utils.validateAddress(address) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidAddressError(address);
                }
                return this.context.readProvider.getDelegate(address, 'head');
            });
        }
        activate(pkh, secret) {
            return __awaiter(this, void 0, void 0, function* () {
                if (utils.validateKeyHash(pkh) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidKeyHashError(pkh);
                }
                const operation = {
                    kind: rpc.OpKind.ACTIVATION,
                    pkh,
                    secret,
                };
                const prepared = yield this.prepareOperation({ operation: [operation], source: pkh });
                const forgedBytes = yield this.forge(prepared);
                const bytes = `${forgedBytes.opbytes}00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`;
                return new Operation(yield this.rpc.injectOperation(bytes), Object.assign(Object.assign({}, forgedBytes), { opbytes: bytes }), [], this.context.clone());
            });
        }
    }

    const MINIMAL_FEE_MUTEZ = 100;
    const MINIMAL_FEE_PER_BYTE_MUTEZ = 1;
    const MINIMAL_FEE_PER_GAS_MUTEZ = 0.1;
    const GAS_BUFFER = 100;
    /**
     * Examples of use :
     *
     *  Estimate a transfer operation :
     * ```
     * // Assuming that provider and signer are already configured...
     *
     * const amount = 2;
     * const address = 'tz1h3rQ8wBxFd8L9B3d7Jhaawu6Z568XU3xY';
     *
     * // Estimate gasLimit, storageLimit and fees for a transfer operation
     * const est = await Tezos.estimate.transfer({ to: address, amount: amount })
     * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,
     *  est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)
     *
     * ```
     *
     * Estimate a contract origination :
     * ```
     * // generic.json is referring to a Michelson Smart Contract
     *
     * const genericMultisigJSON = require('./generic.json')
     * const est = await Tezos.estimate.originate({
     *   code: genericMultisigJSON,
     *   storage: {
     *     stored_counter: 0,
     *     threshold: 1,
     *     keys: ['edpkuLxx9PQD8fZ45eUzrK3BhfDZJHhBuK4Zi49DcEGANwd2rpX82t']
     *   }
     * })
     * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,
     *   est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)
     *
     * ```
     */
    class Estimate {
        constructor(_milligasLimit, _storageLimit, opSize, minimalFeePerStorageByteMutez, 
        /**
         * @description Base fee in mutez (1 mutez = 1e10−6 tez)
         */
        baseFeeMutez = MINIMAL_FEE_MUTEZ) {
            this._milligasLimit = _milligasLimit;
            this._storageLimit = _storageLimit;
            this.opSize = opSize;
            this.minimalFeePerStorageByteMutez = minimalFeePerStorageByteMutez;
            this.baseFeeMutez = baseFeeMutez;
        }
        /**
         * @description The number of Mutez that will be burned for the storage of the [operation](https://tezos.gitlab.io/user/glossary.html#operations). (Storage + Allocation fees)
         */
        get burnFeeMutez() {
            return this.roundUp(Number(this.storageLimit) * Number(this.minimalFeePerStorageByteMutez));
        }
        /**
         * @description  The limit on the amount of storage an [operation](https://tezos.gitlab.io/user/glossary.html#operations) can use.
         */
        get storageLimit() {
            const limit = Math.max(Number(this._storageLimit), 0);
            return limit > 0 ? limit : 0;
        }
        /**
         * @description The limit on the amount of [gas](https://tezos.gitlab.io/user/glossary.html#gas) a given operation can consume.
         */
        get gasLimit() {
            return this.roundUp(Number(this._milligasLimit) / 1000 + GAS_BUFFER);
        }
        get operationFeeMutez() {
            return ((Number(this._milligasLimit) / 1000 + GAS_BUFFER) * MINIMAL_FEE_PER_GAS_MUTEZ +
                Number(this.opSize) * MINIMAL_FEE_PER_BYTE_MUTEZ);
        }
        roundUp(nanotez) {
            return Math.ceil(Number(nanotez));
        }
        /**
         * @description Minimum fees for the [operation](https://tezos.gitlab.io/user/glossary.html#operations) according to [baker](https://tezos.gitlab.io/user/glossary.html#baker) defaults.
         */
        get minimalFeeMutez() {
            return this.roundUp(MINIMAL_FEE_MUTEZ + this.operationFeeMutez);
        }
        /**
         * @description The suggested fee for the operation which includes minimal fees and a small buffer.
         */
        get suggestedFeeMutez() {
            return this.roundUp(this.operationFeeMutez + MINIMAL_FEE_MUTEZ * 2);
        }
        /**
         * @description Fees according to your specified base fee will ensure that at least minimum fees are used.
         */
        get usingBaseFeeMutez() {
            return (Math.max(Number(this.baseFeeMutez), MINIMAL_FEE_MUTEZ) + this.roundUp(this.operationFeeMutez));
        }
        /**
         * @description The sum of `minimalFeeMutez` + `burnFeeMutez`.
         */
        get totalCost() {
            return this.minimalFeeMutez + this.burnFeeMutez;
        }
        /**
         * @description Since Delphinet, consumed gas is provided in milligas for more precision.
         * This function returns an estimation of the gas that operation will consume in milligas.
         */
        get consumedMilligas() {
            return Number(this._milligasLimit);
        }
        static createEstimateInstanceFromProperties(estimateProperties) {
            let milligasLimit = 0;
            let storageLimit = 0;
            let opSize = 0;
            let minimalFeePerStorageByteMutez = 0;
            let baseFeeMutez;
            estimateProperties.forEach((estimate) => {
                milligasLimit += estimate.milligasLimit;
                storageLimit += estimate.storageLimit;
                opSize += estimate.opSize;
                minimalFeePerStorageByteMutez = Math.max(estimate.minimalFeePerStorageByteMutez, minimalFeePerStorageByteMutez);
                if (estimate.baseFeeMutez) {
                    baseFeeMutez = baseFeeMutez ? baseFeeMutez + estimate.baseFeeMutez : estimate.baseFeeMutez;
                }
            });
            return new Estimate(milligasLimit, storageLimit, opSize, minimalFeePerStorageByteMutez, baseFeeMutez);
        }
        static createArrayEstimateInstancesFromProperties(estimateProperties) {
            return estimateProperties.map((x) => new Estimate(x.milligasLimit, x.storageLimit, x.opSize, x.minimalFeePerStorageByteMutez, x.baseFeeMutez));
        }
    }

    /**
     *  @category Error
     *  @description Error that indicates invalid public key being passed when doing a reveal operation estimate
     */
    class RevealEstimateError extends Error {
        constructor() {
            super('Unable to estimate the reveal operation, the public key is unknown');
            this.name = 'Reveal Estimate Error';
        }
    }

    const mergeLimits = (userDefinedLimit, defaultLimits) => {
        return {
            fee: typeof userDefinedLimit.fee === 'undefined' ? defaultLimits.fee : userDefinedLimit.fee,
            gasLimit: typeof userDefinedLimit.gasLimit === 'undefined'
                ? defaultLimits.gasLimit
                : userDefinedLimit.gasLimit,
            storageLimit: typeof userDefinedLimit.storageLimit === 'undefined'
                ? defaultLimits.storageLimit
                : userDefinedLimit.storageLimit,
        };
    };
    // RPC requires a signature but does not verify it
    const SIGNATURE_STUB = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg';
    class RPCEstimateProvider extends OperationEmitter {
        constructor() {
            super(...arguments);
            this.ALLOCATION_STORAGE = 257;
            this.ORIGINATION_STORAGE = 257;
            this.OP_SIZE_REVEAL = 128;
        }
        getKeys() {
            return __awaiter(this, void 0, void 0, function* () {
                const isSignerConfigured = this.context.isAnySignerConfigured();
                return {
                    publicKeyHash: isSignerConfigured
                        ? yield this.signer.publicKeyHash()
                        : yield this.context.walletProvider.getPKH(),
                    publicKey: isSignerConfigured ? yield this.signer.publicKey() : undefined,
                };
            });
        }
        // Maximum values defined by the protocol
        getAccountLimits(pkh, constants, numberOfOps) {
            return __awaiter(this, void 0, void 0, function* () {
                const balance = yield this.context.readProvider.getBalance(pkh, 'head');
                const { hard_gas_limit_per_operation, hard_gas_limit_per_block, hard_storage_limit_per_operation, cost_per_byte, } = constants;
                return {
                    fee: 0,
                    gasLimit: numberOfOps
                        ? Math.floor(this.ajustGasForBatchOperation(hard_gas_limit_per_block, hard_gas_limit_per_operation, numberOfOps).toNumber())
                        : hard_gas_limit_per_operation.toNumber(),
                    storageLimit: Math.floor(BigNumber__default["default"].min(balance.dividedBy(cost_per_byte), hard_storage_limit_per_operation).toNumber()),
                };
            });
        }
        // Fix for Granada where the total gasLimit of a batch can not exceed the hard_gas_limit_per_block.
        // If the total gasLimit of the batch is higher than the hard_gas_limit_per_block,
        // the gasLimit is calculated by dividing the hard_gas_limit_per_block by the number of operation in the batch (numberOfOps).
        // numberOfOps is incremented by 1 for safety in case a reveal operation is needed
        ajustGasForBatchOperation(gasLimitBlock, gaslimitOp, numberOfOps) {
            return BigNumber__default["default"].min(gaslimitOp, gasLimitBlock.div(numberOfOps + 1));
        }
        getEstimationPropertiesFromOperationContent(content, size, costPerByte, tx_rollup_origination_size) {
            const operationResults = flattenOperationResult({ contents: [content] });
            let totalMilligas = 0;
            let totalStorage = 0;
            operationResults.forEach((result) => {
                totalStorage +=
                    'originated_contracts' in result && typeof result.originated_contracts !== 'undefined'
                        ? result.originated_contracts.length * this.ORIGINATION_STORAGE
                        : 0;
                totalStorage += 'allocated_destination_contract' in result ? this.ALLOCATION_STORAGE : 0;
                totalMilligas += Number(result.consumed_milligas) || 0;
                totalStorage +=
                    'paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0;
                totalStorage +=
                    'storage_size' in result && 'global_address' in result
                        ? Number(result.storage_size) || 0
                        : 0;
                totalStorage += 'originated_rollup' in result ? tx_rollup_origination_size : 0;
            });
            if (isOpWithFee(content)) {
                return {
                    milligasLimit: totalMilligas || 0,
                    storageLimit: Number(totalStorage || 0),
                    opSize: size,
                    minimalFeePerStorageByteMutez: costPerByte.toNumber(),
                };
            }
            else {
                return {
                    milligasLimit: 0,
                    storageLimit: 0,
                    opSize: size,
                    minimalFeePerStorageByteMutez: costPerByte.toNumber(),
                    baseFeeMutez: 0,
                };
            }
        }
        prepareEstimate(params, constants, pkh) {
            return __awaiter(this, void 0, void 0, function* () {
                const prepared = yield this.prepareOperation(params, pkh);
                const { opbytes, opOb: { branch, contents }, } = yield this.forge(prepared);
                const operation = {
                    operation: { branch, contents, signature: SIGNATURE_STUB },
                    chain_id: yield this.context.readProvider.getChainId(),
                };
                const { opResponse } = yield this.simulate(operation);
                const { cost_per_byte, tx_rollup_origination_size } = constants;
                const errors = [...flattenErrors(opResponse, 'backtracked'), ...flattenErrors(opResponse)];
                // Fail early in case of errors
                if (errors.length) {
                    throw new TezosOperationError(errors, 'Error occurred during estimation');
                }
                let numberOfOps = 1;
                if (Array.isArray(params.operation) && params.operation.length > 1) {
                    numberOfOps =
                        opResponse.contents[0].kind === 'reveal'
                            ? params.operation.length - 1
                            : params.operation.length;
                }
                return opResponse.contents.map((x) => {
                    return this.getEstimationPropertiesFromOperationContent(x, 
                    // TODO: Calculate a specific opSize for each operation.
                    x.kind === 'reveal' ? this.OP_SIZE_REVEAL / 2 : opbytes.length / 2 / numberOfOps, cost_per_byte, tx_rollup_origination_size !== null && tx_rollup_origination_size !== void 0 ? tx_rollup_origination_size : 0);
                });
            });
        }
        /**
         *
         * @description Estimate gasLimit, storageLimit and fees for an origination operation
         *
         * @returns An estimation of gasLimit, storageLimit and fees for the operation
         *
         * @param OriginationOperation Originate operation parameter
         */
        originate(_a) {
            var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
            return __awaiter(this, void 0, void 0, function* () {
                const { publicKeyHash } = yield this.getKeys();
                const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
                const DEFAULT_PARAMS = yield this.getAccountLimits(publicKeyHash, protocolConstants);
                const op = yield createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS))));
                const isRevealNeeded = yield this.isRevealOpNeeded([op], publicKeyHash);
                const ops = isRevealNeeded ? yield this.addRevealOp([op], publicKeyHash) : op;
                const estimateProperties = yield this.prepareEstimate({ operation: ops, source: publicKeyHash }, protocolConstants, publicKeyHash);
                if (isRevealNeeded) {
                    estimateProperties.shift();
                }
                return Estimate.createEstimateInstanceFromProperties(estimateProperties);
            });
        }
        /**
         *
         * @description Estimate gasLimit, storageLimit and fees for an transfer operation
         *
         * @returns An estimation of gasLimit, storageLimit and fees for the operation
         *
         * @param TransferOperation Originate operation parameter
         */
        transfer(_a) {
            var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
            return __awaiter(this, void 0, void 0, function* () {
                if (utils.validateAddress(rest.to) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidAddressError(rest.to);
                }
                if (rest.source && utils.validateAddress(rest.source) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidAddressError(rest.source);
                }
                const pkh = (yield this.getKeys()).publicKeyHash;
                const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
                const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
                const op = yield createTransferOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
                const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
                const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
                const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
                if (isRevealNeeded) {
                    estimateProperties.shift();
                }
                return Estimate.createEstimateInstanceFromProperties(estimateProperties);
            });
        }
        /**
         *
         * @description Estimate gasLimit, storageLimit and fees for a transferTicket operation
         *
         * @returns An estimation of gasLimit, storageLimit and fees for the operation
         *
         * @param TransferTicketParams operation parameter
         */
        transferTicket(_a) {
            var _b;
            var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
            return __awaiter(this, void 0, void 0, function* () {
                if (utils.validateContractAddress(rest.destination) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidContractAddressError(rest.destination);
                }
                if (rest.source && utils.validateAddress(rest.source) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidAddressError((_b = rest.source) !== null && _b !== void 0 ? _b : '');
                }
                const pkh = (yield this.getKeys()).publicKeyHash;
                const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
                const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
                const op = yield createTransferTicketOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
                const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
                const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
                const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
                if (isRevealNeeded) {
                    estimateProperties.shift();
                }
                return Estimate.createEstimateInstanceFromProperties(estimateProperties);
            });
        }
        /**
         *
         * @description Estimate gasLimit, storageLimit and fees for a delegate operation
         *
         * @returns An estimation of gasLimit, storageLimit and fees for the operation
         *
         * @param Estimate
         */
        setDelegate(_a) {
            var { fee, gasLimit, storageLimit } = _a, rest = __rest(_a, ["fee", "gasLimit", "storageLimit"]);
            return __awaiter(this, void 0, void 0, function* () {
                if (rest.source && utils.validateAddress(rest.source) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidAddressError(rest.source);
                }
                if (rest.delegate && utils.validateAddress(rest.delegate) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidAddressError(rest.delegate);
                }
                const pkh = (yield this.getKeys()).publicKeyHash;
                const sourceOrDefault = rest.source || pkh;
                const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
                const DEFAULT_PARAMS = yield this.getAccountLimits(sourceOrDefault, protocolConstants);
                const op = yield createSetDelegateOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
                const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
                const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
                const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
                if (isRevealNeeded) {
                    estimateProperties.shift();
                }
                return Estimate.createEstimateInstanceFromProperties(estimateProperties);
            });
        }
        /**
         *
         * @description Estimate gasLimit, storageLimit and fees for a each operation in the batch
         *
         * @returns An array of Estimate objects. If a reveal operation is needed, the first element of the array is the Estimate for the reveal operation.
         */
        batch(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const { publicKeyHash } = yield this.getKeys();
                let operations = [];
                const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
                const DEFAULT_PARAMS = yield this.getAccountLimits(publicKeyHash, protocolConstants, params.length);
                for (const param of params) {
                    switch (param.kind) {
                        case rpc.OpKind.TRANSACTION:
                            operations.push(yield createTransferOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
                            break;
                        case rpc.OpKind.ORIGINATION:
                            operations.push(yield createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS)))));
                            break;
                        case rpc.OpKind.DELEGATION:
                            operations.push(yield createSetDelegateOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
                            break;
                        case rpc.OpKind.ACTIVATION:
                            operations.push(Object.assign(Object.assign({}, param), DEFAULT_PARAMS));
                            break;
                        case rpc.OpKind.REGISTER_GLOBAL_CONSTANT:
                            operations.push(yield createRegisterGlobalConstantOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
                            break;
                        case rpc.OpKind.TX_ROLLUP_ORIGINATION:
                            operations.push(yield createTxRollupOriginationOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
                            break;
                        case rpc.OpKind.TX_ROLLUP_SUBMIT_BATCH:
                            operations.push(yield createTxRollupBatchOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
                            break;
                        case rpc.OpKind.TRANSFER_TICKET:
                            operations.push(yield createTransferTicketOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
                            break;
                        case rpc.OpKind.INCREASE_PAID_STORAGE:
                            operations.push(yield createIncreasePaidStorageOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
                            break;
                        default:
                            throw new utils.InvalidOperationKindError(params.kind);
                    }
                }
                const isRevealNeeded = yield this.isRevealOpNeeded(operations, publicKeyHash);
                operations = isRevealNeeded ? yield this.addRevealOp(operations, publicKeyHash) : operations;
                const estimateProperties = yield this.prepareEstimate({ operation: operations, source: publicKeyHash }, protocolConstants, publicKeyHash);
                return Estimate.createArrayEstimateInstancesFromProperties(estimateProperties);
            });
        }
        /**
         *
         * @description Estimate gasLimit, storageLimit and fees for a delegate operation
         *
         * @returns An estimation of gasLimit, storageLimit and fees for the operation
         *
         * @param Estimate
         */
        registerDelegate(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const pkh = (yield this.getKeys()).publicKeyHash;
                const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
                const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
                const op = yield createRegisterDelegateOperation(Object.assign(Object.assign({}, params), DEFAULT_PARAMS), pkh);
                const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
                const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
                const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
                if (isRevealNeeded) {
                    estimateProperties.shift();
                }
                return Estimate.createEstimateInstanceFromProperties(estimateProperties);
            });
        }
        /**
         *
         * @description Estimate gasLimit, storageLimit and fees to reveal the current account
         *
         * @returns An estimation of gasLimit, storageLimit and fees for the operation or undefined if the account is already revealed
         *
         * @param Estimate
         */
        reveal(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const { publicKeyHash, publicKey } = yield this.getKeys();
                if (!publicKey) {
                    throw new RevealEstimateError();
                }
                if (yield this.isAccountRevealRequired(publicKeyHash)) {
                    const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
                    const DEFAULT_PARAMS = yield this.getAccountLimits(publicKeyHash, protocolConstants);
                    const op = yield createRevealOperation(Object.assign(Object.assign({}, params), DEFAULT_PARAMS), publicKeyHash, publicKey);
                    const estimateProperties = yield this.prepareEstimate({ operation: op, source: publicKeyHash }, protocolConstants, publicKeyHash);
                    return Estimate.createEstimateInstanceFromProperties(estimateProperties);
                }
            });
        }
        /**
         *
         * @description Estimate gasLimit, storageLimit and fees for an registerGlobalConstant operation
         *
         * @returns An estimation of gasLimit, storageLimit and fees for the operation
         *
         * @param params registerGlobalConstant operation parameter
         */
        registerGlobalConstant(_a) {
            var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
            return __awaiter(this, void 0, void 0, function* () {
                const pkh = (yield this.getKeys()).publicKeyHash;
                const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
                const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
                const op = yield createRegisterGlobalConstantOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
                const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
                const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
                const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
                if (isRevealNeeded) {
                    estimateProperties.shift();
                }
                return Estimate.createEstimateInstanceFromProperties(estimateProperties);
            });
        }
        /**
         *
         * @description Estimate gasLimit, storageLimit, and fees for an increasePaidStorage operation
         *
         * @returns An estimation of gasLimit, storageLimit, and fees for the operation
         *
         * @param params increasePaidStorage operation parameters
         */
        increasePaidStorage(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const { fee, storageLimit, gasLimit } = params, rest = __rest(params, ["fee", "storageLimit", "gasLimit"]);
                const pkh = (yield this.getKeys()).publicKeyHash;
                const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
                const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
                const op = yield createIncreasePaidStorageOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
                const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
                const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
                const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
                if (isRevealNeeded) {
                    estimateProperties.shift();
                }
                return Estimate.createEstimateInstanceFromProperties(estimateProperties);
            });
        }
        /**
         *
         * @description Estimate gasLimit, storageLimit and fees for a rollup origination operation
         *
         * @returns An estimation of gasLimit, storageLimit and fees for the operation
         *
         * @param TxRollupOriginateParams Originate tx rollup operation parameter
         */
        txRollupOriginate(params) {
            return __awaiter(this, void 0, void 0, function* () {
                params = params ? params : {};
                const { fee, storageLimit, gasLimit } = params, rest = __rest(params, ["fee", "storageLimit", "gasLimit"]);
                const pkh = (yield this.getKeys()).publicKeyHash;
                const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
                const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
                const op = yield createTxRollupOriginationOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
                const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
                const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
                const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
                if (isRevealNeeded) {
                    estimateProperties.shift();
                }
                return Estimate.createEstimateInstanceFromProperties(estimateProperties);
            });
        }
        /**
         *
         * @description Estimate gasLimit, storageLimit and fees for a tx rollup batch operation
         *
         * @returns An estimation of gasLimit, storageLimit and fees for the operation
         *
         * @param Estimate
         */
        txRollupSubmitBatch(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const { fee, storageLimit, gasLimit } = params, rest = __rest(params, ["fee", "storageLimit", "gasLimit"]);
                const pkh = (yield this.getKeys()).publicKeyHash;
                const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
                const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
                const op = yield createTxRollupBatchOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
                const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
                const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
                const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
                if (isRevealNeeded) {
                    estimateProperties.shift();
                }
                return Estimate.createEstimateInstanceFromProperties(estimateProperties);
            });
        }
        /**
         *
         * @description Estimate gasLimit, storageLimit and fees for an Update Consensus Key operation
         *
         * @returns An estimation of gasLimit, storageLimit and fees for the operation
         *
         * @param Estimate
         */
        updateConsensusKey(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const { fee, storageLimit, gasLimit } = params, rest = __rest(params, ["fee", "storageLimit", "gasLimit"]);
                const pkh = (yield this.getKeys()).publicKeyHash;
                const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
                const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
                const op = yield createUpdateConsensusKeyOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
                const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
                const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
                const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
                if (isRevealNeeded) {
                    estimateProperties.shift();
                }
                return Estimate.createEstimateInstanceFromProperties(estimateProperties);
            });
        }
        addRevealOp(op, pkh) {
            return __awaiter(this, void 0, void 0, function* () {
                const { publicKey } = yield this.getKeys();
                if (!publicKey) {
                    throw new RevealEstimateError();
                }
                op.unshift(yield createRevealOperation(Object.assign({
                    fee: exports.DEFAULT_FEE.REVEAL,
                    gasLimit: exports.DEFAULT_GAS_LIMIT.REVEAL,
                    storageLimit: exports.DEFAULT_STORAGE_LIMIT.REVEAL,
                }), pkh, yield this.signer.publicKey()));
                return op;
            });
        }
    }

    /**
     * @description Delegation operation provide utility function to fetch newly issued delegation
     *
     * @warn Currently support only one delegation per operation
     */
    class DelegateOperation extends Operation {
        constructor(hash, params, source, raw, results, context) {
            super(hash, raw, results, context);
            this.params = params;
            this.source = source;
        }
        get operationResults() {
            const delegationOp = Array.isArray(this.results) &&
                this.results.find((op) => op.kind === 'delegation');
            const result = delegationOp && delegationOp.metadata && delegationOp.metadata.operation_result;
            return result ? result : undefined;
        }
        get status() {
            var _a, _b;
            return (_b = (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : 'unknown';
        }
        get delegate() {
            return this.params.delegate;
        }
        get isRegisterOperation() {
            return this.delegate === this.source;
        }
        get fee() {
            return this.params.fee;
        }
        get gasLimit() {
            return this.params.gas_limit;
        }
        get storageLimit() {
            return this.params.storage_limit;
        }
        get consumedGas() {
            BigNumber.BigNumber.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber.BigNumber.ROUND_UP });
            return this.consumedMilliGas
                ? new BigNumber.BigNumber(this.consumedMilliGas).dividedBy(1000).toString()
                : undefined;
        }
        get consumedMilliGas() {
            var _a;
            return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.consumed_milligas;
        }
        get errors() {
            var _a;
            return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.errors;
        }
    }

    /**
     * @description Origination operation provide utility function to fetch newly originated contract
     *
     * @warn Currently support only one origination per operation
     */
    class OriginationOperation extends Operation {
        constructor(hash, params, raw, results, context, contractProvider) {
            super(hash, raw, results, context);
            this.params = params;
            this.contractProvider = contractProvider;
            const originatedContracts = this.operationResults && this.operationResults.originated_contracts;
            if (Array.isArray(originatedContracts)) {
                this.contractAddress = originatedContracts[0];
            }
        }
        get status() {
            var _a, _b;
            return (_b = (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : 'unknown';
        }
        get operationResults() {
            const originationOp = Array.isArray(this.results) &&
                this.results.find((op) => op.kind === 'origination');
            const result = originationOp &&
                hasMetadataWithResult(originationOp) &&
                originationOp.metadata.operation_result;
            return result ? result : undefined;
        }
        get fee() {
            return this.params.fee;
        }
        get gasLimit() {
            return this.params.gas_limit;
        }
        get storageLimit() {
            return this.params.storage_limit;
        }
        get consumedGas() {
            BigNumber.BigNumber.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber.BigNumber.ROUND_UP });
            return this.consumedMilliGas
                ? new BigNumber.BigNumber(this.consumedMilliGas).dividedBy(1000).toString()
                : undefined;
        }
        get consumedMilliGas() {
            var _a;
            return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.consumed_milligas;
        }
        get storageDiff() {
            const storageDiff = this.operationResults && this.operationResults.paid_storage_size_diff;
            return storageDiff ? storageDiff : undefined;
        }
        get storageSize() {
            const storageSize = this.operationResults && this.operationResults.storage_size;
            return storageSize ? storageSize : undefined;
        }
        get errors() {
            var _a;
            return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.errors;
        }
        /**
         * @description Provide the contract abstract of the newly originated contract
         */
        contract(confirmations, timeout) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.contractAddress) {
                    throw new OriginationOperationError('No contract was originated in this operation');
                }
                yield this.confirmation(confirmations, timeout);
                return this.contractProvider.at(this.contractAddress);
            });
        }
    }

    /**
     * @description RegisterGlobalConstantOperation provides utility functions to fetch a newly issued operation of kind register_global_constant
     */
    class RegisterGlobalConstantOperation extends Operation {
        constructor(hash, params, source, raw, results, context) {
            super(hash, raw, results, context);
            this.params = params;
            this.source = source;
            this.globalConstantHash = this.operationResults && this.operationResults.global_address;
        }
        get operationResults() {
            const registerGlobalConstantOp = Array.isArray(this.results) &&
                this.results.find((op) => op.kind === 'register_global_constant');
            const result = registerGlobalConstantOp &&
                registerGlobalConstantOp.metadata &&
                registerGlobalConstantOp.metadata.operation_result;
            return result ? result : undefined;
        }
        get status() {
            var _a, _b;
            return (_b = (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : 'unknown';
        }
        get registeredExpression() {
            return this.params.value;
        }
        get fee() {
            return this.params.fee;
        }
        get gasLimit() {
            return this.params.gas_limit;
        }
        get storageLimit() {
            return this.params.storage_limit;
        }
        get errors() {
            var _a;
            return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.errors;
        }
        get consumedGas() {
            BigNumber.BigNumber.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber.BigNumber.ROUND_UP });
            return this.consumedMilliGas
                ? new BigNumber.BigNumber(this.consumedMilliGas).dividedBy(1000).toString()
                : undefined;
        }
        get consumedMilliGas() {
            var _a;
            return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.consumed_milligas;
        }
    }

    /**
     * @description Reveal operation provides utility functions to fetch a newly issued revelation
     */
    class RevealOperation extends Operation {
        constructor(hash, params, source, raw, results, context) {
            super(hash, raw, results, context);
            this.params = params;
            this.source = source;
        }
        get operationResults() {
            const revealOp = Array.isArray(this.results) &&
                this.results.find((op) => op.kind === 'reveal');
            return revealOp ? [revealOp] : [];
        }
        get status() {
            const operationResults = this.operationResults;
            const txResult = operationResults[0];
            if (txResult) {
                return txResult.metadata.operation_result.status;
            }
            else {
                return 'unknown';
            }
        }
        get fee() {
            return this.params.fee;
        }
        get gasLimit() {
            return this.params.gas_limit;
        }
        get storageLimit() {
            return this.params.storage_limit;
        }
        get publicKey() {
            return this.params.public_key;
        }
        sumProp(arr, prop) {
            return arr.reduce((prev, current) => {
                return prop in current ? Number(current[prop]) + prev : prev;
            }, 0);
        }
        get consumedGas() {
            BigNumber.BigNumber.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber.BigNumber.ROUND_UP });
            return new BigNumber.BigNumber(this.consumedMilliGas).dividedBy(1000).toString();
        }
        get consumedMilliGas() {
            return String(this.sumProp(flattenOperationResult({ contents: this.operationResults }), 'consumed_milligas'));
        }
        get storageDiff() {
            return String(this.sumProp(flattenOperationResult({ contents: this.operationResults }), 'paid_storage_size_diff'));
        }
        get storageSize() {
            return String(this.sumProp(flattenOperationResult({ contents: this.operationResults }), 'storage_size'));
        }
        get errors() {
            return flattenErrors({ contents: this.operationResults });
        }
    }

    /**
     * @description Transaction operation provides utility functions to fetch a newly issued transaction
     *
     * @warn Currently supports one transaction per operation
     */
    class TransactionOperation extends Operation {
        constructor(hash, params, source, raw, results, context) {
            super(hash, raw, results, context);
            this.params = params;
            this.source = source;
        }
        get operationResults() {
            const transactionOp = Array.isArray(this.results) &&
                this.results.find((op) => op.kind === 'transaction');
            return transactionOp ? [transactionOp] : [];
        }
        get status() {
            const operationResults = this.operationResults;
            const txResult = operationResults[0];
            if (txResult) {
                return txResult.metadata.operation_result.status;
            }
            else {
                return 'unknown';
            }
        }
        get amount() {
            return new BigNumber__default["default"](this.params.amount);
        }
        get destination() {
            return this.params.destination;
        }
        get fee() {
            return this.params.fee;
        }
        get gasLimit() {
            return this.params.gas_limit;
        }
        get storageLimit() {
            return this.params.storage_limit;
        }
        sumProp(arr, prop) {
            return arr.reduce((prev, current) => {
                return prop in current ? Number(current[prop]) + prev : prev;
            }, 0);
        }
        get consumedGas() {
            BigNumber__default["default"].config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber__default["default"].ROUND_UP });
            return new BigNumber__default["default"](this.consumedMilliGas).dividedBy(1000).toString();
        }
        get consumedMilliGas() {
            return String(this.sumProp(flattenOperationResult({ contents: this.operationResults }), 'consumed_milligas'));
        }
        get storageDiff() {
            return String(this.sumProp(flattenOperationResult({ contents: this.operationResults }), 'paid_storage_size_diff'));
        }
        get storageSize() {
            return String(this.sumProp(flattenOperationResult({ contents: this.operationResults }), 'storage_size'));
        }
        get errors() {
            return flattenErrors({ contents: this.operationResults });
        }
    }

    const setDelegate = (key) => {
        return [
            { prim: 'DROP' },
            { prim: 'NIL', args: [{ prim: 'operation' }] },
            {
                prim: 'PUSH',
                args: [{ prim: 'key_hash' }, { string: key }],
            },
            { prim: 'SOME' },
            { prim: 'SET_DELEGATE' },
            { prim: 'CONS' },
        ];
    };
    const transferImplicit = (key, mutez) => {
        return [
            { prim: 'DROP' },
            { prim: 'NIL', args: [{ prim: 'operation' }] },
            {
                prim: 'PUSH',
                args: [{ prim: 'key_hash' }, { string: key }],
            },
            { prim: 'IMPLICIT_ACCOUNT' },
            {
                prim: 'PUSH',
                args: [{ prim: 'mutez' }, { int: `${mutez}` }],
            },
            { prim: 'UNIT' },
            { prim: 'TRANSFER_TOKENS' },
            { prim: 'CONS' },
        ];
    };
    const removeDelegate = () => {
        return [
            { prim: 'DROP' },
            { prim: 'NIL', args: [{ prim: 'operation' }] },
            { prim: 'NONE', args: [{ prim: 'key_hash' }] },
            { prim: 'SET_DELEGATE' },
            { prim: 'CONS' },
        ];
    };
    const transferToContract = (key, amount) => {
        return [
            { prim: 'DROP' },
            { prim: 'NIL', args: [{ prim: 'operation' }] },
            {
                prim: 'PUSH',
                args: [{ prim: 'address' }, { string: key }],
            },
            { prim: 'CONTRACT', args: [{ prim: 'unit' }] },
            [
                {
                    prim: 'IF_NONE',
                    args: [[[{ prim: 'UNIT' }, { prim: 'FAILWITH' }]], []],
                },
            ],
            {
                prim: 'PUSH',
                args: [{ prim: 'mutez' }, { int: `${amount}` }],
            },
            { prim: 'UNIT' },
            { prim: 'TRANSFER_TOKENS' },
            { prim: 'CONS' },
        ];
    };
    const MANAGER_LAMBDA = {
        setDelegate,
        removeDelegate,
        transferImplicit,
        transferToContract,
    };

    const code = [
        {
            prim: 'parameter',
            args: [
                {
                    prim: 'lambda',
                    args: [
                        { prim: 'unit' },
                        {
                            prim: 'pair',
                            args: [{ prim: 'list', args: [{ prim: 'operation' }] }, { prim: 'unit' }],
                        },
                    ],
                },
            ],
        },
        { prim: 'storage', args: [{ prim: 'unit' }] },
        { prim: 'code', args: [[{ prim: 'CAR' }, { prim: 'UNIT' }, { prim: 'EXEC' }]] },
    ];
    const storage = 'Unit';
    const VIEW_LAMBDA = {
        code,
        storage
    };

    function compose(functioncomposer1, functioncomposer2) {
        return (contractAbstraction, context) => functioncomposer2(functioncomposer1(contractAbstraction, context), context);
    }

    /**
     * @description Utility class to send smart contract operation
     * The format for the arguments is the flattened representation
     */
    class ContractMethod {
        constructor(provider, address, parameterSchema, name, args, isMultipleEntrypoint = true, isAnonymous = false) {
            this.provider = provider;
            this.address = address;
            this.parameterSchema = parameterSchema;
            this.name = name;
            this.args = args;
            this.isMultipleEntrypoint = isMultipleEntrypoint;
            this.isAnonymous = isAnonymous;
        }
        validateArgs(args, schema, name) {
            const sigs = schema.ExtractSignatures();
            if (!sigs.find((x) => x.length === args.length)) {
                throw new InvalidParameterError(name, sigs, args);
            }
        }
        /**
         * @description Get the schema of the smart contract method
         */
        get schema() {
            return this.isAnonymous
                ? this.parameterSchema.ExtractSchema()[this.name]
                : this.parameterSchema.ExtractSchema();
        }
        /**
         * @description Get the signature of the smart contract method
         */
        getSignature() {
            if (this.isAnonymous) {
                const sig = this.parameterSchema.ExtractSignatures().find((x) => x[0] === this.name);
                if (sig) {
                    sig.shift();
                    return sig;
                }
            }
            else {
                const sig = this.parameterSchema.ExtractSignatures();
                return sig.length == 1 ? sig[0] : sig;
            }
        }
        /**
         *
         * @description Send the smart contract operation
         *
         * @param Options generic operation parameter
         */
        send(params = {}) {
            if (this.provider instanceof Wallet) {
                return this.provider
                    .transfer(this.toTransferParams(params))
                    .send();
            }
            else {
                return this.provider.transfer(this.toTransferParams(params));
            }
        }
        /**
         *
         * @description Create transfer params to be used with TezosToolkit.contract.transfer methods
         *
         * @param Options generic transfer operation parameters
         */
        toTransferParams({ fee, gasLimit, storageLimit, source, amount = 0, mutez = false, } = {}) {
            const fullTransferParams = {
                to: this.address,
                amount,
                fee,
                mutez,
                source,
                gasLimit,
                storageLimit,
                parameter: {
                    entrypoint: this.isMultipleEntrypoint ? this.name : DEFAULT_SMART_CONTRACT_METHOD_NAME,
                    value: this.isAnonymous
                        ? this.parameterSchema.Encode(this.name, ...this.args)
                        : this.parameterSchema.Encode(...this.args),
                },
            };
            return fullTransferParams;
        }
    }

    class SaplingStateAbstraction {
        constructor(id, provider) {
            this.id = id;
            this.provider = provider;
        }
        /**
         *
         * @description Fetch the sapling state
         *
         * @param block optional block level to fetch the values from (head will be use by default)
         * @returns Return a json object of the sapling_state
         *
         */
        getSaplingDiff(block) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.provider.getSaplingDiffByID(this.id.toString(), block);
            });
        }
        getId() {
            return this.id.toString();
        }
    }

    class WalletOperationBatch {
        constructor(walletProvider, context) {
            this.walletProvider = walletProvider;
            this.context = context;
            this.operations = [];
        }
        /**
         *
         * @description Add a transaction operation to the batch
         *
         * @param params Transfer operation parameter
         */
        withTransfer(params) {
            if (utils.validateAddress(params.to) !== utils.ValidationResult.VALID) {
                throw new utils.InvalidAddressError(params.to);
            }
            this.operations.push(Object.assign({ kind: rpc.OpKind.TRANSACTION }, params));
            return this;
        }
        /**
         *
         * @description Add a contract call to the batch
         *
         * @param params Call a contract method
         * @param options Generic operation parameters
         */
        withContractCall(params, options = {}) {
            return this.withTransfer(params.toTransferParams(options));
        }
        /**
         *
         * @description Add a delegation operation to the batch
         *
         * @param params Delegation operation parameter
         */
        withDelegation(params) {
            if (params.delegate && utils.validateAddress(params.delegate) !== utils.ValidationResult.VALID) {
                throw new utils.InvalidAddressError(params.delegate);
            }
            this.operations.push(Object.assign({ kind: rpc.OpKind.DELEGATION }, params));
            return this;
        }
        /**
         *
         * @description Add an origination operation to the batch
         *
         * @param params Origination operation parameter
         */
        withOrigination(params) {
            this.operations.push(Object.assign({ kind: rpc.OpKind.ORIGINATION }, params));
            return this;
        }
        /**
         *
         * @description
         *
         * @param param
         */
        withIncreasePaidStorage(params) {
            if (utils.validateAddress(params.destination) !== utils.ValidationResult.VALID) {
                throw new utils.InvalidAddressError(params.destination);
            }
            this.operations.push(Object.assign({ kind: rpc.OpKind.INCREASE_PAID_STORAGE }, params));
            return this;
        }
        mapOperation(param) {
            return __awaiter(this, void 0, void 0, function* () {
                switch (param.kind) {
                    case rpc.OpKind.TRANSACTION:
                        return this.walletProvider.mapTransferParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () { return param; }));
                    case rpc.OpKind.ORIGINATION:
                        return this.walletProvider.mapOriginateParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () {
                            return this.context.parser.prepareCodeOrigination(Object.assign({}, param));
                        }));
                    case rpc.OpKind.DELEGATION:
                        return this.walletProvider.mapDelegateParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () { return param; }));
                    case rpc.OpKind.INCREASE_PAID_STORAGE:
                        return this.walletProvider.mapIncreasePaidStorageWalletParams(() => __awaiter(this, void 0, void 0, function* () { return param; }));
                    default:
                        throw new utils.InvalidOperationKindError(param.kind);
                }
            });
        }
        /**
         *
         * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array
         *
         * @param params Operations parameter
         */
        with(params) {
            for (const param of params) {
                switch (param.kind) {
                    case rpc.OpKind.TRANSACTION:
                        this.withTransfer(param);
                        break;
                    case rpc.OpKind.ORIGINATION:
                        this.withOrigination(param);
                        break;
                    case rpc.OpKind.DELEGATION:
                        this.withDelegation(param);
                        break;
                    case rpc.OpKind.INCREASE_PAID_STORAGE:
                        this.withIncreasePaidStorage(param);
                        break;
                    default:
                        throw new utils.InvalidOperationKindError(param.kind);
                }
            }
            return this;
        }
        /**
         *
         * @description Submit batch operation to wallet
         *
         */
        send() {
            return __awaiter(this, void 0, void 0, function* () {
                const ops = [];
                for (const op of this.operations) {
                    ops.push(yield this.mapOperation(op));
                }
                const opHash = yield this.walletProvider.sendOperations(ops);
                return this.context.operationFactory.createBatchOperation(opHash);
            });
        }
    }
    class Wallet {
        constructor(context) {
            this.context = context;
            this.walletCommand = (send) => {
                return {
                    send,
                };
            };
        }
        get walletProvider() {
            return this.context.walletProvider;
        }
        /**
         * @description Retrieve the PKH of the account that is currently in use by the wallet
         *
         * @param option Option to use while fetching the PKH.
         * If forceRefetch is specified the wallet provider implementation will refetch the PKH from the wallet
         */
        pkh({ forceRefetch } = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._pkh || forceRefetch) {
                    this._pkh = yield this.walletProvider.getPKH();
                }
                return this._pkh;
            });
        }
        /**
         *
         * @description Originate a new contract according to the script in parameters.
         *
         * @returns An operation handle with the result from the rpc node
         *
         * @param originateParams Originate operation parameter
         */
        originate(params) {
            return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
                const mappedParams = yield this.walletProvider.mapOriginateParamsToWalletParams(() => this.context.parser.prepareCodeOrigination(Object.assign({}, params)));
                const opHash = yield this.walletProvider.sendOperations([mappedParams]);
                return this.context.operationFactory.createOriginationOperation(opHash);
            }));
        }
        /**
         *
         * @description Set the delegate for a contract.
         *
         * @returns An operation handle with the result from the rpc node
         *
         * @param delegateParams operation parameter
         */
        setDelegate(params) {
            if (params.delegate && utils.validateAddress(params.delegate) !== utils.ValidationResult.VALID) {
                throw new utils.InvalidAddressError(params.delegate);
            }
            return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
                const mappedParams = yield this.walletProvider.mapDelegateParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () { return params; }));
                const opHash = yield this.walletProvider.sendOperations([mappedParams]);
                return this.context.operationFactory.createDelegationOperation(opHash);
            }));
        }
        /**
         *
         * @description Register the current address as delegate.
         *
         * @returns An operation handle with the result from the rpc node
         *
         */
        registerDelegate() {
            return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
                const mappedParams = yield this.walletProvider.mapDelegateParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () {
                    const delegate = yield this.pkh();
                    return { delegate };
                }));
                const opHash = yield this.walletProvider.sendOperations([mappedParams]);
                return this.context.operationFactory.createDelegationOperation(opHash);
            }));
        }
        /**
         *
         * @description Transfer tezos tokens from current address to a specific address or call a smart contract.
         *
         * @returns A wallet command from which we can send the operation to the wallet
         *
         * @param params operation parameter
         */
        transfer(params) {
            if (utils.validateAddress(params.to) !== utils.ValidationResult.VALID) {
                throw new utils.InvalidAddressError(params.to);
            }
            return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
                const mappedParams = yield this.walletProvider.mapTransferParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () { return params; }));
                const opHash = yield this.walletProvider.sendOperations([mappedParams]);
                return this.context.operationFactory.createTransactionOperation(opHash);
            }));
        }
        /**
         *
         * @description
         *
         * @returns
         *
         * @param params
         */
        increasePaidStorage(params) {
            if (utils.validateAddress(params.destination) !== utils.ValidationResult.VALID) {
                throw new utils.InvalidAddressError(params.destination);
            }
            return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
                const mappedParams = yield this.walletProvider.mapIncreasePaidStorageWalletParams(() => __awaiter(this, void 0, void 0, function* () { return params; }));
                const opHash = yield this.walletProvider.sendOperations([mappedParams]);
                return this.context.operationFactory.createIncreasePaidStorageOperation(opHash);
            }));
        }
        /**
         *
         * @description Create a batch of operation
         *
         * @returns A batch object from which we can add more operation or send a command to the wallet to execute the batch
         *
         * @param params List of operation to initialize the batch with
         */
        batch(params) {
            const batch = new WalletOperationBatch(this.walletProvider, this.context);
            if (Array.isArray(params)) {
                batch.with(params);
            }
            return batch;
        }
        /**
         *
         * @description Create an smart contract abstraction for the address specified. Calling entrypoints with the returned
         * smart contract abstraction will leverage the wallet provider to make smart contract calls
         *
         * @param address Smart contract address
         */
        at(address, contractAbstractionComposer = (x) => x) {
            return __awaiter(this, void 0, void 0, function* () {
                if (utils.validateContractAddress(address) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidContractAddressError(address);
                }
                const rpc = this.context.withExtensions().rpc;
                const readProvider = this.context.withExtensions().readProvider;
                const script = yield readProvider.getScript(address, 'head');
                const entrypoints = yield readProvider.getEntrypoints(address);
                const abs = new ContractAbstraction(address, script, this, this.context.contract, entrypoints, rpc, readProvider);
                return contractAbstractionComposer(abs, this.context);
            });
        }
    }

    class LegacyWalletProvider {
        constructor(context) {
            this.context = context;
        }
        getPKH() {
            return __awaiter(this, void 0, void 0, function* () {
                return this.context.signer.publicKeyHash();
            });
        }
        mapTransferParamsToWalletParams(params) {
            return __awaiter(this, void 0, void 0, function* () {
                return attachKind(yield params(), rpc.OpKind.TRANSACTION);
            });
        }
        mapOriginateParamsToWalletParams(params) {
            return __awaiter(this, void 0, void 0, function* () {
                return attachKind(yield params(), rpc.OpKind.ORIGINATION);
            });
        }
        mapDelegateParamsToWalletParams(params) {
            return __awaiter(this, void 0, void 0, function* () {
                return attachKind(yield params(), rpc.OpKind.DELEGATION);
            });
        }
        mapIncreasePaidStorageWalletParams(params) {
            return __awaiter(this, void 0, void 0, function* () {
                return attachKind(yield params(), rpc.OpKind.INCREASE_PAID_STORAGE);
            });
        }
        sendOperations(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const op = yield this.context.batch.batch(params).send();
                return op.hash;
            });
        }
    }

    /**
     * @description Utility class to send smart contract operation
     * The format for the arguments is the object representation
     */
    class ContractMethodObject {
        constructor(provider, address, parameterSchema, name, args = 'unit', isMultipleEntrypoint = true, isAnonymous = false) {
            this.provider = provider;
            this.address = address;
            this.parameterSchema = parameterSchema;
            this.name = name;
            this.args = args;
            this.isMultipleEntrypoint = isMultipleEntrypoint;
            this.isAnonymous = isAnonymous;
        }
        /**
         * @description Get the signature of the smart contract method
         */
        getSignature() {
            return this.isAnonymous
                ? this.parameterSchema.ExtractSchema()[this.name]
                : this.parameterSchema.ExtractSchema();
        }
        /**
         *
         * @description Send the smart contract operation
         *
         * @param Options generic operation parameter
         */
        send(params = {}) {
            if (this.provider instanceof Wallet) {
                return this.provider.transfer(this.toTransferParams(params)).send();
            }
            else {
                return this.provider.transfer(this.toTransferParams(params));
            }
        }
        /**
         *
         * @description Create transfer params to be used with TezosToolkit.contract.transfer methods
         *
         * @param Options generic transfer operation parameters
         */
        toTransferParams({ fee, gasLimit, storageLimit, source, amount = 0, mutez = false, } = {}) {
            const fullTransferParams = {
                to: this.address,
                amount,
                fee,
                mutez,
                source,
                gasLimit,
                storageLimit,
                parameter: {
                    entrypoint: this.isMultipleEntrypoint ? this.name : DEFAULT_SMART_CONTRACT_METHOD_NAME,
                    value: this.isAnonymous
                        ? this.parameterSchema.EncodeObject({ [this.name]: this.args })
                        : this.parameterSchema.EncodeObject(this.args),
                },
            };
            return fullTransferParams;
        }
    }

    class OnChainView {
        constructor(_rpc, _readProvider, _contractAddress, _smartContractViewSchema, _contractStorageType, _args = 'Unit') {
            this._rpc = _rpc;
            this._readProvider = _readProvider;
            this._contractAddress = _contractAddress;
            this._smartContractViewSchema = _smartContractViewSchema;
            this._contractStorageType = _contractStorageType;
            this._args = _args;
        }
        /**
         * @description Get the signature of the smart contract view
         */
        getSignature() {
            return {
                parameter: this._smartContractViewSchema.extractArgsSchema(),
                result: this._smartContractViewSchema.extractResultSchema(),
            };
        }
        /**
         * @description Get the result of the view simulation
         * @param executionContext.source the public key hash of the account who initialized this view execution.
         * @param executionContext.viewCaller the contract address which is the caller of view.
         */
        executeView(executionContext) {
            return __awaiter(this, void 0, void 0, function* () {
                this.verifyContextExecution(executionContext);
                const chainId = yield this._readProvider.getChainId();
                const viewArgs = this.transformArgsToMichelson();
                const scriptView = {
                    contract: this._contractAddress,
                    view: this._smartContractViewSchema.viewName,
                    input: viewArgs,
                    chain_id: chainId,
                    source: executionContext.viewCaller,
                };
                if (executionContext.source) {
                    scriptView.payer = executionContext.source;
                }
                return this.executeViewAndDecodeResult(scriptView);
            });
        }
        verifyContextExecution(executionContext) {
            if (executionContext.source &&
                utils.validateAddress(executionContext.source) !== utils.ValidationResult.VALID) {
                throw new InvalidViewSimulationContext(`The source account who initialized the view execution is invalid: ${executionContext.source}.`);
            }
            if (!executionContext.viewCaller ||
                utils.validateAddress(executionContext.viewCaller) !== utils.ValidationResult.VALID) {
                throw new InvalidViewSimulationContext(`The contract which is the caller of view is invalid: ${executionContext.viewCaller}.`);
            }
        }
        transformArgsToMichelson() {
            try {
                return this._smartContractViewSchema.encodeViewArgs(this._args);
            }
            catch (error) {
                throw new InvalidViewParameterError(this._smartContractViewSchema.viewName, this.getSignature(), this._args, error);
            }
        }
        /**
         * @description Loops through the view's instructions and replace BALANCE, SENDER, SELF_ADDRESS and AMOUNT with Michelson expressions that match the current context, if applicable.
         *
         * Certain specific instructions have different semantics in view:
         * BALANCE represents the current amount of mutez held by the contract where view is;
         * SENDER represents the contract which is the caller of view;
         * SELF_ADDRESS represents the contract where view is;
         * AMOUNT is always 0 mutez.
         *
         */
        adaptViewCodeToContext(instructions, viewCaller, contractBalance) {
            const instructionsToReplace = {
                BALANCE: [{ prim: 'PUSH', args: [{ prim: 'mutez' }, { int: contractBalance }] }],
                SENDER: [{ prim: 'PUSH', args: [{ prim: 'address' }, { string: viewCaller }] }],
                SELF_ADDRESS: [
                    { prim: 'PUSH', args: [{ prim: 'address' }, { string: this._contractAddress }] },
                ],
                AMOUNT: [{ prim: 'PUSH', args: [{ prim: 'mutez' }, { int: '0' }] }],
            };
            instructions.forEach((inst, i) => {
                if (inst.prim in instructionsToReplace) {
                    instructions[i] = Object(instructionsToReplace)[inst.prim];
                }
                if (inst.args && inst.args.length !== 0) {
                    this.adaptViewCodeToContext(inst.args, viewCaller, contractBalance);
                }
                else if (Array.isArray(inst)) {
                    this.adaptViewCodeToContext(inst, viewCaller, contractBalance);
                }
            });
            return instructions;
        }
        executeViewAndDecodeResult(viewScript) {
            return __awaiter(this, void 0, void 0, function* () {
                let storage;
                try {
                    storage = (yield this._rpc.runScriptView(viewScript))
                        .data;
                }
                catch (error) {
                    const failWith = validateAndExtractFailwith(error);
                    throw failWith
                        ? new ViewSimulationError(`The simulation of the on-chain view named ${this._smartContractViewSchema.viewName} failed with: ${JSON.stringify(failWith)}`, this._smartContractViewSchema.viewName, failWith, error)
                        : error;
                }
                return this._smartContractViewSchema.decodeViewResult(storage);
            });
        }
    }

    class ContractMethodFactory {
        constructor(provider, contractAddress) {
            this.provider = provider;
            this.contractAddress = contractAddress;
        }
        createContractMethodFlatParams(smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint = true, isAnonymous = false) {
            return new ContractMethod(this.provider, this.contractAddress, smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint, isAnonymous);
        }
        createContractMethodObjectParam(smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint = true, isAnonymous = false) {
            return new ContractMethodObject(this.provider, this.contractAddress, smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint, isAnonymous);
        }
        createContractViewObjectParam(rpc, readProvider, smartContractViewSchema, contractStorageType, viewArgs) {
            return new OnChainView(rpc, readProvider, this.contractAddress, smartContractViewSchema, contractStorageType, viewArgs);
        }
    }

    const DEFAULT_SMART_CONTRACT_METHOD_NAME = 'default';
    /**
     * @description Utility class to retrieve data from a smart contract's storage without incurring fees via a contract's view method
     */
    class ContractView {
        constructor(currentContract, name, callbackParametersSchema, parameterSchema, args, rpc, readProvider) {
            this.currentContract = currentContract;
            this.name = name;
            this.callbackParametersSchema = callbackParametersSchema;
            this.parameterSchema = parameterSchema;
            this.args = args;
            this.rpc = rpc;
            this.readProvider = readProvider;
        }
        read(chainId) {
            return __awaiter(this, void 0, void 0, function* () {
                if (utils.validateContractAddress(chainId !== null && chainId !== void 0 ? chainId : '') == utils.ValidationResult.VALID) {
                    throw new utils.DeprecationError(`Since version 12, the lambda view no longer depends on a lambda contract. The read method no longer accepts a contract address as a parameter.`);
                }
                else if (chainId && utils.validateChain(chainId) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidChainIdError(chainId);
                }
                const arg = this.parameterSchema.Encode(...this.args);
                const result = yield this.rpc.runView({
                    contract: this.currentContract.address,
                    entrypoint: this.name,
                    input: arg,
                    chain_id: chainId ? chainId : yield this.readProvider.getChainId(),
                });
                return this.callbackParametersSchema.Execute(result.data);
            });
        }
    }
    const validateArgs = (args, schema, name) => {
        const sigs = schema.ExtractSignatures();
        if (!sigs.find((x) => x.length === args.length)) {
            throw new InvalidParameterError(name, sigs, args);
        }
    };
    // lambda view tzip4
    const isView = (entrypoint) => {
        let isView = false;
        if ('prim' in entrypoint && entrypoint.prim === 'pair' && entrypoint.args) {
            const lastElement = entrypoint.args[entrypoint.args.length - 1];
            if ('prim' in lastElement && lastElement.prim === 'contract') {
                isView = true;
            }
        }
        return isView;
    };
    /**
     * @description Smart contract abstraction
     */
    class ContractAbstraction {
        constructor(address, script, provider, storageProvider, entrypoints, rpc, readProvider) {
            this.address = address;
            this.script = script;
            this.storageProvider = storageProvider;
            this.entrypoints = entrypoints;
            this.rpc = rpc;
            this.readProvider = readProvider;
            /**
             * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.
             * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.
             *
             */
            this.methods = {};
            /**
             * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.
             * `methodsObject` serves the exact same purpose as the `methods` member. The difference is that it allows passing the parameter in an object format when calling the smart contract method (instead of the flattened representation)
             * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.
             *
             */
            this.methodsObject = {};
            /**
             * @description Contains lamda views (tzip4) that are implemented by the target Tezos Smart Contract, and offers the user to call the lambda views as if they were native TS/JS methods.
             * NB: These are the view defined in the tzip4 standard, not the views introduced by the Hangzhou protocol.
             */
            this.views = {};
            /**
             * @description Contains on-chain views that are defined by the target Tezos Smart Contract, and offers the user to simulate the views execution as if they were native TS/JS methods.
             * NB: the expected format for the parameter when calling a smart contract view is the object format (same format as for the storage) and not the flattened representation.
             *
             */
            this.contractViews = {};
            this.contractMethodFactory = new ContractMethodFactory(provider, address);
            this.schema = michelsonEncoder.Schema.fromRPCResponse({ script: this.script });
            this.parameterSchema = michelsonEncoder.ParameterSchema.fromRPCResponse({ script: this.script });
            this.viewSchema = michelsonEncoder.ViewSchema.fromRPCResponse({ script: this.script });
            if (this.viewSchema.length !== 0) {
                this._initializeOnChainViews(this, rpc, this.readProvider, this.viewSchema);
            }
            this._initializeMethods(this, this.entrypoints.entrypoints, this.rpc, this.readProvider);
        }
        _initializeMethods(currentContract, entrypoints, rpc, readProvider) {
            const parameterSchema = this.parameterSchema;
            const keys = Object.keys(entrypoints);
            if (parameterSchema.isMultipleEntryPoint) {
                keys.forEach((smartContractMethodName) => {
                    const smartContractMethodSchema = new michelsonEncoder.ParameterSchema(entrypoints[smartContractMethodName]);
                    this.methods[smartContractMethodName] = function (...args) {
                        return currentContract.contractMethodFactory.createContractMethodFlatParams(smartContractMethodSchema, smartContractMethodName, args);
                    };
                    this.methodsObject[smartContractMethodName] = function (args) {
                        return currentContract.contractMethodFactory.createContractMethodObjectParam(smartContractMethodSchema, smartContractMethodName, args);
                    };
                    if (isView(entrypoints[smartContractMethodName])) {
                        const view = function (...args) {
                            const entrypointParamWithoutCallback = entrypoints[smartContractMethodName]
                                .args[0];
                            const smartContractMethodSchemaWithoutCallback = new michelsonEncoder.ParameterSchema(entrypointParamWithoutCallback);
                            const parametersCallback = entrypoints[smartContractMethodName].args[1]
                                .args[0];
                            const smartContractMethodCallbackSchema = new michelsonEncoder.ParameterSchema(parametersCallback);
                            validateArgs(args, smartContractMethodSchemaWithoutCallback, smartContractMethodName);
                            return new ContractView(currentContract, smartContractMethodName, smartContractMethodCallbackSchema, smartContractMethodSchemaWithoutCallback, args, rpc, readProvider);
                        };
                        this.views[smartContractMethodName] = view;
                    }
                });
                // Deal with methods with no annotations which were not discovered by the RPC endpoint
                // Methods with no annotations are discovered using parameter schema
                const anonymousMethods = Object.keys(parameterSchema.ExtractSchema()).filter((key) => Object.keys(entrypoints).indexOf(key) === -1);
                anonymousMethods.forEach((smartContractMethodName) => {
                    this.methods[smartContractMethodName] = function (...args) {
                        return currentContract.contractMethodFactory.createContractMethodFlatParams(parameterSchema, smartContractMethodName, args, false, true);
                    };
                    this.methodsObject[smartContractMethodName] = function (args) {
                        return currentContract.contractMethodFactory.createContractMethodObjectParam(parameterSchema, smartContractMethodName, args, false, true);
                    };
                });
            }
            else {
                const smartContractMethodSchema = this.parameterSchema;
                this.methods[DEFAULT_SMART_CONTRACT_METHOD_NAME] = function (...args) {
                    return currentContract.contractMethodFactory.createContractMethodFlatParams(smartContractMethodSchema, DEFAULT_SMART_CONTRACT_METHOD_NAME, args, false);
                };
                this.methodsObject[DEFAULT_SMART_CONTRACT_METHOD_NAME] =
                    function (args) {
                        return currentContract.contractMethodFactory.createContractMethodObjectParam(smartContractMethodSchema, DEFAULT_SMART_CONTRACT_METHOD_NAME, args, false);
                    };
            }
        }
        _initializeOnChainViews(currentContract, rpc, readProvider, allContractViews) {
            const storageType = this.schema.val;
            allContractViews.forEach((viewSchema) => {
                this.contractViews[viewSchema.viewName] = function (args) {
                    return currentContract.contractMethodFactory.createContractViewObjectParam(rpc, readProvider, viewSchema, storageType, args);
                };
            });
        }
        /**
         * @description Return a friendly representation of the smart contract storage
         */
        storage() {
            return this.storageProvider.getStorage(this.address, this.schema);
        }
        /**
         *
         * @description Return a friendly representation of the smart contract big map value
         *
         * @param key BigMap key to fetch
         *
         * @deprecated getBigMapKey has been deprecated in favor of getBigMapKeyByID
         *
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
         */
        bigMap(key) {
            return this.storageProvider.getBigMapKey(this.address, key, this.schema);
        }
    }

    class BigMapAbstraction {
        constructor(id, schema, provider) {
            this.id = id;
            this.schema = schema;
            this.provider = provider;
        }
        /**
         *
         * @description Fetch one value in a big map
         *
         * @param keysToEncode Key to query (will be encoded properly according to the schema)
         * @param block optional block level to fetch the values from (head will be use by default)
         * @returns Return a well formatted json object of a big map value or undefined if the key is not found in the big map
         *
         */
        get(keyToEncode, block) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const id = yield this.provider.getBigMapKeyByID(this.id.toString(), keyToEncode, this.schema, block);
                    return id;
                }
                catch (e) {
                    if (e instanceof httpUtils.HttpResponseError && e.status === httpUtils.STATUS_CODE.NOT_FOUND) {
                        return undefined;
                    }
                    else {
                        throw e;
                    }
                }
            });
        }
        /**
         *
         * @description Fetch multiple values in a big map
         * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.
         * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.
         * If one of the keys does not exist in the big map, its value will be set to undefined.
         *
         * @param keysToEncode Array of keys to query (will be encoded properly according to the schema)
         * @param block optional block level to fetch the values from
         * @param batchSize optional batch size representing the number of requests to execute in parallel
         * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format
         *
         */
        getMultipleValues(keysToEncode, block, batchSize = 5) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.provider.getBigMapKeysByID(this.id.toString(), keysToEncode, this.schema, block, batchSize);
            });
        }
        toJSON() {
            return this.id.toString();
        }
        toString() {
            return this.id.toString();
        }
    }

    // Override the default michelson encoder semantic to provide richer abstraction over storage properties
    const smartContractAbstractionSemantic = (provider) => ({
        // Provide a specific abstraction for BigMaps
        big_map: (val, code) => {
            if (!val || !('int' in val) || val.int === undefined) {
                // Return an empty object in case of missing big map ID
                return {};
            }
            else {
                const schema = new michelsonEncoder.Schema(code);
                return new BigMapAbstraction(new BigNumber__default["default"](val.int), schema, provider);
            }
        },
        sapling_state: (val) => {
            if (!val || !('int' in val) || val.int === undefined) {
                // Return an empty object in case of missing sapling state ID
                return {};
            }
            else {
                return new SaplingStateAbstraction(new BigNumber__default["default"](val.int), provider);
            }
        }
        /*
        // TODO: embed useful other abstractions
        'contract':  () => {},
        'address':  () => {}
        */
    });

    /**
     * @description TxRollupOriginationOperation provides utility functions to fetch a newly issued operation of kind tx_rollup_origination
     */
    class TxRollupOriginationOperation extends Operation {
        constructor(hash, params, source, raw, results, context) {
            super(hash, raw, results, context);
            this.params = params;
            this.source = source;
            this.originatedRollup = this.operationResults && this.operationResults.originated_rollup;
        }
        get operationResults() {
            const rollupOriginationOp = Array.isArray(this.results) &&
                this.results.find((op) => op.kind === 'tx_rollup_origination');
            const result = rollupOriginationOp &&
                rollupOriginationOp.metadata &&
                rollupOriginationOp.metadata.operation_result;
            return result ? result : undefined;
        }
        get status() {
            var _a, _b;
            return (_b = (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : 'unknown';
        }
        get fee() {
            return this.params.fee;
        }
        get gasLimit() {
            return this.params.gas_limit;
        }
        get storageLimit() {
            return this.params.storage_limit;
        }
        get errors() {
            var _a;
            return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.errors;
        }
        get consumedGas() {
            BigNumber.BigNumber.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber.BigNumber.ROUND_UP });
            return this.consumedMilliGas
                ? new BigNumber.BigNumber(this.consumedMilliGas).dividedBy(1000).toString()
                : undefined;
        }
        get consumedMilliGas() {
            var _a;
            return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.consumed_milligas;
        }
    }

    /**
     * @description TxRollupBatchOperation provides utility functions to fetch a newly issued operation of kind tx_rollup_submit_batch
     */
    class TxRollupBatchOperation extends Operation {
        constructor(hash, params, source, raw, results, context) {
            super(hash, raw, results, context);
            this.params = params;
            this.source = source;
        }
        get operationResults() {
            const txrollupBatchOp = Array.isArray(this.results) &&
                this.results.find((op) => op.kind === 'tx_rollup_submit_batch');
            const result = txrollupBatchOp && txrollupBatchOp.metadata && txrollupBatchOp.metadata.operation_result;
            return result ? result : undefined;
        }
        get status() {
            var _a, _b;
            return (_b = (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : 'unknown';
        }
        get content() {
            return this.params.content;
        }
        get fee() {
            return this.params.fee;
        }
        get gasLimit() {
            return this.params.gas_limit;
        }
        get storageLimit() {
            return this.params.storage_limit;
        }
        get errors() {
            var _a;
            return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.errors;
        }
        get consumedGas() {
            BigNumber.BigNumber.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber.BigNumber.ROUND_UP });
            return this.consumedMilliGas
                ? new BigNumber.BigNumber(this.consumedMilliGas).dividedBy(1000).toString()
                : undefined;
        }
        get consumedMilliGas() {
            var _a;
            return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.consumed_milligas;
        }
    }

    /**
     *
     * @description BallotOperation provides utility functions to fetch a new operation of kind ballot
     *
     */
    class BallotOperation extends Operation {
        constructor(hash, params, source, raw, results, context) {
            super(hash, raw, results, context);
            this.params = params;
            this.source = source;
        }
        get operationResults() {
            const ballotOp = Array.isArray(this.results) &&
                this.results.find((op) => op.kind === 'ballot');
            const result = ballotOp;
            return result ? result : undefined;
        }
        get period() {
            var _a;
            return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.period;
        }
        get proposal() {
            return this.params.proposal;
        }
        get ballot() {
            return this.params.ballot;
        }
    }

    /**
     *
     * @description DrainDelegateOperation provides utility functions to fetch a new operation of kind drain_delegate
     *
     */
    class DrainDelegateOperation extends Operation {
        constructor(hash, params, raw, results, context) {
            super(hash, raw, results, context);
            this.params = params;
        }
        get operationResults() {
            const drainDelegateOp = Array.isArray(this.results) &&
                this.results.find((op) => op.kind === 'drain_delegate');
            const result = drainDelegateOp && drainDelegateOp.metadata && drainDelegateOp.metadata.balance_updates;
            return result ? result : undefined;
        }
        get consensusKey() {
            return this.params.consensus_key;
        }
        get delegate() {
            return this.params.delegate;
        }
        get destination() {
            return this.params.destination;
        }
    }

    /**
     *
     * @description Transfer tickets from a Tezos address (tz1, tz2 or tz3) to a smart contract address (KT1) (everything on layer 1 at this step)
     *
     * @warn Currently only supports one L2 ticket holder transfer at once. ie. one collection of tickets owned by tz1, tz2 or tz3 to a smart contract.
     */
    class TransferTicketOperation extends Operation {
        constructor(hash, params, source, raw, results, context) {
            super(hash, raw, results, context);
            this.params = params;
            this.source = source;
        }
        get operationResults() {
            const transferOp = Array.isArray(this.results) &&
                this.results.find((op) => op.kind === rpc.OpKind.TRANSFER_TICKET);
            const result = transferOp && transferOp.metadata && transferOp.metadata.operation_result;
            return result ? result : undefined;
        }
        get status() {
            var _a, _b;
            return (_b = (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : 'unknown';
        }
        get fee() {
            return this.params.fee;
        }
        get gasLimit() {
            return this.params.gas_limit;
        }
        get storageLimit() {
            return this.params.storage_limit;
        }
        get consumedGas() {
            BigNumber.BigNumber.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber.BigNumber.ROUND_UP });
            return this.consumedMilliGas
                ? new BigNumber.BigNumber(this.consumedMilliGas).dividedBy(1000).toString()
                : undefined;
        }
        get consumedMilliGas() {
            var _a;
            return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.consumed_milligas;
        }
    }

    /**
     *
     * @description IncreasePaidStorageOperation provides utility functions to fetch a new operation of kind increase_paid_storage
     *
     */
    class IncreasePaidStorageOperation extends Operation {
        constructor(hash, params, source, raw, results, context) {
            super(hash, raw, results, context);
            this.params = params;
            this.source = source;
        }
        get operationResults() {
            const increasePaidStorageOp = Array.isArray(this.results) &&
                this.results.find((op) => op.kind === 'increase_paid_storage');
            const result = increasePaidStorageOp &&
                increasePaidStorageOp.metadata &&
                increasePaidStorageOp.metadata.operation_result;
            return result ? result : undefined;
        }
        get status() {
            var _a, _b;
            return (_b = (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : 'unknown';
        }
        get fee() {
            return this.params.fee;
        }
        get gasLimit() {
            return this.params.gas_limit;
        }
        get storageLimit() {
            return this.params.storage_limit;
        }
        get errors() {
            var _a;
            return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.errors;
        }
        get consumedMilliGas() {
            var _a;
            return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.consumed_milligas;
        }
        get amount() {
            return this.params.amount;
        }
        get destination() {
            return this.params.destination;
        }
    }

    /**
     *
     * @description ProposalsOperation provides utility functions to fetch a new operation of kind proposals
     *
     */
    class ProposalsOperation extends Operation {
        constructor(hash, params, source, raw, results, context) {
            super(hash, raw, results, context);
            this.params = params;
            this.source = source;
        }
        get operationResults() {
            const proposalsOp = Array.isArray(this.results) &&
                this.results.find((op) => op.kind === 'proposals');
            const result = proposalsOp;
            return result ? result : undefined;
        }
        get proposals() {
            return this.params.proposals;
        }
        get period() {
            var _a;
            return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.period;
        }
    }

    /**
     *
     * @description UpdateConsensusKeyOperation provides utility to fetch properties for Operation of kind UpdateConsensusKey
     *
     */
    class UpdateConsensusKeyOperation extends Operation {
        constructor(hash, params, source, raw, results, context) {
            super(hash, raw, results, context);
            this.params = params;
            this.source = source;
        }
        get operationResults() {
            const updateConsensusKeyOp = Array.isArray(this.results) &&
                this.results.find((op) => op.kind === 'update_consensus_key');
            const result = updateConsensusKeyOp &&
                updateConsensusKeyOp.metadata &&
                updateConsensusKeyOp.metadata.operation_result;
            return result ? result : undefined;
        }
        get status() {
            var _a, _b;
            return (_b = (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : 'unknown';
        }
        get fee() {
            return this.params.fee;
        }
        get gasLimit() {
            return this.params.gas_limit;
        }
        get storageLimit() {
            return this.params.storage_limit;
        }
        get pk() {
            return this.params.pk;
        }
        get consumedMilliGas() {
            var _a;
            return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.consumed_milligas;
        }
        get errors() {
            var _a;
            return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.errors;
        }
    }

    class RpcContractProvider extends OperationEmitter {
        constructor(context, estimator) {
            super(context);
            this.estimator = estimator;
            this.contractProviderTypeSymbol = Symbol.for('taquito-contract-provider-type-symbol');
        }
        /**
         *
         * @description Return a well formatted json object of the contract storage
         *
         * @param contract contract address you want to get the storage from
         * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script
         */
        getStorage(contract, schema) {
            return __awaiter(this, void 0, void 0, function* () {
                if (utils.validateContractAddress(contract) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidContractAddressError(contract);
                }
                const script = yield this.context.readProvider.getScript(contract, 'head');
                if (!schema) {
                    schema = script;
                }
                let contractSchema;
                if (michelsonEncoder.Schema.isSchema(schema)) {
                    contractSchema = schema;
                }
                else {
                    contractSchema = michelsonEncoder.Schema.fromRPCResponse({ script: schema });
                }
                return contractSchema.Execute(script.storage, smartContractAbstractionSemantic(this)); // Cast into T because only the caller can know the true type of the storage
            });
        }
        /**
         *
         * @description Return a well formatted json object of the contract big map storage
         *
         * @param contract contract address you want to get the storage from
         * @param key contract big map key to fetch value from
         * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema
         *
         * @deprecated Deprecated in favor of getBigMapKeyByID
         *
         * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
         */
        getBigMapKey(contract, key, schema) {
            return __awaiter(this, void 0, void 0, function* () {
                if (utils.validateContractAddress(contract) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidContractAddressError(contract);
                }
                if (!schema) {
                    schema = (yield this.rpc.getContract(contract)).script;
                }
                let contractSchema;
                if (michelsonEncoder.Schema.isSchema(schema)) {
                    contractSchema = schema;
                }
                else {
                    contractSchema = michelsonEncoder.Schema.fromRPCResponse({ script: schema });
                }
                const encodedKey = contractSchema.EncodeBigMapKey(key);
                const val = yield this.rpc.getBigMapKey(contract, encodedKey);
                return contractSchema.ExecuteOnBigMapValue(val); // Cast into T because only the caller can know the true type of the storage
            });
        }
        /**
         *
         * @description Return a well formatted json object of a big map value
         *
         * @param id Big Map ID
         * @param keyToEncode key to query (will be encoded properly according to the schema)
         * @param schema Big Map schema (can be determined using your contract type)
         * @param block optional block level to fetch the values from
         *
         * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr
         */
        getBigMapKeyByID(id, keyToEncode, schema, block) {
            return __awaiter(this, void 0, void 0, function* () {
                const { key, type } = schema.EncodeBigMapKey(keyToEncode);
                const { packed } = yield this.context.packer.packData({ data: key, type });
                const encodedExpr = utils.encodeExpr(packed);
                const bigMapValue = block
                    ? yield this.context.readProvider.getBigMapValue({ id: id.toString(), expr: encodedExpr }, block)
                    : yield this.context.readProvider.getBigMapValue({ id: id.toString(), expr: encodedExpr }, 'head');
                return schema.ExecuteOnBigMapValue(bigMapValue, smartContractAbstractionSemantic(this));
            });
        }
        /**
         *
         * @description Fetch multiple values in a big map
         * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.
         * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.
         * If one of the keys does not exist in the big map, its value will be set to undefined.
         *
         * @param id Big Map ID
         * @param keys Array of keys to query (will be encoded properly according to the schema)
         * @param schema Big Map schema (can be determined using your contract type)
         * @param block optional block level to fetch the values from
         * @param batchSize optional batch size representing the number of requests to execute in parallel
         * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format
         *
         */
        getBigMapKeysByID(id, keys, schema, block, batchSize = 5) {
            return __awaiter(this, void 0, void 0, function* () {
                const level = yield this.getBlockForRequest(keys, block);
                const bigMapValues = new michelsonEncoder.MichelsonMap();
                // Execute batch of promises in series
                let position = 0;
                let results = [];
                while (position < keys.length) {
                    const keysBatch = keys.slice(position, position + batchSize);
                    const batch = keysBatch.map((keyToEncode) => this.getBigMapValueOrUndefined(keyToEncode, id, schema, level));
                    results = [...results, ...(yield Promise.all(batch))];
                    position += batchSize;
                }
                for (let i = 0; i < results.length; i++) {
                    bigMapValues.set(keys[i], results[i]);
                }
                return bigMapValues;
            });
        }
        getBlockForRequest(keys, block) {
            return __awaiter(this, void 0, void 0, function* () {
                return keys.length === 1 || typeof block !== 'undefined'
                    ? block
                    : yield this.context.readProvider.getBlockLevel('head');
            });
        }
        getBigMapValueOrUndefined(keyToEncode, id, schema, level) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.getBigMapKeyByID(id, keyToEncode, schema, level);
                }
                catch (ex) {
                    if (ex instanceof httpUtils.HttpResponseError && ex.status === httpUtils.STATUS_CODE.NOT_FOUND) {
                        return;
                    }
                    else {
                        throw ex;
                    }
                }
            });
        }
        /**
         *
         * @description Return a well formatted json object of a sapling state
         *
         * @param id Sapling state ID
         * @param block optional block level to fetch the value from
         *
         */
        getSaplingDiffByID(id, block) {
            return __awaiter(this, void 0, void 0, function* () {
                const saplingState = block
                    ? yield this.context.readProvider.getSaplingDiffById({ id: id.toString() }, block)
                    : yield this.context.readProvider.getSaplingDiffById({ id: id.toString() }, 'head');
                return saplingState;
            });
        }
        addRevealOperationIfNeeded(operation, publicKeyHash) {
            return __awaiter(this, void 0, void 0, function* () {
                if (isOpRequireReveal(operation)) {
                    const ops = [operation];
                    const publicKey = yield this.signer.publicKey();
                    const estimateReveal = yield this.estimator.reveal();
                    if (estimateReveal) {
                        const reveal = { kind: rpc.OpKind.REVEAL };
                        const estimatedReveal = yield this.estimate(reveal, () => __awaiter(this, void 0, void 0, function* () { return estimateReveal; }));
                        ops.unshift(yield createRevealOperation(Object.assign({}, estimatedReveal), publicKeyHash, publicKey));
                        return ops;
                    }
                }
                return operation;
            });
        }
        /**
         *
         * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context
         *
         * @returns An operation handle with the result from the rpc node
         *
         * @warn You cannot specify storage and init at the same time (use init to pass the raw michelson representation of storage)
         *
         * @param OriginationOperation Originate operation parameter
         */
        originate(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const estimate = yield this.estimate(params, this.estimator.originate.bind(this.estimator));
                const publicKeyHash = yield this.signer.publicKeyHash();
                const operation = yield createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign(Object.assign({}, params), estimate)));
                const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);
                const preparedOrigination = yield this.prepareOperation({
                    operation: ops,
                    source: publicKeyHash,
                });
                const forgedOrigination = yield this.forge(preparedOrigination);
                const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(forgedOrigination);
                return new OriginationOperation(hash, operation, forgedBytes, opResponse, context, this);
            });
        }
        /**
         *
         * @description Set the delegate for a contract. Will sign and inject an operation using the current context
         *
         * @returns An operation handle with the result from the rpc node
         *
         * @param SetDelegate operation parameter
         */
        setDelegate(params) {
            return __awaiter(this, void 0, void 0, function* () {
                if (params.source && utils.validateAddress(params.source) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidAddressError(params.source);
                }
                if (params.delegate && utils.validateAddress(params.delegate) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidAddressError(params.delegate);
                }
                // Since babylon delegation source cannot smart contract
                if (/kt1/i.test(params.source)) {
                    throw new InvalidDelegationSource(params.source);
                }
                const estimate = yield this.estimate(params, this.estimator.setDelegate.bind(this.estimator));
                const publicKeyHash = yield this.signer.publicKeyHash();
                const operation = yield createSetDelegateOperation(Object.assign(Object.assign({}, params), estimate));
                const sourceOrDefault = params.source || publicKeyHash;
                const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);
                const prepared = yield this.prepareOperation({
                    operation: ops,
                    source: sourceOrDefault,
                });
                const opBytes = yield this.forge(prepared);
                const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
                return new DelegateOperation(hash, operation, sourceOrDefault, forgedBytes, opResponse, context);
            });
        }
        /**
         *
         * @description Register the current address as delegate. Will sign and inject an operation using the current context
         *
         * @returns An operation handle with the result from the rpc node
         *
         * @param RegisterDelegate operation parameter
         */
        registerDelegate(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const estimate = yield this.estimate(params, this.estimator.registerDelegate.bind(this.estimator));
                const source = yield this.signer.publicKeyHash();
                const operation = yield createRegisterDelegateOperation(Object.assign(Object.assign({}, params), estimate), source);
                const ops = yield this.addRevealOperationIfNeeded(operation, source);
                const prepared = yield this.prepareOperation({ operation: ops });
                const opBytes = yield this.forge(prepared);
                const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
                return new DelegateOperation(hash, operation, source, forgedBytes, opResponse, context);
            });
        }
        /**
         *
         * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context
         *
         * @returns An operation handle with the result from the rpc node
         *
         * @param Transfer operation parameter
         */
        transfer(params) {
            return __awaiter(this, void 0, void 0, function* () {
                if (utils.validateAddress(params.to) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidAddressError(params.to);
                }
                if (params.source && utils.validateAddress(params.source) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidAddressError(params.source);
                }
                const publickKeyHash = yield this.signer.publicKeyHash();
                const estimate = yield this.estimate(params, this.estimator.transfer.bind(this.estimator));
                const operation = yield createTransferOperation(Object.assign(Object.assign({}, params), estimate));
                const source = params.source || publickKeyHash;
                const ops = yield this.addRevealOperationIfNeeded(operation, publickKeyHash);
                const prepared = yield this.prepareOperation({ operation: ops, source: params.source });
                const opBytes = yield this.forge(prepared);
                const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
                return new TransactionOperation(hash, operation, source, forgedBytes, opResponse, context);
            });
        }
        /**
         *
         * @description Transfer Tickets to a smart contract address
         *
         * @returns An operation handle with the result from the rpc node
         *
         * @param TransferTicketParams operation parameter
         */
        transferTicket(params) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                if (utils.validateContractAddress(params.destination) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidContractAddressError(params.destination);
                }
                if (params.source && utils.validateAddress(params.source) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidAddressError(params.source);
                }
                const publicKeyHash = yield this.signer.publicKeyHash();
                const estimate = yield this.estimate(params, this.estimator.transferTicket.bind(this.estimator));
                const operation = yield createTransferTicketOperation(Object.assign(Object.assign({}, params), estimate));
                const source = (_a = params.source) !== null && _a !== void 0 ? _a : publicKeyHash;
                const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);
                const prepared = yield this.prepareOperation({ operation: ops, source: params.source });
                const opBytes = yield this.forge(prepared);
                const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
                return new TransferTicketOperation(hash, operation, source, forgedBytes, opResponse, context);
            });
        }
        /**
         *
         * @description Reveal the current address. Will throw an error if the address is already revealed.
         *
         * @returns An operation handle with the result from the rpc node
         *
         * @param RevealParams operation parameter
         */
        reveal(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const publicKeyHash = yield this.signer.publicKeyHash();
                const estimateReveal = yield this.estimator.reveal(params);
                if (estimateReveal) {
                    const estimated = yield this.estimate(params, () => __awaiter(this, void 0, void 0, function* () { return estimateReveal; }));
                    const operation = yield createRevealOperation(Object.assign({}, estimated), publicKeyHash, yield this.signer.publicKey());
                    const prepared = yield this.prepareOperation({ operation, source: publicKeyHash });
                    const opBytes = yield this.forge(prepared);
                    const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
                    return new RevealOperation(hash, operation, publicKeyHash, forgedBytes, opResponse, context);
                }
                else {
                    throw new RevealOperationError(`The publicKeyHash '${publicKeyHash}' has already been revealed.`);
                }
            });
        }
        /**
         *
         * @description Register a Micheline expression in a global table of constants. Will sign and inject an operation using the current context
         *
         * @returns An operation handle with the result from the rpc node
         *
         * @param params registerGlobalConstant operation parameter
         */
        registerGlobalConstant(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const publickKeyHash = yield this.signer.publicKeyHash();
                const estimate = yield this.estimate(params, this.estimator.registerGlobalConstant.bind(this.estimator));
                const operation = yield createRegisterGlobalConstantOperation(Object.assign(Object.assign({}, params), estimate));
                const ops = yield this.addRevealOperationIfNeeded(operation, publickKeyHash);
                const prepared = yield this.prepareOperation({ operation: ops, source: publickKeyHash });
                const opBytes = yield this.forge(prepared);
                const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
                return new RegisterGlobalConstantOperation(hash, operation, publickKeyHash, forgedBytes, opResponse, context);
            });
        }
        /**
         *
         * @description Increase the paid storage of a smart contract
         *
         * @returns An operation handle with the result from the rpc node
         *
         * @param params increasePaidStorage operation parameter
         */
        increasePaidStorage(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const publicKeyHash = yield this.signer.publicKeyHash();
                const estimate = yield this.estimate(params, this.estimator.increasePaidStorage.bind(this.estimator));
                const operation = yield createIncreasePaidStorageOperation(Object.assign(Object.assign({}, params), estimate));
                const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);
                const prepared = yield this.prepareOperation({ operation: ops, source: publicKeyHash });
                const opBytes = yield this.forge(prepared);
                const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
                return new IncreasePaidStorageOperation(hash, operation, publicKeyHash, forgedBytes, opResponse, context);
            });
        }
        /**
         *
         * @description Transfers the spendable balance of the delegate to destination when consensus_key is the active consensus key of delegate
         *
         * @returns An operation handle with the result from the rpc node
         *
         * @param params drainDelegate operation parameter
         */
        drainDelegate(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const operation = yield createDrainDelegateOperation(Object.assign({}, params));
                const prepared = yield this.prepareOperation({ operation: operation });
                const opBytes = yield this.forge(prepared);
                const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
                return new DrainDelegateOperation(hash, operation, forgedBytes, opResponse, context);
            });
        }
        /**
         *
         * @description Originate a new tx rollup. Will sign and inject an operation using the current context
         *
         * @returns An operation handle with the result from the rpc node
         *
         * @param TxRollupOriginateParams Originate rollup operation parameter
         */
        txRollupOriginate(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const publicKeyHash = yield this.signer.publicKeyHash();
                const estimate = yield this.estimate(params ? params : {}, this.estimator.txRollupOriginate.bind(this.estimator));
                const operation = yield createTxRollupOriginationOperation(Object.assign(Object.assign({}, params), estimate));
                const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);
                const prepared = yield this.prepareOperation({ operation: ops, source: publicKeyHash });
                const opBytes = yield this.forge(prepared);
                const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
                return new TxRollupOriginationOperation(hash, operation, publicKeyHash, forgedBytes, opResponse, context);
            });
        }
        /**
         *
         * @description Submit a tx rollup batch. Will sign and inject an operation using the current context
         *
         * @returns An operation handle with the result from the rpc node
         *
         * @param TxRollupBatchParams Batch tx rollup operation parameter
         */
        txRollupSubmitBatch(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const publicKeyHash = yield this.signer.publicKeyHash();
                const estimate = yield this.estimate(params, this.estimator.txRollupSubmitBatch.bind(this.estimator));
                const operation = yield createTxRollupBatchOperation(Object.assign(Object.assign({}, params), estimate));
                const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);
                const prepared = yield this.prepareOperation({ operation: ops, source: publicKeyHash });
                const opBytes = yield this.forge(prepared);
                const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
                return new TxRollupBatchOperation(hash, operation, publicKeyHash, forgedBytes, opResponse, context);
            });
        }
        /**
         *
         * @description Submit a ballot vote to a specified proposal
         *
         * @returns An operation handle with the result from the rpc node
         *
         * @param BallotParams Ballot operation parameter
         */
        ballot(params) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                const publicKeyHash = yield this.signer.publicKeyHash();
                if (params.source && utils.validateAddress(params.source) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidAddressError(params.source);
                }
                const source = (_a = params.source) !== null && _a !== void 0 ? _a : publicKeyHash;
                const operation = yield createBallotOperation(Object.assign(Object.assign({}, params), { source }));
                const prepared = yield this.prepareOperation({ operation, source });
                const opBytes = yield this.forge(prepared);
                const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
                return new BallotOperation(hash, operation, publicKeyHash, forgedBytes, opResponse, context);
            });
        }
        /**
         *
         * @description Submit or upvote a proposal during the Proposal period
         *
         * @returns An operation handle with the result from the rpc node
         *
         * @param BallotParams Proposals operation parameter
         */
        proposals(params) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                const publicKeyHash = yield this.signer.publicKeyHash();
                if (params.source && utils.validateAddress(params.source) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidAddressError(params.source);
                }
                const source = (_a = params.source) !== null && _a !== void 0 ? _a : publicKeyHash;
                const operation = yield createProposalsOperation(Object.assign(Object.assign({}, params), { source }));
                const prepared = yield this.prepareOperation({ operation, source });
                const opBytes = yield this.forge(prepared);
                const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
                return new ProposalsOperation(hash, operation, publicKeyHash, forgedBytes, opResponse, context);
            });
        }
        /**
         *
         * @description Updates the consensus key of the baker to public_key starting from the current cycle plus PRESERVED_CYCLES + 1
         *
         * @returns An operation handle with the result from the rpc node
         *
         * @param UpdateConsensusKeyParams
         */
        updateConsensusKey(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const publicKeyHash = yield this.signer.publicKeyHash();
                const estimate = yield this.estimate(params, this.estimator.updateConsensusKey.bind(this.estimator));
                const operation = yield createUpdateConsensusKeyOperation(Object.assign(Object.assign({}, params), estimate));
                const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);
                const prepared = yield this.prepareOperation({ operation: ops, source: params.source });
                const opBytes = yield this.forge(prepared);
                const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
                return new UpdateConsensusKeyOperation(hash, operation, publicKeyHash, forgedBytes, opResponse, context);
            });
        }
        at(address, contractAbstractionComposer = (x) => x) {
            return __awaiter(this, void 0, void 0, function* () {
                if (utils.validateContractAddress(address) !== utils.ValidationResult.VALID) {
                    throw new utils.InvalidContractAddressError(address);
                }
                const rpc = this.context.withExtensions().rpc;
                const readProvider = this.context.withExtensions().readProvider;
                const script = yield readProvider.getScript(address, 'head');
                const entrypoints = yield readProvider.getEntrypoints(address);
                const abs = new ContractAbstraction(address, script, this, this, entrypoints, rpc, readProvider);
                return contractAbstractionComposer(abs, this.context);
            });
        }
        /**
         *
         * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch
         *
         * @returns A batch object from which we can add more operation or send a command to execute the batch
         *
         * @param params List of operation to batch together
         */
        batch(params) {
            const batch = new OperationBatch(this.context, this.estimator);
            if (Array.isArray(params)) {
                batch.with(params);
            }
            return batch;
        }
    }

    class MichelCodecParser {
        constructor(context) {
            this.context = context;
        }
        getNextProto() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.context.proto) {
                    const nextProto = yield this.context.readProvider.getNextProtocol('head');
                    this.context.proto = nextProto;
                }
                return this.context.proto;
            });
        }
        parseScript(src) {
            return __awaiter(this, void 0, void 0, function* () {
                const parser = new michelCodec.Parser({ protocol: yield this.getNextProto() });
                return parser.parseScript(src);
            });
        }
        parseMichelineExpression(src) {
            return __awaiter(this, void 0, void 0, function* () {
                const parser = new michelCodec.Parser({ protocol: yield this.getNextProto() });
                return parser.parseMichelineExpression(src);
            });
        }
        parseJSON(src) {
            return __awaiter(this, void 0, void 0, function* () {
                const parser = new michelCodec.Parser({ protocol: yield this.getNextProto() });
                return parser.parseJSON(src);
            });
        }
        prepareCodeOrigination(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const parsedParams = params;
                parsedParams.code = yield this.formatCodeParam(params.code);
                if (params.init) {
                    parsedParams.init = yield this.formatInitParam(params.init);
                }
                else if (params.storage) {
                    const storageType = parsedParams.code.find((p) => 'prim' in p && p.prim === 'storage');
                    if (!(storageType === null || storageType === void 0 ? void 0 : storageType.args)) {
                        throw new InvalidCodeParameter('The storage section is missing from the script', params.code);
                    }
                    const schema = new michelsonEncoder.Schema(storageType.args[0]);
                    const globalconstantsHashAndValue = yield this.findGlobalConstantsHashAndValue(schema);
                    if (Object.keys(globalconstantsHashAndValue).length !== 0) {
                        // If there are global constants in the storage part of the contract code,
                        // they need to be locally expanded in order to encode the storage arguments
                        const p = new michelCodec.Parser({ expandGlobalConstant: globalconstantsHashAndValue });
                        const storageTypeNoGlobalConst = p.parseJSON(storageType.args[0]);
                        const schemaNoGlobalConst = new michelsonEncoder.Schema(storageTypeNoGlobalConst);
                        parsedParams.init = schemaNoGlobalConst.Encode(params.storage);
                    }
                    else {
                        parsedParams.init = schema.Encode(params.storage);
                    }
                    delete parsedParams.storage;
                }
                return parsedParams;
            });
        }
        formatCodeParam(code) {
            return __awaiter(this, void 0, void 0, function* () {
                let parsedCode;
                if (typeof code === 'string') {
                    const c = yield this.parseScript(code);
                    if (c === null) {
                        throw new InvalidCodeParameter('Invalid code parameter', code);
                    }
                    parsedCode = c;
                }
                else {
                    const c = yield this.parseJSON(code);
                    const order = ['parameter', 'storage', 'code'];
                    // Ensure correct ordering for RPC
                    parsedCode = c.sort((a, b) => order.indexOf(a.prim) - order.indexOf(b.prim));
                }
                return parsedCode;
            });
        }
        formatInitParam(init) {
            return __awaiter(this, void 0, void 0, function* () {
                let parsedInit;
                if (typeof init === 'string') {
                    const c = yield this.parseMichelineExpression(init);
                    if (c === null) {
                        throw new InvalidInitParameter('Invalid init parameter', init);
                    }
                    parsedInit = c;
                }
                else {
                    parsedInit = yield this.parseJSON(init);
                }
                return parsedInit;
            });
        }
        findGlobalConstantsHashAndValue(schema) {
            return __awaiter(this, void 0, void 0, function* () {
                const globalConstantTokens = schema.findToken('constant');
                const globalConstantsHashAndValue = {};
                if (globalConstantTokens.length !== 0) {
                    for (const token of globalConstantTokens) {
                        const tokenArgs = token.tokenVal.args;
                        if (tokenArgs) {
                            const expression = tokenArgs[0];
                            if (expression.string) {
                                const hash = expression.string;
                                const michelineValue = yield this.context.globalConstantsProvider.getGlobalConstantByHash(hash);
                                Object.assign(globalConstantsHashAndValue, {
                                    [hash]: michelineValue,
                                });
                            }
                        }
                    }
                }
                return globalConstantsHashAndValue;
            });
        }
    }

    class RpcPacker {
        constructor(context) {
            this.context = context;
        }
        packData(data) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.context.rpc.packData(data);
            });
        }
    }

    /**
     *  @category Error
     *  @description Error that indicates that a global constant does not exist
     */
    class GlobalConstantNotFound extends Error {
        constructor(hash) {
            super(`Please load the value associated with the constant ${hash} using the loadGlobalConstant method of the DefaultGlobalConstantsProvider.`);
            this.hash = hash;
            this.name = 'GlobalConstantNotFound';
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates the global constant provider not being configured under TezosToolkit
     */
    class UnconfiguredGlobalConstantsProviderError extends Error {
        constructor() {
            super('No global constants provider has been configured. Please configure one by calling setGlobalConstantsProvider({globalConstantsProvider}) on your TezosToolkit instance.');
            this.name = 'UnconfiguredGlobalConstantsProviderError';
        }
    }

    class NoopGlobalConstantsProvider {
        getGlobalConstantByHash(_hash) {
            return __awaiter(this, void 0, void 0, function* () {
                throw new UnconfiguredGlobalConstantsProviderError();
            });
        }
    }

    /**
     * @description Converts calls from TzReadProvider into calls to the wrapped RpcClient in a format it can understand.
     */
    class RpcReadAdapter {
        constructor(rpc) {
            this.rpc = rpc;
        }
        /**
         * @description Access the balance of a contract.
         * @param address address from which we want to retrieve the balance
         * @param block from which we want to retrieve the balance
         * @returns the balance in mutez
         */
        getBalance(address, block) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpc.getBalance(address, { block: String(block) });
            });
        }
        /**
         * @description Access the delegate of a contract, if any.
         * @param address contract address from which we want to retrieve the delegate (baker)
         * @param block from which we want to retrieve the delegate
         * @returns the public key hash of the delegate or null if no delegate
         */
        getDelegate(address, block) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpc.getDelegate(address, { block: String(block) });
            });
        }
        /**
         * @description Access the next protocol hash
         * @param block from which we want to retrieve the next protocol hash
         */
        getNextProtocol(block) {
            return __awaiter(this, void 0, void 0, function* () {
                const protocols = yield this.rpc.getProtocols({ block: String(block) });
                return protocols.next_protocol;
            });
        }
        /**
         * @description Access protocol constants used in Taquito
         * @param block from which we want to retrieve the constants
         */
        getProtocolConstants(block) {
            return __awaiter(this, void 0, void 0, function* () {
                const { time_between_blocks, minimal_block_delay, hard_gas_limit_per_operation, hard_gas_limit_per_block, hard_storage_limit_per_operation, cost_per_byte, tx_rollup_origination_size, } = yield this.rpc.getConstants({ block: String(block) });
                return {
                    time_between_blocks,
                    minimal_block_delay,
                    hard_gas_limit_per_operation,
                    hard_gas_limit_per_block,
                    hard_storage_limit_per_operation,
                    cost_per_byte,
                    tx_rollup_origination_size,
                };
            });
        }
        /**
         * @description Access the script (code and storage) of a smart contract
         * @param contract contract address from which we want to retrieve the script
         * @param block from which we want to retrieve the storage value
         * @returns Note: The code must be in the JSON format and not contain global constant
         */
        getScript(contract, block) {
            return __awaiter(this, void 0, void 0, function* () {
                const { script } = yield this.rpc.getContract(contract, { block: String(block) });
                return script;
            });
        }
        /**
         * @description Access the storage value of a contract
         * @param contract contract address from which we want to retrieve the storage
         * @param block from which we want to retrieve the storage value
         */
        getStorage(contract, block) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpc.getStorage(contract, { block: String(block) });
            });
        }
        /**
         * @description Access the block hash
         */
        getBlockHash(block) {
            return __awaiter(this, void 0, void 0, function* () {
                const { hash } = yield this.rpc.getBlockHeader({ block: String(block) });
                return hash;
            });
        }
        /**
         * @description Access the block level
         */
        getBlockLevel(block) {
            return __awaiter(this, void 0, void 0, function* () {
                const { level } = yield this.rpc.getBlockHeader({ block: String(block) });
                return level;
            });
        }
        /**
         * @description Access the counter of an address
         * @param pkh from which we want to retrieve the counter
         * @param block from which we want to retrieve the counter
         */
        getCounter(pkh, block) {
            return __awaiter(this, void 0, void 0, function* () {
                const { counter } = yield this.rpc.getContract(pkh, { block: String(block) });
                return counter || '0';
            });
        }
        /**
         * @description Access the timestamp of a block
         * @param block from which we want to retrieve the timestamp
         * @returns date ISO format zero UTC offset ("2022-01-19T22:37:07Z")
         */
        getBlockTimestamp(block) {
            return __awaiter(this, void 0, void 0, function* () {
                const { timestamp } = yield this.rpc.getBlockHeader({ block: String(block) });
                return timestamp;
            });
        }
        /**
         * @description Access the value associated with a key in a big map.
         * @param bigMapQuery Big Map ID and Expression hash to query (A b58check encoded Blake2b hash of the expression)
         * @param block from which we want to retrieve the big map value
         */
        getBigMapValue(bigMapQuery, block) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpc.getBigMapExpr(bigMapQuery.id, bigMapQuery.expr, {
                    block: String(block),
                });
            });
        }
        /**
         * @description Access the value associated with a sapling state ID.
         * @param id Sapling state ID
         * @param block from which we want to retrieve the sapling state
         */
        getSaplingDiffById(saplingStateQuery, block) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpc.getSaplingDiffById(saplingStateQuery.id, { block: String(block) });
            });
        }
        /**
         * @description Access the sapling state of a smart contract.
         * @param contractAddress The address of the smart contract
         * @param block The block you want to retrieve the sapling state from
         */
        getSaplingDiffByContract(contractAddress, block) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpc.getSaplingDiffByContract(contractAddress, { block: String(block) });
            });
        }
        /**
         * @description Return the list of entrypoints of the contract
         * @param contract address of the contract we want to get the entrypoints of
         */
        getEntrypoints(contract) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpc.getEntrypoints(contract);
            });
        }
        /**
         * @description Access the chain id
         */
        getChainId() {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpc.getChainId();
            });
        }
        /**
         * @description Indicate if an account is revealed
         * @param publicKeyHash of the account
         * @param block from which we want to know if the account is revealed
         */
        isAccountRevealed(publicKeyHash, block) {
            return __awaiter(this, void 0, void 0, function* () {
                const manager = yield this.rpc.getManagerKey(publicKeyHash, { block: String(block) });
                const haveManager = manager && typeof manager === 'object' ? !!manager.key : !!manager;
                return haveManager;
            });
        }
        /**
         * @description Return all the information about a block
         * @param block from which we want to retrieve the information
         */
        getBlock(block) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.rpc.getBlock({ block: String(block) });
            });
        }
        /**
         * @description Return a list of the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.
         * @param block from which we want to retrieve the information
         */
        getLiveBlocks(block) {
            return this.rpc.getLiveBlocks({ block: String(block) });
        }
    }

    const opHashFilter = (op, filter) => op.hash === filter.opHash;
    const sourceFilter = (x, filter) => {
        switch (x.kind) {
            case 'endorsement':
                return 'metadata' in x && x.metadata.delegate === filter.source;
            case 'activate_account':
                return 'metadata' in x && x.pkh === filter.source;
            default:
                return 'source' in x && x.source === filter.source;
        }
    };
    const kindFilter = (x, filter) => 'kind' in x && x.kind === filter.kind;
    const destinationFilter = (x, filter) => {
        switch (x.kind) {
            case 'delegation':
                return x.delegate === filter.destination;
            case 'origination':
                if ('metadata' in x &&
                    'operation_result' in x.metadata &&
                    'originated_contracts' in x.metadata.operation_result &&
                    Array.isArray(x.metadata.operation_result.originated_contracts)) {
                    return x.metadata.operation_result.originated_contracts.some((contract) => contract === filter.destination);
                }
                break;
            case 'transaction':
                return x.destination === filter.destination;
            default:
                return false;
        }
    };
    const eventFilter = (result, address, tag) => {
        if (result.kind === 'event') {
            if (address && tag) {
                return result.source === address && result.tag === tag;
            }
            else if (address && !tag) {
                return result.source === address;
            }
            else if (tag) {
                return result.tag === tag;
            }
            else {
                return true;
            }
        }
        else {
            return false;
        }
    };
    const evaluateOpFilter = (op, filter) => {
        if ('opHash' in filter) {
            return opHashFilter(op, filter);
        }
        else if ('source' in filter) {
            return sourceFilter(op, filter);
        }
        else if ('kind' in filter) {
            return kindFilter(op, filter);
        }
        else if ('destination' in filter) {
            return destinationFilter(op, filter);
        }
        return false;
    };
    const evaluateExpression = (op, exp) => {
        if (Array.isArray(exp.and)) {
            return exp.and.every((x) => evaluateFilter(op, x));
        }
        else if (Array.isArray(exp.or)) {
            return exp.or.some((x) => evaluateFilter(op, x));
        }
        else {
            throw new InvalidFilterExpressionError('Filter expression must contain either and/or property');
        }
    };
    const evaluateFilter = (op, filter) => {
        const filters = [];
        if (!Array.isArray(filter)) {
            filters.push(filter);
        }
        else {
            filters.push(...filter);
        }
        return filters.every((filterOrExp) => {
            if ('and' in filterOrExp || 'or' in filterOrExp) {
                return evaluateExpression(op, filterOrExp);
            }
            else {
                return evaluateOpFilter(op, filterOrExp);
            }
        });
    };

    /* eslint-disable no-dupe-class-members */
    /**
     *  @category Error
     *  @description Error that indicates an unsupported event being passed or used
     */
    class UnsupportedEventError extends Error {
        constructor(message) {
            super(message);
            this.message = message;
            this.name = 'UnsupportedEventError';
        }
    }
    class ObservableSubscription {
        constructor(obs, shouldRetry = false, operatorFunction = operators.retry()) {
            this.shouldRetry = shouldRetry;
            this.operatorFunction = operatorFunction;
            this.errorListeners = [];
            this.messageListeners = [];
            this.closeListeners = [];
            this.completed$ = new rxjs.Subject();
            obs
                .pipe(operators.takeUntil(this.completed$), operators.tap((data) => {
                this.call(this.messageListeners, data);
            }, (error) => {
                this.call(this.errorListeners, error);
            }, () => {
                this.call(this.closeListeners);
            }), this.shouldRetry ? operatorFunction : operators.tap(), operators.catchError(() => rxjs.NEVER))
                .subscribe();
        }
        call(listeners, value) {
            for (const l of listeners) {
                try {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    l(value);
                }
                catch (ex) {
                    console.error(ex);
                }
            }
        }
        remove(listeners, value) {
            const idx = listeners.indexOf(value);
            if (idx !== -1) {
                listeners.splice(idx, 1);
            }
        }
        on(type, cb) {
            switch (type) {
                case 'data':
                    this.messageListeners.push(cb);
                    break;
                case 'error':
                    this.errorListeners.push(cb);
                    break;
                case 'close':
                    this.closeListeners.push(cb);
                    break;
                default:
                    throw new UnsupportedEventError(`Trying to register on an unsupported event: ${type}`);
            }
        }
        off(type, cb) {
            switch (type) {
                case 'data':
                    this.remove(this.messageListeners, cb);
                    break;
                case 'error':
                    this.remove(this.errorListeners, cb);
                    break;
                case 'close':
                    this.remove(this.closeListeners, cb);
                    break;
                default:
                    throw new UnsupportedEventError(`Trying to unregister on an unsupported event: ${type}`);
            }
        }
        close() {
            this.completed$.next();
        }
    }

    const defaultConfigStreamer = {
        shouldObservableSubscriptionRetry: false,
        observableSubscriptionRetryFunction: operators.retry(),
    };
    const getLastBlock = (context) => {
        return rxjs.from(context.rpc.getBlock()).pipe(operators.first());
    };
    const applyFilter = (filter) => operators.concatMap((block) => {
        return new rxjs.Observable((sub) => {
            for (const ops of block.operations) {
                for (const op of ops) {
                    for (const content of op.contents) {
                        if (evaluateFilter(Object.assign({ hash: op.hash }, content), filter)) {
                            sub.next(Object.assign({ hash: op.hash }, content));
                        }
                    }
                }
            }
            sub.complete();
        });
    });
    const applyEventFilter = (filter) => operators.concatMap((block) => {
        return new rxjs.Observable((sub) => {
            for (const ops of block.operations) {
                for (const op of ops) {
                    for (const content of op.contents) {
                        const tx = content;
                        const internalOpResults = tx.metadata.internal_operation_results;
                        if (internalOpResults) {
                            for (const event of internalOpResults) {
                                if (eventFilter(event, filter === null || filter === void 0 ? void 0 : filter.address, filter === null || filter === void 0 ? void 0 : filter.tag)) {
                                    sub.next(Object.assign({ opHash: op.hash, blockHash: block.hash, level: block.header.level }, event));
                                }
                            }
                        }
                    }
                }
            }
            sub.complete();
        });
    });
    class PollingSubscribeProvider {
        constructor(context, config = {}) {
            this.context = context;
            this._config$ = new rxjs.BehaviorSubject(Object.assign(Object.assign({}, defaultConfigStreamer), config));
            this.timer$ = this._config$.pipe(operators.pluck('pollingIntervalMilliseconds'), operators.switchMap((pollingIntervalMilliseconds) => {
                if (!pollingIntervalMilliseconds) {
                    return rxjs.from(this.getConfirmationPollingInterval()).pipe(operators.switchMap((interval) => {
                        return rxjs.timer(0, interval);
                    }));
                }
                else {
                    return rxjs.timer(0, pollingIntervalMilliseconds);
                }
            }));
            this.newBlock$ = this.timer$.pipe(operators.switchMap(() => getLastBlock(this.context)), operators.distinctUntilKeyChanged('hash'), operators.publish(), operators.refCount());
        }
        get config() {
            return this._config$.getValue();
        }
        getConfirmationPollingInterval() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.config.pollingIntervalMilliseconds) {
                    const defaultIntervalTestnetsMainnet = 5000;
                    const defaultIntervalSandbox = 1000;
                    try {
                        const constants = yield this.context.readProvider.getProtocolConstants('head');
                        const blockTime = constants.minimal_block_delay
                            ? constants.minimal_block_delay.multipliedBy(1000)
                            : constants.time_between_blocks
                                ? constants.time_between_blocks[0].multipliedBy(1000)
                                : new BigNumber__default["default"](defaultIntervalTestnetsMainnet);
                        const confirmationPollingInterval = blockTime.dividedBy(3);
                        this.config.pollingIntervalMilliseconds =
                            confirmationPollingInterval.toNumber() === 0
                                ? defaultIntervalSandbox
                                : confirmationPollingInterval.toNumber();
                    }
                    catch (exception) {
                        return defaultIntervalTestnetsMainnet;
                    }
                }
                return this.config.pollingIntervalMilliseconds;
            });
        }
        subscribeBlock(_filter) {
            return new ObservableSubscription(this.newBlock$, this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);
        }
        subscribe(_filter) {
            return new ObservableSubscription(this.newBlock$.pipe(operators.pluck('hash')), this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);
        }
        subscribeOperation(filter) {
            return new ObservableSubscription(this.newBlock$.pipe(applyFilter(filter)), this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);
        }
        subscribeEvent(eventFilter) {
            return new ObservableSubscription(this.newBlock$.pipe(applyEventFilter(eventFilter)), this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);
        }
    }

    class TaquitoLocalForger {
        constructor(context) {
            this.context = context;
        }
        getNextProto() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.context.proto) {
                    const nextProto = yield this.context.readProvider.getNextProtocol('head');
                    this.context.proto = nextProto;
                }
                return this.context.proto;
            });
        }
        forge({ branch, contents }) {
            return __awaiter(this, void 0, void 0, function* () {
                const forger = new localForging.LocalForger(yield this.getNextProto());
                return forger.forge({ branch, contents });
            });
        }
    }

    var _counters;
    /**
     * @description PrepareProvider is a utility class to output the prepared format of an operation
     */
    class PrepareProvider {
        constructor(context) {
            this.context = context;
            _counters.set(this, void 0);
            __classPrivateFieldSet(this, _counters, {});
        }
        get rpc() {
            return this.context.rpc;
        }
        get signer() {
            return this.context.signer;
        }
        get estimate() {
            return this.context.estimate;
        }
        get parser() {
            return this.context.parser;
        }
        getPkh() {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.context.signer.publicKeyHash();
            });
        }
        getBlockHash() {
            return __awaiter(this, void 0, void 0, function* () {
                return this.context.readProvider.getBlockHash('head~2');
            });
        }
        getProtocolHash() {
            return __awaiter(this, void 0, void 0, function* () {
                return this.context.readProvider.getNextProtocol('head');
            });
        }
        getHeadCounter(pkh) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                return (_a = this.context.readProvider.getCounter(pkh, 'head')) !== null && _a !== void 0 ? _a : '0';
            });
        }
        getFee(op, pkh, headCounter) {
            if (!__classPrivateFieldGet(this, _counters)[pkh] || __classPrivateFieldGet(this, _counters)[pkh] < headCounter) {
                __classPrivateFieldGet(this, _counters)[pkh] = headCounter;
            }
            const opCounter = ++__classPrivateFieldGet(this, _counters)[pkh];
            return {
                counter: `${opCounter}`,
                fee: typeof op.fee === 'undefined' ? '0' : `${op.fee}`,
                gas_limit: typeof op.gas_limit === 'undefined' ? '0' : `${op.gas_limit}`,
                storage_limit: typeof op.storage_limit === 'undefined' ? '0' : `${op.storage_limit}`,
            };
        }
        getSource(op, pkh, source) {
            return { source: typeof op.source === 'undefined' ? source || pkh : op.source };
        }
        buildEstimates(estimate) {
            return {
                fee: estimate.suggestedFeeMutez,
                gasLimit: estimate.gasLimit,
                storageLimit: estimate.storageLimit,
            };
        }
        addRevealOperationIfNeeded(operation, publicKeyHash) {
            return __awaiter(this, void 0, void 0, function* () {
                if (isOpRequireReveal(operation)) {
                    const ops = [operation];
                    const publicKey = yield this.signer.publicKey();
                    const estimateReveal = yield this.estimate.reveal();
                    if (estimateReveal) {
                        const estimatedReveal = this.buildEstimates(estimateReveal);
                        ops.unshift(yield createRevealOperation(Object.assign({}, estimatedReveal), publicKeyHash, publicKey));
                        return ops;
                    }
                }
                return operation;
            });
        }
        convertIntoArray(op) {
            if (Array.isArray(op)) {
                return [...op];
            }
            else {
                return [op];
            }
        }
        constructOpContents(ops, headCounter, pkh, source, currentVotingPeriod) {
            return ops.map((op) => {
                switch (op.kind) {
                    case rpc.OpKind.ACTIVATION:
                    case rpc.OpKind.DRAIN_DELEGATE:
                        return Object.assign({}, op);
                    case rpc.OpKind.ORIGINATION:
                        return Object.assign(Object.assign(Object.assign(Object.assign({}, op), { balance: typeof op.balance !== 'undefined' ? `${op.balance}` : '0' }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
                    case rpc.OpKind.TRANSACTION: {
                        const cops = Object.assign(Object.assign(Object.assign(Object.assign({}, op), { amount: typeof op.amount !== 'undefined' ? `${op.amount}` : '0' }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
                        if (cops.source.toLowerCase().startsWith('kt1')) {
                            throw new utils.DeprecationError(`KT1 addresses are not supported as source since ${exports.Protocols.PsBabyM1}`);
                        }
                        return cops;
                    }
                    case rpc.OpKind.REVEAL:
                    case rpc.OpKind.DELEGATION:
                    case rpc.OpKind.REGISTER_GLOBAL_CONSTANT:
                    case rpc.OpKind.TX_ROLLUP_ORIGINATION:
                    case rpc.OpKind.TX_ROLLUP_SUBMIT_BATCH:
                    case rpc.OpKind.UPDATE_CONSENSUS_KEY:
                        return Object.assign(Object.assign(Object.assign({}, op), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
                    case rpc.OpKind.TRANSFER_TICKET:
                        return Object.assign(Object.assign(Object.assign(Object.assign({}, op), { ticket_amount: `${op.ticket_amount}` }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
                    case rpc.OpKind.INCREASE_PAID_STORAGE:
                        return Object.assign(Object.assign(Object.assign(Object.assign({}, op), { amount: `${op.amount}` }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
                    case rpc.OpKind.BALLOT:
                        if (currentVotingPeriod === undefined) {
                            throw new RPCResponseError(`Failed to get the current voting period index`);
                        }
                        return Object.assign(Object.assign({}, op), { period: currentVotingPeriod === null || currentVotingPeriod === void 0 ? void 0 : currentVotingPeriod.voting_period.index });
                    case rpc.OpKind.PROPOSALS:
                        if (currentVotingPeriod === undefined) {
                            throw new RPCResponseError(`Failed to get the current voting period index`);
                        }
                        return Object.assign(Object.assign({}, op), { period: currentVotingPeriod === null || currentVotingPeriod === void 0 ? void 0 : currentVotingPeriod.voting_period.index });
                    default:
                        throw new utils.InvalidOperationKindError(op.kind);
                }
            });
        }
        /**
         *
         * @description Method to prepare a reveal operation
         * @param operation RPCOperation object or RPCOperation array
         * @param source string or undefined source pkh
         * @returns a PreparedOperation object
         */
        reveal(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const pkh = yield this.signer.publicKeyHash();
                const estimate = yield this.estimate.reveal(params);
                if (estimate) {
                    const estimates = this.buildEstimates(estimate);
                    const op = yield createRevealOperation(Object.assign({}, estimates), pkh, yield this.signer.publicKey());
                    const ops = this.convertIntoArray(op);
                    const hash = yield this.getBlockHash();
                    const protocol = yield this.getProtocolHash();
                    const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
                    const contents = this.constructOpContents(ops, headCounter, pkh);
                    return {
                        opOb: {
                            branch: hash,
                            contents,
                            protocol,
                        },
                        counter: headCounter,
                    };
                }
                else {
                    throw new RevealOperationError(`The publicKeyHash '${pkh}' has already been revealed.`);
                }
            });
        }
        /**
         *
         * @description Method to prepare an origination operation
         * @param operation RPCOperation object or RPCOperation array
         * @param source string or undefined source pkh
         * @returns a PreparedOperation object
         */
        originate(params, source) {
            return __awaiter(this, void 0, void 0, function* () {
                const pkh = yield this.signer.publicKeyHash();
                const estimate = yield this.estimate.originate(params);
                const estimates = this.buildEstimates(estimate);
                const op = yield createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign(Object.assign({}, params), estimates)));
                const operation = yield this.addRevealOperationIfNeeded(op, pkh);
                const ops = this.convertIntoArray(operation);
                const hash = yield this.getBlockHash();
                const protocol = yield this.getProtocolHash();
                const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
                const contents = this.constructOpContents(ops, headCounter, pkh, source);
                return {
                    opOb: {
                        branch: hash,
                        contents,
                        protocol,
                    },
                    counter: headCounter,
                };
            });
        }
        /**
         *
         * @description Method to prepare a transaction operation
         * @param operation RPCOperation object or RPCOperation array
         * @param source string or undefined source pkh
         * @returns a PreparedOperation object
         */
        transaction(params, source) {
            return __awaiter(this, void 0, void 0, function* () {
                const pkh = yield this.signer.publicKeyHash();
                const estimate = yield this.estimate.transfer(params);
                const estimates = this.buildEstimates(estimate);
                const op = yield createTransferOperation(Object.assign(Object.assign({}, params), estimates));
                const operation = yield this.addRevealOperationIfNeeded(op, pkh);
                const ops = this.convertIntoArray(operation);
                const hash = yield this.getBlockHash();
                const protocol = yield this.getProtocolHash();
                const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
                const contents = this.constructOpContents(ops, headCounter, pkh, source);
                return {
                    opOb: {
                        branch: hash,
                        contents,
                        protocol,
                    },
                    counter: headCounter,
                };
            });
        }
        /**
         *
         * @description Method to prepare a delegation operation
         * @param operation RPCOperation object or RPCOperation array
         * @param source string or undefined source pkh
         * @returns a PreparedOperation object
         */
        delegation(params, source) {
            return __awaiter(this, void 0, void 0, function* () {
                const pkh = yield this.signer.publicKeyHash();
                const estimate = yield this.estimate.setDelegate(params);
                const estimates = this.buildEstimates(estimate);
                const op = yield createSetDelegateOperation(Object.assign(Object.assign({}, params), estimates));
                const operation = yield this.addRevealOperationIfNeeded(op, pkh);
                const ops = this.convertIntoArray(operation);
                const hash = yield this.getBlockHash();
                const protocol = yield this.getProtocolHash();
                const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
                const contents = this.constructOpContents(ops, headCounter, pkh, source);
                return {
                    opOb: {
                        branch: hash,
                        contents,
                        protocol,
                    },
                    counter: headCounter,
                };
            });
        }
        /**
         *
         * @description Method to prepare a register_global_constant operation
         * @param operation RPCOperation object or RPCOperation array
         * @param source string or undefined source pkh
         * @returns a PreparedOperation object
         */
        registerGlobalConstant(params, source) {
            return __awaiter(this, void 0, void 0, function* () {
                const pkh = yield this.signer.publicKeyHash();
                const estimate = yield this.estimate.registerGlobalConstant(params);
                const estimates = this.buildEstimates(estimate);
                const op = yield createRegisterGlobalConstantOperation(Object.assign(Object.assign({}, params), estimates));
                const operation = yield this.addRevealOperationIfNeeded(op, pkh);
                const ops = this.convertIntoArray(operation);
                const hash = yield this.getBlockHash();
                const protocol = yield this.getProtocolHash();
                const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
                const contents = this.constructOpContents(ops, headCounter, pkh, source);
                return {
                    opOb: {
                        branch: hash,
                        contents,
                        protocol,
                    },
                    counter: headCounter,
                };
            });
        }
        /**
         *
         * @description Method to prepare a tx_rollup_origination operation
         * @param operation RPCOperation object or RPCOperation array
         * @param source string or undefined source pkh
         * @returns a PreparedOperation object
         */
        txRollupOrigination(params, source) {
            return __awaiter(this, void 0, void 0, function* () {
                const pkh = yield this.signer.publicKeyHash();
                const estimate = yield this.estimate.txRollupOriginate(params);
                const estimates = this.buildEstimates(estimate);
                const op = yield createTxRollupOriginationOperation(Object.assign(Object.assign({}, params), estimates));
                const operation = yield this.addRevealOperationIfNeeded(op, pkh);
                const ops = this.convertIntoArray(operation);
                const hash = yield this.getBlockHash();
                const protocol = yield this.getProtocolHash();
                const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
                const contents = this.constructOpContents(ops, headCounter, pkh, source);
                return {
                    opOb: {
                        branch: hash,
                        contents,
                        protocol,
                    },
                    counter: headCounter,
                };
            });
        }
        /**
         *
         * @description Method to prepare a tx_rollup_submit_batch operation
         * @param operation RPCOperation object or RPCOperation array
         * @param source string or undefined source pkh
         * @returns a PreparedOperation object
         */
        txRollupSubmitBatch(params, source) {
            return __awaiter(this, void 0, void 0, function* () {
                const pkh = yield this.signer.publicKeyHash();
                const estimate = yield this.estimate.txRollupSubmitBatch(params);
                const estimates = this.buildEstimates(estimate);
                const op = yield createTxRollupBatchOperation(Object.assign(Object.assign({}, params), estimates));
                const operation = yield this.addRevealOperationIfNeeded(op, pkh);
                const ops = this.convertIntoArray(operation);
                const hash = yield this.getBlockHash();
                const protocol = yield this.getProtocolHash();
                const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
                const contents = this.constructOpContents(ops, headCounter, pkh, source);
                return {
                    opOb: {
                        branch: hash,
                        contents,
                        protocol,
                    },
                    counter: headCounter,
                };
            });
        }
        /**
         *
         * @description Method to prepare an update_consensus_key operation
         * @param operation RPCOperation object or RPCOperation array
         * @param source string or undefined source pkh
         * @returns a PreparedOperation object
         */
        updateConsensusKey(params, source) {
            return __awaiter(this, void 0, void 0, function* () {
                const pkh = yield this.signer.publicKeyHash();
                const estimate = yield this.estimate.updateConsensusKey(params);
                const estimates = this.buildEstimates(estimate);
                const op = yield createUpdateConsensusKeyOperation(Object.assign(Object.assign({}, params), estimates));
                const operation = yield this.addRevealOperationIfNeeded(op, pkh);
                const ops = this.convertIntoArray(operation);
                const hash = yield this.getBlockHash();
                const protocol = yield this.getProtocolHash();
                const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
                const contents = this.constructOpContents(ops, headCounter, pkh, source);
                return {
                    opOb: {
                        branch: hash,
                        contents,
                        protocol,
                    },
                    counter: headCounter,
                };
            });
        }
        /**
         *
         * @description Method to prepare an increase_paid_storage operation
         * @param operation RPCOperation object or RPCOperation array
         * @param source string or undefined source pkh
         * @returns a PreparedOperation object
         */
        increasePaidStorage(params, source) {
            return __awaiter(this, void 0, void 0, function* () {
                const pkh = yield this.signer.publicKeyHash();
                const estimate = yield this.estimate.increasePaidStorage(params);
                const estimates = this.buildEstimates(estimate);
                const op = yield createIncreasePaidStorageOperation(Object.assign(Object.assign({}, params), estimates));
                const operation = yield this.addRevealOperationIfNeeded(op, pkh);
                const ops = this.convertIntoArray(operation);
                const hash = yield this.getBlockHash();
                const protocol = yield this.getProtocolHash();
                const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
                const contents = this.constructOpContents(ops, headCounter, pkh, source);
                return {
                    opOb: {
                        branch: hash,
                        contents,
                        protocol,
                    },
                    counter: headCounter,
                };
            });
        }
        /**
         *
         * @description Method to prepare a ballot operation
         * @param operation RPCOperation object or RPCOperation array
         * @returns a PreparedOperation object
         */
        ballot(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const pkh = yield this.signer.publicKeyHash();
                const op = yield createBallotOperation(Object.assign({}, params));
                const ops = this.convertIntoArray(op);
                const hash = yield this.getBlockHash();
                const protocol = yield this.getProtocolHash();
                const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
                let currentVotingPeriod;
                try {
                    currentVotingPeriod = yield this.rpc.getCurrentPeriod();
                }
                catch (e) {
                    throw new RPCResponseError('Failed to get the current voting period index');
                }
                const contents = this.constructOpContents(ops, headCounter, pkh, undefined, currentVotingPeriod);
                return {
                    opOb: {
                        branch: hash,
                        contents,
                        protocol,
                    },
                    counter: headCounter,
                };
            });
        }
        /**
         *
         * @description Method to prepare a proposals operation
         * @param operation RPCOperation object or RPCOperation array
         * @returns a PreparedOperation object
         */
        proposals(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const pkh = yield this.signer.publicKeyHash();
                const op = yield createProposalsOperation(Object.assign({}, params));
                const ops = this.convertIntoArray(op);
                const hash = yield this.getBlockHash();
                const protocol = yield this.getProtocolHash();
                const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
                let currentVotingPeriod;
                try {
                    currentVotingPeriod = yield this.rpc.getCurrentPeriod();
                }
                catch (e) {
                    throw new RPCResponseError('Failed to get the current voting period index');
                }
                const contents = this.constructOpContents(ops, headCounter, pkh, undefined, currentVotingPeriod);
                return {
                    opOb: {
                        branch: hash,
                        contents,
                        protocol,
                    },
                    counter: headCounter,
                };
            });
        }
        /**
         *
         * @description Method to prepare a drain_delegate operation
         * @param operation RPCOperation object or RPCOperation array
         * @returns a PreparedOperation object
         */
        drainDelegate(params, source) {
            return __awaiter(this, void 0, void 0, function* () {
                const pkh = yield this.signer.publicKeyHash();
                const op = yield createDrainDelegateOperation(Object.assign({}, params));
                const ops = this.convertIntoArray(op);
                const hash = yield this.getBlockHash();
                const protocol = yield this.getProtocolHash();
                const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
                const contents = this.constructOpContents(ops, headCounter, pkh, source);
                return {
                    opOb: {
                        branch: hash,
                        contents,
                        protocol,
                    },
                    counter: headCounter,
                };
            });
        }
        /**
         *
         * @description Method to prepare a transfer_ticket operation
         * @param operation RPCOperation object or RPCOperation array
         * @param source string or undefined source pkh
         * @returns a PreparedOperation object
         */
        transferTicket(params, source) {
            return __awaiter(this, void 0, void 0, function* () {
                const pkh = yield this.signer.publicKeyHash();
                const estimate = yield this.estimate.transferTicket(params);
                const estimates = this.buildEstimates(estimate);
                const op = yield createTransferTicketOperation(Object.assign(Object.assign({}, params), estimates));
                const operation = yield this.addRevealOperationIfNeeded(op, pkh);
                const ops = this.convertIntoArray(operation);
                const hash = yield this.getBlockHash();
                const protocol = yield this.getProtocolHash();
                const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
                const contents = this.constructOpContents(ops, headCounter, pkh, source);
                return {
                    opOb: {
                        branch: hash,
                        contents,
                        protocol,
                    },
                    counter: headCounter,
                };
            });
        }
        /**
         *
         * @description Method to prepare a batch operation
         * @param operation RPCOperation object or RPCOperation array
         * @returns a PreparedOperation object
         */
        batch(batchParams) {
            return __awaiter(this, void 0, void 0, function* () {
                // const ops = this.convertIntoArray(operation);
                const pkh = yield this.signer.publicKeyHash();
                const batch = new OperationBatch(this.context, this.estimate);
                if (Array.isArray(batchParams)) {
                    batch.with(batchParams);
                }
                const ops = yield batch.toPrepare();
                const hash = yield this.getBlockHash();
                const protocol = yield this.getProtocolHash();
                const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
                const contents = this.constructOpContents(ops, headCounter, pkh);
                return {
                    opOb: {
                        branch: hash,
                        contents,
                        protocol,
                    },
                    counter: headCounter,
                };
            });
        }
        /**
         *
         * @description Method to prepare a batch operation
         * @param operation RPCOperation object or RPCOperation array
         * @returns a PreparedOperation object
         */
        contractCall(contractMethod) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const hash = yield this.getBlockHash();
                const protocol = yield this.getProtocolHash();
                const pkh = yield this.signer.publicKeyHash();
                const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
                const params = contractMethod.toTransferParams();
                const estimate = yield this.estimate.transfer(params);
                const ops = [
                    {
                        kind: rpc.OpKind.TRANSACTION,
                        fee: (_a = params.fee) !== null && _a !== void 0 ? _a : estimate.suggestedFeeMutez,
                        gas_limit: (_b = params.gasLimit) !== null && _b !== void 0 ? _b : estimate.gasLimit,
                        storage_limit: (_c = params.storageLimit) !== null && _c !== void 0 ? _c : estimate.storageLimit,
                        amount: String(params.amount),
                        destination: params.to,
                    },
                ];
                const contents = this.constructOpContents(ops, headCounter, pkh);
                return {
                    opOb: {
                        branch: hash,
                        contents,
                        protocol,
                    },
                    counter: headCounter,
                };
            });
        }
    }
    _counters = new WeakMap();

    const defaultConfigConfirmation = {
        defaultConfirmationCount: 1,
        confirmationPollingTimeoutSecond: 180,
    };
    /**
     * @description Encapsulate common service used throughout different part of the library
     */
    class Context {
        constructor(_rpc, _signer = new NoopSigner(), _proto, _config = new rxjs.BehaviorSubject(Object.assign({}, defaultConfigConfirmation)), forger, injector, packer, wallet, parser, globalConstantsProvider, readProvider, stream) {
            this._rpc = _rpc;
            this._signer = _signer;
            this._proto = _proto;
            this._config = _config;
            this.providerDecorator = [];
            this.tz = new RpcTzProvider(this);
            this.estimate = new RPCEstimateProvider(this);
            this.contract = new RpcContractProvider(this, this.estimate);
            this.prepare = new PrepareProvider(this);
            this.batch = new RPCBatchProvider(this, this.estimate);
            this.wallet = new Wallet(this);
            /**
             * @description Applies the decorators on a cloned instance of the context and returned this cloned instance.
             * The decorators are functions that inject logic into the context.
             * They are provided by the extensions set on the TezosToolkit by calling the registerProviderDecorator method.
             */
            this.withExtensions = () => {
                let clonedContext = this.clone();
                this.providerDecorator.forEach((decorator) => {
                    clonedContext = decorator(clonedContext);
                });
                return clonedContext;
            };
            if (typeof this._rpc === 'string') {
                this._rpcClient = new rpc.RpcClient(this._rpc);
            }
            else {
                this._rpcClient = this._rpc;
            }
            this._forger = forger ? forger : new TaquitoLocalForger(this);
            this._injector = injector ? injector : new RpcInjector(this);
            this.operationFactory = new OperationFactory(this);
            this._walletProvider = wallet ? wallet : new LegacyWalletProvider(this);
            this._parser = parser ? parser : new MichelCodecParser(this);
            this._packer = packer ? packer : new RpcPacker(this);
            this._globalConstantsProvider = globalConstantsProvider
                ? globalConstantsProvider
                : new NoopGlobalConstantsProvider();
            this._readProvider = readProvider ? readProvider : new RpcReadAdapter(this._rpcClient);
            this._stream = stream ? stream : new PollingSubscribeProvider(this);
        }
        get config() {
            return this._config.getValue();
        }
        set config(value) {
            this._config.next(Object.assign({}, value));
        }
        setPartialConfig(value) {
            this._config.next(Object.assign(Object.assign({}, this._config.getValue()), value));
        }
        get rpc() {
            return this._rpcClient;
        }
        set rpc(value) {
            this._rpcClient = value;
        }
        get injector() {
            return this._injector;
        }
        set injector(value) {
            this._injector = value;
        }
        get forger() {
            return this._forger;
        }
        set forger(value) {
            this._forger = value;
        }
        get signer() {
            return this._signer;
        }
        set signer(value) {
            this._signer = value;
        }
        get walletProvider() {
            return this._walletProvider;
        }
        set walletProvider(value) {
            this._walletProvider = value;
        }
        set proto(value) {
            this._proto = value;
        }
        get proto() {
            return this._proto;
        }
        get parser() {
            return this._parser;
        }
        set parser(value) {
            this._parser = value;
        }
        get packer() {
            return this._packer;
        }
        set packer(value) {
            this._packer = value;
        }
        get globalConstantsProvider() {
            return this._globalConstantsProvider;
        }
        set globalConstantsProvider(value) {
            this._globalConstantsProvider = value;
        }
        get readProvider() {
            return this._readProvider;
        }
        set readProvider(value) {
            this._readProvider = value;
        }
        get stream() {
            return this._stream;
        }
        set stream(value) {
            this._stream = value;
        }
        isAnyProtocolActive(protocol = []) {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._proto) {
                    return protocol.includes(this._proto);
                }
                else {
                    const next_protocol = yield this.readProvider.getNextProtocol('head');
                    return protocol.includes(next_protocol);
                }
            });
        }
        isAnySignerConfigured() {
            return !(this.signer instanceof NoopSigner);
        }
        /**
         * @description Create a copy of the current context. Useful when you have long running operation and you do not want a context change to affect the operation
         */
        clone() {
            return new Context(this.rpc, this.signer, this.proto, this._config, this.forger, this._injector, this.packer, this._walletProvider, this._parser, this._globalConstantsProvider, this._readProvider, this._stream);
        }
        /**
         * @description Allows extensions set on the TezosToolkit to inject logic into the context
         */
        registerProviderDecorator(fx) {
            this.providerDecorator.push(fx);
        }
    }

    // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
    const VERSION = {
        "commitHash": "178bea7c6a3b3c58f23163fcc72e28aa5f08702a",
        "version": "15.1.0"
    };

    /**
     *  @category Error
     *  @description Error that indicates a value mismatch when forging
     */
    class ForgingMismatchError extends Error {
        constructor(results) {
            super('Forging mismatch error');
            this.results = results;
            this.name = 'ForgingMismatchError';
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates a forger not being specified in TezosToolkit
     */
    class UnspecifiedForgerError extends Error {
        constructor() {
            super('At least one forger must be specified');
            this.name = 'UnspecifiedForgerError';
        }
    }
    class CompositeForger {
        constructor(forgers) {
            this.forgers = forgers;
            if (forgers.length === 0) {
                throw new UnspecifiedForgerError();
            }
        }
        forge({ branch, contents }) {
            return __awaiter(this, void 0, void 0, function* () {
                const results = yield Promise.all(this.forgers.map((forger) => {
                    return forger.forge({ branch, contents });
                }));
                if (results.length === 0) {
                    throw new UnspecifiedForgerError();
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                let lastResult = results.pop(); // Assumed to be more than one since we
                while (results.length) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const currentResult = results.pop();
                    if (currentResult !== lastResult) {
                        throw new ForgingMismatchError([lastResult, currentResult]);
                    }
                    lastResult = currentResult;
                }
                return lastResult;
            });
        }
    }

    class RpcForger {
        constructor(context) {
            this.context = context;
        }
        forge({ branch, contents }) {
            return this.context.rpc.forgeOperations({ branch, contents });
        }
    }

    class NoopParser {
        prepareCodeOrigination(params) {
            return __awaiter(this, void 0, void 0, function* () {
                return params;
            });
        }
    }

    class MichelCodecPacker {
        packData(data) {
            return __awaiter(this, void 0, void 0, function* () {
                const { bytes } = michelCodec.packDataBytes(data.data, data.type);
                return { packed: bytes };
            });
        }
    }

    class DefaultGlobalConstantsProvider {
        constructor() {
            this._globalConstantsLibrary = {};
        }
        /**
         *
         * @description Allows to load global constant hashes and their corresponding Michelson JSON values
         */
        loadGlobalConstant(globalConstant) {
            for (const hash in globalConstant) {
                Object.assign(this._globalConstantsLibrary, {
                    [hash]: globalConstant[hash],
                });
            }
        }
        /**
         *
         * @description Retrieve the Michelson value of a global constant based on its hash
         *
         * @param hash a string representing the global constant hash
         * @returns Expr, the JSON Michelson value
         */
        getGlobalConstantByHash(hash) {
            return __awaiter(this, void 0, void 0, function* () {
                const value = this._globalConstantsLibrary[hash];
                if (!value) {
                    throw new GlobalConstantNotFound(hash);
                }
                return value;
            });
        }
    }

    /**
     * @packageDocumentation
     * @module @taquito/taquito
     */
    /**
     * @description Facade class that surfaces all of the libraries capability and allow it's configuration
     *
     * @param _rpc The RPC server to use
     */
    class TezosToolkit {
        constructor(_rpc) {
            this._rpc = _rpc;
            this._options = {};
            this.format = utils.format;
            if (typeof this._rpc === 'string') {
                this._rpcClient = new rpc.RpcClient(this._rpc);
            }
            else {
                this._rpcClient = this._rpc;
            }
            this._context = new Context(_rpc);
            this._wallet = new Wallet(this._context);
            this.setProvider({ rpc: this._rpcClient });
            this.batch = this._context.batch.batch.bind(this._context.batch);
        }
        /**
         * @description Sets configuration on the Tezos Taquito instance. Allows user to choose which signer, rpc client, rpc url, forger and so forth
         *
         * @param options rpc url or rpcClient to use to interact with the Tezos network
         *
         * @example Tezos.setProvider({rpc: 'https://mainnet.api.tez.ie/', signer: new InMemorySigner.fromSecretKey(“edsk...”)})
         * @example Tezos.setProvider({ config: { confirmationPollingTimeoutSecond: 300 }})
         *
         */
        setProvider({ rpc, stream, signer, protocol, config, forger, wallet, packer, globalConstantsProvider, readProvider, parserProvider, }) {
            this.setRpcProvider(rpc);
            this.setStreamProvider(stream);
            this.setSignerProvider(signer);
            this.setForgerProvider(forger);
            this.setWalletProvider(wallet);
            this.setPackerProvider(packer);
            this.setGlobalConstantsProvider(globalConstantsProvider);
            this.setReadProvider(readProvider);
            this.setParserProvider(parserProvider);
            this._context.proto = protocol;
            if (config) {
                this._context.setPartialConfig(config);
            }
        }
        /**
         * @description Sets signer provider on the Tezos Taquito instance.
         *
         * @param options signer to use to interact with the Tezos network
         *
         * @example Tezos.setSignerProvider(new InMemorySigner.fromSecretKey('edsk...'))
         *
         */
        setSignerProvider(signer) {
            if (!this._options.signer && typeof signer === 'undefined') {
                this._context.signer = new NoopSigner();
                this._options.signer = signer;
            }
            else if (typeof signer !== 'undefined') {
                this._context.signer = signer;
                this._options.signer = signer;
            }
        }
        /**
         * @description Sets rpc provider on the Tezos Taquito instance
         *
         * @param options rpc url or rpcClient to use to interact with the Tezos network
         *
         * @example Tezos.setRpcProvider('https://mainnet.api.tez.ie/')
         *
         */
        setRpcProvider(rpc$1) {
            if (typeof rpc$1 === 'string') {
                this._rpcClient = new rpc.RpcClient(rpc$1);
            }
            else if (rpc$1 === undefined) ;
            else {
                this._rpcClient = rpc$1;
            }
            this._options.rpc = this._rpcClient;
            this._context.rpc = this._rpcClient;
        }
        /**
         * @description Sets forger provider on the Tezos Taquito instance
         * The `LocalForger` from `@taquito/local-forging` is set by default.
         *
         * @param options forger to use to interact with the Tezos network
         *
         * @example Tezos.setForgerProvider(this.getFactory(RpcForger)())
         *
         */
        setForgerProvider(forger) {
            if (typeof forger !== 'undefined') {
                this._options.forger = forger;
                this._context.forger = forger;
            }
            else if (this._options.forger === undefined) {
                const f = this.getFactory(TaquitoLocalForger)();
                this._options.forger = f;
                this._context.forger = f;
            }
        }
        /**
         * @description Sets stream provider on the Tezos Taquito instance
         *
         * @param options stream to use to interact with the Tezos network
         *
         * @example Tezos.setStreamProvider(...)
         *
         */
        setStreamProvider(stream) {
            if (typeof stream === 'string') {
                const s = new PollingSubscribeProvider(new Context(new rpc.RpcClient(stream)));
                this._options.stream = s;
                this._context.stream = s;
            }
            else if (typeof stream !== 'undefined') {
                this._options.stream = stream;
                this._context.stream = stream;
            }
            else if (this._options.stream === undefined) {
                const s = this.getFactory(PollingSubscribeProvider)();
                this._options.stream = s;
                this._context.stream = s;
            }
        }
        /**
         * @description Sets wallet provider on the Tezos Taquito instance
         *
         * @param options wallet to use to interact with the Tezos network
         *
         * @example Tezos.setWalletProvider(...)
         *
         */
        setWalletProvider(wallet) {
            if (!this._options.wallet && typeof wallet === 'undefined') {
                const w = this.getFactory(LegacyWalletProvider)();
                this._options.wallet = w;
                this._context.walletProvider = w;
            }
            else if (typeof wallet !== 'undefined') {
                this._options.wallet = wallet;
                this._context.walletProvider = wallet;
            }
        }
        /**
         * @description Sets Packer provider on the Tezos Taquito instance
         *
         * @param options packer to use to interact with the Tezos network
         *
         * @example Tezos.setPackerProvider(new MichelCodecPacker())
         *
         */
        setPackerProvider(packer) {
            if (!this._options.packer && typeof packer === 'undefined') {
                const p = this.getFactory(RpcPacker)();
                this._context.packer = p;
                this._options.packer = p;
            }
            else if (typeof packer !== 'undefined') {
                this._context.packer = packer;
                this._options.packer = packer;
            }
        }
        /**
         * @description Sets global constants provider on the Tezos Taquito instance
         *
         * @param options globalConstantsProvider to use to interact with the Tezos network
         *
         * @example
         * ```
         * const globalConst = new DefaultGlobalConstantsProvider();
         * globalConst.loadGlobalConstant({
         *  "expruu5BTdW7ajqJ9XPTF3kgcV78pRiaBW3Gq31mgp3WSYjjUBYxre": { prim: "int" },
         *  // ...
         * })
         * Tezos.setGlobalConstantsProvider(globalConst);
         * ```
         *
         */
        setGlobalConstantsProvider(globalConstantsProvider) {
            if (!this._options.globalConstantsProvider && typeof globalConstantsProvider === 'undefined') {
                const g = new NoopGlobalConstantsProvider();
                this._context.globalConstantsProvider = g;
                this._options.globalConstantsProvider = g;
            }
            else if (typeof globalConstantsProvider !== 'undefined') {
                this._context.globalConstantsProvider = globalConstantsProvider;
                this._options.globalConstantsProvider = globalConstantsProvider;
            }
        }
        /**
         * @description Sets read provider on the Tezos Taquito instance
         * By default reads are done from the RPC usign the RpcReadAdapter class, this can be overridden to read from an indexer that implements the TzReadProvider interface
         *
         * @param options TzReadProvider to use to interact with the Tezos network
         *
         */
        setReadProvider(readProvider) {
            const readP = readProvider ? readProvider : new RpcReadAdapter(this._context.rpc);
            this._options.readProvider = readP;
            this._context.readProvider = readP;
        }
        /**
         * @description Sets parser provider on the Tezos Taquito instance
         *
         * @param options parserProvider to use to interact with the Tezos network
         *
         */
        setParserProvider(parserProvider) {
            if (!this._options.parserProvider && typeof parserProvider === 'undefined') {
                const p = new MichelCodecParser(this._context);
                this._context.parser = p;
                this._options.parserProvider = p;
            }
            else if (typeof parserProvider !== 'undefined') {
                this._context.parser = parserProvider;
                this._options.parserProvider = parserProvider;
            }
        }
        /**
         * @description Provide access to tezos account management
         */
        get tz() {
            return this._context.tz;
        }
        /**
         * @description Provide access to smart contract utilities
         */
        get contract() {
            return this._context.contract;
        }
        /**
         * @description Provide access to tezos operation preparation utilities
         */
        get prepare() {
            return this._context.prepare;
        }
        get wallet() {
            return this._wallet;
        }
        get operation() {
            return this._context.operationFactory;
        }
        /**
         * @description Provide access to operation estimation utilities
         */
        get estimate() {
            return this._context.estimate;
        }
        /**
         * @description Provide access to streaming utilities backed by an streamer implementation
         */
        get stream() {
            return this._context.stream;
        }
        /**
         * @description Provide access to the currently used rpc client
         */
        get rpc() {
            return this._context.rpc;
        }
        /**
         * @description Provide access to the currently used signer
         */
        get signer() {
            return this._context.signer;
        }
        /**
         * @description Provide access to the currently used globalConstantsProvider
         */
        get globalConstants() {
            return this._context.globalConstantsProvider;
        }
        /**
         * @description Allow to add a module to the TezosToolkit instance. This method adds the appropriate Providers(s) required by the module to the internal context.
         *
         * @param module extension to add to the TezosToolkit instance
         *
         * @example Tezos.addExtension(new Tzip16Module());
         */
        addExtension(module) {
            if (Array.isArray(module)) {
                module.forEach((extension) => extension.configureContext(this._context));
            }
            else {
                module.configureContext(this._context);
            }
        }
        getFactory(ctor) {
            return (...args) => {
                return new ctor(this._context, ...args);
            };
        }
        /**
         * @description Gets an object containing the version of Taquito library and git sha of the commit this library is compiled from
         */
        getVersionInfo() {
            return VERSION;
        }
    }

    Object.defineProperty(exports, 'OpKind', {
        enumerable: true,
        get: function () { return rpc.OpKind; }
    });
    Object.defineProperty(exports, 'MichelsonMap', {
        enumerable: true,
        get: function () { return michelsonEncoder.MichelsonMap; }
    });
    Object.defineProperty(exports, 'UnitValue', {
        enumerable: true,
        get: function () { return michelsonEncoder.UnitValue; }
    });
    exports.BallotOperation = BallotOperation;
    exports.BatchOperation = BatchOperation;
    exports.BigMapAbstraction = BigMapAbstraction;
    exports.COST_PER_BYTE = COST_PER_BYTE;
    exports.CompositeForger = CompositeForger;
    exports.Context = Context;
    exports.ContractAbstraction = ContractAbstraction;
    exports.ContractMethod = ContractMethod;
    exports.ContractMethodObject = ContractMethodObject;
    exports.ContractView = ContractView;
    exports.DEFAULT_SMART_CONTRACT_METHOD_NAME = DEFAULT_SMART_CONTRACT_METHOD_NAME;
    exports.DefaultGlobalConstantsProvider = DefaultGlobalConstantsProvider;
    exports.DelegateOperation = DelegateOperation;
    exports.DelegationWalletOperation = DelegationWalletOperation;
    exports.DrainDelegateOperation = DrainDelegateOperation;
    exports.Estimate = Estimate;
    exports.GlobalConstantNotFound = GlobalConstantNotFound;
    exports.IntegerError = IntegerError;
    exports.InvalidCodeParameter = InvalidCodeParameter;
    exports.InvalidDelegationSource = InvalidDelegationSource;
    exports.InvalidInitParameter = InvalidInitParameter;
    exports.InvalidParameterError = InvalidParameterError;
    exports.InvalidViewParameterError = InvalidViewParameterError;
    exports.InvalidViewSimulationContext = InvalidViewSimulationContext;
    exports.LegacyWalletProvider = LegacyWalletProvider;
    exports.MANAGER_LAMBDA = MANAGER_LAMBDA;
    exports.MichelCodecPacker = MichelCodecPacker;
    exports.MichelCodecParser = MichelCodecParser;
    exports.NoopParser = NoopParser;
    exports.ObservableSubscription = ObservableSubscription;
    exports.Operation = Operation;
    exports.OperationBatch = OperationBatch;
    exports.OriginationOperation = OriginationOperation;
    exports.OriginationParameterError = OriginationParameterError;
    exports.OriginationWalletOperation = OriginationWalletOperation;
    exports.PollingSubscribeProvider = PollingSubscribeProvider;
    exports.PrepareProvider = PrepareProvider;
    exports.RPCEstimateProvider = RPCEstimateProvider;
    exports.RevealEstimateError = RevealEstimateError;
    exports.RevealOperationError = RevealOperationError;
    exports.RpcForger = RpcForger;
    exports.RpcPacker = RpcPacker;
    exports.RpcReadAdapter = RpcReadAdapter;
    exports.SaplingStateAbstraction = SaplingStateAbstraction;
    exports.TaquitoLocalForger = TaquitoLocalForger;
    exports.TezosOperationError = TezosOperationError;
    exports.TezosPreapplyFailureError = TezosPreapplyFailureError;
    exports.TezosToolkit = TezosToolkit;
    exports.TransactionOperation = TransactionOperation;
    exports.TransactionWalletOperation = TransactionWalletOperation;
    exports.UnconfiguredGlobalConstantsProviderError = UnconfiguredGlobalConstantsProviderError;
    exports.VIEW_LAMBDA = VIEW_LAMBDA;
    exports.ViewSimulationError = ViewSimulationError;
    exports.Wallet = Wallet;
    exports.WalletOperation = WalletOperation;
    exports.WalletOperationBatch = WalletOperationBatch;
    exports.compose = compose;
    exports.createBallotOperation = createBallotOperation;
    exports.createDrainDelegateOperation = createDrainDelegateOperation;
    exports.createIncreasePaidStorageOperation = createIncreasePaidStorageOperation;
    exports.createOriginationOperation = createOriginationOperation;
    exports.createProposalsOperation = createProposalsOperation;
    exports.createRegisterDelegateOperation = createRegisterDelegateOperation;
    exports.createRegisterGlobalConstantOperation = createRegisterGlobalConstantOperation;
    exports.createRevealOperation = createRevealOperation;
    exports.createSetDelegateOperation = createSetDelegateOperation;
    exports.createTransferOperation = createTransferOperation;
    exports.createTransferTicketOperation = createTransferTicketOperation;
    exports.createTxRollupBatchOperation = createTxRollupBatchOperation;
    exports.createTxRollupOriginationOperation = createTxRollupOriginationOperation;
    exports.createUpdateConsensusKeyOperation = createUpdateConsensusKeyOperation;
    exports.defaultConfigConfirmation = defaultConfigConfirmation;
    exports.protocols = protocols;
    exports.validateAndExtractFailwith = validateAndExtractFailwith;

    Object.defineProperty(exports, '__esModule', { value: true });

}));


},{"@taquito/http-utils":169,"@taquito/local-forging":200,"@taquito/michel-codec":201,"@taquito/michelson-encoder":202,"@taquito/rpc":203,"@taquito/utils":205,"bignumber.js":242,"rxjs":306,"rxjs/operators":505}],205:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('buffer'), require('@stablelib/ed25519'), require('@stablelib/blake2b'), require('blakejs'), require('bs58check'), require('bignumber.js'), require('elliptic'), require('typedarray-to-buffer')) :
  typeof define === 'function' && define.amd ? define(['exports', 'buffer', '@stablelib/ed25519', '@stablelib/blake2b', 'blakejs', 'bs58check', 'bignumber.js', 'elliptic', 'typedarray-to-buffer'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.taquitoUtils = {}, global.buffer, global.ed25519, global.blake2b, global.blake, global.bs58check, global.BigNumber, global.elliptic, global.toBuffer));
})(this, (function (exports, buffer, ed25519, blake2b, blake, bs58check, BigNumber, elliptic, toBuffer) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var blake__default = /*#__PURE__*/_interopDefaultLegacy(blake);
  var bs58check__default = /*#__PURE__*/_interopDefaultLegacy(bs58check);
  var BigNumber__default = /*#__PURE__*/_interopDefaultLegacy(BigNumber);
  var elliptic__default = /*#__PURE__*/_interopDefaultLegacy(elliptic);
  var toBuffer__default = /*#__PURE__*/_interopDefaultLegacy(toBuffer);

  exports.Prefix = void 0;
  (function (Prefix) {
      Prefix["TZ1"] = "tz1";
      Prefix["TZ2"] = "tz2";
      Prefix["TZ3"] = "tz3";
      Prefix["TZ4"] = "tz4";
      Prefix["KT"] = "KT";
      Prefix["KT1"] = "KT1";
      Prefix["EDSK2"] = "edsk2";
      Prefix["SPSK"] = "spsk";
      Prefix["P2SK"] = "p2sk";
      Prefix["EDPK"] = "edpk";
      Prefix["SPPK"] = "sppk";
      Prefix["P2PK"] = "p2pk";
      Prefix["BLPK"] = "BLpk";
      Prefix["EDESK"] = "edesk";
      Prefix["SPESK"] = "spesk";
      Prefix["P2ESK"] = "p2esk";
      Prefix["EDSK"] = "edsk";
      Prefix["EDSIG"] = "edsig";
      Prefix["SPSIG"] = "spsig";
      Prefix["P2SIG"] = "p2sig";
      Prefix["SIG"] = "sig";
      Prefix["NET"] = "Net";
      Prefix["NCE"] = "nce";
      Prefix["B"] = "B";
      Prefix["O"] = "o";
      Prefix["LO"] = "Lo";
      Prefix["LLO"] = "LLo";
      Prefix["P"] = "P";
      Prefix["CO"] = "Co";
      Prefix["ID"] = "id";
      Prefix["EXPR"] = "expr";
      Prefix["TZ"] = "TZ";
      Prefix["VH"] = "vh";
      Prefix["SASK"] = "sask";
      Prefix["ZET1"] = "zet1";
      //rollups
      Prefix["TXR1"] = "txr1";
      Prefix["TXI"] = "txi";
      Prefix["TXM"] = "txm";
      Prefix["TXC"] = "txc";
      Prefix["TXMR"] = "txmr";
      Prefix["TXRL"] = "txM";
      Prefix["TXW"] = "txw";
  })(exports.Prefix || (exports.Prefix = {}));
  const prefix = {
      [exports.Prefix.TZ1]: new Uint8Array([6, 161, 159]),
      [exports.Prefix.TZ2]: new Uint8Array([6, 161, 161]),
      [exports.Prefix.TZ3]: new Uint8Array([6, 161, 164]),
      [exports.Prefix.TZ4]: new Uint8Array([6, 161, 166]),
      [exports.Prefix.KT]: new Uint8Array([2, 90, 121]),
      [exports.Prefix.KT1]: new Uint8Array([2, 90, 121]),
      [exports.Prefix.EDSK]: new Uint8Array([43, 246, 78, 7]),
      [exports.Prefix.EDSK2]: new Uint8Array([13, 15, 58, 7]),
      [exports.Prefix.SPSK]: new Uint8Array([17, 162, 224, 201]),
      [exports.Prefix.P2SK]: new Uint8Array([16, 81, 238, 189]),
      [exports.Prefix.EDPK]: new Uint8Array([13, 15, 37, 217]),
      [exports.Prefix.SPPK]: new Uint8Array([3, 254, 226, 86]),
      [exports.Prefix.P2PK]: new Uint8Array([3, 178, 139, 127]),
      [exports.Prefix.BLPK]: new Uint8Array([6, 149, 135, 204]),
      [exports.Prefix.EDESK]: new Uint8Array([7, 90, 60, 179, 41]),
      [exports.Prefix.SPESK]: new Uint8Array([0x09, 0xed, 0xf1, 0xae, 0x96]),
      [exports.Prefix.P2ESK]: new Uint8Array([0x09, 0x30, 0x39, 0x73, 0xab]),
      [exports.Prefix.EDSIG]: new Uint8Array([9, 245, 205, 134, 18]),
      [exports.Prefix.SPSIG]: new Uint8Array([13, 115, 101, 19, 63]),
      [exports.Prefix.P2SIG]: new Uint8Array([54, 240, 44, 52]),
      [exports.Prefix.SIG]: new Uint8Array([4, 130, 43]),
      [exports.Prefix.NET]: new Uint8Array([87, 82, 0]),
      [exports.Prefix.NCE]: new Uint8Array([69, 220, 169]),
      [exports.Prefix.B]: new Uint8Array([1, 52]),
      [exports.Prefix.O]: new Uint8Array([5, 116]),
      [exports.Prefix.LO]: new Uint8Array([133, 233]),
      [exports.Prefix.LLO]: new Uint8Array([29, 159, 109]),
      [exports.Prefix.P]: new Uint8Array([2, 170]),
      [exports.Prefix.CO]: new Uint8Array([79, 179]),
      [exports.Prefix.ID]: new Uint8Array([153, 103]),
      [exports.Prefix.EXPR]: new Uint8Array([13, 44, 64, 27]),
      // Legacy prefix
      [exports.Prefix.TZ]: new Uint8Array([2, 90, 121]),
      [exports.Prefix.VH]: new Uint8Array([1, 106, 242]),
      [exports.Prefix.SASK]: new Uint8Array([11, 237, 20, 92]),
      [exports.Prefix.ZET1]: new Uint8Array([18, 71, 40, 223]),
      [exports.Prefix.TXR1]: new Uint8Array([1, 128, 120, 31]),
      [exports.Prefix.TXI]: new Uint8Array([79, 148, 196]),
      [exports.Prefix.TXM]: new Uint8Array([79, 149, 30]),
      [exports.Prefix.TXC]: new Uint8Array([79, 148, 17]),
      [exports.Prefix.TXMR]: new Uint8Array([18, 7, 206, 87]),
      [exports.Prefix.TXRL]: new Uint8Array([79, 146, 82]),
      [exports.Prefix.TXW]: new Uint8Array([79, 150, 72]),
  };
  const prefixLength = {
      [exports.Prefix.TZ1]: 20,
      [exports.Prefix.TZ2]: 20,
      [exports.Prefix.TZ3]: 20,
      [exports.Prefix.TZ4]: 20,
      [exports.Prefix.KT]: 20,
      [exports.Prefix.KT1]: 20,
      [exports.Prefix.EDPK]: 32,
      [exports.Prefix.SPPK]: 33,
      [exports.Prefix.P2PK]: 33,
      //working with value in comment for base58.ml line 445 but not consistent with the three above
      [exports.Prefix.BLPK]: 48,
      [exports.Prefix.EDSIG]: 64,
      [exports.Prefix.SPSIG]: 64,
      [exports.Prefix.P2SIG]: 64,
      [exports.Prefix.SIG]: 64,
      [exports.Prefix.NET]: 4,
      [exports.Prefix.B]: 32,
      [exports.Prefix.P]: 32,
      [exports.Prefix.O]: 32,
      [exports.Prefix.VH]: 32,
      [exports.Prefix.SASK]: 169,
      [exports.Prefix.ZET1]: 43,
      [exports.Prefix.TXR1]: 20,
      [exports.Prefix.TXI]: 32,
      [exports.Prefix.TXM]: 32,
      [exports.Prefix.TXC]: 32,
      [exports.Prefix.TXMR]: 32,
      [exports.Prefix.TXRL]: 32,
      [exports.Prefix.TXW]: 32,
  };

  /**
   *  @category Error
   *  @description Error that indicates an invalid key being passed or used
   */
  class InvalidKeyError extends Error {
      constructor(key, errorDetail) {
          super();
          this.key = key;
          this.errorDetail = errorDetail;
          this.name = 'InvalidKeyError';
          const baseMessage = `The key ${key} is invalid.`;
          this.message = errorDetail ? `${baseMessage} ${errorDetail}` : baseMessage;
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an Invalid Public Key being passed or used
   */
  class InvalidPublicKeyError extends Error {
      constructor(publicKey, errorDetail) {
          super();
          this.publicKey = publicKey;
          this.name = 'InvalidPublicKeyError';
          const baseMessage = `The public key '${publicKey}' is invalid.`;
          this.message = errorDetail ? `${baseMessage} ${errorDetail}` : baseMessage;
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid signature being passed or used
   */
  class InvalidSignatureError extends Error {
      constructor(signature, errorDetail) {
          super();
          this.signature = signature;
          this.name = 'InvalidSignatureError';
          const baseMessage = `The signature '${signature}' is invalid.`;
          this.message = errorDetail ? `${baseMessage} ${errorDetail}` : baseMessage;
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid message being passed or used
   */
  class InvalidMessageError extends Error {
      constructor(msg, errorDetail) {
          super();
          this.msg = msg;
          this.errorDetail = errorDetail;
          this.name = 'InvalidMessageError';
          const baseMessage = `The message '${msg}' is invalid.`;
          this.message = errorDetail ? `${baseMessage} ${errorDetail}` : baseMessage;
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid contract address being passed or used
   */
  class InvalidContractAddressError extends Error {
      constructor(contractAddress) {
          super(`The contract address '${contractAddress}' is invalid`);
          this.contractAddress = contractAddress;
          this.name = 'InvalidContractAddressError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid address being passed or used (both contract and implicit)
   */
  class InvalidAddressError extends Error {
      constructor(address, errorDetail) {
          super();
          this.address = address;
          this.name = 'InvalidAddressError';
          const baseMessage = `The address '${address}' is invalid.`;
          this.message = errorDetail ? `${baseMessage} ${errorDetail}` : baseMessage;
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid chain id being passed or used
   */
  class InvalidChainIdError extends Error {
      constructor(chainId) {
          super(`The chain id '${chainId}' is invalid`);
          this.chainId = chainId;
          this.name = 'InvalidChainIdError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid key hash being passed or used
   */
  class InvalidKeyHashError extends Error {
      constructor(keyHash) {
          super(`The public key hash '${keyHash}' is invalid`);
          this.keyHash = keyHash;
          this.name = 'InvalidKeyHashError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid block hash being passed or used
   */ class InvalidBlockHashError extends Error {
      constructor(blockHash) {
          super(`The block hash '${blockHash}' is invalid`);
          this.blockHash = blockHash;
          this.name = 'InvalidBlockHashError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates invalid protocol hash being passed or used
   */
  class InvalidProtocolHashError extends Error {
      constructor(protocolHash) {
          super(`The protocol hash '${protocolHash}' is invalid`);
          this.protocolHash = protocolHash;
          this.name = 'InvalidProtocolHashError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid operation hash being passed or used
   */ class InvalidOperationHashError extends Error {
      constructor(operationHash) {
          super(`The operation hash '${operationHash}' is invalid`);
          this.operationHash = operationHash;
          this.name = 'InvalidOperationHashError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid operation kind being passed or used
   */
  class InvalidOperationKindError extends Error {
      constructor(operationKind) {
          super(`The operation kind '${operationKind}' is unsupported`);
          this.operationKind = operationKind;
          this.name = 'InvalidOperationKindError';
      }
  }
  /**
   *  @category Error
   *  @description General error that indicates something is no longer supported and/or deprecated
   */
  class DeprecationError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'DeprecationError';
      }
  }
  /**
   *  @category Error
   *  @description General error that indicates an action is prohibited or not allowed
   */
  class ProhibitedActionError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'ProhibitedActionError';
      }
  }
  /**
   *  @category Error
   *  @description General error that indicates a failure when trying to convert data from one type to another
   */
  class ValueConversionError extends Error {
      constructor(value, desiredType) {
          super(`Unable to convert ${value} to a ${desiredType}`);
          this.value = value;
          this.desiredType = desiredType;
          this.name = 'ValueConversionError';
      }
  }
  /**
   *  @category Error
   *  @description Error that indicates an invalid hex string being passed or used
   */
  class InvalidHexStringError extends Error {
      constructor(message) {
          super(message);
          this.message = message;
          this.name = 'InvalidHexStringError';
      }
  }

  /**
   * @description Verify signature of a payload
   *
   * @param messageBytes The forged message including the magic byte (11 for block,
   *        12 for preendorsement, 13 for endorsement, 3 for generic, 5 for the PACK format of michelson)
   * @param publicKey The public key to verify the signature against
   * @param signature The signature to verify
   * @returns A boolean indicating if the signature matches
   *
   * @example
   * ```
   * const message = '03d0c10e3ed11d7c6e3357f6ef335bab9e8f2bd54d0ce20c482e241191a6e4b8ce6c01be917311d9ac46959750e405d57e268e2ed9e174a80794fbd504e12a4a000141eb3781afed2f69679ff2bbe1c5375950b0e40d00ff000000005e05050505050507070100000024747a32526773486e74516b72794670707352466261313652546656503539684b72654a4d07070100000024747a315a6672455263414c42776d4171776f6e525859565142445439426a4e6a42484a750001';
   * const pk = 'sppk7c7hkPj47yjYFEHX85q46sFJGw6RBrqoVSHwAJAT4e14KJwzoey';
   * const sig = 'spsig1cdLkp1RLgUHAp13aRFkZ6MQDPp7xCnjAExGL3MBSdMDmT6JgQSX8cufyDgJRM3sinFtiCzLbsyP6d365EHoNevxhT47nx'
   *
   * const response = verifySignature(message, pk, sig);
   * ```
   *
   */
  function verifySignature(messageBytes, publicKey, signature) {
      const pkPrefix = validatePkAndExtractPrefix(publicKey);
      const sigPrefix = validateSigAndExtractPrefix(signature);
      const decodedPublicKey = b58cdecode(publicKey, prefix[pkPrefix]);
      const decodedSig = b58cdecode(signature, prefix[sigPrefix]);
      const bytesHash = blake2b.hash(hex2buf(validateMessageNotEmpty(messageBytes)), 32);
      if (pkPrefix === exports.Prefix.EDPK) {
          return verifyEdSignature(decodedSig, bytesHash, decodedPublicKey);
      }
      else if (pkPrefix === exports.Prefix.SPPK) {
          return verifySpSignature(decodedSig, bytesHash, decodedPublicKey);
      }
      else if (pkPrefix === exports.Prefix.P2PK) {
          return verifyP2Signature(decodedSig, bytesHash, decodedPublicKey);
      }
      else {
          return false;
      }
  }
  function validateMessageNotEmpty(message) {
      if (message === '') {
          throw new InvalidMessageError(message, 'The message provided for verifying signature cannot be empty.');
      }
      return message;
  }
  function validatePkAndExtractPrefix(publicKey) {
      if (publicKey === '') {
          throw new InvalidPublicKeyError(publicKey, 'Public key cannot be empty');
      }
      const pkPrefix = publicKey.substring(0, 4);
      const validation = validatePublicKey(publicKey);
      if (validation !== exports.ValidationResult.VALID) {
          if (validation === exports.ValidationResult.INVALID_CHECKSUM) {
              throw new InvalidPublicKeyError(publicKey, 'The public key provided has an invalid checksum');
          }
          else if (validation === exports.ValidationResult.INVALID_LENGTH) {
              throw new InvalidPublicKeyError(publicKey, 'The public key provided has an invalid length');
          }
          else if (validation === exports.ValidationResult.NO_PREFIX_MATCHED) {
              throw new InvalidPublicKeyError(publicKey, `The public key provided has an unsupported prefix: ${pkPrefix}`);
          }
      }
      return pkPrefix;
  }
  function validateSigAndExtractPrefix(signature) {
      const signaturePrefix = signature.startsWith('sig')
          ? signature.substr(0, 3)
          : signature.substr(0, 5);
      const validation = validateSignature(signature);
      if (validation !== exports.ValidationResult.VALID) {
          if (validation === exports.ValidationResult.INVALID_CHECKSUM) {
              throw new InvalidSignatureError(signature, `invalid checksum`);
          }
          else if (validation === exports.ValidationResult.INVALID_LENGTH) {
              throw new InvalidSignatureError(signature, 'invalid length');
          }
          else if (validation === exports.ValidationResult.NO_PREFIX_MATCHED) {
              throw new InvalidSignatureError(signaturePrefix, 'unsupported prefix');
          }
      }
      return signaturePrefix;
  }
  function verifyEdSignature(decodedSig, bytesHash, decodedPublicKey) {
      try {
          return ed25519.verify(decodedPublicKey, bytesHash, decodedSig);
      }
      catch (e) {
          return false;
      }
  }
  function verifySpSignature(decodedSig, bytesHash, decodedPublicKey) {
      const key = new elliptic__default["default"].ec('secp256k1').keyFromPublic(decodedPublicKey);
      return verifySpOrP2Sig(decodedSig, bytesHash, key);
  }
  function verifyP2Signature(decodedSig, bytesHash, decodedPublicKey) {
      const key = new elliptic__default["default"].ec('p256').keyFromPublic(decodedPublicKey);
      return verifySpOrP2Sig(decodedSig, bytesHash, key);
  }
  function verifySpOrP2Sig(decodedSig, bytesHash, key) {
      const hexSig = buf2hex(toBuffer__default["default"](decodedSig));
      const match = hexSig.match(/([a-f\d]{64})/gi);
      if (match) {
          try {
              const [r, s] = match;
              return key.verify(bytesHash, { r, s });
          }
          catch (e) {
              return false;
          }
      }
      return false;
  }

  exports.ValidationResult = void 0;
  (function (ValidationResult) {
      ValidationResult[ValidationResult["NO_PREFIX_MATCHED"] = 0] = "NO_PREFIX_MATCHED";
      ValidationResult[ValidationResult["INVALID_CHECKSUM"] = 1] = "INVALID_CHECKSUM";
      ValidationResult[ValidationResult["INVALID_LENGTH"] = 2] = "INVALID_LENGTH";
      ValidationResult[ValidationResult["VALID"] = 3] = "VALID";
  })(exports.ValidationResult || (exports.ValidationResult = {}));
  function isValidPrefix(value) {
      if (typeof value !== 'string') {
          return false;
      }
      return value in prefix;
  }
  /**
   * @description This function is called by the validation functions ([[validateAddress]], [[validateChain]], [[validateContractAddress]], [[validateKeyHash]], [[validateSignature]], [[validatePublicKey]]).
   * Verify if the value has the right prefix or return `NO_PREFIX_MATCHED`,
   * decode the value using base58 and return `INVALID_CHECKSUM` if it fails,
   * check if the length of the value matches the prefix type or return `INVALID_LENGTH`.
   * If all checks pass, return `VALID`.
   *
   * @param value Value to validate
   * @param prefixes prefix the value should have
   */
  function validatePrefixedValue(value, prefixes) {
      const match = new RegExp(`^(${prefixes.join('|')})`).exec(value);
      if (!match || match.length === 0) {
          return exports.ValidationResult.NO_PREFIX_MATCHED;
      }
      const prefixKey = match[0];
      if (!isValidPrefix(prefixKey)) {
          return exports.ValidationResult.NO_PREFIX_MATCHED;
      }
      // Remove annotation from contract address before doing the validation
      const contractAddress = /^(KT1\w{33})(%(.*))?/.exec(value);
      if (contractAddress) {
          value = contractAddress[1];
      }
      // decodeUnsafe return undefined if decoding fail
      let decoded = bs58check__default["default"].decodeUnsafe(value);
      if (!decoded) {
          return exports.ValidationResult.INVALID_CHECKSUM;
      }
      decoded = decoded.slice(prefix[prefixKey].length);
      if (decoded.length !== prefixLength[prefixKey]) {
          return exports.ValidationResult.INVALID_LENGTH;
      }
      return exports.ValidationResult.VALID;
  }
  const implicitPrefix = [exports.Prefix.TZ1, exports.Prefix.TZ2, exports.Prefix.TZ3, exports.Prefix.TZ4];
  const contractPrefix = [exports.Prefix.KT1, exports.Prefix.TXR1];
  const signaturePrefix = [exports.Prefix.EDSIG, exports.Prefix.P2SIG, exports.Prefix.SPSIG, exports.Prefix.SIG];
  const pkPrefix = [exports.Prefix.EDPK, exports.Prefix.SPPK, exports.Prefix.P2PK, exports.Prefix.BLPK];
  const operationPrefix = [exports.Prefix.O];
  const protocolPrefix = [exports.Prefix.P];
  const blockPrefix = [exports.Prefix.B];
  /**
   * @description Used to check if an address or a contract address is valid.
   *
   * @returns
   * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).
   *
   * @example
   * ```
   * import { validateAddress } from '@taquito/utils';
   * const pkh = 'tz1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'
   * const validation = validateAddress(pkh)
   * console.log(validation)
   * // This example return 3 which correspond to VALID
   * ```
   */
  function validateAddress(value) {
      return validatePrefixedValue(value, [...implicitPrefix, ...contractPrefix]);
  }
  /**
   * @description Used to check if a chain id is valid.
   *
   * @returns
   * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).
   *
   * @example
   * ```
   * import { validateChain } from '@taquito/utils';
   * const chainId = 'NetXdQprcVkpaWU'
   * const validation = validateChain(chainId)
   * console.log(validation)
   * // This example return 3 which correspond to VALID
   * ```
   */
  function validateChain(value) {
      return validatePrefixedValue(value, [exports.Prefix.NET]);
  }
  /**
   * @description Used to check if a contract address is valid.
   *
   * @returns
   * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).
   *
   * @example
   * ```
   * import { validateContractAddress } from '@taquito/utils';
   * const contractAddress = 'KT1JVErLYTgtY8uGGZ4mso2npTSxqVLDRVbC'
   * const validation = validateContractAddress(contractAddress)
   * console.log(validation)
   * // This example return 3 which correspond to VALID
   * ```
   */
  function validateContractAddress(value) {
      return validatePrefixedValue(value, contractPrefix);
  }
  /**
   * @description Used to check if a key hash is valid.
   *
   * @returns
   * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).
   *
   * @example
   * ```
   * import { validateKeyHash } from '@taquito/utils';
   * const keyHashWithoutPrefix = '1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'
   * const validation = validateKeyHash(keyHashWithoutPrefix)
   * console.log(validation)
   * // This example return 0 which correspond to NO_PREFIX_MATCHED
   * ```
   */
  function validateKeyHash(value) {
      return validatePrefixedValue(value, implicitPrefix);
  }
  /**
   * @description Used to check if a signature is valid.
   *
   * @returns
   * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).
   *
   * @example
   * ```
   * import { validateSignature } from '@taquito/utils';
   * const signature = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'
   * const validation = validateSignature(signature)
   * console.log(validation)
   * // This example return 3 which correspond to VALID
   * ```
   */
  function validateSignature(value) {
      return validatePrefixedValue(value, signaturePrefix);
  }
  /**
   * @description Used to check if a public key is valid.
   *
   * @returns
   * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).
   *
   * @example
   * ```
   * import { validatePublicKey } from '@taquito/utils';
   * const publicKey = 'edpkvS5QFv7KRGfa3b87gg9DBpxSm3NpSwnjhUjNBQrRUUR66F7C9g'
   * const validation = validatePublicKey(publicKey)
   * console.log(validation)
   * // This example return 3 which correspond to VALID
   * ```
   */
  function validatePublicKey(value) {
      return validatePrefixedValue(value, pkPrefix);
  }
  /**
   * @description Used to check if an operation hash is valid.
   *
   * @returns
   * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).
   *
   * @example
   * ```
   * import { validateOperation } from '@taquito/utils';
   * const operationHash = 'oo6JPEAy8VuMRGaFuMmLNFFGdJgiaKfnmT1CpHJfKP3Ye5ZahiP'
   * const validation = validateOperation(operationHash)
   * console.log(validation)
   * // This example return 3 which correspond to VALID
   * ```
   */
  function validateOperation(value) {
      return validatePrefixedValue(value, operationPrefix);
  }
  /**
   * @description Used to check if a protocol hash is valid.
   *
   * @returns
   * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).
   *
   * @example
   * ```
   * import { validateProtocol } from '@taquito/utils';
   * const protocolHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'
   * const validation = validateProtocol(protocolHash)
   * console.log(validation)
   * // This example return 3 which correspond to VALID
   * ```
   */
  function validateProtocol(value) {
      return validatePrefixedValue(value, protocolPrefix);
  }
  /**
   * @description Used to check if a block hash is valid.
   *
   * @returns
   * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).
   *
   * @example
   * ```
   * import { validateBlock } from '@taquito/utils';
   * const blockHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'
   * const validation = validateBlock(blockHash)
   * console.log(validation)
   * // This example return 3 which correspond to VALID
   * ```
   */
  function validateBlock(value) {
      return validatePrefixedValue(value, blockPrefix);
  }
  /**
   * @description Used to check if a spending key is valid.
   * @returns 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).
   *
   */
  function validateSpendingKey(value) {
      return validatePrefixedValue(value, [exports.Prefix.SASK]);
  }

  // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
  const VERSION = {
      "commitHash": "178bea7c6a3b3c58f23163fcc72e28aa5f08702a",
      "version": "15.1.0"
  };

  const TZ_DECIMALS = 6;
  const MTZ_DECIMALS = 3;
  function getDecimal(format) {
      switch (format) {
          case 'tz':
              return TZ_DECIMALS;
          case 'mtz':
              return MTZ_DECIMALS;
          case 'mutez':
          default:
              return 0;
      }
  }
  function format(from = 'mutez', to = 'mutez', amount) {
      const bigNum = new BigNumber__default["default"](amount);
      if (bigNum.isNaN()) {
          return amount;
      }
      return bigNum
          .multipliedBy(Math.pow(10, getDecimal(from)))
          .dividedBy(Math.pow(10, getDecimal(to)));
  }

  /**
   * @packageDocumentation
   * @module @taquito/utils
   */
  /**
   *
   * @description Hash a string using the BLAKE2b algorithm, base58 encode the hash obtained and appends the prefix 'expr' to it
   *
   * @param value Value in hex
   */
  function encodeExpr(value) {
      const blakeHash = blake__default["default"].blake2b(hex2buf(value), undefined, 32);
      return b58cencode(blakeHash, prefix['expr']);
  }
  /**
   *
   * @description Return the operation hash of a signed operation
   * @param value Value in hex of a signed operation
   */
  function encodeOpHash(value) {
      const blakeHash = blake__default["default"].blake2b(hex2buf(value), undefined, 32);
      return b58cencode(blakeHash, prefix.o);
  }
  /**
   *
   * @description Base58 encode a string or a Uint8Array and append a prefix to it
   *
   * @param value Value to base58 encode
   * @param prefix prefix to append to the encoded string
   */
  function b58cencode(value, prefix) {
      const payloadAr = typeof value === 'string' ? Uint8Array.from(buffer.Buffer.from(value, 'hex')) : value;
      const n = new Uint8Array(prefix.length + payloadAr.length);
      n.set(prefix);
      n.set(payloadAr, prefix.length);
      return bs58check__default["default"].encode(buffer.Buffer.from(n.buffer));
  }
  /**
   *
   * @description Base58 decode a string and remove the prefix from it
   *
   * @param value Value to base58 decode
   * @param prefix prefix to remove from the decoded string
   */
  const b58cdecode = (enc, prefixArg) => bs58check__default["default"].decode(enc).slice(prefixArg.length);
  /**
   *
   * @description Base58 decode a string with predefined prefix
   *
   * @param value Value to base58 decode
   */
  function b58decode(payload) {
      const buf = bs58check__default["default"].decode(payload);
      const prefixMap = {
          [prefix.tz1.toString()]: '0000',
          [prefix.tz2.toString()]: '0001',
          [prefix.tz3.toString()]: '0002',
      };
      const rollupPrefMap = {
          [prefix.txr1.toString()]: '02',
      };
      const pref = prefixMap[new Uint8Array(buf.slice(0, 3)).toString()];
      const rollupPref = rollupPrefMap[new Uint8Array(buf.slice(0, 4)).toString()];
      if (pref) {
          // tz addresses
          const hex = buf2hex(buf.slice(3));
          return pref + hex;
      }
      else if (rollupPref) {
          const hex = buf2hex(buf.slice(4));
          return rollupPref + hex + '00';
      }
      else {
          // other (kt addresses)
          return '01' + buf2hex(buf.slice(3, 42)) + '00';
      }
  }
  /**
   *
   * @description b58 decode a string without predefined prefix
   * @param value
   * @returns string of bytes
   */
  function b58decodeL2Address(payload) {
      const buf = bs58check__default["default"].decode(payload);
      // tz4 address currently
      return buf2hex(buf.slice(3, 42));
  }
  /**
   *
   * @description Base58 encode an address using predefined prefix
   *
   * @param value Address to base58 encode (tz1, tz2, tz3 or KT1)
   */
  function encodePubKey(value) {
      if (value.substring(0, 2) === '00') {
          const pref = {
              '0000': prefix.tz1,
              '0001': prefix.tz2,
              '0002': prefix.tz3,
          };
          return b58cencode(value.substring(4), pref[value.substring(0, 4)]);
      }
      else if (value.substring(0, 2) === '02') {
          // 42 also works but the removes the 00 padding at the end
          return b58cencode(value.substring(2, value.length - 2), prefix.txr1);
      }
      return b58cencode(value.substring(2, 42), prefix.KT);
  }
  /**
   *
   * @description Base58 encode an address without predefined prefix
   * @param value Address to base58 encode (tz4) hex dec
   * @returns return address
   */
  function encodeL2Address(value) {
      return b58cencode(value, prefix.tz4);
  }
  /**
   *
   * @description Base58 encode a key according to its prefix
   *
   * @param value Key to base58 encode
   */
  function encodeKey(value) {
      if (value[0] === '0') {
          const pref = {
              '00': new Uint8Array([13, 15, 37, 217]),
              '01': new Uint8Array([3, 254, 226, 86]),
              '02': new Uint8Array([3, 178, 139, 127]),
          };
          return b58cencode(value.substring(2), pref[value.substring(0, 2)]);
      }
  }
  /**
   *
   * @description Base58 encode a key hash according to its prefix
   *
   * @param value Key hash to base58 encode
   */
  function encodeKeyHash(value) {
      if (value[0] === '0') {
          const pref = {
              '00': new Uint8Array([6, 161, 159]),
              '01': new Uint8Array([6, 161, 161]),
              '02': new Uint8Array([6, 161, 164]),
          };
          return b58cencode(value.substring(2), pref[value.substring(0, 2)]);
      }
  }
  /**
   *
   * @description Convert an hex string to a Uint8Array
   *
   * @param hex Hex string to convert
   */
  const hex2buf = (hex) => {
      const match = hex.match(/[\da-f]{2}/gi);
      if (match) {
          return new Uint8Array(match.map((h) => parseInt(h, 16)));
      }
      else {
          throw new ValueConversionError(hex, 'Uint8Array');
      }
  };
  /**
   *
   * @description Merge 2 buffers together
   *
   * @param b1 First buffer
   * @param b2 Second buffer
   */
  const mergebuf = (b1, b2) => {
      const r = new Uint8Array(b1.length + b2.length);
      r.set(b1);
      r.set(b2, b1.length);
      return r;
  };
  /**
   *
   * @description Flatten a michelson json representation to an array
   *
   * @param s michelson json
   */
  const mic2arr = function me2(s) {
      let ret = [];
      if (Object.prototype.hasOwnProperty.call(s, 'prim')) {
          if (s.prim === 'Pair') {
              ret.push(me2(s.args[0]));
              ret = ret.concat(me2(s.args[1]));
          }
          else if (s.prim === 'Elt') {
              ret = {
                  key: me2(s.args[0]),
                  val: me2(s.args[1]),
              };
          }
          else if (s.prim === 'True') {
              ret = true;
          }
          else if (s.prim === 'False') {
              ret = false;
          }
      }
      else if (Array.isArray(s)) {
          const sc = s.length;
          for (let i = 0; i < sc; i++) {
              const n = me2(s[i]);
              if (typeof n.key !== 'undefined') {
                  if (Array.isArray(ret)) {
                      ret = {
                          keys: [],
                          vals: [],
                      };
                  }
                  ret.keys.push(n.key);
                  ret.vals.push(n.val);
              }
              else {
                  ret.push(n);
              }
          }
      }
      else if (Object.prototype.hasOwnProperty.call(s, 'string')) {
          ret = s.string;
      }
      else if (Object.prototype.hasOwnProperty.call(s, 'int')) {
          ret = parseInt(s.int, 10);
      }
      else {
          ret = s;
      }
      return ret;
  };
  /**
   *
   * @description Convert a buffer to an hex string
   *
   * @param buffer Buffer to convert
   */
  const buf2hex = (buffer) => {
      const byteArray = new Uint8Array(buffer);
      const hexParts = [];
      byteArray.forEach((byte) => {
          const hex = byte.toString(16);
          const paddedHex = `00${hex}`.slice(-2);
          hexParts.push(paddedHex);
      });
      return hexParts.join('');
  };
  /**
   *
   *  @description Gets Tezos address (PKH) from Public Key
   *
   *  @param publicKey Public Key
   *  @returns A string of the Tezos address (PKH) that was derived from the given Public Key
   */
  const getPkhfromPk = (publicKey) => {
      let encodingPrefix;
      let prefixLen;
      const keyPrefix = validatePkAndExtractPrefix(publicKey);
      const decoded = b58cdecode(publicKey, prefix[keyPrefix]);
      switch (keyPrefix) {
          case exports.Prefix.EDPK:
              encodingPrefix = prefix[exports.Prefix.TZ1];
              prefixLen = prefixLength[exports.Prefix.TZ1];
              break;
          case exports.Prefix.SPPK:
              encodingPrefix = prefix[exports.Prefix.TZ2];
              prefixLen = prefixLength[exports.Prefix.TZ2];
              break;
          case exports.Prefix.P2PK:
              encodingPrefix = prefix[exports.Prefix.TZ3];
              prefixLen = prefixLength[exports.Prefix.TZ3];
              break;
          case exports.Prefix.BLPK:
              encodingPrefix = prefix[exports.Prefix.TZ4];
              prefixLen = prefixLength[exports.Prefix.TZ4];
      }
      const hashed = blake2b.hash(decoded, prefixLen);
      const result = b58cencode(hashed, encodingPrefix);
      return result;
  };
  /**
   *
   * @description Convert a string to bytes
   *
   * @param str String to convert
   */
  function char2Bytes(str) {
      return buffer.Buffer.from(str, 'utf8').toString('hex');
  }
  /**
   *
   * @description Convert bytes to a string
   *
   * @param str Bytes to convert
   */
  function bytes2Char(hex) {
      return buffer.Buffer.from(hex2buf(hex)).toString('utf8');
  }
  /**
   *
   * @description Convert hex string/UintArray/Buffer to bytes
   *
   * @param hex String value to convert to bytes
   */
  function hex2Bytes(hex) {
      if (!hex.match(/[\da-f]{2}/gi)) {
          throw new InvalidHexStringError(`The hex string ${hex} does not have an even number of characters`);
      }
      return buffer.Buffer.from(hex, 'hex');
  }
  /**
   *
   * @description Converts a number or Bignumber to hexadecimal  string
   *
   * @param val The value  that will be converted to a hexadecimal string value
   */
  function toHexBuf(val, bitLength = 8) {
      return buffer.Buffer.from(num2PaddedHex(val, bitLength), 'hex');
  }
  /**
   *
   * @description Converts a number or BigNumber to a padded hexadecimal string
   * @param val The value that will be converted into a padded hexadecimal string value
   * @param bitLength The length of bits
   *
   */
  function num2PaddedHex(val, bitLength = 8) {
      if (new BigNumber__default["default"](val).isPositive()) {
          const nibbleLength = Math.ceil(bitLength / 4);
          const hex = val.toString(16);
          // check whether nibble (4 bits) length is higher or lowerthan the current hex string length
          let targetLength = hex.length >= nibbleLength ? hex.length : nibbleLength;
          // make sure the hex string target length is even
          targetLength = targetLength % 2 == 0 ? targetLength : targetLength + 1;
          return padHexWithZero(hex, targetLength);
      }
      else {
          const twosCompliment = new BigNumber__default["default"](2)
              .pow(bitLength)
              .minus(new BigNumber__default["default"](val).abs());
          return twosCompliment.toString(16);
      }
  }
  function padHexWithZero(hex, targetLength) {
      const padString = '0';
      if (hex.length >= targetLength) {
          return hex;
      }
      else {
          const padLength = targetLength - hex.length;
          return padString.repeat(padLength) + hex;
      }
  }
  /**
   *
   * @description Strips the first 2 characters of a hex string (0x)
   *
   * @param hex string to strip prefix from
   */
  function stripHexPrefix(hex) {
      return hex.startsWith('0x') ? hex.slice(2) : hex;
  }

  exports.DeprecationError = DeprecationError;
  exports.InvalidAddressError = InvalidAddressError;
  exports.InvalidBlockHashError = InvalidBlockHashError;
  exports.InvalidChainIdError = InvalidChainIdError;
  exports.InvalidContractAddressError = InvalidContractAddressError;
  exports.InvalidHexStringError = InvalidHexStringError;
  exports.InvalidKeyError = InvalidKeyError;
  exports.InvalidKeyHashError = InvalidKeyHashError;
  exports.InvalidMessageError = InvalidMessageError;
  exports.InvalidOperationHashError = InvalidOperationHashError;
  exports.InvalidOperationKindError = InvalidOperationKindError;
  exports.InvalidProtocolHashError = InvalidProtocolHashError;
  exports.InvalidPublicKeyError = InvalidPublicKeyError;
  exports.InvalidSignatureError = InvalidSignatureError;
  exports.ProhibitedActionError = ProhibitedActionError;
  exports.VERSION = VERSION;
  exports.ValueConversionError = ValueConversionError;
  exports.b58cdecode = b58cdecode;
  exports.b58cencode = b58cencode;
  exports.b58decode = b58decode;
  exports.b58decodeL2Address = b58decodeL2Address;
  exports.buf2hex = buf2hex;
  exports.bytes2Char = bytes2Char;
  exports.char2Bytes = char2Bytes;
  exports.encodeExpr = encodeExpr;
  exports.encodeKey = encodeKey;
  exports.encodeKeyHash = encodeKeyHash;
  exports.encodeL2Address = encodeL2Address;
  exports.encodeOpHash = encodeOpHash;
  exports.encodePubKey = encodePubKey;
  exports.format = format;
  exports.getPkhfromPk = getPkhfromPk;
  exports.hex2Bytes = hex2Bytes;
  exports.hex2buf = hex2buf;
  exports.isValidPrefix = isValidPrefix;
  exports.mergebuf = mergebuf;
  exports.mic2arr = mic2arr;
  exports.num2PaddedHex = num2PaddedHex;
  exports.prefix = prefix;
  exports.prefixLength = prefixLength;
  exports.stripHexPrefix = stripHexPrefix;
  exports.toHexBuf = toHexBuf;
  exports.validateAddress = validateAddress;
  exports.validateBlock = validateBlock;
  exports.validateChain = validateChain;
  exports.validateContractAddress = validateContractAddress;
  exports.validateKeyHash = validateKeyHash;
  exports.validateOperation = validateOperation;
  exports.validatePkAndExtractPrefix = validatePkAndExtractPrefix;
  exports.validateProtocol = validateProtocol;
  exports.validatePublicKey = validatePublicKey;
  exports.validateSignature = validateSignature;
  exports.validateSpendingKey = validateSpendingKey;
  exports.verifySignature = verifySignature;

  Object.defineProperty(exports, '__esModule', { value: true });

}));


},{"@stablelib/blake2b":147,"@stablelib/ed25519":150,"bignumber.js":242,"blakejs":245,"bs58check":251,"buffer":3,"elliptic":254,"typedarray-to-buffer":516}],206:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DAppClientWrapped = void 0;
const bs58check = __importStar(require("bs58check"));
const axios_1 = __importDefault(require("axios"));
const beacon_dapp_1 = require("@airgap/beacon-dapp");
const beacon_core_1 = require("@airgap/beacon-core");
const beacon_message_events_1 = require("@airgap/beacon-dapp/dist/cjs/beacon-message-events");
const DappP2PTransport_1 = require("@airgap/beacon-dapp/dist/cjs/transports/DappP2PTransport");
const DappPostMessageTransport_1 = require("@airgap/beacon-dapp/dist/cjs/transports/DappPostMessageTransport");
const beacon_sdk_1 = require("@airgap/beacon-sdk");
const events_wrapped_1 = require("./features-wrapped/events-wrapped");
const logger = new beacon_sdk_1.Logger('DAppClient');
/**
 * @publicapi
 *
 * This Class is extended from the original DappClient of beacon, with more flexible UI.
 * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible
 * wallets and sending requests.
 * This is a wrapper.
 *
 * @category DAppWrapped
 */
class DAppClientWrapped extends beacon_sdk_1.Client {
    constructor(config) {
        var _a, _b, _c, _d, _e, _f;
        super(Object.assign({ storage: config && config.storage ? config.storage : new beacon_sdk_1.LocalStorage() }, config));
        this.isAutonomy = false;
        this.events = new beacon_sdk_1.BeaconEventHandler();
        this.eventsWrapped = new events_wrapped_1.BeaconEventHandlerWrapped();
        /**
         * A map of requests that are currently "open", meaning we have sent them to a wallet and are still awaiting a response.
         */
        this.openRequests = new Map();
        /**
         * The currently active account. For all requests that are associated to a specific request (operation request, signing request),
         * the active account is used to determine the network and destination wallet
         */
        this._activeAccount = new beacon_sdk_1.ExposedPromise();
        /**
         * The currently active peer. This is used to address a peer in case the active account is not set. (Eg. for permission requests)
         */
        this._activePeer = new beacon_sdk_1.ExposedPromise();
        this.blockchains = new Map();
        this.events = new beacon_sdk_1.BeaconEventHandler(config.eventHandlers, (_a = config.disableDefaultEvents) !== null && _a !== void 0 ? _a : false);
        this.eventsWrapped = new events_wrapped_1.BeaconEventHandlerWrapped(config.eventHandlers, (_b = config.disableDefaultEvents) !== null && _b !== void 0 ? _b : false);
        this.blockExplorer = (_c = config.blockExplorer) !== null && _c !== void 0 ? _c : new beacon_sdk_1.TzktBlockExplorer();
        this.preferredNetwork = (_d = config.preferredNetwork) !== null && _d !== void 0 ? _d : beacon_dapp_1.NetworkType.MAINNET;
        (0, beacon_sdk_1.setColorMode)((_e = config.colorMode) !== null && _e !== void 0 ? _e : beacon_sdk_1.ColorMode.LIGHT);
        this.disclaimerText = config.disclaimerText;
        this.errorMessages = (_f = config.errorMessages) !== null && _f !== void 0 ? _f : {};
        this.appMetadataManager = new beacon_sdk_1.AppMetadataManager(this.storage);
        this.activeAccountLoaded = this.storage
            .get(beacon_dapp_1.StorageKey.ACTIVE_ACCOUNT)
            .then((activeAccountIdentifier) => __awaiter(this, void 0, void 0, function* () {
            if (activeAccountIdentifier) {
                yield this.setActiveAccount(yield this.accountManager.getAccount(activeAccountIdentifier));
            }
            else {
                yield this.setActiveAccount(undefined);
            }
        }))
            .catch((storageError) => __awaiter(this, void 0, void 0, function* () {
            yield this.setActiveAccount(undefined);
            console.error(storageError);
        }));
        this.handleResponse = (message, connectionInfo) => __awaiter(this, void 0, void 0, function* () {
            var _g, _h;
            const openRequest = this.openRequests.get(message.id);
            logger.log('handleResponse', 'Received message', message, connectionInfo);
            if (message.version === '3') {
                const typedMessage = message;
                if (openRequest && typedMessage.message.type === beacon_sdk_1.BeaconMessageType.Acknowledge) {
                    logger.log(`acknowledge message received for ${message.id}`);
                    console.timeLog(message.id, 'acknowledge');
                    this.events
                        .emit(beacon_sdk_1.BeaconEvent.ACKNOWLEDGE_RECEIVED, {
                        message: typedMessage.message,
                        extraInfo: {},
                        walletInfo: yield this.getWalletInfo()
                    })
                        .catch(console.error);
                }
                else if (openRequest) {
                    const appMetadata = typedMessage.message /* Why is this unkown cast needed? */.blockchainData.appMetadata;
                    if (typedMessage.message.type === beacon_sdk_1.BeaconMessageType.PermissionResponse && appMetadata) {
                        yield this.appMetadataManager.addAppMetadata(appMetadata);
                    }
                    console.timeLog(typedMessage.id, 'response');
                    console.timeEnd(typedMessage.id);
                    if (typedMessage.message.type === beacon_sdk_1.BeaconMessageType.Error) {
                        openRequest.reject(typedMessage.message);
                    }
                    else {
                        openRequest.resolve({ message, connectionInfo });
                    }
                    this.openRequests.delete(typedMessage.id);
                }
                else {
                    if (typedMessage.message.type === beacon_sdk_1.BeaconMessageType.Disconnect) {
                        const relevantTransport = connectionInfo.origin === beacon_sdk_1.Origin.P2P
                            ? this.p2pTransport
                            : (_g = this.postMessageTransport) !== null && _g !== void 0 ? _g : (yield this.transport);
                        if (relevantTransport) {
                            // TODO: Handle removing it from the right transport (if it was received from the non-active transport)
                            const peers = yield relevantTransport.getPeers();
                            const peer = peers.find((peerEl) => peerEl.senderId === message.senderId);
                            if (peer) {
                                yield relevantTransport.removePeer(peer);
                                yield this.removeAccountsForPeers([peer]);
                                yield this.events.emit(beacon_sdk_1.BeaconEvent.CHANNEL_CLOSED);
                            }
                            else {
                                logger.error('handleDisconnect', 'cannot find peer for sender ID', message.senderId);
                            }
                        }
                    }
                    else {
                        logger.error('handleResponse', 'no request found for id ', message.id, message);
                    }
                }
            }
            else {
                const typedMessage = message;
                if (openRequest && typedMessage.type === beacon_sdk_1.BeaconMessageType.Acknowledge) {
                    logger.log(`acknowledge message received for ${message.id}`);
                    console.timeLog(message.id, 'acknowledge');
                    this.events
                        .emit(beacon_sdk_1.BeaconEvent.ACKNOWLEDGE_RECEIVED, {
                        message: typedMessage,
                        extraInfo: {},
                        walletInfo: yield this.getWalletInfo()
                    })
                        .catch(console.error);
                }
                else if (openRequest) {
                    if (typedMessage.type === beacon_sdk_1.BeaconMessageType.PermissionResponse &&
                        typedMessage.appMetadata) {
                        yield this.appMetadataManager.addAppMetadata(typedMessage.appMetadata);
                    }
                    console.timeLog(typedMessage.id, 'response');
                    console.timeEnd(typedMessage.id);
                    if (typedMessage.type === beacon_sdk_1.BeaconMessageType.Error || message.errorType) {
                        // TODO: Remove "any" once we remove support for v1 wallets
                        openRequest.reject(typedMessage);
                    }
                    else {
                        openRequest.resolve({ message, connectionInfo });
                    }
                    this.openRequests.delete(typedMessage.id);
                }
                else {
                    if (typedMessage.type === beacon_sdk_1.BeaconMessageType.Disconnect ||
                        message.typedMessage.type === beacon_sdk_1.BeaconMessageType.Disconnect // TODO: TYPE
                    ) {
                        const relevantTransport = connectionInfo.origin === beacon_sdk_1.Origin.P2P
                            ? this.p2pTransport
                            : (_h = this.postMessageTransport) !== null && _h !== void 0 ? _h : (yield this.transport);
                        if (relevantTransport) {
                            // TODO: Handle removing it from the right transport (if it was received from the non-active transport)
                            const peers = yield relevantTransport.getPeers();
                            const peer = peers.find((peerEl) => peerEl.senderId === message.senderId);
                            if (peer) {
                                yield relevantTransport.removePeer(peer);
                                yield this.removeAccountsForPeers([peer]);
                                yield this.events.emit(beacon_sdk_1.BeaconEvent.CHANNEL_CLOSED);
                            }
                            else {
                                logger.error('handleDisconnect', 'cannot find peer for sender ID', message.senderId);
                            }
                        }
                    }
                    else {
                        logger.error('handleResponse', 'no request found for id ', message.id, message);
                    }
                }
            }
        });
    }
    /**
     * This function will delete other account before connect to Autonomy
     */
    prepareBeforeAutonomyRequestPermission() {
        return __awaiter(this, void 0, void 0, function* () {
            const autonomyName = "Autonomy";
            const activeAccount = yield this.getActiveAccount();
            if (activeAccount) {
                const peerOfActiveAccount = yield this.getPeer(activeAccount);
                if (!peerOfActiveAccount.name.includes(autonomyName)) {
                    yield this.clearActiveAccount();
                }
            }
        });
    }
    initInternalTransports() {
        return __awaiter(this, void 0, void 0, function* () {
            const keyPair = yield this.keyPair;
            if (this.postMessageTransport || this.p2pTransport) {
                return;
            }
            this.postMessageTransport = new DappPostMessageTransport_1.DappPostMessageTransport(this.name, keyPair, this.storage);
            yield this.addListener(this.postMessageTransport);
            this.p2pTransport = new DappP2PTransport_1.DappP2PTransport(this.name, keyPair, this.storage, this.matrixNodes, this.iconUrl, this.appUrl);
            yield this.addListener(this.p2pTransport);
        });
    }
    init(transport) {
        const _super = Object.create(null, {
            init: { get: () => super.init }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this._initPromise) {
                return this._initPromise;
            }
            try {
                yield this.activeAccountLoaded;
            }
            catch (_a) {
                //
            }
            this._initPromise = new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                if (transport) {
                    yield this.addListener(transport);
                    resolve(yield _super.init.call(this, transport));
                }
                else if (this._transport.isSettled()) {
                    yield (yield this.transport).connect();
                    resolve(yield _super.init.call(this, yield this.transport));
                }
                else {
                    const activeAccount = yield this.getActiveAccount();
                    const stopListening = () => {
                        if (this.postMessageTransport) {
                            this.postMessageTransport.stopListeningForNewPeers().catch(console.error);
                        }
                        if (this.p2pTransport) {
                            this.p2pTransport.stopListeningForNewPeers().catch(console.error);
                        }
                    };
                    yield this.initInternalTransports();
                    if (!this.postMessageTransport || !this.p2pTransport) {
                        return;
                    }
                    this.postMessageTransport.connect().then().catch(console.error);
                    if (activeAccount && activeAccount.origin) {
                        const origin = activeAccount.origin.type;
                        // Select the transport that matches the active account
                        if (origin === beacon_sdk_1.Origin.EXTENSION) {
                            resolve(yield _super.init.call(this, this.postMessageTransport));
                        }
                        else if (origin === beacon_sdk_1.Origin.P2P) {
                            resolve(yield _super.init.call(this, this.p2pTransport));
                        }
                    }
                    else {
                        const p2pTransport = this.p2pTransport;
                        const postMessageTransport = this.postMessageTransport;
                        postMessageTransport
                            .listenForNewPeer((peer) => {
                            logger.log('init', 'postmessage transport peer connected', peer);
                            this.events
                                .emit(beacon_sdk_1.BeaconEvent.PAIR_SUCCESS, peer)
                                .catch((emitError) => console.warn(emitError));
                            this.setActivePeer(peer).catch(console.error);
                            this.setTransport(this.postMessageTransport).catch(console.error);
                            stopListening();
                            resolve(beacon_sdk_1.TransportType.POST_MESSAGE);
                        })
                            .catch(console.error);
                        p2pTransport
                            .listenForNewPeer((peer) => {
                            logger.log('init', 'p2p transport peer connected', peer);
                            this.events
                                .emit(beacon_sdk_1.BeaconEvent.PAIR_SUCCESS, peer)
                                .catch((emitError) => console.warn(emitError));
                            this.setActivePeer(peer).catch(console.error);
                            this.setTransport(this.p2pTransport).catch(console.error);
                            stopListening();
                            resolve(beacon_sdk_1.TransportType.P2P);
                        })
                            .catch(console.error);
                        beacon_dapp_1.PostMessageTransport.getAvailableExtensions()
                            .then(() => __awaiter(this, void 0, void 0, function* () {
                            const tempEvents = this.isAutonomy ? this.eventsWrapped : this.events;
                            tempEvents
                                .emit(beacon_sdk_1.BeaconEvent.PAIR_INIT, {
                                p2pPeerInfo: () => {
                                    p2pTransport.connect().then().catch(console.error);
                                    return p2pTransport.getPairingRequestInfo();
                                },
                                postmessagePeerInfo: () => postMessageTransport.getPairingRequestInfo(),
                                preferredNetwork: this.preferredNetwork,
                                abortedHandler: () => {
                                    console.log('ABORTED');
                                    this._initPromise = undefined;
                                },
                                disclaimerText: this.disclaimerText
                            })
                                .catch((emitError) => console.warn(emitError));
                        }))
                            .catch((error) => {
                            this._initPromise = undefined;
                            console.error(error);
                        });
                    }
                }
            }));
            return this._initPromise;
        });
    }
    /**
     * Returns the active account
     */
    getActiveAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._activeAccount.promise;
        });
    }
    /**
     * Sets the active account
     *
     * @param account The account that will be set as the active account
     */
    setActiveAccount(account) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._activeAccount.isSettled()) {
                // If the promise has already been resolved we need to create a new one.
                this._activeAccount = beacon_sdk_1.ExposedPromise.resolve(account);
            }
            else {
                this._activeAccount.resolve(account);
            }
            if (account) {
                const origin = account.origin.type;
                yield this.initInternalTransports();
                // Select the transport that matches the active account
                if (origin === beacon_sdk_1.Origin.EXTENSION) {
                    yield this.setTransport(this.postMessageTransport);
                }
                else if (origin === beacon_sdk_1.Origin.P2P) {
                    yield this.setTransport(this.p2pTransport);
                }
                const peer = yield this.getPeer(account);
                yield this.setActivePeer(peer);
            }
            else {
                yield this.setActivePeer(undefined);
                yield this.setTransport(undefined);
            }
            yield this.storage.set(beacon_dapp_1.StorageKey.ACTIVE_ACCOUNT, account ? account.accountIdentifier : undefined);
            yield this.events.emit(beacon_sdk_1.BeaconEvent.ACTIVE_ACCOUNT_SET, account);
            return;
        });
    }
    /**
     * Clear the active account
     */
    clearActiveAccount() {
        return this.setActiveAccount();
    }
    setColorMode(colorMode) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, beacon_sdk_1.setColorMode)(colorMode);
        });
    }
    getColorMode() {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, beacon_sdk_1.getColorMode)();
        });
    }
    /**
     * @deprecated
     *
     * Use getOwnAppMetadata instead
     */
    getAppMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getOwnAppMetadata();
        });
    }
    showPrepare() {
        return __awaiter(this, void 0, void 0, function* () {
            const walletInfo = yield (() => __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.getWalletInfo();
                }
                catch (_a) {
                    return undefined;
                }
            }))();
            yield this.events.emit(beacon_sdk_1.BeaconEvent.SHOW_PREPARE, { walletInfo });
        });
    }
    hideUI(elements) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.events.emit(beacon_sdk_1.BeaconEvent.HIDE_UI, elements);
        });
    }
    /**
     * Will remove the account from the local storage and set a new active account if necessary.
     *
     * @param accountIdentifier ID of the account
     */
    removeAccount(accountIdentifier) {
        const _super = Object.create(null, {
            removeAccount: { get: () => super.removeAccount }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const removeAccountResult = _super.removeAccount.call(this, accountIdentifier);
            const activeAccount = yield this.getActiveAccount();
            if (activeAccount && activeAccount.accountIdentifier === accountIdentifier) {
                yield this.setActiveAccount(undefined);
            }
            return removeAccountResult;
        });
    }
    /**
     * Remove all accounts and set active account to undefined
     */
    removeAllAccounts() {
        const _super = Object.create(null, {
            removeAllAccounts: { get: () => super.removeAllAccounts }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.removeAllAccounts.call(this);
            yield this.setActiveAccount(undefined);
        });
    }
    /**
     * Removes a peer and all the accounts that have been connected through that peer
     *
     * @param peer Peer to be removed
     */
    removePeer(peer, sendDisconnectToPeer = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const transport = yield this.transport;
            const removePeerResult = transport.removePeer(peer);
            yield this.removeAccountsForPeers([peer]);
            if (sendDisconnectToPeer) {
                yield this.sendDisconnectToPeer(peer, transport);
            }
            return removePeerResult;
        });
    }
    /**
     * Remove all peers and all accounts that have been connected through those peers
     */
    removeAllPeers(sendDisconnectToPeers = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const transport = yield this.transport;
            const peers = yield transport.getPeers();
            const removePeerResult = transport.removeAllPeers();
            yield this.removeAccountsForPeers(peers);
            if (sendDisconnectToPeers) {
                const disconnectPromises = peers.map((peer) => this.sendDisconnectToPeer(peer, transport));
                yield Promise.all(disconnectPromises);
            }
            return removePeerResult;
        });
    }
    /**
     * Allows the user to subscribe to specific events that are fired in the SDK
     *
     * @param internalEvent The event to subscribe to
     * @param eventCallback The callback that will be called when the event occurs
     */
    subscribeToEvent(internalEvent, eventCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.events.on(internalEvent, eventCallback);
        });
    }
    /**
     * Check if we have permissions to send the specific message type to the active account.
     * If no active account is set, only permission requests are allowed.
     *
     * @param type The type of the message
     */
    checkPermissions(type) {
        return __awaiter(this, void 0, void 0, function* () {
            if (type === beacon_sdk_1.BeaconMessageType.PermissionRequest) {
                return true;
            }
            const activeAccount = yield this.getActiveAccount();
            if (!activeAccount) {
                throw yield this.sendInternalError('No active account set!');
            }
            const permissions = activeAccount.scopes;
            switch (type) {
                case beacon_sdk_1.BeaconMessageType.OperationRequest:
                    return permissions.includes(beacon_sdk_1.PermissionScope.OPERATION_REQUEST);
                case beacon_sdk_1.BeaconMessageType.SignPayloadRequest:
                    return permissions.includes(beacon_sdk_1.PermissionScope.SIGN);
                // TODO: ENCRYPTION
                // case BeaconMessageType.EncryptPayloadRequest:
                //   return permissions.includes(PermissionScope.ENCRYPT)
                case beacon_sdk_1.BeaconMessageType.BroadcastRequest:
                    return true;
                default:
                    return false;
            }
        });
    }
    sendNotification(title, message, payload, protocolIdentifier) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const activeAccount = yield this.getActiveAccount();
            if (!activeAccount ||
                (activeAccount &&
                    !activeAccount.scopes.includes(beacon_sdk_1.PermissionScope.NOTIFICATION) &&
                    !activeAccount.notification)) {
                throw new Error('notification permissions not given');
            }
            if (!((_a = activeAccount.notification) === null || _a === void 0 ? void 0 : _a.token)) {
                throw new Error('No AccessToken');
            }
            const url = (_b = activeAccount.notification) === null || _b === void 0 ? void 0 : _b.apiUrl;
            if (!url) {
                throw new Error('No Push URL set');
            }
            return this.sendNotificationWithAccessToken({
                url,
                recipient: activeAccount.address,
                title,
                body: message,
                payload,
                protocolIdentifier,
                accessToken: (_c = activeAccount.notification) === null || _c === void 0 ? void 0 : _c.token
            });
        });
    }
    addBlockchain(chain) {
        this.blockchains.set(chain.identifier, chain);
        chain.getWalletLists().then((walletLists) => {
            (0, beacon_sdk_1.setDesktopList)(walletLists.desktopList);
            (0, beacon_sdk_1.setExtensionList)(walletLists.extensionList);
            (0, beacon_sdk_1.setWebList)(walletLists.webList);
            (0, beacon_sdk_1.setiOSList)(walletLists.iOSList);
        });
    }
    removeBlockchain(chainIdentifier) {
        this.blockchains.delete(chainIdentifier);
    }
    /** Generic messages */
    permissionRequest(input) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('PERMISSION REQUEST');
            const blockchain = this.blockchains.get(input.blockchainIdentifier);
            if (!blockchain) {
                throw new Error(`Blockchain "${input.blockchainIdentifier}" not supported by dAppClient`);
            }
            const request = Object.assign(Object.assign({}, input), { type: beacon_sdk_1.BeaconMessageType.PermissionRequest, blockchainData: Object.assign(Object.assign({}, input.blockchainData), { appMetadata: yield this.getOwnAppMetadata() }) });
            console.log('REQUESTION PERMIMISSION V3', 'xxx', request);
            const { message: response, connectionInfo } = yield this.makeRequestV3(request).catch((_requestError) => __awaiter(this, void 0, void 0, function* () {
                throw new Error('TODO');
                // throw await this.handleRequestError(request, requestError)
            }));
            console.log('RESPONSE V3', response, connectionInfo);
            const partialAccountInfos = yield blockchain.getAccountInfosFromPermissionResponse(response.message);
            // const accountInfo: AccountInfo = {
            const accountInfo = {
                accountIdentifier: partialAccountInfos[0].accountId,
                senderId: response.senderId,
                origin: {
                    type: connectionInfo.origin,
                    id: connectionInfo.id
                },
                address: partialAccountInfos[0].address,
                publicKey: partialAccountInfos[0].publicKey,
                scopes: response.message.blockchainData.scopes,
                connectedAt: new Date().getTime(),
                chainData: response.message.blockchainData
            };
            yield this.accountManager.addAccount(accountInfo);
            yield this.setActiveAccount(accountInfo);
            yield blockchain.handleResponse({
                request,
                account: accountInfo,
                output: response,
                blockExplorer: this.blockExplorer,
                connectionContext: connectionInfo,
                walletInfo: yield this.getWalletInfo()
            });
            yield this.notifySuccess(request, {
                account: accountInfo,
                output: {
                    address: partialAccountInfos[0].address,
                    network: { type: beacon_dapp_1.NetworkType.MAINNET },
                    scopes: [beacon_sdk_1.PermissionScope.OPERATION_REQUEST]
                },
                blockExplorer: this.blockExplorer,
                connectionContext: connectionInfo,
                walletInfo: yield this.getWalletInfo()
            });
            // return output
            return response.message;
        });
    }
    request(input) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('REQUEST', input);
            const blockchain = this.blockchains.get(input.blockchainIdentifier);
            if (!blockchain) {
                throw new Error(`Blockchain "${blockchain}" not supported by dAppClient`);
            }
            yield blockchain.validateRequest(input);
            const activeAccount = yield this.getActiveAccount();
            if (!activeAccount) {
                throw yield this.sendInternalError('No active account!');
            }
            const request = Object.assign(Object.assign({}, input), { type: beacon_sdk_1.BeaconMessageType.BlockchainRequest, accountId: activeAccount.accountIdentifier });
            const { message: response, connectionInfo } = yield this.makeRequestV3(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {
                console.error(requestError);
                throw new Error('TODO');
                // throw await this.handleRequestError(request, requestError)
            }));
            yield blockchain.handleResponse({
                request,
                account: activeAccount,
                output: response,
                blockExplorer: this.blockExplorer,
                connectionContext: connectionInfo,
                walletInfo: yield this.getWalletInfo()
            });
            return response.message;
        });
    }
    /**
     * Send a permission request to the DApp. This should be done as the first step. The wallet will respond
     * with an publicKey and permissions that were given. The account returned will be set as the "activeAccount"
     * and will be used for the following requests.
     *
     * @param input The message details we need to prepare the PermissionRequest message.
     */
    requestPermissions(input, isAutonomy) {
        return __awaiter(this, void 0, void 0, function* () {
            this.isAutonomy = isAutonomy || false;
            const request = {
                appMetadata: yield this.getOwnAppMetadata(),
                type: beacon_sdk_1.BeaconMessageType.PermissionRequest,
                network: input && input.network ? input.network : { type: beacon_dapp_1.NetworkType.MAINNET },
                scopes: input && input.scopes
                    ? input.scopes
                    : [beacon_sdk_1.PermissionScope.OPERATION_REQUEST, beacon_sdk_1.PermissionScope.SIGN]
            };
            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {
                throw yield this.handleRequestError(request, requestError);
            }));
            // TODO: Migration code. Remove sometime after 1.0.0 release.
            const publicKey = message.publicKey || message.pubkey || message.pubKey;
            const address = yield (0, beacon_sdk_1.getAddressFromPublicKey)(publicKey);
            const accountInfo = {
                accountIdentifier: yield (0, beacon_sdk_1.getAccountIdentifier)(address, message.network),
                senderId: message.senderId,
                origin: {
                    type: connectionInfo.origin,
                    id: connectionInfo.id
                },
                address,
                publicKey,
                network: message.network,
                scopes: message.scopes,
                threshold: message.threshold,
                notification: message.notification,
                connectedAt: new Date().getTime()
            };
            yield this.accountManager.addAccount(accountInfo);
            yield this.setActiveAccount(accountInfo);
            const output = Object.assign(Object.assign({}, message), { address,
                accountInfo });
            yield this.notifySuccess(request, {
                account: accountInfo,
                output,
                blockExplorer: this.blockExplorer,
                connectionContext: connectionInfo,
                walletInfo: yield this.getWalletInfo()
            });
            return output;
        });
    }
    /**
     * This method will send a "SignPayloadRequest" to the wallet. This method is meant to be used to sign
     * arbitrary data (eg. a string). It will return the signature in the format of "edsig..."
     *
     * @param input The message details we need to prepare the SignPayloadRequest message.
     */
    requestSignPayload(input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!input.payload) {
                throw yield this.sendInternalError('Payload must be provided');
            }
            const activeAccount = yield this.getActiveAccount();
            if (!activeAccount) {
                throw yield this.sendInternalError('No active account!');
            }
            const payload = input.payload;
            if (typeof payload !== 'string') {
                throw new Error('Payload must be a string');
            }
            const signingType = (() => {
                switch (input.signingType) {
                    case beacon_sdk_1.SigningType.OPERATION:
                        if (!payload.startsWith('03')) {
                            throw new Error('When using signing type "OPERATION", the payload must start with prefix "03"');
                        }
                        return beacon_sdk_1.SigningType.OPERATION;
                    case beacon_sdk_1.SigningType.MICHELINE:
                        if (!payload.startsWith('05')) {
                            throw new Error('When using signing type "MICHELINE", the payload must start with prefix "05"');
                        }
                        return beacon_sdk_1.SigningType.MICHELINE;
                    case beacon_sdk_1.SigningType.RAW:
                    default:
                        return beacon_sdk_1.SigningType.RAW;
                }
            })();
            const request = {
                type: beacon_sdk_1.BeaconMessageType.SignPayloadRequest,
                signingType,
                payload,
                sourceAddress: input.sourceAddress || activeAccount.address
            };
            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {
                throw yield this.handleRequestError(request, requestError);
            }));
            yield this.notifySuccess(request, {
                account: activeAccount,
                output: message,
                connectionContext: connectionInfo,
                walletInfo: yield this.getWalletInfo()
            });
            return message;
        });
    }
    /**
     * This method will send an "EncryptPayloadRequest" to the wallet. This method is meant to be used to encrypt or decrypt
     * arbitrary data (eg. a string). It will return the encrypted or decrypted payload
     *
     * @param input The message details we need to prepare the EncryptPayloadRequest message.
     */
    // TODO: ENCRYPTION
    // public async requestEncryptPayload(
    //   input: RequestEncryptPayloadInput
    // ): Promise<EncryptPayloadResponseOutput> {
    //   if (!input.payload) {
    //     throw await this.sendInternalError('Payload must be provided')
    //   }
    //   const activeAccount: AccountInfo | undefined = await this.getActiveAccount()
    //   if (!activeAccount) {
    //     throw await this.sendInternalError('No active account!')
    //   }
    //   const payload = input.payload
    //   if (typeof payload !== 'string') {
    //     throw new Error('Payload must be a string')
    //   }
    //   if (typeof input.encryptionCryptoOperation === 'undefined') {
    //     throw new Error('encryptionCryptoOperation must be defined')
    //   }
    //   if (typeof input.encryptionType === 'undefined') {
    //     throw new Error('encryptionType must be defined')
    //   }
    //   const request: EncryptPayloadRequestInput = {
    //     type: BeaconMessageType.EncryptPayloadRequest,
    //     cryptoOperation: input.encryptionCryptoOperation,
    //     encryptionType: input.encryptionType,
    //     payload,
    //     sourceAddress: input.sourceAddress || activeAccount.address
    //   }
    //   const { message, connectionInfo } = await this.makeRequest<
    //     EncryptPayloadRequest,
    //     EncryptPayloadResponse
    //   >(request).catch(async (requestError: ErrorResponse) => {
    //     throw await this.handleRequestError(request, requestError)
    //   })
    //   await this.notifySuccess(request, {
    //     account: activeAccount,
    //     output: message,
    //     connectionContext: connectionInfo,
    //     walletInfo: await this.getWalletInfo()
    //   })
    //   return message
    // }
    /**
     * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,
     * eg. transaction or delegation. Not all properties have to be provided. Data like "counter" and fees will be
     * fetched and calculated by the wallet (but they can still be provided if required).
     *
     * @param input The message details we need to prepare the OperationRequest message.
     */
    requestOperation(input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!input.operationDetails) {
                throw yield this.sendInternalError('Operation details must be provided');
            }
            const activeAccount = yield this.getActiveAccount();
            if (!activeAccount) {
                throw yield this.sendInternalError('No active account!');
            }
            const request = {
                type: beacon_sdk_1.BeaconMessageType.OperationRequest,
                network: activeAccount.network || { type: beacon_dapp_1.NetworkType.MAINNET },
                operationDetails: input.operationDetails,
                sourceAddress: activeAccount.address || ''
            };
            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {
                throw yield this.handleRequestError(request, requestError);
            }));
            yield this.notifySuccess(request, {
                account: activeAccount,
                output: message,
                blockExplorer: this.blockExplorer,
                connectionContext: connectionInfo,
                walletInfo: yield this.getWalletInfo()
            });
            return message;
        });
    }
    /**
     * Sends a "BroadcastRequest" to the wallet. This method can be used to inject an already signed transaction
     * to the network.
     *
     * @param input The message details we need to prepare the BroadcastRequest message.
     */
    requestBroadcast(input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!input.signedTransaction) {
                throw yield this.sendInternalError('Signed transaction must be provided');
            }
            const network = input.network || { type: beacon_dapp_1.NetworkType.MAINNET };
            const request = {
                type: beacon_sdk_1.BeaconMessageType.BroadcastRequest,
                network,
                signedTransaction: input.signedTransaction
            };
            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {
                throw yield this.handleRequestError(request, requestError);
            }));
            yield this.notifySuccess(request, {
                network,
                output: message,
                blockExplorer: this.blockExplorer,
                connectionContext: connectionInfo,
                walletInfo: yield this.getWalletInfo()
            });
            return message;
        });
    }
    setActivePeer(peer) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._activePeer.isSettled()) {
                // If the promise has already been resolved we need to create a new one.
                this._activePeer = beacon_sdk_1.ExposedPromise.resolve(peer);
            }
            else {
                this._activePeer.resolve(peer);
            }
            if (peer) {
                yield this.initInternalTransports();
                if (peer.type === 'postmessage-pairing-response') {
                    yield this.setTransport(this.postMessageTransport);
                }
                else if (peer.type === 'p2p-pairing-response') {
                    yield this.setTransport(this.p2pTransport);
                }
            }
            return;
        });
    }
    /**
     * A "setter" for when the transport needs to be changed.
     */
    setTransport(transport) {
        const _super = Object.create(null, {
            setTransport: { get: () => super.setTransport }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (!transport) {
                this._initPromise = undefined;
            }
            const result = _super.setTransport.call(this, transport);
            yield this.events.emit(beacon_sdk_1.BeaconEvent.ACTIVE_TRANSPORT_SET, transport);
            return result;
        });
    }
    /**
     * This method will emit an internal error message.
     *
     * @param errorMessage The error message to send.
     */
    sendInternalError(errorMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.events.emit(beacon_sdk_1.BeaconEvent.INTERNAL_ERROR, { text: errorMessage });
            throw new Error(errorMessage);
        });
    }
    /**
     * This method will remove all accounts associated with a specific peer.
     *
     * @param peersToRemove An array of peers for which accounts should be removed
     */
    removeAccountsForPeers(peersToRemove) {
        return __awaiter(this, void 0, void 0, function* () {
            const accounts = yield this.accountManager.getAccounts();
            const peerIdsToRemove = peersToRemove.map((peer) => peer.senderId);
            // Remove all accounts with origin of the specified peer
            const accountsToRemove = accounts.filter((account) => peerIdsToRemove.includes(account.senderId));
            const accountIdentifiersToRemove = accountsToRemove.map((accountInfo) => accountInfo.accountIdentifier);
            yield this.accountManager.removeAccounts(accountIdentifiersToRemove);
            // Check if one of the accounts that was removed was the active account and if yes, set it to undefined
            const activeAccount = yield this.getActiveAccount();
            if (activeAccount) {
                if (accountIdentifiersToRemove.includes(activeAccount.accountIdentifier)) {
                    yield this.setActiveAccount(undefined);
                }
            }
        });
    }
    /**
     * This message handles errors that we receive from the wallet.
     *
     * @param request The request we sent
     * @param beaconError The error we received
     */
    handleRequestError(request, beaconError) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.error('handleRequestError', 'error response', beaconError);
            if (beaconError.errorType) {
                const buttons = [];
                if (beaconError.errorType === beacon_sdk_1.BeaconErrorType.NO_PRIVATE_KEY_FOUND_ERROR) {
                    const actionCallback = () => __awaiter(this, void 0, void 0, function* () {
                        const operationRequest = request;
                        // if the account we requested is not available, we remove it locally
                        let accountInfo;
                        if (operationRequest.sourceAddress && operationRequest.network) {
                            const accountIdentifier = yield (0, beacon_sdk_1.getAccountIdentifier)(operationRequest.sourceAddress, operationRequest.network);
                            accountInfo = yield this.getAccount(accountIdentifier);
                            if (accountInfo) {
                                yield this.removeAccount(accountInfo.accountIdentifier);
                            }
                        }
                    });
                    buttons.push({ text: 'Remove account', actionCallback });
                }
                const peer = yield this.getPeer();
                const activeAccount = yield this.getActiveAccount();
                // If we sent a permission request, received an error and there is no active account, we need to reset the DAppClient.
                // This most likely means that the user rejected the first permission request after pairing a wallet, so we "forget" the paired wallet to allow the user to pair again.
                if (request.type === beacon_sdk_1.BeaconMessageType.PermissionRequest &&
                    (yield this.getActiveAccount()) === undefined) {
                    this._initPromise = undefined;
                    this.postMessageTransport = undefined;
                    this.p2pTransport = undefined;
                    yield this.setTransport();
                    yield this.setActivePeer();
                }
                this.events
                    .emit(beacon_message_events_1.messageEvents[request.type].error, {
                    errorResponse: beaconError,
                    walletInfo: yield this.getWalletInfo(peer, activeAccount),
                    errorMessages: this.errorMessages
                }, buttons)
                    .catch((emitError) => logger.error('handleRequestError', emitError));
                throw beacon_sdk_1.BeaconError.getError(beaconError.errorType, beaconError.errorData);
            }
            throw beaconError;
        });
    }
    /**
     * This message will send an event when we receive a successful response to one of the requests we sent.
     *
     * @param request The request we sent
     * @param response The response we received
     */
    notifySuccess(request, response) {
        return __awaiter(this, void 0, void 0, function* () {
            this.events
                .emit(beacon_message_events_1.messageEvents[request.type].success, response)
                .catch((emitError) => console.warn(emitError));
        });
    }
    getWalletInfo(peer, account) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const selectedAccount = account ? account : yield this.getActiveAccount();
            const selectedPeer = peer ? peer : yield this.getPeer(selectedAccount);
            let walletInfo;
            if (selectedAccount) {
                walletInfo = yield this.appMetadataManager.getAppMetadata(selectedAccount.senderId);
            }
            const typedPeer = selectedPeer;
            if (!walletInfo) {
                walletInfo = {
                    name: typedPeer.name,
                    icon: typedPeer.icon
                };
            }
            const lowerCaseCompare = (str1, str2) => {
                if (str1 && str2) {
                    return str1.toLowerCase() === str2.toLowerCase();
                }
                return false;
            };
            let selectedApp;
            let type;
            // TODO: Remove once all wallets send the icon?
            if ((0, beacon_sdk_1.getiOSList)().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) {
                selectedApp = (0, beacon_sdk_1.getiOSList)().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name));
                type = 'mobile';
            }
            else if ((0, beacon_sdk_1.getWebList)().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) {
                selectedApp = (0, beacon_sdk_1.getWebList)().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name));
                type = 'web';
            }
            else if ((0, beacon_sdk_1.getDesktopList)().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) {
                selectedApp = (0, beacon_sdk_1.getDesktopList)().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name));
                type = 'desktop';
            }
            else if ((0, beacon_sdk_1.getExtensionList)().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) {
                selectedApp = (0, beacon_sdk_1.getExtensionList)().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name));
                type = 'extension';
            }
            if (selectedApp) {
                let deeplink;
                if (selectedApp.hasOwnProperty('links')) {
                    deeplink = selectedApp.links[(_a = selectedAccount === null || selectedAccount === void 0 ? void 0 : selectedAccount.network.type) !== null && _a !== void 0 ? _a : this.preferredNetwork];
                }
                else if (selectedApp.hasOwnProperty('deepLink')) {
                    deeplink = selectedApp.deepLink;
                }
                return {
                    name: walletInfo.name,
                    icon: (_b = walletInfo.icon) !== null && _b !== void 0 ? _b : selectedApp.logo,
                    deeplink,
                    type
                };
            }
            return walletInfo;
        });
    }
    getPeer(account) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            let peer;
            if (account) {
                logger.log('getPeer', 'We have an account', account);
                const postMessagePeers = (_b = (yield ((_a = this.postMessageTransport) === null || _a === void 0 ? void 0 : _a.getPeers()))) !== null && _b !== void 0 ? _b : [];
                const p2pPeers = (_d = (yield ((_c = this.p2pTransport) === null || _c === void 0 ? void 0 : _c.getPeers()))) !== null && _d !== void 0 ? _d : [];
                const peers = [...postMessagePeers, ...p2pPeers];
                logger.log('getPeer', 'Found peers', peers, account);
                peer = peers.find((peerEl) => peerEl.senderId === account.senderId);
                if (!peer) {
                    // We could not find an exact match for a sender, so we most likely received it over a relay
                    peer = peers.find((peerEl) => peerEl.extensionId === account.origin.id);
                }
            }
            else {
                peer = yield this._activePeer.promise;
                logger.log('getPeer', 'Active peer', peer);
            }
            if (!peer) {
                throw new Error('No matching peer found.');
            }
            return peer;
        });
    }
    /**
     * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected
     * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent
     * to the DApp over the transport.
     *
     * @param requestInput The BeaconMessage to be sent to the wallet
     * @param account The account that the message will be sent to
     */
    makeRequest(requestInput) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const messageId = yield (0, beacon_sdk_1.generateGUID)();
            console.time(messageId);
            logger.log('makeRequest', 'starting');
            yield this.init();
            console.timeLog(messageId, 'init done');
            logger.log('makeRequest', 'after init');
            if (yield this.addRequestAndCheckIfRateLimited()) {
                this.events
                    .emit(beacon_sdk_1.BeaconEvent.LOCAL_RATE_LIMIT_REACHED)
                    .catch((emitError) => console.warn(emitError));
                throw new Error('rate limit reached');
            }
            if (!(yield this.checkPermissions(requestInput.type))) {
                this.events.emit(beacon_sdk_1.BeaconEvent.NO_PERMISSIONS).catch((emitError) => console.warn(emitError));
                throw new Error('No permissions to send this request to wallet!');
            }
            if (!this.beaconId) {
                throw yield this.sendInternalError('BeaconID not defined');
            }
            const request = Object.assign({ id: messageId, version: '2', senderId: yield (0, beacon_sdk_1.getSenderId)(yield this.beaconId) }, requestInput);
            const exposed = new beacon_sdk_1.ExposedPromise();
            this.addOpenRequest(request.id, exposed);
            const payload = yield new beacon_core_1.Serializer().serialize(request);
            const account = yield this.getActiveAccount();
            const peer = yield this.getPeer(account);
            const walletInfo = yield this.getWalletInfo(peer, account);
            logger.log('makeRequest', 'sending message', request);
            console.timeLog(messageId, 'sending');
            try {
                yield (yield this.transport).send(payload, peer);
            }
            catch (sendError) {
                this.events.emit(beacon_sdk_1.BeaconEvent.INTERNAL_ERROR, {
                    text: 'Unable to send message. If this problem persists, please reset the connection and pair your wallet again.',
                    buttons: [
                        {
                            text: 'Reset Connection',
                            actionCallback: () => __awaiter(this, void 0, void 0, function* () {
                                yield (0, beacon_sdk_1.closeToast)();
                                this.disconnect();
                            })
                        }
                    ]
                });
                console.timeLog(messageId, 'send error');
                throw sendError;
            }
            console.timeLog(messageId, 'sent');
            this.events
                .emit(beacon_message_events_1.messageEvents[requestInput.type].sent, {
                walletInfo: Object.assign(Object.assign({}, walletInfo), { name: (_a = walletInfo.name) !== null && _a !== void 0 ? _a : 'Wallet' }),
                extraInfo: {
                    resetCallback: () => __awaiter(this, void 0, void 0, function* () {
                        this.disconnect();
                    })
                }
            })
                .catch((emitError) => console.warn(emitError));
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return exposed.promise; // TODO: fix type
        });
    }
    /**
     * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected
     * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent
     * to the DApp over the transport.
     *
     * @param requestInput The BeaconMessage to be sent to the wallet
     * @param account The account that the message will be sent to
     */
    makeRequestV3(requestInput) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const messageId = yield (0, beacon_sdk_1.generateGUID)();
            console.time(messageId);
            logger.log('makeRequest', 'starting');
            yield this.init();
            console.timeLog(messageId, 'init done');
            logger.log('makeRequest', 'after init');
            if (yield this.addRequestAndCheckIfRateLimited()) {
                this.events
                    .emit(beacon_sdk_1.BeaconEvent.LOCAL_RATE_LIMIT_REACHED)
                    .catch((emitError) => console.warn(emitError));
                throw new Error('rate limit reached');
            }
            // if (!(await this.checkPermissions(requestInput.type as BeaconMessageType))) {
            //   this.events.emit(BeaconEvent.NO_PERMISSIONS).catch((emitError) => console.warn(emitError))
            //   throw new Error('No permissions to send this request to wallet!')
            // }
            if (!this.beaconId) {
                throw yield this.sendInternalError('BeaconID not defined');
            }
            const request = {
                id: messageId,
                version: '3',
                senderId: yield (0, beacon_sdk_1.getSenderId)(yield this.beaconId),
                message: requestInput
            };
            const exposed = new beacon_sdk_1.ExposedPromise();
            this.addOpenRequest(request.id, exposed);
            const payload = yield new beacon_core_1.Serializer().serialize(request);
            const account = yield this.getActiveAccount();
            const peer = yield this.getPeer(account);
            const walletInfo = yield this.getWalletInfo(peer, account);
            logger.log('makeRequest', 'sending message', request);
            console.timeLog(messageId, 'sending');
            try {
                yield (yield this.transport).send(payload, peer);
            }
            catch (sendError) {
                this.events.emit(beacon_sdk_1.BeaconEvent.INTERNAL_ERROR, {
                    text: 'Unable to send message. If this problem persists, please reset the connection and pair your wallet again.',
                    buttons: [
                        {
                            text: 'Reset Connection',
                            actionCallback: () => __awaiter(this, void 0, void 0, function* () {
                                yield (0, beacon_sdk_1.closeToast)();
                                this.disconnect();
                            })
                        }
                    ]
                });
                console.timeLog(messageId, 'send error');
                throw sendError;
            }
            console.timeLog(messageId, 'sent');
            const index = requestInput.type;
            this.events
                .emit(beacon_message_events_1.messageEvents[index].sent, {
                walletInfo: Object.assign(Object.assign({}, walletInfo), { name: (_a = walletInfo.name) !== null && _a !== void 0 ? _a : 'Wallet' }),
                extraInfo: {
                    resetCallback: () => __awaiter(this, void 0, void 0, function* () {
                        this.disconnect();
                    })
                }
            })
                .catch((emitError) => console.warn(emitError));
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return exposed.promise; // TODO: fix type
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this.postMessageTransport = undefined;
            this.p2pTransport = undefined;
            yield Promise.all([this.clearActiveAccount(), (yield this.transport).disconnect()]);
        });
    }
    /**
     * Adds a requests to the "openRequests" set so we know what messages have already been answered/handled.
     *
     * @param id The ID of the message
     * @param promise A promise that resolves once the response for that specific message is received
     */
    addOpenRequest(id, promise) {
        logger.log('addOpenRequest', this.name, `adding request ${id} and waiting for answer`);
        this.openRequests.set(id, promise);
    }
    sendNotificationWithAccessToken(notification) {
        return __awaiter(this, void 0, void 0, function* () {
            const { url, recipient, title, body, payload, protocolIdentifier, accessToken } = notification;
            const timestamp = new Date().toISOString();
            const keypair = yield this.keyPair;
            const rawPublicKey = keypair.publicKey;
            const prefix = Buffer.from(new Uint8Array([13, 15, 37, 217]));
            const publicKey = bs58check.encode(Buffer.concat([prefix, Buffer.from(rawPublicKey)]));
            const constructedString = [
                'Tezos Signed Message: ',
                recipient,
                title,
                body,
                timestamp,
                payload
            ].join(' ');
            const bytes = (0, beacon_sdk_1.toHex)(constructedString);
            const payloadBytes = '05' + '01' + bytes.length.toString(16).padStart(8, '0') + bytes;
            const signature = yield (0, beacon_sdk_1.signMessage)(payloadBytes, {
                secretKey: Buffer.from(keypair.secretKey)
            });
            const notificationResponse = yield axios_1.default.post(`${url}/send`, {
                recipient,
                title,
                body,
                timestamp,
                payload,
                accessToken,
                protocolIdentifier,
                sender: {
                    name: this.name,
                    publicKey,
                    signature
                }
            });
            return notificationResponse.data;
        });
    }
}
exports.DAppClientWrapped = DAppClientWrapped;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./features-wrapped/events-wrapped":209,"@airgap/beacon-core":58,"@airgap/beacon-dapp":78,"@airgap/beacon-dapp/dist/cjs/beacon-message-events":75,"@airgap/beacon-dapp/dist/cjs/transports/DappP2PTransport":79,"@airgap/beacon-dapp/dist/cjs/transports/DappPostMessageTransport":80,"@airgap/beacon-sdk":85,"axios":212,"bs58check":251,"buffer":3}],207:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.openAlertWrapped = void 0;
const html_elements_1 = require("@airgap/beacon-ui/dist/cjs/utils/html-elements");
const templates_1 = require("@airgap/beacon-ui/dist/cjs/utils/templates");
const alert_templates_1 = require("@airgap/beacon-ui/dist/cjs/ui/alert/alert-templates");
const Alert_1 = require("@airgap/beacon-ui/dist/cjs/ui/alert/Alert");
const PairingAlertWrapped_1 = require("./PairingAlertWrapped");
const beacon_sdk_1 = require("@airgap/beacon-sdk");
const timeout = {};
let lastFocusedElement;
const addQR = (dataString) => {
    if (typeof dataString === 'string') {
        return (0, html_elements_1.createSanitizedElement)('div', [], [['id', 'beacon--qr__container']], [
            (0, html_elements_1.createSanitizedElement)('div', [], [['id', 'beacon--qr__copy__container']], [
                (0, html_elements_1.createSanitizedElement)('button', ['beacon-modal__button--outline'], [['id', 'beacon--qr__copy']], 'Copy')
            ])
        ]);
    }
    return (0, html_elements_1.createSanitizedElement)('span', [], [], '');
};
const formatAlert = (id, body, title, buttons, hasPairingPayload) => {
    const callToAction = title;
    const buttonsHtml = buttons.map((button, index) => (0, html_elements_1.createSanitizedElement)('button', [`beacon-modal__button${button.style === 'outline' ? '--outline' : ''}`], [['id', `beacon-alert-${id}-${index}`]], button.text));
    let allStyles = alert_templates_1.alertTemplates.default.css;
    if (hasPairingPayload) {
        allStyles += alert_templates_1.alertTemplates.pair.css;
    }
    const callToActionEl = (0, html_elements_1.createSanitizedElement)('span', [], [], callToAction);
    const alertEl = hasPairingPayload
        ? (0, templates_1.constructPairAlert)(id, [callToActionEl], buttonsHtml, [body])
        : (0, templates_1.constructDefaultAlert)(id, [callToActionEl], buttonsHtml, [body]);
    return {
        style: allStyles,
        html: alertEl
    };
};
/**
 * Show an alert
 *
 * @param alertConfig The configuration of the alert
 */
// eslint-disable-next-line complexity
const openAlertWrapped = (alertConfig) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const body = alertConfig.body;
    const data = alertConfig.data;
    const title = alertConfig.title;
    const timer = alertConfig.timer;
    const pairingPayload = alertConfig.pairingPayload;
    const disclaimer = alertConfig.disclaimerText;
    // eslint-disable-next-line @typescript-eslint/unbound-method
    const closeButtonCallback = alertConfig.closeButtonCallback;
    yield (0, beacon_sdk_1.closeAlerts)();
    const id = (yield (0, beacon_sdk_1.generateGUID)()).split('-').join('');
    const shadowRootEl = document.createElement('div');
    shadowRootEl.setAttribute('id', `beacon-alert-wrapper-${id}`);
    const shadowRoot = shadowRootEl.attachShadow({ mode: 'open' });
    const wrapper = document.createElement('div');
    wrapper.setAttribute('tabindex', `0`); // Make modal focussable
    shadowRoot.appendChild(wrapper);
    const buttons = [
        ...((_b = (_a = alertConfig.buttons) === null || _a === void 0 ? void 0 : _a.map((button) => {
            var _a, _b;
            return ({
                text: button.text,
                // eslint-disable-next-line @typescript-eslint/unbound-method
                actionCallback: (_a = button.actionCallback) !== null && _a !== void 0 ? _a : (() => Promise.resolve()),
                style: (_b = button.style) !== null && _b !== void 0 ? _b : 'outline'
            });
        })) !== null && _b !== void 0 ? _b : [])
    ];
    let formattedBody = pairingPayload
        ? addQR(body)
        : (0, html_elements_1.createSanitizedElement)('span', [], [], body !== null && body !== void 0 ? body : '');
    if (data) {
        formattedBody = (0, html_elements_1.createSanitizedElement)('span', [], [], [formattedBody, (0, html_elements_1.createSanitizedElement)('pre', [], [['style', 'text-align: left']], data)]);
    }
    const { style, html } = formatAlert(id, formattedBody, title, buttons, !!(pairingPayload === null || pairingPayload === void 0 ? void 0 : pairingPayload.p2pSyncCode));
    wrapper.appendChild(html);
    const styleEl = document.createElement('style');
    styleEl.textContent = style;
    shadowRoot.appendChild(styleEl);
    if (timer) {
        timeout[id] = window.setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
            yield (0, Alert_1.closeAlert)(id);
        }), timer);
    }
    document.body.prepend(shadowRootEl);
    const closeButton = shadowRoot.getElementById(`beacon-alert-${id}-close`);
    const closeButtonClick = () => __awaiter(void 0, void 0, void 0, function* () {
        if (closeButtonCallback) {
            closeButtonCallback();
        }
        yield (0, Alert_1.closeAlert)(id);
    });
    if (disclaimer) {
        const disclaimerContainer = shadowRoot.getElementById(`beacon--disclaimer`);
        if (disclaimerContainer) {
            disclaimerContainer.innerText = disclaimer;
        }
    }
    const colorMode = (0, beacon_sdk_1.getColorMode)();
    const elm = shadowRoot.getElementById(`beacon-alert-modal-${id}`);
    if (elm) {
        elm.classList.add(`theme__${colorMode}`);
        elm.addEventListener('click', closeButtonClick); // Backdrop click dismisses alert
    }
    const modal = shadowRoot.querySelectorAll('.beacon-modal__wrapper');
    if (modal.length > 0) {
        modal[0].addEventListener('click', (event) => {
            event.stopPropagation();
        });
    }
    lastFocusedElement = document.activeElement; // Store which element has been focussed before the alert is shown
    wrapper.focus(); // Focus alert for accessibility
    buttons.forEach((button, index) => {
        const buttonElement = shadowRoot.getElementById(`beacon-alert-${id}-${index}`);
        if (buttonElement) {
            buttonElement.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {
                yield (0, Alert_1.closeAlert)(id);
                if (button.actionCallback) {
                    yield button.actionCallback();
                }
            }));
        }
    });
    if (closeButton) {
        closeButton.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {
            yield closeButtonClick();
        }));
    }
    window.addEventListener('keydown', (event) => __awaiter(void 0, void 0, void 0, function* () {
        if (event.key === 'Escape') {
            yield closeButtonClick();
        }
    }));
    if (pairingPayload) {
        yield (0, PairingAlertWrapped_1.preparePairingAlert)(id, shadowRoot, pairingPayload);
    }
    return id;
});
exports.openAlertWrapped = openAlertWrapped;

},{"./PairingAlertWrapped":208,"@airgap/beacon-sdk":85,"@airgap/beacon-ui/dist/cjs/ui/alert/Alert":123,"@airgap/beacon-ui/dist/cjs/ui/alert/alert-templates":126,"@airgap/beacon-ui/dist/cjs/utils/html-elements":132,"@airgap/beacon-ui/dist/cjs/utils/templates":135}],208:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.preparePairingAlert = void 0;
const beacon_sdk_1 = require("@airgap/beacon-sdk");
const Pairing_1 = require("@airgap/beacon-ui/dist/cjs/ui/alert/Pairing");
const html_elements_1 = require("@airgap/beacon-ui/dist/cjs/utils/html-elements");
const platform_1 = require("@airgap/beacon-ui/dist/cjs/utils/platform");
const get_tzip10_link_1 = require("@airgap/beacon-ui/dist/cjs/utils/get-tzip10-link");
const qr_1 = require("@airgap/beacon-ui/dist/cjs/utils/qr");
const logger = new beacon_sdk_1.Logger('Alert');
const serializer = new beacon_sdk_1.Serializer();
const preparePairingAlert = (id, shadowRoot, pairingPayload) => __awaiter(void 0, void 0, void 0, function* () {
    const getInfo = () => __awaiter(void 0, void 0, void 0, function* () {
        return Pairing_1.Pairing.getPairingInfo(pairingPayload, (_walletType, _wallet, keepOpen) => __awaiter(void 0, void 0, void 0, function* () {
            if (keepOpen) {
                return;
            }
            yield (0, beacon_sdk_1.closeAlerts)();
        }), () => __awaiter(void 0, void 0, void 0, function* () {
            switchPlatform();
        }));
    });
    const info = yield getInfo();
    const container = shadowRoot.getElementById(`pairing-container`);
    if (!container) {
        throw new Error('container not found');
    }
    const buttonListWrapper = document.createElement('span');
    container.appendChild(buttonListWrapper);
    info.buttons.forEach((button) => __awaiter(void 0, void 0, void 0, function* () {
        const randomId = yield (0, beacon_sdk_1.generateGUID)();
        const titleEl = (0, html_elements_1.createSanitizedElement)('div', ['beacon-list__title'], [], button.title);
        const buttonEl = (0, html_elements_1.createSanitizedElement)('button', ['beacon-modal__button', 'connect__btn'], [], button.text);
        const linkEl = document.createElement('a');
        linkEl.id = `button_${randomId}`;
        linkEl.appendChild(titleEl);
        linkEl.appendChild(buttonEl);
        buttonListWrapper.appendChild(linkEl);
        const shadowButtonEl = shadowRoot.getElementById(linkEl.id);
        if (shadowButtonEl) {
            shadowButtonEl.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {
                button.clickHandler();
            }));
        }
    }));
    const showWallet = (listEl, type, wallet) => {
        const altTag = `Open in ${wallet.name}`;
        const walletKey = wallet.key;
        const logoEl = wallet.logo
            ? (0, html_elements_1.createSanitizedElement)('div', [], [], [(0, html_elements_1.createSanitizedElement)('img', ['beacon-selection__img'], [['src', wallet.logo]], '')])
            : (0, html_elements_1.createSVGElement)(['beacon-selection__img', 'svg-inline--fa', 'fa-wallet', 'fa-w-16'], [
                ['aria-hidden', 'true'],
                ['focusable', 'false'],
                ['data-prefix', 'fas'],
                ['data-icon', 'wallet'],
                ['role', 'img'],
                ['xmlns', 'http://www.w3.org/2000/svg'],
                ['viewBox', '0 0 512 512'],
                ['style', 'enable-background:new 0 0 512 512;'],
                ['xml:space', 'preserve']
            ], [
                (0, html_elements_1.createSVGPathElement)([
                    [
                        'd',
                        'M376.2,181H152.9c-5.2,0-9.4-4.2-9.4-9.4s4.2-9.4,9.4-9.4h225c5.2,0,9.4-4.2,9.4-9.4c0-15.5-12.6-28.1-28.1-28.1H143.5c-20.7,0-37.5,16.8-37.5,37.5v187.5c0,20.7,16.8,37.5,37.5,37.5h232.7c16.4,0,29.8-12.6,29.8-28.1v-150C406,193.6,392.7,181,376.2,181z M349.8,302.9c-10.4,0-18.8-8.4-18.8-18.8s8.4-18.8,18.8-18.8s18.8,8.4,18.8,18.8S360.1,302.9,349.8,302.9z'
                    ]
                ])
            ]);
        const nameEl = (0, html_elements_1.createSanitizedElement)('div', ['beacon-selection__name'], [], [
            (0, html_elements_1.createSanitizedElement)('span', [], [], wallet.name),
            wallet.enabled ? undefined : (0, html_elements_1.createSanitizedElement)('p', [], [], 'Not installed')
        ]);
        const linkEl = (0, html_elements_1.createSanitizedElement)('a', ['beacon-selection__list', wallet.enabled ? '' : 'disabled'], [
            ['tabindex', '0'],
            ['id', `wallet_${walletKey}`],
            ['alt', altTag],
            ['target', '_blank']
        ], [nameEl, logoEl]);
        const el = document.createElement('span');
        el.appendChild(linkEl);
        listEl.appendChild(el);
        const walletEl = shadowRoot.getElementById(`wallet_${walletKey}`);
        const completeHandler = (event) => __awaiter(void 0, void 0, void 0, function* () {
            if (event && event.key !== 'Enter') {
                return;
            }
            wallet.clickHandler();
            const modalEl = shadowRoot.getElementById('beacon-modal__content');
            if (modalEl && type !== Pairing_1.WalletType.EXTENSION && type !== Pairing_1.WalletType.IOS) {
                (0, html_elements_1.removeAllChildren)(modalEl);
                modalEl.appendChild((0, html_elements_1.createSanitizedElement)('p', ['beacon-alert__title'], [], 'Establishing Connection..'));
                modalEl.appendChild((0, html_elements_1.createSanitizedElement)('div', ['progress-line'], [['id', 'beacon-toast-loader']], ''));
                modalEl.appendChild((0, html_elements_1.createSanitizedElement)('div', ['beacon--selected__container'], [], [
                    ...(wallet.logo
                        ? [
                            (0, html_elements_1.createSanitizedElement)('img', ['beacon-selection__img'], [['src', wallet.logo]], ''),
                            (0, html_elements_1.createSanitizedElement)('img', ['beacon--selection__name__lg'], [], wallet.name)
                        ]
                        : [])
                ]));
            }
        });
        if (walletEl) {
            walletEl.addEventListener('click', () => completeHandler());
            walletEl.addEventListener('keydown', completeHandler);
        }
    };
    const listContainer = document.createElement('span');
    container.appendChild(listContainer);
    const showWalletLists = (walletLists) => {
        (0, html_elements_1.removeAllChildren)(listContainer);
        walletLists.forEach((list) => {
            const listWrapperEl = document.createElement('div');
            listWrapperEl.classList.add('beacon-list__wrapper');
            listContainer.appendChild(listWrapperEl);
            listWrapperEl.appendChild((0, html_elements_1.createSanitizedElement)('div', ['beacon-list__title'], [], list.title));
            const listEl = document.createElement('span');
            listWrapperEl.appendChild(listEl);
            list.wallets.forEach((wallet) => __awaiter(void 0, void 0, void 0, function* () {
                showWallet(listEl, list.type, wallet);
            }));
        });
    };
    //   showWalletLists(info.walletLists)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const messageFn = (event) => __awaiter(void 0, void 0, void 0, function* () {
        if (event.data === 'extensionsUpdated') {
            const newInfo = yield getInfo();
            //   showWalletLists(newInfo.walletLists)
        }
    });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let closeFn;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    closeFn = (event) => {
        if (event.data === `closeAlert-${id}`) {
            beacon_sdk_1.windowRef.removeEventListener('message', messageFn);
            beacon_sdk_1.windowRef.removeEventListener('message', closeFn);
        }
    };
    beacon_sdk_1.windowRef.addEventListener('message', messageFn);
    beacon_sdk_1.windowRef.addEventListener('message', closeFn);
    const qr = shadowRoot.getElementById(`beacon--qr__container`);
    const copyButton = shadowRoot.getElementById(`beacon--qr__copy`);
    const titleEl = shadowRoot.getElementById(`beacon-title`);
    const platform = (0, platform_1.isAndroid)(window) ? 'android' : (0, platform_1.isIOS)(window) ? 'ios' : 'desktop';
    const mainText = shadowRoot.getElementById(`beacon-main-text`);
    const walletList = shadowRoot.getElementById(`pairing-container`);
    const switchButton = shadowRoot.getElementById(`beacon--switch__container`);
    if (switchButton) {
        switchButton.remove();
    }
    // if (mainText && walletList && switchButton && copyButton && qr && titleEl) {
    const clipboardFn = () => __awaiter(void 0, void 0, void 0, function* () {
        const code = pairingPayload
            ? yield serializer.serialize(yield pairingPayload.p2pSyncCode())
            : '';
        navigator.clipboard.writeText(code).then(() => {
            if (copyButton) {
                copyButton.innerText = 'Copied';
            }
            logger.log('Copying to clipboard was successful!');
        }, (err) => {
            logger.error('Could not copy text to clipboard: ', err);
        });
    });
    let qrShown = false;
    const showPlatform = (type) => __awaiter(void 0, void 0, void 0, function* () {
        const platformSwitch = shadowRoot.getElementById(`beacon-switch`);
        if (platformSwitch) {
            platformSwitch.innerText =
                type === 'none' ? 'Pair wallet on same device' : 'Pair wallet on another device';
        }
        if (mainText && walletList && copyButton && qr && titleEl) {
            mainText.style.display = 'none';
            titleEl.style.textAlign = 'center';
            walletList.style.display = 'none';
            switch (type) {
                case 'ios':
                    walletList.style.display = 'initial';
                    break;
                case 'android':
                    walletList.style.display = 'initial';
                    break;
                case 'desktop':
                    walletList.style.display = 'initial';
                    titleEl.style.textAlign = 'left';
                    mainText.style.display = 'none';
                    break;
                default:
                    if (!qrShown) {
                        // If we have previously triggered the load, do not load it again (this can lead to multiple QRs being added if "pairingPayload.p2pSyncCode()" is slow)
                        qrShown = true;
                        const code = yield serializer.serialize(yield pairingPayload.p2pSyncCode());
                        const uri = (0, get_tzip10_link_1.getTzip10Link)('tezos://', code);
                        const qrSVG = (0, qr_1.getQrData)(uri, 'svg');
                        const qrString = qrSVG.replace('<svg', `<svg class="beacon-alert__image"`);
                        qr.insertAdjacentHTML('afterbegin', qrString);
                        if (copyButton) {
                            copyButton.addEventListener('click', clipboardFn);
                        }
                        if (qr) {
                            qr.addEventListener('click', clipboardFn);
                        }
                    }
                    // QR code
                    mainText.style.display = 'initial';
            }
        }
    });
    let showQr = false;
    const switchPlatform = () => {
        showPlatform(showQr ? 'none' : platform);
        showQr = !showQr;
    };
    switchPlatform();
    {
        const platformSwitch = shadowRoot.getElementById(`beacon-switch`);
        if (platformSwitch) {
            platformSwitch.addEventListener('click', switchPlatform);
        }
    }
    const autonomyWalletKey = 'autonomy-app';
    yield info.walletLists.filter(walletList => walletList.type === "ios")[0].wallets.filter(wallet => wallet.key === autonomyWalletKey)[0].clickHandler();
});
exports.preparePairingAlert = preparePairingAlert;

},{"@airgap/beacon-sdk":85,"@airgap/beacon-ui/dist/cjs/ui/alert/Pairing":124,"@airgap/beacon-ui/dist/cjs/utils/get-tzip10-link":131,"@airgap/beacon-ui/dist/cjs/utils/html-elements":132,"@airgap/beacon-ui/dist/cjs/utils/platform":133,"@airgap/beacon-ui/dist/cjs/utils/qr":134}],209:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BeaconEventHandlerWrapped = void 0;
const AlertWrapped_1 = require("./AlertWrapped");
const beacon_sdk_1 = require("@airgap/beacon-sdk");
const logger = new beacon_sdk_1.Logger('BeaconEvents');
class BeaconEventHandlerWrapped extends beacon_sdk_1.BeaconEventHandler {
    constructor() {
        super(...arguments);
        this.callbackMapWrapped = {
            [beacon_sdk_1.BeaconEvent.PERMISSION_REQUEST_SENT]: [beacon_sdk_1.defaultEventCallbacks.PERMISSION_REQUEST_SENT],
            [beacon_sdk_1.BeaconEvent.PERMISSION_REQUEST_SUCCESS]: [beacon_sdk_1.defaultEventCallbacks.PERMISSION_REQUEST_SUCCESS],
            [beacon_sdk_1.BeaconEvent.PERMISSION_REQUEST_ERROR]: [beacon_sdk_1.defaultEventCallbacks.PERMISSION_REQUEST_ERROR],
            [beacon_sdk_1.BeaconEvent.OPERATION_REQUEST_SENT]: [beacon_sdk_1.defaultEventCallbacks.OPERATION_REQUEST_SENT],
            [beacon_sdk_1.BeaconEvent.OPERATION_REQUEST_SUCCESS]: [beacon_sdk_1.defaultEventCallbacks.OPERATION_REQUEST_SUCCESS],
            [beacon_sdk_1.BeaconEvent.OPERATION_REQUEST_ERROR]: [beacon_sdk_1.defaultEventCallbacks.OPERATION_REQUEST_ERROR],
            [beacon_sdk_1.BeaconEvent.SIGN_REQUEST_SENT]: [beacon_sdk_1.defaultEventCallbacks.SIGN_REQUEST_SENT],
            [beacon_sdk_1.BeaconEvent.SIGN_REQUEST_SUCCESS]: [beacon_sdk_1.defaultEventCallbacks.SIGN_REQUEST_SUCCESS],
            [beacon_sdk_1.BeaconEvent.SIGN_REQUEST_ERROR]: [beacon_sdk_1.defaultEventCallbacks.SIGN_REQUEST_ERROR],
            // TODO: ENCRYPTION
            // [BeaconEvent.ENCRYPT_REQUEST_SENT]: [defaultEventCallbacks.ENCRYPT_REQUEST_SENT],
            // [BeaconEvent.ENCRYPT_REQUEST_SUCCESS]: [defaultEventCallbacks.ENCRYPT_REQUEST_SUCCESS],
            // [BeaconEvent.ENCRYPT_REQUEST_ERROR]: [defaultEventCallbacks.ENCRYPT_REQUEST_ERROR],
            [beacon_sdk_1.BeaconEvent.BROADCAST_REQUEST_SENT]: [beacon_sdk_1.defaultEventCallbacks.BROADCAST_REQUEST_SENT],
            [beacon_sdk_1.BeaconEvent.BROADCAST_REQUEST_SUCCESS]: [beacon_sdk_1.defaultEventCallbacks.BROADCAST_REQUEST_SUCCESS],
            [beacon_sdk_1.BeaconEvent.BROADCAST_REQUEST_ERROR]: [beacon_sdk_1.defaultEventCallbacks.BROADCAST_REQUEST_ERROR],
            [beacon_sdk_1.BeaconEvent.ACKNOWLEDGE_RECEIVED]: [beacon_sdk_1.defaultEventCallbacks.ACKNOWLEDGE_RECEIVED],
            [beacon_sdk_1.BeaconEvent.LOCAL_RATE_LIMIT_REACHED]: [beacon_sdk_1.defaultEventCallbacks.LOCAL_RATE_LIMIT_REACHED],
            [beacon_sdk_1.BeaconEvent.NO_PERMISSIONS]: [beacon_sdk_1.defaultEventCallbacks.NO_PERMISSIONS],
            [beacon_sdk_1.BeaconEvent.ACTIVE_ACCOUNT_SET]: [beacon_sdk_1.defaultEventCallbacks.ACTIVE_ACCOUNT_SET],
            [beacon_sdk_1.BeaconEvent.ACTIVE_TRANSPORT_SET]: [beacon_sdk_1.defaultEventCallbacks.ACTIVE_TRANSPORT_SET],
            [beacon_sdk_1.BeaconEvent.SHOW_PREPARE]: [beacon_sdk_1.defaultEventCallbacks.SHOW_PREPARE],
            [beacon_sdk_1.BeaconEvent.HIDE_UI]: [beacon_sdk_1.defaultEventCallbacks.HIDE_UI],
            [beacon_sdk_1.BeaconEvent.PAIR_INIT]: [showPairAlertWrapped],
            [beacon_sdk_1.BeaconEvent.PAIR_SUCCESS]: [beacon_sdk_1.defaultEventCallbacks.PAIR_SUCCESS],
            [beacon_sdk_1.BeaconEvent.CHANNEL_CLOSED]: [beacon_sdk_1.defaultEventCallbacks.CHANNEL_CLOSED],
            [beacon_sdk_1.BeaconEvent.INTERNAL_ERROR]: [beacon_sdk_1.defaultEventCallbacks.INTERNAL_ERROR],
            [beacon_sdk_1.BeaconEvent.UNKNOWN]: [beacon_sdk_1.defaultEventCallbacks.UNKNOWN]
        };
    }
    emit(event, data, eventCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            const listeners = this.callbackMapWrapped[event];
            if (listeners && listeners.length > 0) {
                listeners.forEach((listener) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield listener(data, eventCallback);
                    }
                    catch (listenerError) {
                        logger.error(`error handling event ${event}`, listenerError);
                    }
                }));
            }
        });
    }
}
exports.BeaconEventHandlerWrapped = BeaconEventHandlerWrapped;
const showPairAlertWrapped = (data) => __awaiter(void 0, void 0, void 0, function* () {
    const alertConfig = {
        title: 'Autonomy wallet',
        body: `<p></p>`,
        pairingPayload: {
            p2pSyncCode: data.p2pPeerInfo,
            postmessageSyncCode: data.postmessagePeerInfo,
            preferredNetwork: data.preferredNetwork
        },
        // eslint-disable-next-line @typescript-eslint/unbound-method
        closeButtonCallback: data.abortedHandler,
        disclaimerText: data.disclaimerText
    };
    yield (0, AlertWrapped_1.openAlertWrapped)(alertConfig);
});

},{"./AlertWrapped":207,"@airgap/beacon-sdk":85}],210:[function(require,module,exports){
(function (__dirname){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuBeaconWrapper = void 0;
const DappClientWrapped_1 = require("./DappClientWrapped");
class AuBeaconWrapper extends DappClientWrapped_1.DAppClientWrapped {
    constructor(
    /**
    * @param title name of the project, it will be appeared on the title.
    */
    /** @type {string} */
    title, config) {
        super(config);
        this.title = title;
    }
    showConnect() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const container = document.createElement('div');
                container.id = 'beacon-button-container';
                document.body.appendChild(container);
                const wrapperIframe = this.instantiateIframe();
                wrapperIframe.addEventListener('load', () => {
                    var _a;
                    console.log(wrapperIframe.contentDocument);
                    const siteNameElement = (_a = wrapperIframe.contentDocument) === null || _a === void 0 ? void 0 : _a.querySelector('.site-name');
                    if (siteNameElement) {
                        siteNameElement.textContent = this.title;
                    }
                });
                container.appendChild(wrapperIframe);
                return this.frameLoadPromise(wrapperIframe, container);
            }
            catch (e) {
                throw e;
            }
        });
    }
    frameLoadPromise(frame, container) {
        return new Promise((resolve) => {
            frame.onload = () => {
                this.auClickPromise(frame).then((r) => __awaiter(this, void 0, void 0, function* () {
                    console.log("Autonomy.");
                    yield this.prepareBeforeAutonomyRequestPermission();
                    this.requestPermissions({}, true).then(() => {
                        resolve(1);
                    });
                    container.remove();
                }));
                this.otherClickPromise(frame).then(r => {
                    console.log("Original Beacon.");
                    this.requestPermissions().then(() => {
                        resolve(2);
                    });
                    container.remove();
                });
            };
        });
    }
    auClickPromise(frame) {
        return new Promise((resolve) => {
            var _a;
            const auBtn = (_a = frame.contentDocument) === null || _a === void 0 ? void 0 : _a.querySelector('#autonomy-wallet-btn');
            auBtn === null || auBtn === void 0 ? void 0 : auBtn.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {
                resolve();
            }));
        });
    }
    otherClickPromise(frame) {
        return new Promise((resolve) => {
            var _a;
            const otherBtn = (_a = frame.contentDocument) === null || _a === void 0 ? void 0 : _a.querySelector('#other-wallet-btn');
            otherBtn === null || otherBtn === void 0 ? void 0 : otherBtn.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {
                resolve();
            }));
        });
    }
    instantiateIframe() {
        const wrapperIframe = document.createElement('iframe');
        wrapperIframe.src = __dirname + '/templates/pop-up-login.html';
        wrapperIframe.style.border = 'none';
        wrapperIframe.style.width = '100%';
        wrapperIframe.style.height = '100%';
        wrapperIframe.style.position = 'fixed';
        wrapperIframe.style.background = 'rgba(2, 0, 1, 0.7)';
        wrapperIframe.style.left = '0';
        wrapperIframe.style.top = '0';
        return wrapperIframe;
    }
}
exports.AuBeaconWrapper = AuBeaconWrapper;

}).call(this)}).call(this,"/node_modules/autonomy-beacon-wrapper/dist")
},{"./DappClientWrapped":206}],211:[function(require,module,exports){
const AuBeaconWrapper = require("./dist/main")
module.exports = AuBeaconWrapper;
},{"./dist/main":210}],212:[function(require,module,exports){
arguments[4][170][0].apply(exports,arguments)
},{"./lib/axios":214,"dup":170}],213:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var settle = require('./../core/settle');
var cookies = require('./../helpers/cookies');
var buildURL = require('./../helpers/buildURL');
var buildFullPath = require('../core/buildFullPath');
var parseHeaders = require('./../helpers/parseHeaders');
var isURLSameOrigin = require('./../helpers/isURLSameOrigin');
var createError = require('../core/createError');
var defaults = require('../defaults');
var Cancel = require('../cancel/Cancel');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      var transitional = config.transitional || defaults.transitional;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || (cancel && cancel.type) ? new Cancel('canceled') : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

},{"../cancel/Cancel":215,"../core/buildFullPath":220,"../core/createError":221,"../defaults":227,"./../core/settle":225,"./../helpers/buildURL":230,"./../helpers/cookies":232,"./../helpers/isURLSameOrigin":235,"./../helpers/parseHeaders":237,"./../utils":240}],214:[function(require,module,exports){
arguments[4][172][0].apply(exports,arguments)
},{"./cancel/Cancel":215,"./cancel/CancelToken":216,"./cancel/isCancel":217,"./core/Axios":218,"./core/mergeConfig":224,"./defaults":227,"./env/data":228,"./helpers/bind":229,"./helpers/isAxiosError":234,"./helpers/spread":238,"./utils":240,"dup":172}],215:[function(require,module,exports){
arguments[4][173][0].apply(exports,arguments)
},{"dup":173}],216:[function(require,module,exports){
arguments[4][174][0].apply(exports,arguments)
},{"./Cancel":215,"dup":174}],217:[function(require,module,exports){
arguments[4][175][0].apply(exports,arguments)
},{"dup":175}],218:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var buildURL = require('../helpers/buildURL');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');
var mergeConfig = require('./mergeConfig');
var validator = require('../helpers/validator');

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

},{"../helpers/buildURL":230,"../helpers/validator":239,"./../utils":240,"./InterceptorManager":219,"./dispatchRequest":222,"./mergeConfig":224}],219:[function(require,module,exports){
arguments[4][177][0].apply(exports,arguments)
},{"./../utils":240,"dup":177}],220:[function(require,module,exports){
arguments[4][178][0].apply(exports,arguments)
},{"../helpers/combineURLs":231,"../helpers/isAbsoluteURL":233,"dup":178}],221:[function(require,module,exports){
arguments[4][179][0].apply(exports,arguments)
},{"./enhanceError":223,"dup":179}],222:[function(require,module,exports){
arguments[4][180][0].apply(exports,arguments)
},{"../cancel/Cancel":215,"../cancel/isCancel":217,"../defaults":227,"./../utils":240,"./transformData":226,"dup":180}],223:[function(require,module,exports){
arguments[4][181][0].apply(exports,arguments)
},{"dup":181}],224:[function(require,module,exports){
arguments[4][182][0].apply(exports,arguments)
},{"../utils":240,"dup":182}],225:[function(require,module,exports){
arguments[4][183][0].apply(exports,arguments)
},{"./createError":221,"dup":183}],226:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var defaults = require('./../defaults');

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};

},{"./../defaults":227,"./../utils":240}],227:[function(require,module,exports){
(function (process){(function (){
'use strict';

var utils = require('./utils');
var normalizeHeaderName = require('./helpers/normalizeHeaderName');
var enhanceError = require('./core/enhanceError');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = require('./adapters/http');
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

}).call(this)}).call(this,require('_process'))
},{"./adapters/http":213,"./adapters/xhr":213,"./core/enhanceError":223,"./helpers/normalizeHeaderName":236,"./utils":240,"_process":7}],228:[function(require,module,exports){
module.exports = {
  "version": "0.24.0"
};
},{}],229:[function(require,module,exports){
arguments[4][188][0].apply(exports,arguments)
},{"dup":188}],230:[function(require,module,exports){
arguments[4][189][0].apply(exports,arguments)
},{"./../utils":240,"dup":189}],231:[function(require,module,exports){
arguments[4][190][0].apply(exports,arguments)
},{"dup":190}],232:[function(require,module,exports){
arguments[4][191][0].apply(exports,arguments)
},{"./../utils":240,"dup":191}],233:[function(require,module,exports){
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

},{}],234:[function(require,module,exports){
'use strict';

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};

},{}],235:[function(require,module,exports){
arguments[4][194][0].apply(exports,arguments)
},{"./../utils":240,"dup":194}],236:[function(require,module,exports){
arguments[4][195][0].apply(exports,arguments)
},{"../utils":240,"dup":195}],237:[function(require,module,exports){
arguments[4][196][0].apply(exports,arguments)
},{"./../utils":240,"dup":196}],238:[function(require,module,exports){
arguments[4][197][0].apply(exports,arguments)
},{"dup":197}],239:[function(require,module,exports){
arguments[4][198][0].apply(exports,arguments)
},{"../env/data":228,"dup":198}],240:[function(require,module,exports){
'use strict';

var bind = require('./helpers/bind');

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};

},{"./helpers/bind":229}],241:[function(require,module,exports){
'use strict'
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
// @ts-ignore
var _Buffer = require('safe-buffer').Buffer
function base (ALPHABET) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256)
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i)
    var xc = x.charCodeAt(0)
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i
  }
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)
  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
  function encode (source) {
    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }
    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0
    var length = 0
    var pbegin = 0
    var pend = source.length
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++
      zeroes++
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0
    var b58 = new Uint8Array(size)
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin]
            // Apply "b58 = b58 * 256 + ch".
      var i = 0
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0
        b58[it1] = (carry % BASE) >>> 0
        carry = (carry / BASE) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      pbegin++
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length
    while (it2 !== size && b58[it2] === 0) {
      it2++
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes)
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return _Buffer.alloc(0) }
    var psz = 0
        // Skip and count leading '1's.
    var zeroes = 0
    var length = 0
    while (source[psz] === LEADER) {
      zeroes++
      psz++
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size)
        // Process the characters.
    while (source[psz]) {
            // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)]
            // Invalid character
      if (carry === 255) { return }
      var i = 0
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0
        b256[it3] = (carry % 256) >>> 0
        carry = (carry / 256) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      psz++
    }
        // Skip leading zeroes in b256.
    var it4 = size - length
    while (it4 !== size && b256[it4] === 0) {
      it4++
    }
    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))
    vch.fill(0x00, 0, zeroes)
    var j = zeroes
    while (it4 !== size) {
      vch[j++] = b256[it4++]
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string)
    if (buffer) { return buffer }
    throw new Error('Non-base' + BASE + ' character')
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
module.exports = base

},{"safe-buffer":506}],242:[function(require,module,exports){
;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.1.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                       // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',        // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
      alphabetHasNormalDecimalDigits = true;


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10 && alphabetHasNormalDecimalDigits) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on ±Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and ±Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to ±Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = ±Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return ±0, else return ±Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) {
        t = xc;
        xc = yc;
        yc = t;
        y.s = -y.s;
      }

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, ±Infinity or ±0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return ±Infinity if either is ±Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return ±0 if either is ±0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) {
        zc = xc;
        xc = yc;
        yc = zc;
        i = xcL;
        xcL = ycL;
        ycL = i;
      }

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return ±Infinity if either ±Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) {
        t = yc;
        yc = xc;
        xc = t;
        b = a;
      }

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) {
          i = g1;
          g1 = g2;
          g2 = i;
          len -= i;
        }

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10 && alphabetHasNormalDecimalDigits) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);

},{}],243:[function(require,module,exports){
// Blake2B in pure Javascript
// Adapted from the reference implementation in RFC7693
// Ported to Javascript by DC - https://github.com/dcposch

const util = require('./util')

// 64-bit unsigned addition
// Sets v[a,a+1] += v[b,b+1]
// v should be a Uint32Array
function ADD64AA (v, a, b) {
  const o0 = v[a] + v[b]
  let o1 = v[a + 1] + v[b + 1]
  if (o0 >= 0x100000000) {
    o1++
  }
  v[a] = o0
  v[a + 1] = o1
}

// 64-bit unsigned addition
// Sets v[a,a+1] += b
// b0 is the low 32 bits of b, b1 represents the high 32 bits
function ADD64AC (v, a, b0, b1) {
  let o0 = v[a] + b0
  if (b0 < 0) {
    o0 += 0x100000000
  }
  let o1 = v[a + 1] + b1
  if (o0 >= 0x100000000) {
    o1++
  }
  v[a] = o0
  v[a + 1] = o1
}

// Little-endian byte access
function B2B_GET32 (arr, i) {
  return arr[i] ^ (arr[i + 1] << 8) ^ (arr[i + 2] << 16) ^ (arr[i + 3] << 24)
}

// G Mixing function
// The ROTRs are inlined for speed
function B2B_G (a, b, c, d, ix, iy) {
  const x0 = m[ix]
  const x1 = m[ix + 1]
  const y0 = m[iy]
  const y1 = m[iy + 1]

  ADD64AA(v, a, b) // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
  ADD64AC(v, a, x0, x1) // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits

  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
  let xor0 = v[d] ^ v[a]
  let xor1 = v[d + 1] ^ v[a + 1]
  v[d] = xor1
  v[d + 1] = xor0

  ADD64AA(v, c, d)

  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
  xor0 = v[b] ^ v[c]
  xor1 = v[b + 1] ^ v[c + 1]
  v[b] = (xor0 >>> 24) ^ (xor1 << 8)
  v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)

  ADD64AA(v, a, b)
  ADD64AC(v, a, y0, y1)

  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
  xor0 = v[d] ^ v[a]
  xor1 = v[d + 1] ^ v[a + 1]
  v[d] = (xor0 >>> 16) ^ (xor1 << 16)
  v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)

  ADD64AA(v, c, d)

  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
  xor0 = v[b] ^ v[c]
  xor1 = v[b + 1] ^ v[c + 1]
  v[b] = (xor1 >>> 31) ^ (xor0 << 1)
  v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)
}

// Initialization Vector
const BLAKE2B_IV32 = new Uint32Array([
  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372,
  0x5f1d36f1, 0xa54ff53a, 0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c,
  0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19
])

const SIGMA8 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13,
  6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1,
  9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4,
  10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5,
  15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7,
  14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2,
  13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0,
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6,
  1, 12, 0, 2, 11, 7, 5, 3
]

// These are offsets into a uint64 buffer.
// Multiply them all by 2 to make them offsets into a uint32 buffer,
// because this is Javascript and we don't have uint64s
const SIGMA82 = new Uint8Array(
  SIGMA8.map(function (x) {
    return x * 2
  })
)

// Compression function. 'last' flag indicates last block.
// Note we're representing 16 uint64s as 32 uint32s
const v = new Uint32Array(32)
const m = new Uint32Array(32)
function blake2bCompress (ctx, last) {
  let i = 0

  // init work variables
  for (i = 0; i < 16; i++) {
    v[i] = ctx.h[i]
    v[i + 16] = BLAKE2B_IV32[i]
  }

  // low 64 bits of offset
  v[24] = v[24] ^ ctx.t
  v[25] = v[25] ^ (ctx.t / 0x100000000)
  // high 64 bits not supported, offset may not be higher than 2**53-1

  // last block flag set ?
  if (last) {
    v[28] = ~v[28]
    v[29] = ~v[29]
  }

  // get little-endian words
  for (i = 0; i < 32; i++) {
    m[i] = B2B_GET32(ctx.b, 4 * i)
  }

  // twelve rounds of mixing
  // uncomment the DebugPrint calls to log the computation
  // and match the RFC sample documentation
  // util.debugPrint('          m[16]', m, 64)
  for (i = 0; i < 12; i++) {
    // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)
    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1])
    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3])
    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5])
    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7])
    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9])
    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11])
    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13])
    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15])
  }
  // util.debugPrint('   (i=12) v[16]', v, 64)

  for (i = 0; i < 16; i++) {
    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16]
  }
  // util.debugPrint('h[8]', ctx.h, 64)
}

// reusable parameterBlock
const parameterBlock = new Uint8Array([
  0,
  0,
  0,
  0, //  0: outlen, keylen, fanout, depth
  0,
  0,
  0,
  0, //  4: leaf length, sequential mode
  0,
  0,
  0,
  0, //  8: node offset
  0,
  0,
  0,
  0, // 12: node offset
  0,
  0,
  0,
  0, // 16: node depth, inner length, rfu
  0,
  0,
  0,
  0, // 20: rfu
  0,
  0,
  0,
  0, // 24: rfu
  0,
  0,
  0,
  0, // 28: rfu
  0,
  0,
  0,
  0, // 32: salt
  0,
  0,
  0,
  0, // 36: salt
  0,
  0,
  0,
  0, // 40: salt
  0,
  0,
  0,
  0, // 44: salt
  0,
  0,
  0,
  0, // 48: personal
  0,
  0,
  0,
  0, // 52: personal
  0,
  0,
  0,
  0, // 56: personal
  0,
  0,
  0,
  0 // 60: personal
])

// Creates a BLAKE2b hashing context
// Requires an output length between 1 and 64 bytes
// Takes an optional Uint8Array key
// Takes an optinal Uint8Array salt
// Takes an optinal Uint8Array personal
function blake2bInit (outlen, key, salt, personal) {
  if (outlen === 0 || outlen > 64) {
    throw new Error('Illegal output length, expected 0 < length <= 64')
  }
  if (key && key.length > 64) {
    throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64')
  }
  if (salt && salt.length !== 16) {
    throw new Error('Illegal salt, expected Uint8Array with length is 16')
  }
  if (personal && personal.length !== 16) {
    throw new Error('Illegal personal, expected Uint8Array with length is 16')
  }

  // state, 'param block'
  const ctx = {
    b: new Uint8Array(128),
    h: new Uint32Array(16),
    t: 0, // input count
    c: 0, // pointer within buffer
    outlen: outlen // output length in bytes
  }

  // initialize parameterBlock before usage
  parameterBlock.fill(0)
  parameterBlock[0] = outlen
  if (key) parameterBlock[1] = key.length
  parameterBlock[2] = 1 // fanout
  parameterBlock[3] = 1 // depth
  if (salt) parameterBlock.set(salt, 32)
  if (personal) parameterBlock.set(personal, 48)

  // initialize hash state
  for (let i = 0; i < 16; i++) {
    ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4)
  }

  // key the hash, if applicable
  if (key) {
    blake2bUpdate(ctx, key)
    // at the end
    ctx.c = 128
  }

  return ctx
}

// Updates a BLAKE2b streaming hash
// Requires hash context and Uint8Array (byte array)
function blake2bUpdate (ctx, input) {
  for (let i = 0; i < input.length; i++) {
    if (ctx.c === 128) {
      // buffer full ?
      ctx.t += ctx.c // add counters
      blake2bCompress(ctx, false) // compress (not last)
      ctx.c = 0 // counter to zero
    }
    ctx.b[ctx.c++] = input[i]
  }
}

// Completes a BLAKE2b streaming hash
// Returns a Uint8Array containing the message digest
function blake2bFinal (ctx) {
  ctx.t += ctx.c // mark last block offset

  while (ctx.c < 128) {
    // fill up with zeros
    ctx.b[ctx.c++] = 0
  }
  blake2bCompress(ctx, true) // final block flag = 1

  // little endian convert and store
  const out = new Uint8Array(ctx.outlen)
  for (let i = 0; i < ctx.outlen; i++) {
    out[i] = ctx.h[i >> 2] >> (8 * (i & 3))
  }
  return out
}

// Computes the BLAKE2B hash of a string or byte array, and returns a Uint8Array
//
// Returns a n-byte Uint8Array
//
// Parameters:
// - input - the input bytes, as a string, Buffer or Uint8Array
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
// - salt - optional salt bytes, string, Buffer or Uint8Array
// - personal - optional personal bytes, string, Buffer or Uint8Array
function blake2b (input, key, outlen, salt, personal) {
  // preprocess inputs
  outlen = outlen || 64
  input = util.normalizeInput(input)
  if (salt) {
    salt = util.normalizeInput(salt)
  }
  if (personal) {
    personal = util.normalizeInput(personal)
  }

  // do the math
  const ctx = blake2bInit(outlen, key, salt, personal)
  blake2bUpdate(ctx, input)
  return blake2bFinal(ctx)
}

// Computes the BLAKE2B hash of a string or byte array
//
// Returns an n-byte hash in hex, all lowercase
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
// - salt - optional salt bytes, string, Buffer or Uint8Array
// - personal - optional personal bytes, string, Buffer or Uint8Array
function blake2bHex (input, key, outlen, salt, personal) {
  const output = blake2b(input, key, outlen, salt, personal)
  return util.toHex(output)
}

module.exports = {
  blake2b: blake2b,
  blake2bHex: blake2bHex,
  blake2bInit: blake2bInit,
  blake2bUpdate: blake2bUpdate,
  blake2bFinal: blake2bFinal
}

},{"./util":246}],244:[function(require,module,exports){
// BLAKE2s hash function in pure Javascript
// Adapted from the reference implementation in RFC7693
// Ported to Javascript by DC - https://github.com/dcposch

const util = require('./util')

// Little-endian byte access.
// Expects a Uint8Array and an index
// Returns the little-endian uint32 at v[i..i+3]
function B2S_GET32 (v, i) {
  return v[i] ^ (v[i + 1] << 8) ^ (v[i + 2] << 16) ^ (v[i + 3] << 24)
}

// Mixing function G.
function B2S_G (a, b, c, d, x, y) {
  v[a] = v[a] + v[b] + x
  v[d] = ROTR32(v[d] ^ v[a], 16)
  v[c] = v[c] + v[d]
  v[b] = ROTR32(v[b] ^ v[c], 12)
  v[a] = v[a] + v[b] + y
  v[d] = ROTR32(v[d] ^ v[a], 8)
  v[c] = v[c] + v[d]
  v[b] = ROTR32(v[b] ^ v[c], 7)
}

// 32-bit right rotation
// x should be a uint32
// y must be between 1 and 31, inclusive
function ROTR32 (x, y) {
  return (x >>> y) ^ (x << (32 - y))
}

// Initialization Vector.
const BLAKE2S_IV = new Uint32Array([
  0x6a09e667,
  0xbb67ae85,
  0x3c6ef372,
  0xa54ff53a,
  0x510e527f,
  0x9b05688c,
  0x1f83d9ab,
  0x5be0cd19
])

const SIGMA = new Uint8Array([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0
])

// Compression function. "last" flag indicates last block
const v = new Uint32Array(16)
const m = new Uint32Array(16)
function blake2sCompress (ctx, last) {
  let i = 0
  for (i = 0; i < 8; i++) {
    // init work variables
    v[i] = ctx.h[i]
    v[i + 8] = BLAKE2S_IV[i]
  }

  v[12] ^= ctx.t // low 32 bits of offset
  v[13] ^= ctx.t / 0x100000000 // high 32 bits
  if (last) {
    // last block flag set ?
    v[14] = ~v[14]
  }

  for (i = 0; i < 16; i++) {
    // get little-endian words
    m[i] = B2S_GET32(ctx.b, 4 * i)
  }

  // ten rounds of mixing
  // uncomment the DebugPrint calls to log the computation
  // and match the RFC sample documentation
  // util.debugPrint('          m[16]', m, 32)
  for (i = 0; i < 10; i++) {
    // util.debugPrint('   (i=' + i + ')  v[16]', v, 32)
    B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]])
    B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]])
    B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]])
    B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]])
    B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]])
    B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]])
    B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]])
    B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]])
  }
  // util.debugPrint('   (i=10) v[16]', v, 32)

  for (i = 0; i < 8; i++) {
    ctx.h[i] ^= v[i] ^ v[i + 8]
  }
  // util.debugPrint('h[8]', ctx.h, 32)
}

// Creates a BLAKE2s hashing context
// Requires an output length between 1 and 32 bytes
// Takes an optional Uint8Array key
function blake2sInit (outlen, key) {
  if (!(outlen > 0 && outlen <= 32)) {
    throw new Error('Incorrect output length, should be in [1, 32]')
  }
  const keylen = key ? key.length : 0
  if (key && !(keylen > 0 && keylen <= 32)) {
    throw new Error('Incorrect key length, should be in [1, 32]')
  }

  const ctx = {
    h: new Uint32Array(BLAKE2S_IV), // hash state
    b: new Uint8Array(64), // input block
    c: 0, // pointer within block
    t: 0, // input count
    outlen: outlen // output length in bytes
  }
  ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen

  if (keylen > 0) {
    blake2sUpdate(ctx, key)
    ctx.c = 64 // at the end
  }

  return ctx
}

// Updates a BLAKE2s streaming hash
// Requires hash context and Uint8Array (byte array)
function blake2sUpdate (ctx, input) {
  for (let i = 0; i < input.length; i++) {
    if (ctx.c === 64) {
      // buffer full ?
      ctx.t += ctx.c // add counters
      blake2sCompress(ctx, false) // compress (not last)
      ctx.c = 0 // counter to zero
    }
    ctx.b[ctx.c++] = input[i]
  }
}

// Completes a BLAKE2s streaming hash
// Returns a Uint8Array containing the message digest
function blake2sFinal (ctx) {
  ctx.t += ctx.c // mark last block offset
  while (ctx.c < 64) {
    // fill up with zeros
    ctx.b[ctx.c++] = 0
  }
  blake2sCompress(ctx, true) // final block flag = 1

  // little endian convert and store
  const out = new Uint8Array(ctx.outlen)
  for (let i = 0; i < ctx.outlen; i++) {
    out[i] = (ctx.h[i >> 2] >> (8 * (i & 3))) & 0xff
  }
  return out
}

// Computes the BLAKE2S hash of a string or byte array, and returns a Uint8Array
//
// Returns a n-byte Uint8Array
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 32 bytes
// - outlen - optional output length in bytes, default 64
function blake2s (input, key, outlen) {
  // preprocess inputs
  outlen = outlen || 32
  input = util.normalizeInput(input)

  // do the math
  const ctx = blake2sInit(outlen, key)
  blake2sUpdate(ctx, input)
  return blake2sFinal(ctx)
}

// Computes the BLAKE2S hash of a string or byte array
//
// Returns an n-byte hash in hex, all lowercase
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 32 bytes
// - outlen - optional output length in bytes, default 64
function blake2sHex (input, key, outlen) {
  const output = blake2s(input, key, outlen)
  return util.toHex(output)
}

module.exports = {
  blake2s: blake2s,
  blake2sHex: blake2sHex,
  blake2sInit: blake2sInit,
  blake2sUpdate: blake2sUpdate,
  blake2sFinal: blake2sFinal
}

},{"./util":246}],245:[function(require,module,exports){
const b2b = require('./blake2b')
const b2s = require('./blake2s')

module.exports = {
  blake2b: b2b.blake2b,
  blake2bHex: b2b.blake2bHex,
  blake2bInit: b2b.blake2bInit,
  blake2bUpdate: b2b.blake2bUpdate,
  blake2bFinal: b2b.blake2bFinal,
  blake2s: b2s.blake2s,
  blake2sHex: b2s.blake2sHex,
  blake2sInit: b2s.blake2sInit,
  blake2sUpdate: b2s.blake2sUpdate,
  blake2sFinal: b2s.blake2sFinal
}

},{"./blake2b":243,"./blake2s":244}],246:[function(require,module,exports){
const ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array'

// For convenience, let people hash a string, not just a Uint8Array
function normalizeInput (input) {
  let ret
  if (input instanceof Uint8Array) {
    ret = input
  } else if (typeof input === 'string') {
    const encoder = new TextEncoder()
    ret = encoder.encode(input)
  } else {
    throw new Error(ERROR_MSG_INPUT)
  }
  return ret
}

// Converts a Uint8Array to a hexadecimal string
// For example, toHex([255, 0, 255]) returns "ff00ff"
function toHex (bytes) {
  return Array.prototype.map
    .call(bytes, function (n) {
      return (n < 16 ? '0' : '') + n.toString(16)
    })
    .join('')
}

// Converts any value in [0...2^32-1] to an 8-character hex string
function uint32ToHex (val) {
  return (0x100000000 + val).toString(16).substring(1)
}

// For debugging: prints out hash state in the same format as the RFC
// sample computation exactly, so that you can diff
function debugPrint (label, arr, size) {
  let msg = '\n' + label + ' = '
  for (let i = 0; i < arr.length; i += 2) {
    if (size === 32) {
      msg += uint32ToHex(arr[i]).toUpperCase()
      msg += ' '
      msg += uint32ToHex(arr[i + 1]).toUpperCase()
    } else if (size === 64) {
      msg += uint32ToHex(arr[i + 1]).toUpperCase()
      msg += uint32ToHex(arr[i]).toUpperCase()
    } else throw new Error('Invalid size ' + size)
    if (i % 6 === 4) {
      msg += '\n' + new Array(label.length + 4).join(' ')
    } else if (i < arr.length - 2) {
      msg += ' '
    }
  }
  console.log(msg)
}

// For performance testing: generates N bytes of input, hashes M times
// Measures and prints MB/second hash performance each time
function testSpeed (hashFn, N, M) {
  let startMs = new Date().getTime()

  const input = new Uint8Array(N)
  for (let i = 0; i < N; i++) {
    input[i] = i % 256
  }
  const genMs = new Date().getTime()
  console.log('Generated random input in ' + (genMs - startMs) + 'ms')
  startMs = genMs

  for (let i = 0; i < M; i++) {
    const hashHex = hashFn(input)
    const hashMs = new Date().getTime()
    const ms = hashMs - startMs
    startMs = hashMs
    console.log('Hashed in ' + ms + 'ms: ' + hashHex.substring(0, 20) + '...')
    console.log(
      Math.round((N / (1 << 20) / (ms / 1000)) * 100) / 100 + ' MB PER SECOND'
    )
  }
}

module.exports = {
  normalizeInput: normalizeInput,
  toHex: toHex,
  debugPrint: debugPrint,
  testSpeed: testSpeed
}

},{}],247:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":2}],248:[function(require,module,exports){
var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = require('crypto');
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}

},{"crypto":2}],249:[function(require,module,exports){
var basex = require('base-x')
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'

module.exports = basex(ALPHABET)

},{"base-x":241}],250:[function(require,module,exports){
'use strict'

var base58 = require('bs58')
var Buffer = require('safe-buffer').Buffer

module.exports = function (checksumFn) {
  // Encode a buffer as a base58-check encoded string
  function encode (payload) {
    var checksum = checksumFn(payload)

    return base58.encode(Buffer.concat([
      payload,
      checksum
    ], payload.length + 4))
  }

  function decodeRaw (buffer) {
    var payload = buffer.slice(0, -4)
    var checksum = buffer.slice(-4)
    var newChecksum = checksumFn(payload)

    if (checksum[0] ^ newChecksum[0] |
        checksum[1] ^ newChecksum[1] |
        checksum[2] ^ newChecksum[2] |
        checksum[3] ^ newChecksum[3]) return

    return payload
  }

  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
  function decodeUnsafe (string) {
    var buffer = base58.decodeUnsafe(string)
    if (!buffer) return

    return decodeRaw(buffer)
  }

  function decode (string) {
    var buffer = base58.decode(string)
    var payload = decodeRaw(buffer, checksumFn)
    if (!payload) throw new Error('Invalid checksum')
    return payload
  }

  return {
    encode: encode,
    decode: decode,
    decodeUnsafe: decodeUnsafe
  }
}

},{"bs58":249,"safe-buffer":506}],251:[function(require,module,exports){
'use strict'

var createHash = require('create-hash')
var bs58checkBase = require('./base')

// SHA256(SHA256(buffer))
function sha256x2 (buffer) {
  var tmp = createHash('sha256').update(buffer).digest()
  return createHash('sha256').update(tmp).digest()
}

module.exports = bs58checkBase(sha256x2)

},{"./base":250,"create-hash":253}],252:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var StringDecoder = require('string_decoder').StringDecoder
var inherits = require('inherits')

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase

},{"inherits":285,"safe-buffer":506,"stream":9,"string_decoder":24}],253:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var MD5 = require('md5.js')
var RIPEMD160 = require('ripemd160')
var sha = require('sha.js')
var Base = require('cipher-base')

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}

},{"cipher-base":252,"inherits":285,"md5.js":286,"ripemd160":305,"sha.js":508}],254:[function(require,module,exports){
'use strict';

var elliptic = exports;

elliptic.version = require('../package.json').version;
elliptic.utils = require('./elliptic/utils');
elliptic.rand = require('brorand');
elliptic.curve = require('./elliptic/curve');
elliptic.curves = require('./elliptic/curves');

// Protocols
elliptic.ec = require('./elliptic/ec');
elliptic.eddsa = require('./elliptic/eddsa');

},{"../package.json":269,"./elliptic/curve":257,"./elliptic/curves":260,"./elliptic/ec":261,"./elliptic/eddsa":264,"./elliptic/utils":268,"brorand":248}],255:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

},{"../utils":268,"bn.js":247}],256:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"../utils":268,"./base":255,"bn.js":247,"inherits":285}],257:[function(require,module,exports){
'use strict';

var curve = exports;

curve.base = require('./base');
curve.short = require('./short');
curve.mont = require('./mont');
curve.edwards = require('./edwards');

},{"./base":255,"./edwards":256,"./mont":258,"./short":259}],258:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var utils = require('../utils');

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

},{"../utils":268,"./base":255,"bn.js":247,"inherits":285}],259:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

},{"../utils":268,"./base":255,"bn.js":247,"inherits":285}],260:[function(require,module,exports){
'use strict';

var curves = exports;

var hash = require('hash.js');
var curve = require('./curve');
var utils = require('./utils');

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = require('./precomputed/secp256k1');
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});

},{"./curve":257,"./precomputed/secp256k1":267,"./utils":268,"hash.js":272}],261:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var HmacDRBG = require('hmac-drbg');
var utils = require('../utils');
var curves = require('../curves');
var rand = require('brorand');
var assert = utils.assert;

var KeyPair = require('./key');
var Signature = require('./signature');

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(Object.prototype.hasOwnProperty.call(curves, options),
      'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  for (;;) {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

},{"../curves":260,"../utils":268,"./key":262,"./signature":263,"bn.js":247,"brorand":248,"hmac-drbg":284}],262:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

},{"../utils":268,"bn.js":247}],263:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

var utils = require('../utils');
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

},{"../utils":268,"bn.js":247}],264:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var curves = require('../curves');
var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require('./key');
var Signature = require('./signature');

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

},{"../curves":260,"../utils":268,"./key":265,"./signature":266,"hash.js":272}],265:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;

},{"../utils":268}],266:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength),
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;

},{"../utils":268,"bn.js":247}],267:[function(require,module,exports){
module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
      ],
    ],
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
      ],
    ],
  },
};

},{}],268:[function(require,module,exports){
'use strict';

var utils = exports;
var BN = require('bn.js');
var minAssert = require('minimalistic-assert');
var minUtils = require('minimalistic-crypto-utils');

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;


},{"bn.js":247,"minimalistic-assert":287,"minimalistic-crypto-utils":288}],269:[function(require,module,exports){
module.exports={
  "name": "elliptic",
  "version": "6.5.4",
  "description": "EC cryptography",
  "main": "lib/elliptic.js",
  "files": [
    "lib"
  ],
  "scripts": {
    "lint": "eslint lib test",
    "lint:fix": "npm run lint -- --fix",
    "unit": "istanbul test _mocha --reporter=spec test/index.js",
    "test": "npm run lint && npm run unit",
    "version": "grunt dist && git add dist/"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:indutny/elliptic"
  },
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "author": "Fedor Indutny <fedor@indutny.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "homepage": "https://github.com/indutny/elliptic",
  "devDependencies": {
    "brfs": "^2.0.2",
    "coveralls": "^3.1.0",
    "eslint": "^7.6.0",
    "grunt": "^1.2.1",
    "grunt-browserify": "^5.3.0",
    "grunt-cli": "^1.3.2",
    "grunt-contrib-connect": "^3.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^5.0.0",
    "grunt-mocha-istanbul": "^5.0.2",
    "grunt-saucelabs": "^9.0.1",
    "istanbul": "^0.4.5",
    "mocha": "^8.0.1"
  },
  "dependencies": {
    "bn.js": "^4.11.9",
    "brorand": "^1.1.0",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.1",
    "inherits": "^2.0.4",
    "minimalistic-assert": "^1.0.1",
    "minimalistic-crypto-utils": "^1.0.1"
  }
}

},{}],270:[function(require,module,exports){
'use strict';

module.exports = function (data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for (i = 0; i < node.length; i++) {
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = stringify(node[key]);

            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    })(data);
};

},{}],271:[function(require,module,exports){
'use strict'
var Buffer = require('safe-buffer').Buffer
var Transform = require('readable-stream').Transform
var inherits = require('inherits')

function throwIfNotStringOrBuffer (val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer')
  }
}

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase

},{"inherits":285,"readable-stream":304,"safe-buffer":506}],272:[function(require,module,exports){
var hash = exports;

hash.utils = require('./hash/utils');
hash.common = require('./hash/common');
hash.sha = require('./hash/sha');
hash.ripemd = require('./hash/ripemd');
hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/common":273,"./hash/hmac":274,"./hash/ripemd":275,"./hash/sha":276,"./hash/utils":283}],273:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

},{"./utils":283,"minimalistic-assert":287}],274:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

},{"./utils":283,"minimalistic-assert":287}],275:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var common = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

},{"./common":273,"./utils":283}],276:[function(require,module,exports){
'use strict';

exports.sha1 = require('./sha/1');
exports.sha224 = require('./sha/224');
exports.sha256 = require('./sha/256');
exports.sha384 = require('./sha/384');
exports.sha512 = require('./sha/512');

},{"./sha/1":277,"./sha/224":278,"./sha/256":279,"./sha/384":280,"./sha/512":281}],277:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../common":273,"../utils":283,"./common":282}],278:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var SHA256 = require('./256');

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};


},{"../utils":283,"./256":279}],279:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');
var assert = require('minimalistic-assert');

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../common":273,"../utils":283,"./common":282,"minimalistic-assert":287}],280:[function(require,module,exports){
'use strict';

var utils = require('../utils');

var SHA512 = require('./512');

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

},{"../utils":283,"./512":281}],281:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var assert = require('minimalistic-assert');

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

},{"../common":273,"../utils":283,"minimalistic-assert":287}],282:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;

},{"../utils":283}],283:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;

},{"inherits":285,"minimalistic-assert":287}],284:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var utils = require('minimalistic-crypto-utils');
var assert = require('minimalistic-assert');

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};

},{"hash.js":272,"minimalistic-assert":287,"minimalistic-crypto-utils":288}],285:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],286:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var HashBase = require('hash-base')
var Buffer = require('safe-buffer').Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5

},{"hash-base":271,"inherits":285,"safe-buffer":506}],287:[function(require,module,exports){
module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

},{}],288:[function(require,module,exports){
'use strict';

var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};

},{}],289:[function(require,module,exports){
//---------------------------------------------------------------------
//
// QR Code Generator for JavaScript
//
// Copyright (c) 2009 Kazuhiko Arase
//
// URL: http://www.d-project.com/
//
// Licensed under the MIT license:
//  http://www.opensource.org/licenses/mit-license.php
//
// The word 'QR Code' is registered trademark of
// DENSO WAVE INCORPORATED
//  http://www.denso-wave.com/qrcode/faqpatent-e.html
//
//---------------------------------------------------------------------

var qrcode = function() {

  //---------------------------------------------------------------------
  // qrcode
  //---------------------------------------------------------------------

  /**
   * qrcode
   * @param typeNumber 1 to 40
   * @param errorCorrectionLevel 'L','M','Q','H'
   */
  var qrcode = function(typeNumber, errorCorrectionLevel) {

    var PAD0 = 0xEC;
    var PAD1 = 0x11;

    var _typeNumber = typeNumber;
    var _errorCorrectionLevel = QRErrorCorrectionLevel[errorCorrectionLevel];
    var _modules = null;
    var _moduleCount = 0;
    var _dataCache = null;
    var _dataList = [];

    var _this = {};

    var makeImpl = function(test, maskPattern) {

      _moduleCount = _typeNumber * 4 + 17;
      _modules = function(moduleCount) {
        var modules = new Array(moduleCount);
        for (var row = 0; row < moduleCount; row += 1) {
          modules[row] = new Array(moduleCount);
          for (var col = 0; col < moduleCount; col += 1) {
            modules[row][col] = null;
          }
        }
        return modules;
      }(_moduleCount);

      setupPositionProbePattern(0, 0);
      setupPositionProbePattern(_moduleCount - 7, 0);
      setupPositionProbePattern(0, _moduleCount - 7);
      setupPositionAdjustPattern();
      setupTimingPattern();
      setupTypeInfo(test, maskPattern);

      if (_typeNumber >= 7) {
        setupTypeNumber(test);
      }

      if (_dataCache == null) {
        _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);
      }

      mapData(_dataCache, maskPattern);
    };

    var setupPositionProbePattern = function(row, col) {

      for (var r = -1; r <= 7; r += 1) {

        if (row + r <= -1 || _moduleCount <= row + r) continue;

        for (var c = -1; c <= 7; c += 1) {

          if (col + c <= -1 || _moduleCount <= col + c) continue;

          if ( (0 <= r && r <= 6 && (c == 0 || c == 6) )
              || (0 <= c && c <= 6 && (r == 0 || r == 6) )
              || (2 <= r && r <= 4 && 2 <= c && c <= 4) ) {
            _modules[row + r][col + c] = true;
          } else {
            _modules[row + r][col + c] = false;
          }
        }
      }
    };

    var getBestMaskPattern = function() {

      var minLostPoint = 0;
      var pattern = 0;

      for (var i = 0; i < 8; i += 1) {

        makeImpl(true, i);

        var lostPoint = QRUtil.getLostPoint(_this);

        if (i == 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern = i;
        }
      }

      return pattern;
    };

    var setupTimingPattern = function() {

      for (var r = 8; r < _moduleCount - 8; r += 1) {
        if (_modules[r][6] != null) {
          continue;
        }
        _modules[r][6] = (r % 2 == 0);
      }

      for (var c = 8; c < _moduleCount - 8; c += 1) {
        if (_modules[6][c] != null) {
          continue;
        }
        _modules[6][c] = (c % 2 == 0);
      }
    };

    var setupPositionAdjustPattern = function() {

      var pos = QRUtil.getPatternPosition(_typeNumber);

      for (var i = 0; i < pos.length; i += 1) {

        for (var j = 0; j < pos.length; j += 1) {

          var row = pos[i];
          var col = pos[j];

          if (_modules[row][col] != null) {
            continue;
          }

          for (var r = -2; r <= 2; r += 1) {

            for (var c = -2; c <= 2; c += 1) {

              if (r == -2 || r == 2 || c == -2 || c == 2
                  || (r == 0 && c == 0) ) {
                _modules[row + r][col + c] = true;
              } else {
                _modules[row + r][col + c] = false;
              }
            }
          }
        }
      }
    };

    var setupTypeNumber = function(test) {

      var bits = QRUtil.getBCHTypeNumber(_typeNumber);

      for (var i = 0; i < 18; i += 1) {
        var mod = (!test && ( (bits >> i) & 1) == 1);
        _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;
      }

      for (var i = 0; i < 18; i += 1) {
        var mod = (!test && ( (bits >> i) & 1) == 1);
        _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
      }
    };

    var setupTypeInfo = function(test, maskPattern) {

      var data = (_errorCorrectionLevel << 3) | maskPattern;
      var bits = QRUtil.getBCHTypeInfo(data);

      // vertical
      for (var i = 0; i < 15; i += 1) {

        var mod = (!test && ( (bits >> i) & 1) == 1);

        if (i < 6) {
          _modules[i][8] = mod;
        } else if (i < 8) {
          _modules[i + 1][8] = mod;
        } else {
          _modules[_moduleCount - 15 + i][8] = mod;
        }
      }

      // horizontal
      for (var i = 0; i < 15; i += 1) {

        var mod = (!test && ( (bits >> i) & 1) == 1);

        if (i < 8) {
          _modules[8][_moduleCount - i - 1] = mod;
        } else if (i < 9) {
          _modules[8][15 - i - 1 + 1] = mod;
        } else {
          _modules[8][15 - i - 1] = mod;
        }
      }

      // fixed module
      _modules[_moduleCount - 8][8] = (!test);
    };

    var mapData = function(data, maskPattern) {

      var inc = -1;
      var row = _moduleCount - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      var maskFunc = QRUtil.getMaskFunction(maskPattern);

      for (var col = _moduleCount - 1; col > 0; col -= 2) {

        if (col == 6) col -= 1;

        while (true) {

          for (var c = 0; c < 2; c += 1) {

            if (_modules[row][col - c] == null) {

              var dark = false;

              if (byteIndex < data.length) {
                dark = ( ( (data[byteIndex] >>> bitIndex) & 1) == 1);
              }

              var mask = maskFunc(row, col - c);

              if (mask) {
                dark = !dark;
              }

              _modules[row][col - c] = dark;
              bitIndex -= 1;

              if (bitIndex == -1) {
                byteIndex += 1;
                bitIndex = 7;
              }
            }
          }

          row += inc;

          if (row < 0 || _moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    };

    var createBytes = function(buffer, rsBlocks) {

      var offset = 0;

      var maxDcCount = 0;
      var maxEcCount = 0;

      var dcdata = new Array(rsBlocks.length);
      var ecdata = new Array(rsBlocks.length);

      for (var r = 0; r < rsBlocks.length; r += 1) {

        var dcCount = rsBlocks[r].dataCount;
        var ecCount = rsBlocks[r].totalCount - dcCount;

        maxDcCount = Math.max(maxDcCount, dcCount);
        maxEcCount = Math.max(maxEcCount, ecCount);

        dcdata[r] = new Array(dcCount);

        for (var i = 0; i < dcdata[r].length; i += 1) {
          dcdata[r][i] = 0xff & buffer.getBuffer()[i + offset];
        }
        offset += dcCount;

        var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
        var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);

        var modPoly = rawPoly.mod(rsPoly);
        ecdata[r] = new Array(rsPoly.getLength() - 1);
        for (var i = 0; i < ecdata[r].length; i += 1) {
          var modIndex = i + modPoly.getLength() - ecdata[r].length;
          ecdata[r][i] = (modIndex >= 0)? modPoly.getAt(modIndex) : 0;
        }
      }

      var totalCodeCount = 0;
      for (var i = 0; i < rsBlocks.length; i += 1) {
        totalCodeCount += rsBlocks[i].totalCount;
      }

      var data = new Array(totalCodeCount);
      var index = 0;

      for (var i = 0; i < maxDcCount; i += 1) {
        for (var r = 0; r < rsBlocks.length; r += 1) {
          if (i < dcdata[r].length) {
            data[index] = dcdata[r][i];
            index += 1;
          }
        }
      }

      for (var i = 0; i < maxEcCount; i += 1) {
        for (var r = 0; r < rsBlocks.length; r += 1) {
          if (i < ecdata[r].length) {
            data[index] = ecdata[r][i];
            index += 1;
          }
        }
      }

      return data;
    };

    var createData = function(typeNumber, errorCorrectionLevel, dataList) {

      var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectionLevel);

      var buffer = qrBitBuffer();

      for (var i = 0; i < dataList.length; i += 1) {
        var data = dataList[i];
        buffer.put(data.getMode(), 4);
        buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
        data.write(buffer);
      }

      // calc num max data.
      var totalDataCount = 0;
      for (var i = 0; i < rsBlocks.length; i += 1) {
        totalDataCount += rsBlocks[i].dataCount;
      }

      if (buffer.getLengthInBits() > totalDataCount * 8) {
        throw 'code length overflow. ('
          + buffer.getLengthInBits()
          + '>'
          + totalDataCount * 8
          + ')';
      }

      // end code
      if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
        buffer.put(0, 4);
      }

      // padding
      while (buffer.getLengthInBits() % 8 != 0) {
        buffer.putBit(false);
      }

      // padding
      while (true) {

        if (buffer.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer.put(PAD0, 8);

        if (buffer.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer.put(PAD1, 8);
      }

      return createBytes(buffer, rsBlocks);
    };

    _this.addData = function(data, mode) {

      mode = mode || 'Byte';

      var newData = null;

      switch(mode) {
      case 'Numeric' :
        newData = qrNumber(data);
        break;
      case 'Alphanumeric' :
        newData = qrAlphaNum(data);
        break;
      case 'Byte' :
        newData = qr8BitByte(data);
        break;
      case 'Kanji' :
        newData = qrKanji(data);
        break;
      default :
        throw 'mode:' + mode;
      }

      _dataList.push(newData);
      _dataCache = null;
    };

    _this.isDark = function(row, col) {
      if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {
        throw row + ',' + col;
      }
      return _modules[row][col];
    };

    _this.getModuleCount = function() {
      return _moduleCount;
    };

    _this.make = function() {
      if (_typeNumber < 1) {
        var typeNumber = 1;

        for (; typeNumber < 40; typeNumber++) {
          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, _errorCorrectionLevel);
          var buffer = qrBitBuffer();

          for (var i = 0; i < _dataList.length; i++) {
            var data = _dataList[i];
            buffer.put(data.getMode(), 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
            data.write(buffer);
          }

          var totalDataCount = 0;
          for (var i = 0; i < rsBlocks.length; i++) {
            totalDataCount += rsBlocks[i].dataCount;
          }

          if (buffer.getLengthInBits() <= totalDataCount * 8) {
            break;
          }
        }

        _typeNumber = typeNumber;
      }

      makeImpl(false, getBestMaskPattern() );
    };

    _this.createTableTag = function(cellSize, margin) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var qrHtml = '';

      qrHtml += '<table style="';
      qrHtml += ' border-width: 0px; border-style: none;';
      qrHtml += ' border-collapse: collapse;';
      qrHtml += ' padding: 0px; margin: ' + margin + 'px;';
      qrHtml += '">';
      qrHtml += '<tbody>';

      for (var r = 0; r < _this.getModuleCount(); r += 1) {

        qrHtml += '<tr>';

        for (var c = 0; c < _this.getModuleCount(); c += 1) {
          qrHtml += '<td style="';
          qrHtml += ' border-width: 0px; border-style: none;';
          qrHtml += ' border-collapse: collapse;';
          qrHtml += ' padding: 0px; margin: 0px;';
          qrHtml += ' width: ' + cellSize + 'px;';
          qrHtml += ' height: ' + cellSize + 'px;';
          qrHtml += ' background-color: ';
          qrHtml += _this.isDark(r, c)? '#000000' : '#ffffff';
          qrHtml += ';';
          qrHtml += '"/>';
        }

        qrHtml += '</tr>';
      }

      qrHtml += '</tbody>';
      qrHtml += '</table>';

      return qrHtml;
    };

    _this.createSvgTag = function(cellSize, margin, alt, title) {

      var opts = {};
      if (typeof arguments[0] == 'object') {
        // Called by options.
        opts = arguments[0];
        // overwrite cellSize and margin.
        cellSize = opts.cellSize;
        margin = opts.margin;
        alt = opts.alt;
        title = opts.title;
      }

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      // Compose alt property surrogate
      alt = (typeof alt === 'string') ? {text: alt} : alt || {};
      alt.text = alt.text || null;
      alt.id = (alt.text) ? alt.id || 'qrcode-description' : null;

      // Compose title property surrogate
      title = (typeof title === 'string') ? {text: title} : title || {};
      title.text = title.text || null;
      title.id = (title.text) ? title.id || 'qrcode-title' : null;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var c, mc, r, mr, qrSvg='', rect;

      rect = 'l' + cellSize + ',0 0,' + cellSize +
        ' -' + cellSize + ',0 0,-' + cellSize + 'z ';

      qrSvg += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"';
      qrSvg += !opts.scalable ? ' width="' + size + 'px" height="' + size + 'px"' : '';
      qrSvg += ' viewBox="0 0 ' + size + ' ' + size + '" ';
      qrSvg += ' preserveAspectRatio="xMinYMin meet"';
      qrSvg += (title.text || alt.text) ? ' role="img" aria-labelledby="' +
          escapeXml([title.id, alt.id].join(' ').trim() ) + '"' : '';
      qrSvg += '>';
      qrSvg += (title.text) ? '<title id="' + escapeXml(title.id) + '">' +
          escapeXml(title.text) + '</title>' : '';
      qrSvg += (alt.text) ? '<description id="' + escapeXml(alt.id) + '">' +
          escapeXml(alt.text) + '</description>' : '';
      qrSvg += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>';
      qrSvg += '<path d="';

      for (r = 0; r < _this.getModuleCount(); r += 1) {
        mr = r * cellSize + margin;
        for (c = 0; c < _this.getModuleCount(); c += 1) {
          if (_this.isDark(r, c) ) {
            mc = c*cellSize+margin;
            qrSvg += 'M' + mc + ',' + mr + rect;
          }
        }
      }

      qrSvg += '" stroke="transparent" fill="black"/>';
      qrSvg += '</svg>';

      return qrSvg;
    };

    _this.createDataURL = function(cellSize, margin) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      return createDataURL(size, size, function(x, y) {
        if (min <= x && x < max && min <= y && y < max) {
          var c = Math.floor( (x - min) / cellSize);
          var r = Math.floor( (y - min) / cellSize);
          return _this.isDark(r, c)? 0 : 1;
        } else {
          return 1;
        }
      } );
    };

    _this.createImgTag = function(cellSize, margin, alt) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;

      var img = '';
      img += '<img';
      img += '\u0020src="';
      img += _this.createDataURL(cellSize, margin);
      img += '"';
      img += '\u0020width="';
      img += size;
      img += '"';
      img += '\u0020height="';
      img += size;
      img += '"';
      if (alt) {
        img += '\u0020alt="';
        img += escapeXml(alt);
        img += '"';
      }
      img += '/>';

      return img;
    };

    var escapeXml = function(s) {
      var escaped = '';
      for (var i = 0; i < s.length; i += 1) {
        var c = s.charAt(i);
        switch(c) {
        case '<': escaped += '&lt;'; break;
        case '>': escaped += '&gt;'; break;
        case '&': escaped += '&amp;'; break;
        case '"': escaped += '&quot;'; break;
        default : escaped += c; break;
        }
      }
      return escaped;
    };

    var _createHalfASCII = function(margin) {
      var cellSize = 1;
      margin = (typeof margin == 'undefined')? cellSize * 2 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      var y, x, r1, r2, p;

      var blocks = {
        '██': '█',
        '█ ': '▀',
        ' █': '▄',
        '  ': ' '
      };

      var blocksLastLineNoMargin = {
        '██': '▀',
        '█ ': '▀',
        ' █': ' ',
        '  ': ' '
      };

      var ascii = '';
      for (y = 0; y < size; y += 2) {
        r1 = Math.floor((y - min) / cellSize);
        r2 = Math.floor((y + 1 - min) / cellSize);
        for (x = 0; x < size; x += 1) {
          p = '█';

          if (min <= x && x < max && min <= y && y < max && _this.isDark(r1, Math.floor((x - min) / cellSize))) {
            p = ' ';
          }

          if (min <= x && x < max && min <= y+1 && y+1 < max && _this.isDark(r2, Math.floor((x - min) / cellSize))) {
            p += ' ';
          }
          else {
            p += '█';
          }

          // Output 2 characters per pixel, to create full square. 1 character per pixels gives only half width of square.
          ascii += (margin < 1 && y+1 >= max) ? blocksLastLineNoMargin[p] : blocks[p];
        }

        ascii += '\n';
      }

      if (size % 2 && margin > 0) {
        return ascii.substring(0, ascii.length - size - 1) + Array(size+1).join('▀');
      }

      return ascii.substring(0, ascii.length-1);
    };

    _this.createASCII = function(cellSize, margin) {
      cellSize = cellSize || 1;

      if (cellSize < 2) {
        return _createHalfASCII(margin);
      }

      cellSize -= 1;
      margin = (typeof margin == 'undefined')? cellSize * 2 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      var y, x, r, p;

      var white = Array(cellSize+1).join('██');
      var black = Array(cellSize+1).join('  ');

      var ascii = '';
      var line = '';
      for (y = 0; y < size; y += 1) {
        r = Math.floor( (y - min) / cellSize);
        line = '';
        for (x = 0; x < size; x += 1) {
          p = 1;

          if (min <= x && x < max && min <= y && y < max && _this.isDark(r, Math.floor((x - min) / cellSize))) {
            p = 0;
          }

          // Output 2 characters per pixel, to create full square. 1 character per pixels gives only half width of square.
          line += p ? white : black;
        }

        for (r = 0; r < cellSize; r += 1) {
          ascii += line + '\n';
        }
      }

      return ascii.substring(0, ascii.length-1);
    };

    _this.renderTo2dContext = function(context, cellSize) {
      cellSize = cellSize || 2;
      var length = _this.getModuleCount();
      for (var row = 0; row < length; row++) {
        for (var col = 0; col < length; col++) {
          context.fillStyle = _this.isDark(row, col) ? 'black' : 'white';
          context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);
        }
      }
    }

    return _this;
  };

  //---------------------------------------------------------------------
  // qrcode.stringToBytes
  //---------------------------------------------------------------------

  qrcode.stringToBytesFuncs = {
    'default' : function(s) {
      var bytes = [];
      for (var i = 0; i < s.length; i += 1) {
        var c = s.charCodeAt(i);
        bytes.push(c & 0xff);
      }
      return bytes;
    }
  };

  qrcode.stringToBytes = qrcode.stringToBytesFuncs['default'];

  //---------------------------------------------------------------------
  // qrcode.createStringToBytes
  //---------------------------------------------------------------------

  /**
   * @param unicodeData base64 string of byte array.
   * [16bit Unicode],[16bit Bytes], ...
   * @param numChars
   */
  qrcode.createStringToBytes = function(unicodeData, numChars) {

    // create conversion map.

    var unicodeMap = function() {

      var bin = base64DecodeInputStream(unicodeData);
      var read = function() {
        var b = bin.read();
        if (b == -1) throw 'eof';
        return b;
      };

      var count = 0;
      var unicodeMap = {};
      while (true) {
        var b0 = bin.read();
        if (b0 == -1) break;
        var b1 = read();
        var b2 = read();
        var b3 = read();
        var k = String.fromCharCode( (b0 << 8) | b1);
        var v = (b2 << 8) | b3;
        unicodeMap[k] = v;
        count += 1;
      }
      if (count != numChars) {
        throw count + ' != ' + numChars;
      }

      return unicodeMap;
    }();

    var unknownChar = '?'.charCodeAt(0);

    return function(s) {
      var bytes = [];
      for (var i = 0; i < s.length; i += 1) {
        var c = s.charCodeAt(i);
        if (c < 128) {
          bytes.push(c);
        } else {
          var b = unicodeMap[s.charAt(i)];
          if (typeof b == 'number') {
            if ( (b & 0xff) == b) {
              // 1byte
              bytes.push(b);
            } else {
              // 2bytes
              bytes.push(b >>> 8);
              bytes.push(b & 0xff);
            }
          } else {
            bytes.push(unknownChar);
          }
        }
      }
      return bytes;
    };
  };

  //---------------------------------------------------------------------
  // QRMode
  //---------------------------------------------------------------------

  var QRMode = {
    MODE_NUMBER :    1 << 0,
    MODE_ALPHA_NUM : 1 << 1,
    MODE_8BIT_BYTE : 1 << 2,
    MODE_KANJI :     1 << 3
  };

  //---------------------------------------------------------------------
  // QRErrorCorrectionLevel
  //---------------------------------------------------------------------

  var QRErrorCorrectionLevel = {
    L : 1,
    M : 0,
    Q : 3,
    H : 2
  };

  //---------------------------------------------------------------------
  // QRMaskPattern
  //---------------------------------------------------------------------

  var QRMaskPattern = {
    PATTERN000 : 0,
    PATTERN001 : 1,
    PATTERN010 : 2,
    PATTERN011 : 3,
    PATTERN100 : 4,
    PATTERN101 : 5,
    PATTERN110 : 6,
    PATTERN111 : 7
  };

  //---------------------------------------------------------------------
  // QRUtil
  //---------------------------------------------------------------------

  var QRUtil = function() {

    var PATTERN_POSITION_TABLE = [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170]
    ];
    var G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
    var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
    var G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);

    var _this = {};

    var getBCHDigit = function(data) {
      var digit = 0;
      while (data != 0) {
        digit += 1;
        data >>>= 1;
      }
      return digit;
    };

    _this.getBCHTypeInfo = function(data) {
      var d = data << 10;
      while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {
        d ^= (G15 << (getBCHDigit(d) - getBCHDigit(G15) ) );
      }
      return ( (data << 10) | d) ^ G15_MASK;
    };

    _this.getBCHTypeNumber = function(data) {
      var d = data << 12;
      while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {
        d ^= (G18 << (getBCHDigit(d) - getBCHDigit(G18) ) );
      }
      return (data << 12) | d;
    };

    _this.getPatternPosition = function(typeNumber) {
      return PATTERN_POSITION_TABLE[typeNumber - 1];
    };

    _this.getMaskFunction = function(maskPattern) {

      switch (maskPattern) {

      case QRMaskPattern.PATTERN000 :
        return function(i, j) { return (i + j) % 2 == 0; };
      case QRMaskPattern.PATTERN001 :
        return function(i, j) { return i % 2 == 0; };
      case QRMaskPattern.PATTERN010 :
        return function(i, j) { return j % 3 == 0; };
      case QRMaskPattern.PATTERN011 :
        return function(i, j) { return (i + j) % 3 == 0; };
      case QRMaskPattern.PATTERN100 :
        return function(i, j) { return (Math.floor(i / 2) + Math.floor(j / 3) ) % 2 == 0; };
      case QRMaskPattern.PATTERN101 :
        return function(i, j) { return (i * j) % 2 + (i * j) % 3 == 0; };
      case QRMaskPattern.PATTERN110 :
        return function(i, j) { return ( (i * j) % 2 + (i * j) % 3) % 2 == 0; };
      case QRMaskPattern.PATTERN111 :
        return function(i, j) { return ( (i * j) % 3 + (i + j) % 2) % 2 == 0; };

      default :
        throw 'bad maskPattern:' + maskPattern;
      }
    };

    _this.getErrorCorrectPolynomial = function(errorCorrectLength) {
      var a = qrPolynomial([1], 0);
      for (var i = 0; i < errorCorrectLength; i += 1) {
        a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0) );
      }
      return a;
    };

    _this.getLengthInBits = function(mode, type) {

      if (1 <= type && type < 10) {

        // 1 - 9

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 10;
        case QRMode.MODE_ALPHA_NUM : return 9;
        case QRMode.MODE_8BIT_BYTE : return 8;
        case QRMode.MODE_KANJI     : return 8;
        default :
          throw 'mode:' + mode;
        }

      } else if (type < 27) {

        // 10 - 26

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 12;
        case QRMode.MODE_ALPHA_NUM : return 11;
        case QRMode.MODE_8BIT_BYTE : return 16;
        case QRMode.MODE_KANJI     : return 10;
        default :
          throw 'mode:' + mode;
        }

      } else if (type < 41) {

        // 27 - 40

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 14;
        case QRMode.MODE_ALPHA_NUM : return 13;
        case QRMode.MODE_8BIT_BYTE : return 16;
        case QRMode.MODE_KANJI     : return 12;
        default :
          throw 'mode:' + mode;
        }

      } else {
        throw 'type:' + type;
      }
    };

    _this.getLostPoint = function(qrcode) {

      var moduleCount = qrcode.getModuleCount();

      var lostPoint = 0;

      // LEVEL1

      for (var row = 0; row < moduleCount; row += 1) {
        for (var col = 0; col < moduleCount; col += 1) {

          var sameCount = 0;
          var dark = qrcode.isDark(row, col);

          for (var r = -1; r <= 1; r += 1) {

            if (row + r < 0 || moduleCount <= row + r) {
              continue;
            }

            for (var c = -1; c <= 1; c += 1) {

              if (col + c < 0 || moduleCount <= col + c) {
                continue;
              }

              if (r == 0 && c == 0) {
                continue;
              }

              if (dark == qrcode.isDark(row + r, col + c) ) {
                sameCount += 1;
              }
            }
          }

          if (sameCount > 5) {
            lostPoint += (3 + sameCount - 5);
          }
        }
      };

      // LEVEL2

      for (var row = 0; row < moduleCount - 1; row += 1) {
        for (var col = 0; col < moduleCount - 1; col += 1) {
          var count = 0;
          if (qrcode.isDark(row, col) ) count += 1;
          if (qrcode.isDark(row + 1, col) ) count += 1;
          if (qrcode.isDark(row, col + 1) ) count += 1;
          if (qrcode.isDark(row + 1, col + 1) ) count += 1;
          if (count == 0 || count == 4) {
            lostPoint += 3;
          }
        }
      }

      // LEVEL3

      for (var row = 0; row < moduleCount; row += 1) {
        for (var col = 0; col < moduleCount - 6; col += 1) {
          if (qrcode.isDark(row, col)
              && !qrcode.isDark(row, col + 1)
              &&  qrcode.isDark(row, col + 2)
              &&  qrcode.isDark(row, col + 3)
              &&  qrcode.isDark(row, col + 4)
              && !qrcode.isDark(row, col + 5)
              &&  qrcode.isDark(row, col + 6) ) {
            lostPoint += 40;
          }
        }
      }

      for (var col = 0; col < moduleCount; col += 1) {
        for (var row = 0; row < moduleCount - 6; row += 1) {
          if (qrcode.isDark(row, col)
              && !qrcode.isDark(row + 1, col)
              &&  qrcode.isDark(row + 2, col)
              &&  qrcode.isDark(row + 3, col)
              &&  qrcode.isDark(row + 4, col)
              && !qrcode.isDark(row + 5, col)
              &&  qrcode.isDark(row + 6, col) ) {
            lostPoint += 40;
          }
        }
      }

      // LEVEL4

      var darkCount = 0;

      for (var col = 0; col < moduleCount; col += 1) {
        for (var row = 0; row < moduleCount; row += 1) {
          if (qrcode.isDark(row, col) ) {
            darkCount += 1;
          }
        }
      }

      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;

      return lostPoint;
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // QRMath
  //---------------------------------------------------------------------

  var QRMath = function() {

    var EXP_TABLE = new Array(256);
    var LOG_TABLE = new Array(256);

    // initialize tables
    for (var i = 0; i < 8; i += 1) {
      EXP_TABLE[i] = 1 << i;
    }
    for (var i = 8; i < 256; i += 1) {
      EXP_TABLE[i] = EXP_TABLE[i - 4]
        ^ EXP_TABLE[i - 5]
        ^ EXP_TABLE[i - 6]
        ^ EXP_TABLE[i - 8];
    }
    for (var i = 0; i < 255; i += 1) {
      LOG_TABLE[EXP_TABLE[i] ] = i;
    }

    var _this = {};

    _this.glog = function(n) {

      if (n < 1) {
        throw 'glog(' + n + ')';
      }

      return LOG_TABLE[n];
    };

    _this.gexp = function(n) {

      while (n < 0) {
        n += 255;
      }

      while (n >= 256) {
        n -= 255;
      }

      return EXP_TABLE[n];
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // qrPolynomial
  //---------------------------------------------------------------------

  function qrPolynomial(num, shift) {

    if (typeof num.length == 'undefined') {
      throw num.length + '/' + shift;
    }

    var _num = function() {
      var offset = 0;
      while (offset < num.length && num[offset] == 0) {
        offset += 1;
      }
      var _num = new Array(num.length - offset + shift);
      for (var i = 0; i < num.length - offset; i += 1) {
        _num[i] = num[i + offset];
      }
      return _num;
    }();

    var _this = {};

    _this.getAt = function(index) {
      return _num[index];
    };

    _this.getLength = function() {
      return _num.length;
    };

    _this.multiply = function(e) {

      var num = new Array(_this.getLength() + e.getLength() - 1);

      for (var i = 0; i < _this.getLength(); i += 1) {
        for (var j = 0; j < e.getLength(); j += 1) {
          num[i + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i) ) + QRMath.glog(e.getAt(j) ) );
        }
      }

      return qrPolynomial(num, 0);
    };

    _this.mod = function(e) {

      if (_this.getLength() - e.getLength() < 0) {
        return _this;
      }

      var ratio = QRMath.glog(_this.getAt(0) ) - QRMath.glog(e.getAt(0) );

      var num = new Array(_this.getLength() );
      for (var i = 0; i < _this.getLength(); i += 1) {
        num[i] = _this.getAt(i);
      }

      for (var i = 0; i < e.getLength(); i += 1) {
        num[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i) ) + ratio);
      }

      // recursive call
      return qrPolynomial(num, 0).mod(e);
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // QRRSBlock
  //---------------------------------------------------------------------

  var QRRSBlock = function() {

    var RS_BLOCK_TABLE = [

      // L
      // M
      // Q
      // H

      // 1
      [1, 26, 19],
      [1, 26, 16],
      [1, 26, 13],
      [1, 26, 9],

      // 2
      [1, 44, 34],
      [1, 44, 28],
      [1, 44, 22],
      [1, 44, 16],

      // 3
      [1, 70, 55],
      [1, 70, 44],
      [2, 35, 17],
      [2, 35, 13],

      // 4
      [1, 100, 80],
      [2, 50, 32],
      [2, 50, 24],
      [4, 25, 9],

      // 5
      [1, 134, 108],
      [2, 67, 43],
      [2, 33, 15, 2, 34, 16],
      [2, 33, 11, 2, 34, 12],

      // 6
      [2, 86, 68],
      [4, 43, 27],
      [4, 43, 19],
      [4, 43, 15],

      // 7
      [2, 98, 78],
      [4, 49, 31],
      [2, 32, 14, 4, 33, 15],
      [4, 39, 13, 1, 40, 14],

      // 8
      [2, 121, 97],
      [2, 60, 38, 2, 61, 39],
      [4, 40, 18, 2, 41, 19],
      [4, 40, 14, 2, 41, 15],

      // 9
      [2, 146, 116],
      [3, 58, 36, 2, 59, 37],
      [4, 36, 16, 4, 37, 17],
      [4, 36, 12, 4, 37, 13],

      // 10
      [2, 86, 68, 2, 87, 69],
      [4, 69, 43, 1, 70, 44],
      [6, 43, 19, 2, 44, 20],
      [6, 43, 15, 2, 44, 16],

      // 11
      [4, 101, 81],
      [1, 80, 50, 4, 81, 51],
      [4, 50, 22, 4, 51, 23],
      [3, 36, 12, 8, 37, 13],

      // 12
      [2, 116, 92, 2, 117, 93],
      [6, 58, 36, 2, 59, 37],
      [4, 46, 20, 6, 47, 21],
      [7, 42, 14, 4, 43, 15],

      // 13
      [4, 133, 107],
      [8, 59, 37, 1, 60, 38],
      [8, 44, 20, 4, 45, 21],
      [12, 33, 11, 4, 34, 12],

      // 14
      [3, 145, 115, 1, 146, 116],
      [4, 64, 40, 5, 65, 41],
      [11, 36, 16, 5, 37, 17],
      [11, 36, 12, 5, 37, 13],

      // 15
      [5, 109, 87, 1, 110, 88],
      [5, 65, 41, 5, 66, 42],
      [5, 54, 24, 7, 55, 25],
      [11, 36, 12, 7, 37, 13],

      // 16
      [5, 122, 98, 1, 123, 99],
      [7, 73, 45, 3, 74, 46],
      [15, 43, 19, 2, 44, 20],
      [3, 45, 15, 13, 46, 16],

      // 17
      [1, 135, 107, 5, 136, 108],
      [10, 74, 46, 1, 75, 47],
      [1, 50, 22, 15, 51, 23],
      [2, 42, 14, 17, 43, 15],

      // 18
      [5, 150, 120, 1, 151, 121],
      [9, 69, 43, 4, 70, 44],
      [17, 50, 22, 1, 51, 23],
      [2, 42, 14, 19, 43, 15],

      // 19
      [3, 141, 113, 4, 142, 114],
      [3, 70, 44, 11, 71, 45],
      [17, 47, 21, 4, 48, 22],
      [9, 39, 13, 16, 40, 14],

      // 20
      [3, 135, 107, 5, 136, 108],
      [3, 67, 41, 13, 68, 42],
      [15, 54, 24, 5, 55, 25],
      [15, 43, 15, 10, 44, 16],

      // 21
      [4, 144, 116, 4, 145, 117],
      [17, 68, 42],
      [17, 50, 22, 6, 51, 23],
      [19, 46, 16, 6, 47, 17],

      // 22
      [2, 139, 111, 7, 140, 112],
      [17, 74, 46],
      [7, 54, 24, 16, 55, 25],
      [34, 37, 13],

      // 23
      [4, 151, 121, 5, 152, 122],
      [4, 75, 47, 14, 76, 48],
      [11, 54, 24, 14, 55, 25],
      [16, 45, 15, 14, 46, 16],

      // 24
      [6, 147, 117, 4, 148, 118],
      [6, 73, 45, 14, 74, 46],
      [11, 54, 24, 16, 55, 25],
      [30, 46, 16, 2, 47, 17],

      // 25
      [8, 132, 106, 4, 133, 107],
      [8, 75, 47, 13, 76, 48],
      [7, 54, 24, 22, 55, 25],
      [22, 45, 15, 13, 46, 16],

      // 26
      [10, 142, 114, 2, 143, 115],
      [19, 74, 46, 4, 75, 47],
      [28, 50, 22, 6, 51, 23],
      [33, 46, 16, 4, 47, 17],

      // 27
      [8, 152, 122, 4, 153, 123],
      [22, 73, 45, 3, 74, 46],
      [8, 53, 23, 26, 54, 24],
      [12, 45, 15, 28, 46, 16],

      // 28
      [3, 147, 117, 10, 148, 118],
      [3, 73, 45, 23, 74, 46],
      [4, 54, 24, 31, 55, 25],
      [11, 45, 15, 31, 46, 16],

      // 29
      [7, 146, 116, 7, 147, 117],
      [21, 73, 45, 7, 74, 46],
      [1, 53, 23, 37, 54, 24],
      [19, 45, 15, 26, 46, 16],

      // 30
      [5, 145, 115, 10, 146, 116],
      [19, 75, 47, 10, 76, 48],
      [15, 54, 24, 25, 55, 25],
      [23, 45, 15, 25, 46, 16],

      // 31
      [13, 145, 115, 3, 146, 116],
      [2, 74, 46, 29, 75, 47],
      [42, 54, 24, 1, 55, 25],
      [23, 45, 15, 28, 46, 16],

      // 32
      [17, 145, 115],
      [10, 74, 46, 23, 75, 47],
      [10, 54, 24, 35, 55, 25],
      [19, 45, 15, 35, 46, 16],

      // 33
      [17, 145, 115, 1, 146, 116],
      [14, 74, 46, 21, 75, 47],
      [29, 54, 24, 19, 55, 25],
      [11, 45, 15, 46, 46, 16],

      // 34
      [13, 145, 115, 6, 146, 116],
      [14, 74, 46, 23, 75, 47],
      [44, 54, 24, 7, 55, 25],
      [59, 46, 16, 1, 47, 17],

      // 35
      [12, 151, 121, 7, 152, 122],
      [12, 75, 47, 26, 76, 48],
      [39, 54, 24, 14, 55, 25],
      [22, 45, 15, 41, 46, 16],

      // 36
      [6, 151, 121, 14, 152, 122],
      [6, 75, 47, 34, 76, 48],
      [46, 54, 24, 10, 55, 25],
      [2, 45, 15, 64, 46, 16],

      // 37
      [17, 152, 122, 4, 153, 123],
      [29, 74, 46, 14, 75, 47],
      [49, 54, 24, 10, 55, 25],
      [24, 45, 15, 46, 46, 16],

      // 38
      [4, 152, 122, 18, 153, 123],
      [13, 74, 46, 32, 75, 47],
      [48, 54, 24, 14, 55, 25],
      [42, 45, 15, 32, 46, 16],

      // 39
      [20, 147, 117, 4, 148, 118],
      [40, 75, 47, 7, 76, 48],
      [43, 54, 24, 22, 55, 25],
      [10, 45, 15, 67, 46, 16],

      // 40
      [19, 148, 118, 6, 149, 119],
      [18, 75, 47, 31, 76, 48],
      [34, 54, 24, 34, 55, 25],
      [20, 45, 15, 61, 46, 16]
    ];

    var qrRSBlock = function(totalCount, dataCount) {
      var _this = {};
      _this.totalCount = totalCount;
      _this.dataCount = dataCount;
      return _this;
    };

    var _this = {};

    var getRsBlockTable = function(typeNumber, errorCorrectionLevel) {

      switch(errorCorrectionLevel) {
      case QRErrorCorrectionLevel.L :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
      case QRErrorCorrectionLevel.M :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
      case QRErrorCorrectionLevel.Q :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
      case QRErrorCorrectionLevel.H :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
      default :
        return undefined;
      }
    };

    _this.getRSBlocks = function(typeNumber, errorCorrectionLevel) {

      var rsBlock = getRsBlockTable(typeNumber, errorCorrectionLevel);

      if (typeof rsBlock == 'undefined') {
        throw 'bad rs block @ typeNumber:' + typeNumber +
            '/errorCorrectionLevel:' + errorCorrectionLevel;
      }

      var length = rsBlock.length / 3;

      var list = [];

      for (var i = 0; i < length; i += 1) {

        var count = rsBlock[i * 3 + 0];
        var totalCount = rsBlock[i * 3 + 1];
        var dataCount = rsBlock[i * 3 + 2];

        for (var j = 0; j < count; j += 1) {
          list.push(qrRSBlock(totalCount, dataCount) );
        }
      }

      return list;
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // qrBitBuffer
  //---------------------------------------------------------------------

  var qrBitBuffer = function() {

    var _buffer = [];
    var _length = 0;

    var _this = {};

    _this.getBuffer = function() {
      return _buffer;
    };

    _this.getAt = function(index) {
      var bufIndex = Math.floor(index / 8);
      return ( (_buffer[bufIndex] >>> (7 - index % 8) ) & 1) == 1;
    };

    _this.put = function(num, length) {
      for (var i = 0; i < length; i += 1) {
        _this.putBit( ( (num >>> (length - i - 1) ) & 1) == 1);
      }
    };

    _this.getLengthInBits = function() {
      return _length;
    };

    _this.putBit = function(bit) {

      var bufIndex = Math.floor(_length / 8);
      if (_buffer.length <= bufIndex) {
        _buffer.push(0);
      }

      if (bit) {
        _buffer[bufIndex] |= (0x80 >>> (_length % 8) );
      }

      _length += 1;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrNumber
  //---------------------------------------------------------------------

  var qrNumber = function(data) {

    var _mode = QRMode.MODE_NUMBER;
    var _data = data;

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _data.length;
    };

    _this.write = function(buffer) {

      var data = _data;

      var i = 0;

      while (i + 2 < data.length) {
        buffer.put(strToNum(data.substring(i, i + 3) ), 10);
        i += 3;
      }

      if (i < data.length) {
        if (data.length - i == 1) {
          buffer.put(strToNum(data.substring(i, i + 1) ), 4);
        } else if (data.length - i == 2) {
          buffer.put(strToNum(data.substring(i, i + 2) ), 7);
        }
      }
    };

    var strToNum = function(s) {
      var num = 0;
      for (var i = 0; i < s.length; i += 1) {
        num = num * 10 + chatToNum(s.charAt(i) );
      }
      return num;
    };

    var chatToNum = function(c) {
      if ('0' <= c && c <= '9') {
        return c.charCodeAt(0) - '0'.charCodeAt(0);
      }
      throw 'illegal char :' + c;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrAlphaNum
  //---------------------------------------------------------------------

  var qrAlphaNum = function(data) {

    var _mode = QRMode.MODE_ALPHA_NUM;
    var _data = data;

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _data.length;
    };

    _this.write = function(buffer) {

      var s = _data;

      var i = 0;

      while (i + 1 < s.length) {
        buffer.put(
          getCode(s.charAt(i) ) * 45 +
          getCode(s.charAt(i + 1) ), 11);
        i += 2;
      }

      if (i < s.length) {
        buffer.put(getCode(s.charAt(i) ), 6);
      }
    };

    var getCode = function(c) {

      if ('0' <= c && c <= '9') {
        return c.charCodeAt(0) - '0'.charCodeAt(0);
      } else if ('A' <= c && c <= 'Z') {
        return c.charCodeAt(0) - 'A'.charCodeAt(0) + 10;
      } else {
        switch (c) {
        case ' ' : return 36;
        case '$' : return 37;
        case '%' : return 38;
        case '*' : return 39;
        case '+' : return 40;
        case '-' : return 41;
        case '.' : return 42;
        case '/' : return 43;
        case ':' : return 44;
        default :
          throw 'illegal char :' + c;
        }
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qr8BitByte
  //---------------------------------------------------------------------

  var qr8BitByte = function(data) {

    var _mode = QRMode.MODE_8BIT_BYTE;
    var _data = data;
    var _bytes = qrcode.stringToBytes(data);

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _bytes.length;
    };

    _this.write = function(buffer) {
      for (var i = 0; i < _bytes.length; i += 1) {
        buffer.put(_bytes[i], 8);
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrKanji
  //---------------------------------------------------------------------

  var qrKanji = function(data) {

    var _mode = QRMode.MODE_KANJI;
    var _data = data;

    var stringToBytes = qrcode.stringToBytesFuncs['SJIS'];
    if (!stringToBytes) {
      throw 'sjis not supported.';
    }
    !function(c, code) {
      // self test for sjis support.
      var test = stringToBytes(c);
      if (test.length != 2 || ( (test[0] << 8) | test[1]) != code) {
        throw 'sjis not supported.';
      }
    }('\u53cb', 0x9746);

    var _bytes = stringToBytes(data);

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return ~~(_bytes.length / 2);
    };

    _this.write = function(buffer) {

      var data = _bytes;

      var i = 0;

      while (i + 1 < data.length) {

        var c = ( (0xff & data[i]) << 8) | (0xff & data[i + 1]);

        if (0x8140 <= c && c <= 0x9FFC) {
          c -= 0x8140;
        } else if (0xE040 <= c && c <= 0xEBBF) {
          c -= 0xC140;
        } else {
          throw 'illegal char at ' + (i + 1) + '/' + c;
        }

        c = ( (c >>> 8) & 0xff) * 0xC0 + (c & 0xff);

        buffer.put(c, 13);

        i += 2;
      }

      if (i < data.length) {
        throw 'illegal char at ' + (i + 1);
      }
    };

    return _this;
  };

  //=====================================================================
  // GIF Support etc.
  //

  //---------------------------------------------------------------------
  // byteArrayOutputStream
  //---------------------------------------------------------------------

  var byteArrayOutputStream = function() {

    var _bytes = [];

    var _this = {};

    _this.writeByte = function(b) {
      _bytes.push(b & 0xff);
    };

    _this.writeShort = function(i) {
      _this.writeByte(i);
      _this.writeByte(i >>> 8);
    };

    _this.writeBytes = function(b, off, len) {
      off = off || 0;
      len = len || b.length;
      for (var i = 0; i < len; i += 1) {
        _this.writeByte(b[i + off]);
      }
    };

    _this.writeString = function(s) {
      for (var i = 0; i < s.length; i += 1) {
        _this.writeByte(s.charCodeAt(i) );
      }
    };

    _this.toByteArray = function() {
      return _bytes;
    };

    _this.toString = function() {
      var s = '';
      s += '[';
      for (var i = 0; i < _bytes.length; i += 1) {
        if (i > 0) {
          s += ',';
        }
        s += _bytes[i];
      }
      s += ']';
      return s;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // base64EncodeOutputStream
  //---------------------------------------------------------------------

  var base64EncodeOutputStream = function() {

    var _buffer = 0;
    var _buflen = 0;
    var _length = 0;
    var _base64 = '';

    var _this = {};

    var writeEncoded = function(b) {
      _base64 += String.fromCharCode(encode(b & 0x3f) );
    };

    var encode = function(n) {
      if (n < 0) {
        // error.
      } else if (n < 26) {
        return 0x41 + n;
      } else if (n < 52) {
        return 0x61 + (n - 26);
      } else if (n < 62) {
        return 0x30 + (n - 52);
      } else if (n == 62) {
        return 0x2b;
      } else if (n == 63) {
        return 0x2f;
      }
      throw 'n:' + n;
    };

    _this.writeByte = function(n) {

      _buffer = (_buffer << 8) | (n & 0xff);
      _buflen += 8;
      _length += 1;

      while (_buflen >= 6) {
        writeEncoded(_buffer >>> (_buflen - 6) );
        _buflen -= 6;
      }
    };

    _this.flush = function() {

      if (_buflen > 0) {
        writeEncoded(_buffer << (6 - _buflen) );
        _buffer = 0;
        _buflen = 0;
      }

      if (_length % 3 != 0) {
        // padding
        var padlen = 3 - _length % 3;
        for (var i = 0; i < padlen; i += 1) {
          _base64 += '=';
        }
      }
    };

    _this.toString = function() {
      return _base64;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // base64DecodeInputStream
  //---------------------------------------------------------------------

  var base64DecodeInputStream = function(str) {

    var _str = str;
    var _pos = 0;
    var _buffer = 0;
    var _buflen = 0;

    var _this = {};

    _this.read = function() {

      while (_buflen < 8) {

        if (_pos >= _str.length) {
          if (_buflen == 0) {
            return -1;
          }
          throw 'unexpected end of file./' + _buflen;
        }

        var c = _str.charAt(_pos);
        _pos += 1;

        if (c == '=') {
          _buflen = 0;
          return -1;
        } else if (c.match(/^\s$/) ) {
          // ignore if whitespace.
          continue;
        }

        _buffer = (_buffer << 6) | decode(c.charCodeAt(0) );
        _buflen += 6;
      }

      var n = (_buffer >>> (_buflen - 8) ) & 0xff;
      _buflen -= 8;
      return n;
    };

    var decode = function(c) {
      if (0x41 <= c && c <= 0x5a) {
        return c - 0x41;
      } else if (0x61 <= c && c <= 0x7a) {
        return c - 0x61 + 26;
      } else if (0x30 <= c && c <= 0x39) {
        return c - 0x30 + 52;
      } else if (c == 0x2b) {
        return 62;
      } else if (c == 0x2f) {
        return 63;
      } else {
        throw 'c:' + c;
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // gifImage (B/W)
  //---------------------------------------------------------------------

  var gifImage = function(width, height) {

    var _width = width;
    var _height = height;
    var _data = new Array(width * height);

    var _this = {};

    _this.setPixel = function(x, y, pixel) {
      _data[y * _width + x] = pixel;
    };

    _this.write = function(out) {

      //---------------------------------
      // GIF Signature

      out.writeString('GIF87a');

      //---------------------------------
      // Screen Descriptor

      out.writeShort(_width);
      out.writeShort(_height);

      out.writeByte(0x80); // 2bit
      out.writeByte(0);
      out.writeByte(0);

      //---------------------------------
      // Global Color Map

      // black
      out.writeByte(0x00);
      out.writeByte(0x00);
      out.writeByte(0x00);

      // white
      out.writeByte(0xff);
      out.writeByte(0xff);
      out.writeByte(0xff);

      //---------------------------------
      // Image Descriptor

      out.writeString(',');
      out.writeShort(0);
      out.writeShort(0);
      out.writeShort(_width);
      out.writeShort(_height);
      out.writeByte(0);

      //---------------------------------
      // Local Color Map

      //---------------------------------
      // Raster Data

      var lzwMinCodeSize = 2;
      var raster = getLZWRaster(lzwMinCodeSize);

      out.writeByte(lzwMinCodeSize);

      var offset = 0;

      while (raster.length - offset > 255) {
        out.writeByte(255);
        out.writeBytes(raster, offset, 255);
        offset += 255;
      }

      out.writeByte(raster.length - offset);
      out.writeBytes(raster, offset, raster.length - offset);
      out.writeByte(0x00);

      //---------------------------------
      // GIF Terminator
      out.writeString(';');
    };

    var bitOutputStream = function(out) {

      var _out = out;
      var _bitLength = 0;
      var _bitBuffer = 0;

      var _this = {};

      _this.write = function(data, length) {

        if ( (data >>> length) != 0) {
          throw 'length over';
        }

        while (_bitLength + length >= 8) {
          _out.writeByte(0xff & ( (data << _bitLength) | _bitBuffer) );
          length -= (8 - _bitLength);
          data >>>= (8 - _bitLength);
          _bitBuffer = 0;
          _bitLength = 0;
        }

        _bitBuffer = (data << _bitLength) | _bitBuffer;
        _bitLength = _bitLength + length;
      };

      _this.flush = function() {
        if (_bitLength > 0) {
          _out.writeByte(_bitBuffer);
        }
      };

      return _this;
    };

    var getLZWRaster = function(lzwMinCodeSize) {

      var clearCode = 1 << lzwMinCodeSize;
      var endCode = (1 << lzwMinCodeSize) + 1;
      var bitLength = lzwMinCodeSize + 1;

      // Setup LZWTable
      var table = lzwTable();

      for (var i = 0; i < clearCode; i += 1) {
        table.add(String.fromCharCode(i) );
      }
      table.add(String.fromCharCode(clearCode) );
      table.add(String.fromCharCode(endCode) );

      var byteOut = byteArrayOutputStream();
      var bitOut = bitOutputStream(byteOut);

      // clear code
      bitOut.write(clearCode, bitLength);

      var dataIndex = 0;

      var s = String.fromCharCode(_data[dataIndex]);
      dataIndex += 1;

      while (dataIndex < _data.length) {

        var c = String.fromCharCode(_data[dataIndex]);
        dataIndex += 1;

        if (table.contains(s + c) ) {

          s = s + c;

        } else {

          bitOut.write(table.indexOf(s), bitLength);

          if (table.size() < 0xfff) {

            if (table.size() == (1 << bitLength) ) {
              bitLength += 1;
            }

            table.add(s + c);
          }

          s = c;
        }
      }

      bitOut.write(table.indexOf(s), bitLength);

      // end code
      bitOut.write(endCode, bitLength);

      bitOut.flush();

      return byteOut.toByteArray();
    };

    var lzwTable = function() {

      var _map = {};
      var _size = 0;

      var _this = {};

      _this.add = function(key) {
        if (_this.contains(key) ) {
          throw 'dup key:' + key;
        }
        _map[key] = _size;
        _size += 1;
      };

      _this.size = function() {
        return _size;
      };

      _this.indexOf = function(key) {
        return _map[key];
      };

      _this.contains = function(key) {
        return typeof _map[key] != 'undefined';
      };

      return _this;
    };

    return _this;
  };

  var createDataURL = function(width, height, getPixel) {
    var gif = gifImage(width, height);
    for (var y = 0; y < height; y += 1) {
      for (var x = 0; x < width; x += 1) {
        gif.setPixel(x, y, getPixel(x, y) );
      }
    }

    var b = byteArrayOutputStream();
    gif.write(b);

    var base64 = base64EncodeOutputStream();
    var bytes = b.toByteArray();
    for (var i = 0; i < bytes.length; i += 1) {
      base64.writeByte(bytes[i]);
    }
    base64.flush();

    return 'data:image/gif;base64,' + base64;
  };

  //---------------------------------------------------------------------
  // returns qrcode function.

  return qrcode;
}();

// multibyte support
!function() {

  qrcode.stringToBytesFuncs['UTF-8'] = function(s) {
    // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
    function toUTF8Array(str) {
      var utf8 = [];
      for (var i=0; i < str.length; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 0x80) utf8.push(charcode);
        else if (charcode < 0x800) {
          utf8.push(0xc0 | (charcode >> 6),
              0x80 | (charcode & 0x3f));
        }
        else if (charcode < 0xd800 || charcode >= 0xe000) {
          utf8.push(0xe0 | (charcode >> 12),
              0x80 | ((charcode>>6) & 0x3f),
              0x80 | (charcode & 0x3f));
        }
        // surrogate pair
        else {
          i++;
          // UTF-16 encodes 0x10000-0x10FFFF by
          // subtracting 0x10000 and splitting the
          // 20 bits of 0x0-0xFFFFF into two halves
          charcode = 0x10000 + (((charcode & 0x3ff)<<10)
            | (str.charCodeAt(i) & 0x3ff));
          utf8.push(0xf0 | (charcode >>18),
              0x80 | ((charcode>>12) & 0x3f),
              0x80 | ((charcode>>6) & 0x3f),
              0x80 | (charcode & 0x3f));
        }
      }
      return utf8;
    }
    return toUTF8Array(s);
  };

}();

(function (factory) {
  if (typeof define === 'function' && define.amd) {
      define([], factory);
  } else if (typeof exports === 'object') {
      module.exports = factory();
  }
}(function () {
    return qrcode;
}));

},{}],290:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],291:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
};
/*</replacement>*/

module.exports = Duplex;
const Readable = require('./_stream_readable');
const Writable = require('./_stream_writable');
require('inherits')(Duplex, Readable);
{
  // Allow the keys array to be GC'ed.
  const keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    const method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get() {
    return this._writableState.length;
  }
});

// the no-half-open enforcer
function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))
},{"./_stream_readable":293,"./_stream_writable":295,"_process":7,"inherits":285}],292:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;
const Transform = require('./_stream_transform');
require('inherits')(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":294,"inherits":285}],293:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

module.exports = Readable;

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
const EE = require('events').EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

const Buffer = require('buffer').Buffer;
const OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*<replacement>*/
const debugUtil = require('util');
let debug;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

const BufferList = require('./internal/streams/buffer_list');
const destroyImpl = require('./internal/streams/destroy');
const _require = require('./internal/streams/state'),
  getHighWaterMark = _require.getHighWaterMark;
const _require$codes = require('../errors').codes,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

// Lazy loaded to improve the startup performance.
let StringDecoder;
let createReadableStreamAsyncIterator;
let from;
require('inherits')(Readable, Stream);
const errorOrDestroy = destroyImpl.errorOrDestroy;
const kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'end' (and potentially 'finish')
  this.autoDestroy = !!options.autoDestroy;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options);

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5
  const isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);

  // legacy
  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }
  Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }
  return er;
}
Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  const decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  // If setEncoding(null), decoder.encoding equals utf8
  this._readableState.encoding = this._readableState.decoder.encoding;

  // Iterate over current buffer to convert already stored Buffers:
  let p = this._readableState.buffer.head;
  let content = '';
  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }
  this._readableState.buffer.clear();
  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};

// Don't raise the hwm > 1GB
const MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit('data', ret);
  return ret;
};
function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;
    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);
  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  }

  // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    const len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);
    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
      hasUnpiped: false
    });
    return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  const res = Stream.prototype.on.call(this, ev, fn);
  const state = this._readableState;
  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0;

    // Try start flowing on next tick if stream isn't explicitly paused
    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function (ev, fn) {
  const res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.removeAllListeners = function (ev) {
  const res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self) {
  const state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;
  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;

    // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state.paused = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug('resume', state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  this._readableState.paused = true;
  return this;
};
function flow(stream) {
  const state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null);
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;
  stream.on('end', () => {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) this.push(chunk);
    }
    this.push(null);
  });
  stream.on('data', chunk => {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = n => {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return this;
};
if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get() {
    return this._readableState.length;
  }
});

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length);

  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      const wState = stream._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}
if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }
    return from(Readable, iterable, opts);
  };
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":290,"./_stream_duplex":291,"./internal/streams/async_iterator":296,"./internal/streams/buffer_list":297,"./internal/streams/destroy":298,"./internal/streams/from":300,"./internal/streams/state":302,"./internal/streams/stream":303,"_process":7,"buffer":3,"events":4,"inherits":285,"string_decoder/":515,"util":2}],294:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;
const _require$codes = require('../errors').codes,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
const Duplex = require('./_stream_duplex');
require('inherits')(Transform, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}
function prefinish() {
  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush((er, data) => {
      done(this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, err2 => {
    cb(err2);
  });
};
function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null)
    // single equals check for both `null` and `undefined`
    stream.push(data);

  // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":290,"./_stream_duplex":291,"inherits":285}],295:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  this.next = null;
  this.entry = null;
  this.finish = () => {
    onCorkedFinish(this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
const internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

const Buffer = require('buffer').Buffer;
const OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
const destroyImpl = require('./internal/streams/destroy');
const _require = require('./internal/streams/state'),
  getHighWaterMark = _require.getHighWaterMark;
const _require$codes = require('../errors').codes,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
const errorOrDestroy = destroyImpl.errorOrDestroy;
require('inherits')(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'finish' (and potentially 'end')
  this.autoDestroy = !!options.autoDestroy;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5
  const isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }
  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  // TODO: defer error events consistently everywhere, not just the cb
  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }
  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  this._writableState.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk,
      encoding,
      isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
  return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get() {
    return this._writableState.length;
  }
});
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(err => {
    state.pendingcb--;
    if (err) {
      errorOrDestroy(stream, err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        const rState = stream._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":290,"./_stream_duplex":291,"./internal/streams/destroy":298,"./internal/streams/state":302,"./internal/streams/stream":303,"_process":7,"buffer":3,"inherits":285,"util-deprecate":517}],296:[function(require,module,exports){
(function (process){(function (){
'use strict';

const finished = require('./end-of-stream');
const kLastResolve = Symbol('lastResolve');
const kLastReject = Symbol('lastReject');
const kError = Symbol('error');
const kEnded = Symbol('ended');
const kLastPromise = Symbol('lastPromise');
const kHandlePromise = Symbol('handlePromise');
const kStream = Symbol('stream');
function createIterResult(value, done) {
  return {
    value,
    done
  };
}
function readAndResolve(iter) {
  const resolve = iter[kLastResolve];
  if (resolve !== null) {
    const data = iter[kStream].read();
    // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'
    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}
function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
  return (resolve, reject) => {
    lastPromise.then(() => {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }
      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}
const AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
const ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf({
  get stream() {
    return this[kStream];
  },
  next() {
    // if we have detected an error in the meanwhile
    // reject straight away
    const error = this[kError];
    if (error !== null) {
      return Promise.reject(error);
    }
    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }
    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise((resolve, reject) => {
        process.nextTick(() => {
          if (this[kError]) {
            reject(this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    }

    // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time
    const lastPromise = this[kLastPromise];
    let promise;
    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      const data = this[kStream].read();
      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }
      promise = new Promise(this[kHandlePromise]);
    }
    this[kLastPromise] = promise;
    return promise;
  },
  [Symbol.asyncIterator]() {
    return this;
  },
  return() {
    // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to
    return new Promise((resolve, reject) => {
      this[kStream].destroy(null, err => {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(undefined, true));
      });
    });
  }
}, AsyncIteratorPrototype);
const createReadableStreamAsyncIterator = stream => {
  const iterator = Object.create(ReadableStreamAsyncIteratorPrototype, {
    [kStream]: {
      value: stream,
      writable: true
    },
    [kLastResolve]: {
      value: null,
      writable: true
    },
    [kLastReject]: {
      value: null,
      writable: true
    },
    [kError]: {
      value: null,
      writable: true
    },
    [kEnded]: {
      value: stream._readableState.endEmitted,
      writable: true
    },
    // the function passed to new Promise
    // is cached so we avoid allocating a new
    // closure at every run
    [kHandlePromise]: {
      value: (resolve, reject) => {
        const data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }
  });
  iterator[kLastPromise] = null;
  finished(stream, err => {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      const reject = iterator[kLastReject];
      // reject if we are waiting for data in the Promise
      // returned by next() and store the error
      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }
      iterator[kError] = err;
      return;
    }
    const resolve = iterator[kLastResolve];
    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }
    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};
module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))
},{"./end-of-stream":299,"_process":7}],297:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const _require = require('buffer'),
  Buffer = _require.Buffer;
const _require2 = require('util'),
  inspect = _require2.inspect;
const custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}
module.exports = class BufferList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  push(v) {
    const entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  }
  unshift(v) {
    const entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  }
  shift() {
    if (this.length === 0) return;
    const ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  }
  clear() {
    this.head = this.tail = null;
    this.length = 0;
  }
  join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) ret += s + p.data;
    return ret;
  }
  concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    const ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  }

  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(n, hasStrings) {
    var ret;
    if (n < this.head.data.length) {
      // `slice` is the same for buffers and strings.
      ret = this.head.data.slice(0, n);
      this.head.data = this.head.data.slice(n);
    } else if (n === this.head.data.length) {
      // First chunk is a perfect match.
      ret = this.shift();
    } else {
      // Result spans more than one buffer.
      ret = hasStrings ? this._getString(n) : this._getBuffer(n);
    }
    return ret;
  }
  first() {
    return this.head.data;
  }

  // Consumes a specified amount of characters from the buffered data.
  _getString(n) {
    var p = this.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      const str = p.data;
      const nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) this.head = p.next;else this.head = this.tail = null;
        } else {
          this.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    this.length -= c;
    return ret;
  }

  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(n) {
    const ret = Buffer.allocUnsafe(n);
    var p = this.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      const buf = p.data;
      const nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) this.head = p.next;else this.head = this.tail = null;
        } else {
          this.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    this.length -= c;
    return ret;
  }

  // Make sure the linked list only shows the minimal necessary information.
  [custom](_, options) {
    return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: false
    }));
  }
};
},{"buffer":3,"util":2}],298:[function(require,module,exports){
(function (process){(function (){
'use strict';

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  const readableDestroyed = this._readableState && this._readableState.destroyed;
  const writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, err => {
    if (!cb && err) {
      if (!this._writableState) {
        process.nextTick(emitErrorAndCloseNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, this, err);
      } else {
        process.nextTick(emitCloseNT, this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self, err) {
  self.emit('error', err);
}
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  const rState = stream._readableState;
  const wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy,
  undestroy,
  errorOrDestroy
};
}).call(this)}).call(this,require('_process'))
},{"_process":7}],299:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

const ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
  let called = false;
  return function () {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop() {}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  let readable = opts.readable || opts.readable !== false && stream.readable;
  let writable = opts.writable || opts.writable !== false && stream.writable;
  const onlegacyfinish = () => {
    if (!stream.writable) onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  const onfinish = () => {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  const onend = () => {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };
  const onerror = err => {
    callback.call(stream, err);
  };
  const onclose = () => {
    let err;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  const onrequest = () => {
    stream.req.on('finish', onfinish);
  };
  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}
module.exports = eos;
},{"../../../errors":290}],300:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],301:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

let eos;
function once(callback) {
  let called = false;
  return function () {
    if (called) return;
    called = true;
    callback(...arguments);
  };
}
const _require$codes = require('../../../errors').codes,
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  let closed = false;
  stream.on('close', () => {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, err => {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  let destroyed = false;
  return err => {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
function call(fn) {
  fn();
}
function pipe(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  const callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  let error;
  const destroys = streams.map(function (stream, i) {
    const reading = i < streams.length - 1;
    const writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
module.exports = pipeline;
},{"../../../errors":290,"./end-of-stream":299}],302:[function(require,module,exports){
'use strict';

const ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      const name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }

  // Default value
  return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
  getHighWaterMark
};
},{"../../../errors":290}],303:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23,"events":4}],304:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

},{"./lib/_stream_duplex.js":291,"./lib/_stream_passthrough.js":292,"./lib/_stream_readable.js":293,"./lib/_stream_transform.js":294,"./lib/_stream_writable.js":295,"./lib/internal/streams/end-of-stream.js":299,"./lib/internal/streams/pipeline.js":301}],305:[function(require,module,exports){
'use strict'
var Buffer = require('buffer').Buffer
var inherits = require('inherits')
var HashBase = require('hash-base')

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160

},{"buffer":3,"hash-base":271,"inherits":285}],306:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("./internal/Observable");
exports.Observable = Observable_1.Observable;
var ConnectableObservable_1 = require("./internal/observable/ConnectableObservable");
exports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;
var groupBy_1 = require("./internal/operators/groupBy");
exports.GroupedObservable = groupBy_1.GroupedObservable;
var observable_1 = require("./internal/symbol/observable");
exports.observable = observable_1.observable;
var Subject_1 = require("./internal/Subject");
exports.Subject = Subject_1.Subject;
var BehaviorSubject_1 = require("./internal/BehaviorSubject");
exports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;
var ReplaySubject_1 = require("./internal/ReplaySubject");
exports.ReplaySubject = ReplaySubject_1.ReplaySubject;
var AsyncSubject_1 = require("./internal/AsyncSubject");
exports.AsyncSubject = AsyncSubject_1.AsyncSubject;
var asap_1 = require("./internal/scheduler/asap");
exports.asap = asap_1.asap;
exports.asapScheduler = asap_1.asapScheduler;
var async_1 = require("./internal/scheduler/async");
exports.async = async_1.async;
exports.asyncScheduler = async_1.asyncScheduler;
var queue_1 = require("./internal/scheduler/queue");
exports.queue = queue_1.queue;
exports.queueScheduler = queue_1.queueScheduler;
var animationFrame_1 = require("./internal/scheduler/animationFrame");
exports.animationFrame = animationFrame_1.animationFrame;
exports.animationFrameScheduler = animationFrame_1.animationFrameScheduler;
var VirtualTimeScheduler_1 = require("./internal/scheduler/VirtualTimeScheduler");
exports.VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;
exports.VirtualAction = VirtualTimeScheduler_1.VirtualAction;
var Scheduler_1 = require("./internal/Scheduler");
exports.Scheduler = Scheduler_1.Scheduler;
var Subscription_1 = require("./internal/Subscription");
exports.Subscription = Subscription_1.Subscription;
var Subscriber_1 = require("./internal/Subscriber");
exports.Subscriber = Subscriber_1.Subscriber;
var Notification_1 = require("./internal/Notification");
exports.Notification = Notification_1.Notification;
exports.NotificationKind = Notification_1.NotificationKind;
var pipe_1 = require("./internal/util/pipe");
exports.pipe = pipe_1.pipe;
var noop_1 = require("./internal/util/noop");
exports.noop = noop_1.noop;
var identity_1 = require("./internal/util/identity");
exports.identity = identity_1.identity;
var isObservable_1 = require("./internal/util/isObservable");
exports.isObservable = isObservable_1.isObservable;
var ArgumentOutOfRangeError_1 = require("./internal/util/ArgumentOutOfRangeError");
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
var EmptyError_1 = require("./internal/util/EmptyError");
exports.EmptyError = EmptyError_1.EmptyError;
var ObjectUnsubscribedError_1 = require("./internal/util/ObjectUnsubscribedError");
exports.ObjectUnsubscribedError = ObjectUnsubscribedError_1.ObjectUnsubscribedError;
var UnsubscriptionError_1 = require("./internal/util/UnsubscriptionError");
exports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;
var TimeoutError_1 = require("./internal/util/TimeoutError");
exports.TimeoutError = TimeoutError_1.TimeoutError;
var bindCallback_1 = require("./internal/observable/bindCallback");
exports.bindCallback = bindCallback_1.bindCallback;
var bindNodeCallback_1 = require("./internal/observable/bindNodeCallback");
exports.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;
var combineLatest_1 = require("./internal/observable/combineLatest");
exports.combineLatest = combineLatest_1.combineLatest;
var concat_1 = require("./internal/observable/concat");
exports.concat = concat_1.concat;
var defer_1 = require("./internal/observable/defer");
exports.defer = defer_1.defer;
var empty_1 = require("./internal/observable/empty");
exports.empty = empty_1.empty;
var forkJoin_1 = require("./internal/observable/forkJoin");
exports.forkJoin = forkJoin_1.forkJoin;
var from_1 = require("./internal/observable/from");
exports.from = from_1.from;
var fromEvent_1 = require("./internal/observable/fromEvent");
exports.fromEvent = fromEvent_1.fromEvent;
var fromEventPattern_1 = require("./internal/observable/fromEventPattern");
exports.fromEventPattern = fromEventPattern_1.fromEventPattern;
var generate_1 = require("./internal/observable/generate");
exports.generate = generate_1.generate;
var iif_1 = require("./internal/observable/iif");
exports.iif = iif_1.iif;
var interval_1 = require("./internal/observable/interval");
exports.interval = interval_1.interval;
var merge_1 = require("./internal/observable/merge");
exports.merge = merge_1.merge;
var never_1 = require("./internal/observable/never");
exports.never = never_1.never;
var of_1 = require("./internal/observable/of");
exports.of = of_1.of;
var onErrorResumeNext_1 = require("./internal/observable/onErrorResumeNext");
exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;
var pairs_1 = require("./internal/observable/pairs");
exports.pairs = pairs_1.pairs;
var partition_1 = require("./internal/observable/partition");
exports.partition = partition_1.partition;
var race_1 = require("./internal/observable/race");
exports.race = race_1.race;
var range_1 = require("./internal/observable/range");
exports.range = range_1.range;
var throwError_1 = require("./internal/observable/throwError");
exports.throwError = throwError_1.throwError;
var timer_1 = require("./internal/observable/timer");
exports.timer = timer_1.timer;
var using_1 = require("./internal/observable/using");
exports.using = using_1.using;
var zip_1 = require("./internal/observable/zip");
exports.zip = zip_1.zip;
var scheduled_1 = require("./internal/scheduled/scheduled");
exports.scheduled = scheduled_1.scheduled;
var empty_2 = require("./internal/observable/empty");
exports.EMPTY = empty_2.EMPTY;
var never_2 = require("./internal/observable/never");
exports.NEVER = never_2.NEVER;
var config_1 = require("./internal/config");
exports.config = config_1.config;

},{"./internal/AsyncSubject":307,"./internal/BehaviorSubject":308,"./internal/Notification":310,"./internal/Observable":311,"./internal/ReplaySubject":314,"./internal/Scheduler":315,"./internal/Subject":316,"./internal/Subscriber":318,"./internal/Subscription":319,"./internal/config":320,"./internal/observable/ConnectableObservable":322,"./internal/observable/bindCallback":324,"./internal/observable/bindNodeCallback":325,"./internal/observable/combineLatest":326,"./internal/observable/concat":327,"./internal/observable/defer":328,"./internal/observable/empty":329,"./internal/observable/forkJoin":330,"./internal/observable/from":331,"./internal/observable/fromEvent":333,"./internal/observable/fromEventPattern":334,"./internal/observable/generate":335,"./internal/observable/iif":336,"./internal/observable/interval":337,"./internal/observable/merge":338,"./internal/observable/never":339,"./internal/observable/of":340,"./internal/observable/onErrorResumeNext":341,"./internal/observable/pairs":342,"./internal/observable/partition":343,"./internal/observable/race":344,"./internal/observable/range":345,"./internal/observable/throwError":346,"./internal/observable/timer":347,"./internal/observable/using":348,"./internal/observable/zip":349,"./internal/operators/groupBy":385,"./internal/scheduled/scheduled":457,"./internal/scheduler/VirtualTimeScheduler":467,"./internal/scheduler/animationFrame":468,"./internal/scheduler/asap":469,"./internal/scheduler/async":470,"./internal/scheduler/queue":471,"./internal/symbol/observable":473,"./internal/util/ArgumentOutOfRangeError":475,"./internal/util/EmptyError":476,"./internal/util/ObjectUnsubscribedError":478,"./internal/util/TimeoutError":479,"./internal/util/UnsubscriptionError":480,"./internal/util/identity":483,"./internal/util/isObservable":492,"./internal/util/noop":495,"./internal/util/pipe":497}],307:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("./Subject");
var Subscription_1 = require("./Subscription");
var AsyncSubject = (function (_super) {
    __extends(AsyncSubject, _super);
    function AsyncSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject_1.Subject));
exports.AsyncSubject = AsyncSubject;

},{"./Subject":316,"./Subscription":319}],308:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("./Subject");
var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
var BehaviorSubject = (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject_1.Subject));
exports.BehaviorSubject = BehaviorSubject;

},{"./Subject":316,"./util/ObjectUnsubscribedError":478}],309:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("./Subscriber");
var InnerSubscriber = (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
exports.InnerSubscriber = InnerSubscriber;

},{"./Subscriber":318}],310:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var empty_1 = require("./observable/empty");
var of_1 = require("./observable/of");
var throwError_1 = require("./observable/throwError");
var NotificationKind;
(function (NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
})(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));
var Notification = (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return of_1.of(this.value);
            case 'E':
                return throwError_1.throwError(this.error);
            case 'C':
                return empty_1.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());
exports.Notification = Notification;

},{"./observable/empty":329,"./observable/of":340,"./observable/throwError":346}],311:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var canReportError_1 = require("./util/canReportError");
var toSubscriber_1 = require("./util/toSubscriber");
var observable_1 = require("./symbol/observable");
var pipe_1 = require("./util/pipe");
var config_1 = require("./config");
var Observable = (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            sink.add(operator.call(sink, this.source));
        }
        else {
            sink.add(this.source || (config_1.config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if (canReportError_1.canReportError(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[observable_1.observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;
function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = config_1.config.Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}

},{"./config":320,"./symbol/observable":473,"./util/canReportError":481,"./util/pipe":497,"./util/toSubscriber":504}],312:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = require("./config");
var hostReportError_1 = require("./util/hostReportError");
exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            hostReportError_1.hostReportError(err);
        }
    },
    complete: function () { }
};

},{"./config":320,"./util/hostReportError":482}],313:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("./Subscriber");
var OuterSubscriber = (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber));
exports.OuterSubscriber = OuterSubscriber;

},{"./Subscriber":318}],314:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("./Subject");
var queue_1 = require("./scheduler/queue");
var Subscription_1 = require("./Subscription");
var observeOn_1 = require("./operators/observeOn");
var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
var SubjectSubscription_1 = require("./SubjectSubscription");
var ReplaySubject = (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        if (!this.isStopped) {
            var _events = this._events;
            _events.push(value);
            if (_events.length > this._bufferSize) {
                _events.shift();
            }
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        if (!this.isStopped) {
            this._events.push(new ReplayEvent(this._getNow(), value));
            this._trimBufferThenGetEvents();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.isStopped || this.hasError) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue_1.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1.Subject));
exports.ReplaySubject = ReplaySubject;
var ReplayEvent = (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());

},{"./Subject":316,"./SubjectSubscription":317,"./Subscription":319,"./operators/observeOn":400,"./scheduler/queue":471,"./util/ObjectUnsubscribedError":478}],315:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Scheduler = (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler.now; }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = function () { return Date.now(); };
    return Scheduler;
}());
exports.Scheduler = Scheduler;

},{}],316:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("./Observable");
var Subscriber_1 = require("./Subscriber");
var Subscription_1 = require("./Subscription");
var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
var SubjectSubscription_1 = require("./SubjectSubscription");
var rxSubscriber_1 = require("../internal/symbol/rxSubscriber");
var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;

},{"../internal/symbol/rxSubscriber":474,"./Observable":311,"./SubjectSubscription":317,"./Subscriber":318,"./Subscription":319,"./util/ObjectUnsubscribedError":478}],317:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = require("./Subscription");
var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;

},{"./Subscription":319}],318:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var isFunction_1 = require("./util/isFunction");
var Observer_1 = require("./Observer");
var Subscription_1 = require("./Subscription");
var rxSubscriber_1 = require("../internal/symbol/rxSubscriber");
var config_1 = require("./config");
var hostReportError_1 = require("./util/hostReportError");
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer_1.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!config_1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = config_1.config.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                hostReportError_1.hostReportError(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    hostReportError_1.hostReportError(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!config_1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError_1.hostReportError(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!config_1.config.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                hostReportError_1.hostReportError(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
exports.SafeSubscriber = SafeSubscriber;

},{"../internal/symbol/rxSubscriber":474,"./Observer":312,"./Subscription":319,"./config":320,"./util/hostReportError":482,"./util/isFunction":487}],319:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("./util/isArray");
var isObject_1 = require("./util/isObject");
var isFunction_1 = require("./util/isFunction");
var UnsubscriptionError_1 = require("./util/UnsubscriptionError");
var Subscription = (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._ctorUnsubscribe = true;
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription) {
            _parentOrParents.remove(this);
        }
        else if (_parentOrParents !== null) {
            for (var index = 0; index < _parentOrParents.length; ++index) {
                var parent_1 = _parentOrParents[index];
                parent_1.remove(this);
            }
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            if (_ctorUnsubscribe) {
                this._unsubscribe = undefined;
            }
            try {
                _unsubscribe.call(this);
            }
            catch (e) {
                errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    try {
                        sub.unsubscribe();
                    }
                    catch (e) {
                        errors = errors || [];
                        if (e instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                        }
                        else {
                            errors.push(e);
                        }
                    }
                }
            }
        }
        if (errors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        var subscription = teardown;
        if (!teardown) {
            return Subscription.EMPTY;
        }
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default: {
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
            subscription._parentOrParents = this;
        }
        else if (_parentOrParents instanceof Subscription) {
            if (_parentOrParents === this) {
                return subscription;
            }
            subscription._parentOrParents = [_parentOrParents, this];
        }
        else if (_parentOrParents.indexOf(this) === -1) {
            _parentOrParents.push(this);
        }
        else {
            return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
            this._subscriptions = [subscription];
        }
        else {
            subscriptions.push(subscription);
        }
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}

},{"./util/UnsubscriptionError":480,"./util/isArray":484,"./util/isFunction":487,"./util/isObject":491}],320:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _enable_super_gross_mode_that_will_cause_bad_things = false;
exports.config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = new Error();
            console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};

},{}],321:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("./Subscriber");
var Observable_1 = require("./Observable");
var subscribeTo_1 = require("./util/subscribeTo");
var SimpleInnerSubscriber = (function (_super) {
    __extends(SimpleInnerSubscriber, _super);
    function SimpleInnerSubscriber(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        return _this;
    }
    SimpleInnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(value);
    };
    SimpleInnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error);
        this.unsubscribe();
    };
    SimpleInnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete();
        this.unsubscribe();
    };
    return SimpleInnerSubscriber;
}(Subscriber_1.Subscriber));
exports.SimpleInnerSubscriber = SimpleInnerSubscriber;
var ComplexInnerSubscriber = (function (_super) {
    __extends(ComplexInnerSubscriber, _super);
    function ComplexInnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        return _this;
    }
    ComplexInnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this);
    };
    ComplexInnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error);
        this.unsubscribe();
    };
    ComplexInnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return ComplexInnerSubscriber;
}(Subscriber_1.Subscriber));
exports.ComplexInnerSubscriber = ComplexInnerSubscriber;
var SimpleOuterSubscriber = (function (_super) {
    __extends(SimpleOuterSubscriber, _super);
    function SimpleOuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SimpleOuterSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    SimpleOuterSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SimpleOuterSubscriber.prototype.notifyComplete = function () {
        this.destination.complete();
    };
    return SimpleOuterSubscriber;
}(Subscriber_1.Subscriber));
exports.SimpleOuterSubscriber = SimpleOuterSubscriber;
var ComplexOuterSubscriber = (function (_super) {
    __extends(ComplexOuterSubscriber, _super);
    function ComplexOuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComplexOuterSubscriber.prototype.notifyNext = function (_outerValue, innerValue, _outerIndex, _innerSub) {
        this.destination.next(innerValue);
    };
    ComplexOuterSubscriber.prototype.notifyError = function (error) {
        this.destination.error(error);
    };
    ComplexOuterSubscriber.prototype.notifyComplete = function (_innerSub) {
        this.destination.complete();
    };
    return ComplexOuterSubscriber;
}(Subscriber_1.Subscriber));
exports.ComplexOuterSubscriber = ComplexOuterSubscriber;
function innerSubscribe(result, innerSubscriber) {
    if (innerSubscriber.closed) {
        return undefined;
    }
    if (result instanceof Observable_1.Observable) {
        return result.subscribe(innerSubscriber);
    }
    var subscription;
    try {
        subscription = subscribeTo_1.subscribeTo(result)(innerSubscriber);
    }
    catch (error) {
        innerSubscriber.error(error);
    }
    return subscription;
}
exports.innerSubscribe = innerSubscribe;

},{"./Observable":311,"./Subscriber":318,"./util/subscribeTo":498}],322:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var Observable_1 = require("../Observable");
var Subscriber_1 = require("../Subscriber");
var Subscription_1 = require("../Subscription");
var refCount_1 = require("../operators/refCount");
var ConnectableObservable = (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount_1.refCount()(this);
    };
    return ConnectableObservable;
}(Observable_1.Observable));
exports.ConnectableObservable = ConnectableObservable;
exports.connectableObservableDescriptor = (function () {
    var connectableProto = ConnectableObservable.prototype;
    return {
        operator: { value: null },
        _refCount: { value: 0, writable: true },
        _subject: { value: null, writable: true },
        _connection: { value: null, writable: true },
        _subscribe: { value: connectableProto._subscribe },
        _isComplete: { value: connectableProto._isComplete, writable: true },
        getSubject: { value: connectableProto.getSubject },
        connect: { value: connectableProto.connect },
        refCount: { value: connectableProto.refCount }
    };
})();
var ConnectableSubscriber = (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber));
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Observable":311,"../Subject":316,"../Subscriber":318,"../Subscription":319,"../operators/refCount":411}],323:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var asap_1 = require("../scheduler/asap");
var isNumeric_1 = require("../util/isNumeric");
var SubscribeOnObservable = (function (_super) {
    __extends(SubscribeOnObservable, _super);
    function SubscribeOnObservable(source, delayTime, scheduler) {
        if (delayTime === void 0) { delayTime = 0; }
        if (scheduler === void 0) { scheduler = asap_1.asap; }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!isNumeric_1.isNumeric(delayTime) || delayTime < 0) {
            _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            _this.scheduler = asap_1.asap;
        }
        return _this;
    }
    SubscribeOnObservable.create = function (source, delay, scheduler) {
        if (delay === void 0) { delay = 0; }
        if (scheduler === void 0) { scheduler = asap_1.asap; }
        return new SubscribeOnObservable(source, delay, scheduler);
    };
    SubscribeOnObservable.dispatch = function (arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
    };
    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
        var delay = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source, subscriber: subscriber
        });
    };
    return SubscribeOnObservable;
}(Observable_1.Observable));
exports.SubscribeOnObservable = SubscribeOnObservable;

},{"../Observable":311,"../scheduler/asap":469,"../util/isNumeric":490}],324:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var AsyncSubject_1 = require("../AsyncSubject");
var map_1 = require("../operators/map");
var canReportError_1 = require("../util/canReportError");
var isArray_1 = require("../util/isArray");
var isScheduler_1 = require("../util/isScheduler");
function bindCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var context = this;
        var subject;
        var params = {
            context: context,
            subject: subject,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
        };
        return new Observable_1.Observable(function (subscriber) {
            if (!scheduler) {
                if (!subject) {
                    subject = new AsyncSubject_1.AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if (canReportError_1.canReportError(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                var state = {
                    args: args, subscriber: subscriber, params: params,
                };
                return scheduler.schedule(dispatch, 0, state);
            }
        });
    };
}
exports.bindCallback = bindCallback;
function dispatch(state) {
    var _this = this;
    var self = this;
    var args = state.args, subscriber = state.subscriber, params = state.params;
    var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new AsyncSubject_1.AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
            _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            subject.error(err);
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(state) {
    var value = state.value, subject = state.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(state) {
    var err = state.err, subject = state.subject;
    subject.error(err);
}

},{"../AsyncSubject":307,"../Observable":311,"../operators/map":389,"../util/canReportError":481,"../util/isArray":484,"../util/isScheduler":494}],325:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var AsyncSubject_1 = require("../AsyncSubject");
var map_1 = require("../operators/map");
var canReportError_1 = require("../util/canReportError");
var isScheduler_1 = require("../util/isScheduler");
var isArray_1 = require("../util/isArray");
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var params = {
            subject: undefined,
            args: args,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
            context: this,
        };
        return new Observable_1.Observable(function (subscriber) {
            var context = params.context;
            var subject = params.subject;
            if (!scheduler) {
                if (!subject) {
                    subject = params.subject = new AsyncSubject_1.AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        var err = innerArgs.shift();
                        if (err) {
                            subject.error(err);
                            return;
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if (canReportError_1.canReportError(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                return scheduler.schedule(dispatch, 0, { params: params, subscriber: subscriber, context: context });
            }
        });
    };
}
exports.bindNodeCallback = bindNodeCallback;
function dispatch(state) {
    var _this = this;
    var params = state.params, subscriber = state.subscriber, context = state.context;
    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new AsyncSubject_1.AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var err = innerArgs.shift();
            if (err) {
                _this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
            }
            else {
                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
            }
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(arg) {
    var value = arg.value, subject = arg.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(arg) {
    var err = arg.err, subject = arg.subject;
    subject.error(err);
}

},{"../AsyncSubject":307,"../Observable":311,"../operators/map":389,"../util/canReportError":481,"../util/isArray":484,"../util/isScheduler":494}],326:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var isScheduler_1 = require("../util/isScheduler");
var isArray_1 = require("../util/isArray");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
var fromArray_1 = require("./fromArray");
var NONE = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = undefined;
    var scheduler = undefined;
    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
    }
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0];
    }
    return fromArray_1.fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
exports.combineLatest = combineLatest;
var CombineLatestOperator = (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());
exports.CombineLatestOperator = CombineLatestOperator;
var CombineLatestSubscriber = (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, undefined, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.CombineLatestSubscriber = CombineLatestSubscriber;

},{"../OuterSubscriber":313,"../util/isArray":484,"../util/isScheduler":494,"../util/subscribeToResult":503,"./fromArray":332}],327:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var of_1 = require("./of");
var concatAll_1 = require("../operators/concatAll");
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));
}
exports.concat = concat;

},{"../operators/concatAll":361,"./of":340}],328:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var from_1 = require("./from");
var empty_1 = require("./empty");
function defer(observableFactory) {
    return new Observable_1.Observable(function (subscriber) {
        var input;
        try {
            input = observableFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = input ? from_1.from(input) : empty_1.empty();
        return source.subscribe(subscriber);
    });
}
exports.defer = defer;

},{"../Observable":311,"./empty":329,"./from":331}],329:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
exports.EMPTY = new Observable_1.Observable(function (subscriber) { return subscriber.complete(); });
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
}
exports.empty = empty;
function emptyScheduled(scheduler) {
    return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}

},{"../Observable":311}],330:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var isArray_1 = require("../util/isArray");
var map_1 = require("../operators/map");
var isObject_1 = require("../util/isObject");
var from_1 = require("./from");
function forkJoin() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 1) {
        var first_1 = sources[0];
        if (isArray_1.isArray(first_1)) {
            return forkJoinInternal(first_1, null);
        }
        if (isObject_1.isObject(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
            var keys = Object.keys(first_1);
            return forkJoinInternal(keys.map(function (key) { return first_1[key]; }), keys);
        }
    }
    if (typeof sources[sources.length - 1] === 'function') {
        var resultSelector_1 = sources.pop();
        sources = (sources.length === 1 && isArray_1.isArray(sources[0])) ? sources[0] : sources;
        return forkJoinInternal(sources, null).pipe(map_1.map(function (args) { return resultSelector_1.apply(void 0, args); }));
    }
    return forkJoinInternal(sources, null);
}
exports.forkJoin = forkJoin;
function forkJoinInternal(sources, keys) {
    return new Observable_1.Observable(function (subscriber) {
        var len = sources.length;
        if (len === 0) {
            subscriber.complete();
            return;
        }
        var values = new Array(len);
        var completed = 0;
        var emitted = 0;
        var _loop_1 = function (i) {
            var source = from_1.from(sources[i]);
            var hasValue = false;
            subscriber.add(source.subscribe({
                next: function (value) {
                    if (!hasValue) {
                        hasValue = true;
                        emitted++;
                    }
                    values[i] = value;
                },
                error: function (err) { return subscriber.error(err); },
                complete: function () {
                    completed++;
                    if (completed === len || !hasValue) {
                        if (emitted === len) {
                            subscriber.next(keys ?
                                keys.reduce(function (result, key, i) { return (result[key] = values[i], result); }, {}) :
                                values);
                        }
                        subscriber.complete();
                    }
                }
            }));
        };
        for (var i = 0; i < len; i++) {
            _loop_1(i);
        }
    });
}

},{"../Observable":311,"../operators/map":389,"../util/isArray":484,"../util/isObject":491,"./from":331}],331:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var subscribeTo_1 = require("../util/subscribeTo");
var scheduled_1 = require("../scheduled/scheduled");
function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof Observable_1.Observable) {
            return input;
        }
        return new Observable_1.Observable(subscribeTo_1.subscribeTo(input));
    }
    else {
        return scheduled_1.scheduled(input, scheduler);
    }
}
exports.from = from;

},{"../Observable":311,"../scheduled/scheduled":457,"../util/subscribeTo":498}],332:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var subscribeToArray_1 = require("../util/subscribeToArray");
var scheduleArray_1 = require("../scheduled/scheduleArray");
function fromArray(input, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(subscribeToArray_1.subscribeToArray(input));
    }
    else {
        return scheduleArray_1.scheduleArray(input, scheduler);
    }
}
exports.fromArray = fromArray;

},{"../Observable":311,"../scheduled/scheduleArray":453,"../util/subscribeToArray":499}],333:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var isArray_1 = require("../util/isArray");
var isFunction_1 = require("../util/isFunction");
var map_1 = require("../operators/map");
var toString = (function () { return Object.prototype.toString; })();
function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction_1.isFunction(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable_1.Observable(function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
exports.fromEvent = fromEvent;
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}

},{"../Observable":311,"../operators/map":389,"../util/isArray":484,"../util/isFunction":487}],334:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var isArray_1 = require("../util/isArray");
var isFunction_1 = require("../util/isFunction");
var map_1 = require("../operators/map");
function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable_1.Observable(function (subscriber) {
        var handler = function () {
            var e = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                e[_i] = arguments[_i];
            }
            return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue;
        try {
            retValue = addHandler(handler);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!isFunction_1.isFunction(removeHandler)) {
            return undefined;
        }
        return function () { return removeHandler(handler, retValue); };
    });
}
exports.fromEventPattern = fromEventPattern;

},{"../Observable":311,"../operators/map":389,"../util/isArray":484,"../util/isFunction":487}],335:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var identity_1 = require("../util/identity");
var isScheduler_1 = require("../util/isScheduler");
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
    var resultSelector;
    var initialState;
    if (arguments.length == 1) {
        var options = initialStateOrOptions;
        initialState = options.initialState;
        condition = options.condition;
        iterate = options.iterate;
        resultSelector = options.resultSelector || identity_1.identity;
        scheduler = options.scheduler;
    }
    else if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {
        initialState = initialStateOrOptions;
        resultSelector = identity_1.identity;
        scheduler = resultSelectorOrObservable;
    }
    else {
        initialState = initialStateOrOptions;
        resultSelector = resultSelectorOrObservable;
    }
    return new Observable_1.Observable(function (subscriber) {
        var state = initialState;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                subscriber: subscriber,
                iterate: iterate,
                condition: condition,
                resultSelector: resultSelector,
                state: state
            });
        }
        do {
            if (condition) {
                var conditionResult = void 0;
                try {
                    conditionResult = condition(state);
                }
                catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
                if (!conditionResult) {
                    subscriber.complete();
                    break;
                }
            }
            var value = void 0;
            try {
                value = resultSelector(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
            subscriber.next(value);
            if (subscriber.closed) {
                break;
            }
            try {
                state = iterate(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
        } while (true);
        return undefined;
    });
}
exports.generate = generate;
function dispatch(state) {
    var subscriber = state.subscriber, condition = state.condition;
    if (subscriber.closed) {
        return undefined;
    }
    if (state.needIterate) {
        try {
            state.state = state.iterate(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
    }
    else {
        state.needIterate = true;
    }
    if (condition) {
        var conditionResult = void 0;
        try {
            conditionResult = condition(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!conditionResult) {
            subscriber.complete();
            return undefined;
        }
        if (subscriber.closed) {
            return undefined;
        }
    }
    var value;
    try {
        value = state.resultSelector(state.state);
    }
    catch (err) {
        subscriber.error(err);
        return undefined;
    }
    if (subscriber.closed) {
        return undefined;
    }
    subscriber.next(value);
    if (subscriber.closed) {
        return undefined;
    }
    return this.schedule(state);
}

},{"../Observable":311,"../util/identity":483,"../util/isScheduler":494}],336:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var defer_1 = require("./defer");
var empty_1 = require("./empty");
function iif(condition, trueResult, falseResult) {
    if (trueResult === void 0) { trueResult = empty_1.EMPTY; }
    if (falseResult === void 0) { falseResult = empty_1.EMPTY; }
    return defer_1.defer(function () { return condition() ? trueResult : falseResult; });
}
exports.iif = iif;

},{"./defer":328,"./empty":329}],337:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var async_1 = require("../scheduler/async");
var isNumeric_1 = require("../util/isNumeric");
function interval(period, scheduler) {
    if (period === void 0) { period = 0; }
    if (scheduler === void 0) { scheduler = async_1.async; }
    if (!isNumeric_1.isNumeric(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = async_1.async;
    }
    return new Observable_1.Observable(function (subscriber) {
        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));
        return subscriber;
    });
}
exports.interval = interval;
function dispatch(state) {
    var subscriber = state.subscriber, counter = state.counter, period = state.period;
    subscriber.next(counter);
    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
}

},{"../Observable":311,"../scheduler/async":470,"../util/isNumeric":490}],338:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var isScheduler_1 = require("../util/isScheduler");
var mergeAll_1 = require("../operators/mergeAll");
var fromArray_1 = require("./fromArray");
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return mergeAll_1.mergeAll(concurrent)(fromArray_1.fromArray(observables, scheduler));
}
exports.merge = merge;

},{"../Observable":311,"../operators/mergeAll":394,"../util/isScheduler":494,"./fromArray":332}],339:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var noop_1 = require("../util/noop");
exports.NEVER = new Observable_1.Observable(noop_1.noop);
function never() {
    return exports.NEVER;
}
exports.never = never;

},{"../Observable":311,"../util/noop":495}],340:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isScheduler_1 = require("../util/isScheduler");
var fromArray_1 = require("./fromArray");
var scheduleArray_1 = require("../scheduled/scheduleArray");
function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        args.pop();
        return scheduleArray_1.scheduleArray(args, scheduler);
    }
    else {
        return fromArray_1.fromArray(args);
    }
}
exports.of = of;

},{"../scheduled/scheduleArray":453,"../util/isScheduler":494,"./fromArray":332}],341:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var from_1 = require("./from");
var isArray_1 = require("../util/isArray");
var empty_1 = require("./empty");
function onErrorResumeNext() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 0) {
        return empty_1.EMPTY;
    }
    var first = sources[0], remainder = sources.slice(1);
    if (sources.length === 1 && isArray_1.isArray(first)) {
        return onErrorResumeNext.apply(void 0, first);
    }
    return new Observable_1.Observable(function (subscriber) {
        var subNext = function () { return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)); };
        return from_1.from(first).subscribe({
            next: function (value) { subscriber.next(value); },
            error: subNext,
            complete: subNext,
        });
    });
}
exports.onErrorResumeNext = onErrorResumeNext;

},{"../Observable":311,"../util/isArray":484,"./empty":329,"./from":331}],342:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
function pairs(obj, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(function (subscriber) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length && !subscriber.closed; i++) {
                var key = keys[i];
                if (obj.hasOwnProperty(key)) {
                    subscriber.next([key, obj[key]]);
                }
            }
            subscriber.complete();
        });
    }
    else {
        return new Observable_1.Observable(function (subscriber) {
            var keys = Object.keys(obj);
            var subscription = new Subscription_1.Subscription();
            subscription.add(scheduler.schedule(dispatch, 0, { keys: keys, index: 0, subscriber: subscriber, subscription: subscription, obj: obj }));
            return subscription;
        });
    }
}
exports.pairs = pairs;
function dispatch(state) {
    var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
    if (!subscriber.closed) {
        if (index < keys.length) {
            var key = keys[index];
            subscriber.next([key, obj[key]]);
            subscription.add(this.schedule({ keys: keys, index: index + 1, subscriber: subscriber, subscription: subscription, obj: obj }));
        }
        else {
            subscriber.complete();
        }
    }
}
exports.dispatch = dispatch;

},{"../Observable":311,"../Subscription":319}],343:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var not_1 = require("../util/not");
var subscribeTo_1 = require("../util/subscribeTo");
var filter_1 = require("../operators/filter");
var Observable_1 = require("../Observable");
function partition(source, predicate, thisArg) {
    return [
        filter_1.filter(predicate, thisArg)(new Observable_1.Observable(subscribeTo_1.subscribeTo(source))),
        filter_1.filter(not_1.not(predicate, thisArg))(new Observable_1.Observable(subscribeTo_1.subscribeTo(source)))
    ];
}
exports.partition = partition;

},{"../Observable":311,"../operators/filter":380,"../util/not":496,"../util/subscribeTo":498}],344:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("../util/isArray");
var fromArray_1 = require("./fromArray");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    if (observables.length === 1) {
        if (isArray_1.isArray(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return fromArray_1.fromArray(observables, undefined).lift(new RaceOperator());
}
exports.race = race;
var RaceOperator = (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());
exports.RaceOperator = RaceOperator;
var RaceSubscriber = (function (_super) {
    __extends(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult_1.subscribeToResult(this, observable, undefined, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.RaceSubscriber = RaceSubscriber;

},{"../OuterSubscriber":313,"../util/isArray":484,"../util/subscribeToResult":503,"./fromArray":332}],345:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
function range(start, count, scheduler) {
    if (start === void 0) { start = 0; }
    return new Observable_1.Observable(function (subscriber) {
        if (count === undefined) {
            count = start;
            start = 0;
        }
        var index = 0;
        var current = start;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                index: index, count: count, start: start, subscriber: subscriber
            });
        }
        else {
            do {
                if (index++ >= count) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(current++);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
        }
        return undefined;
    });
}
exports.range = range;
function dispatch(state) {
    var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
    if (index >= count) {
        subscriber.complete();
        return;
    }
    subscriber.next(start);
    if (subscriber.closed) {
        return;
    }
    state.index = index + 1;
    state.start = start + 1;
    this.schedule(state);
}
exports.dispatch = dispatch;

},{"../Observable":311}],346:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
function throwError(error, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
    }
}
exports.throwError = throwError;
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}

},{"../Observable":311}],347:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var async_1 = require("../scheduler/async");
var isNumeric_1 = require("../util/isNumeric");
var isScheduler_1 = require("../util/isScheduler");
function timer(dueTime, periodOrScheduler, scheduler) {
    if (dueTime === void 0) { dueTime = 0; }
    var period = -1;
    if (isNumeric_1.isNumeric(periodOrScheduler)) {
        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
    }
    else if (isScheduler_1.isScheduler(periodOrScheduler)) {
        scheduler = periodOrScheduler;
    }
    if (!isScheduler_1.isScheduler(scheduler)) {
        scheduler = async_1.async;
    }
    return new Observable_1.Observable(function (subscriber) {
        var due = isNumeric_1.isNumeric(dueTime)
            ? dueTime
            : (+dueTime - scheduler.now());
        return scheduler.schedule(dispatch, due, {
            index: 0, period: period, subscriber: subscriber
        });
    });
}
exports.timer = timer;
function dispatch(state) {
    var index = state.index, period = state.period, subscriber = state.subscriber;
    subscriber.next(index);
    if (subscriber.closed) {
        return;
    }
    else if (period === -1) {
        return subscriber.complete();
    }
    state.index = index + 1;
    this.schedule(state, period);
}

},{"../Observable":311,"../scheduler/async":470,"../util/isNumeric":490,"../util/isScheduler":494}],348:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var from_1 = require("./from");
var empty_1 = require("./empty");
function using(resourceFactory, observableFactory) {
    return new Observable_1.Observable(function (subscriber) {
        var resource;
        try {
            resource = resourceFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var result;
        try {
            result = observableFactory(resource);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = result ? from_1.from(result) : empty_1.EMPTY;
        var subscription = source.subscribe(subscriber);
        return function () {
            subscription.unsubscribe();
            if (resource) {
                resource.unsubscribe();
            }
        };
    });
}
exports.using = using;

},{"../Observable":311,"./empty":329,"./from":331}],349:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var fromArray_1 = require("./fromArray");
var isArray_1 = require("../util/isArray");
var Subscriber_1 = require("../Subscriber");
var iterator_1 = require("../../internal/symbol/iterator");
var innerSubscribe_1 = require("../innerSubscribe");
function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = observables[observables.length - 1];
    if (typeof resultSelector === 'function') {
        observables.pop();
    }
    return fromArray_1.fromArray(observables, undefined).lift(new ZipOperator(resultSelector));
}
exports.zip = zip;
var ZipOperator = (function () {
    function ZipOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
    };
    return ZipOperator;
}());
exports.ZipOperator = ZipOperator;
var ZipSubscriber = (function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, resultSelector, values) {
        if (values === void 0) { values = Object.create(null); }
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : undefined;
        return _this;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray_1.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator_1.iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator_1.iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                var destination = this.destination;
                destination.add(iterator.subscribe());
            }
            else {
                this.active--;
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.resultSelector) {
            this._tryresultSelector(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryresultSelector = function (args) {
        var result;
        try {
            result = this.resultSelector.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber));
exports.ZipSubscriber = ZipSubscriber;
var StaticIterator = (function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return Boolean(nextResult && nextResult.done);
    };
    return StaticIterator;
}());
var StaticArrayIterator = (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
var ZipBufferIterator = (function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
    }
    ZipBufferIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (innerValue) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function () {
        return innerSubscribe_1.innerSubscribe(this.observable, new innerSubscribe_1.SimpleInnerSubscriber(this));
    };
    return ZipBufferIterator;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../../internal/symbol/iterator":472,"../Subscriber":318,"../innerSubscribe":321,"../util/isArray":484,"./fromArray":332}],350:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function audit(durationSelector) {
    return function auditOperatorFunction(source) {
        return source.lift(new AuditOperator(durationSelector));
    };
}
exports.audit = audit;
var AuditOperator = (function () {
    function AuditOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    AuditOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator;
}());
var AuditSubscriber = (function (_super) {
    __extends(AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = void 0;
            try {
                var durationSelector = this.durationSelector;
                duration = durationSelector(value);
            }
            catch (err) {
                return this.destination.error(err);
            }
            var innerSubscription = innerSubscribe_1.innerSubscribe(duration, new innerSubscribe_1.SimpleInnerSubscriber(this));
            if (!innerSubscription || innerSubscription.closed) {
                this.clearThrottle();
            }
            else {
                this.add(this.throttled = innerSubscription);
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = undefined;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = undefined;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function () {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":321}],351:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var audit_1 = require("./audit");
var timer_1 = require("../observable/timer");
function auditTime(duration, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });
}
exports.auditTime = auditTime;

},{"../observable/timer":347,"../scheduler/async":470,"./audit":350}],352:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function buffer(closingNotifier) {
    return function bufferOperatorFunction(source) {
        return source.lift(new BufferOperator(closingNotifier));
    };
}
exports.buffer = buffer;
var BufferOperator = (function () {
    function BufferOperator(closingNotifier) {
        this.closingNotifier = closingNotifier;
    }
    BufferOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator;
}());
var BufferSubscriber = (function (_super) {
    __extends(BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        var _this = _super.call(this, destination) || this;
        _this.buffer = [];
        _this.add(innerSubscribe_1.innerSubscribe(closingNotifier, new innerSubscribe_1.SimpleInnerSubscriber(_this)));
        return _this;
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function () {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":321}],353:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) { startBufferEvery = null; }
    return function bufferCountOperatorFunction(source) {
        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
    };
}
exports.bufferCount = bufferCount;
var BufferCountOperator = (function () {
    function BufferCountOperator(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
            this.subscriberClass = BufferCountSubscriber;
        }
        else {
            this.subscriberClass = BufferSkipCountSubscriber;
        }
    }
    BufferCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator;
}());
var BufferCountSubscriber = (function (_super) {
    __extends(BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.buffer = [];
        return _this;
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var buffer = this.buffer;
        buffer.push(value);
        if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(Subscriber_1.Subscriber));
var BufferSkipCountSubscriber = (function (_super) {
    __extends(BufferSkipCountSubscriber, _super);
    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.startBufferEvery = startBufferEvery;
        _this.buffers = [];
        _this.count = 0;
        return _this;
    }
    BufferSkipCountSubscriber.prototype._next = function (value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
        this.count++;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
            }
        }
    };
    BufferSkipCountSubscriber.prototype._complete = function () {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],354:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var Subscriber_1 = require("../Subscriber");
var isScheduler_1 = require("../util/isScheduler");
function bufferTime(bufferTimeSpan) {
    var length = arguments.length;
    var scheduler = async_1.async;
    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {
        scheduler = arguments[arguments.length - 1];
        length--;
    }
    var bufferCreationInterval = null;
    if (length >= 2) {
        bufferCreationInterval = arguments[1];
    }
    var maxBufferSize = Number.POSITIVE_INFINITY;
    if (length >= 3) {
        maxBufferSize = arguments[2];
    }
    return function bufferTimeOperatorFunction(source) {
        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
    };
}
exports.bufferTime = bufferTime;
var BufferTimeOperator = (function () {
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    }
    BufferTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    };
    return BufferTimeOperator;
}());
var Context = (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
var BufferTimeSubscriber = (function (_super) {
    __extends(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: _this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context_1 = contexts[i];
            var buffer = context_1.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context_1;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}

},{"../Subscriber":318,"../scheduler/async":470,"../util/isScheduler":494}],355:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = require("../Subscription");
var subscribeToResult_1 = require("../util/subscribeToResult");
var OuterSubscriber_1 = require("../OuterSubscriber");
function bufferToggle(openings, closingSelector) {
    return function bufferToggleOperatorFunction(source) {
        return source.lift(new BufferToggleOperator(openings, closingSelector));
    };
}
exports.bufferToggle = bufferToggle;
var BufferToggleOperator = (function () {
    function BufferToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    BufferToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return BufferToggleOperator;
}());
var BufferToggleSubscriber = (function (_super) {
    __extends(BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(subscribeToResult_1.subscribeToResult(_this, openings));
        return _this;
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_1 = contexts.shift();
            context_1.subscription.unsubscribe();
            context_1.buffer = null;
            context_1.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            this.destination.next(context_2.buffer);
            context_2.subscription.unsubscribe();
            context_2.buffer = null;
            context_2.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer, subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new Subscription_1.Subscription();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        }
        else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":313,"../Subscription":319,"../util/subscribeToResult":503}],356:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = require("../Subscription");
var innerSubscribe_1 = require("../innerSubscribe");
function bufferWhen(closingSelector) {
    return function (source) {
        return source.lift(new BufferWhenOperator(closingSelector));
    };
}
exports.bufferWhen = bufferWhen;
var BufferWhenOperator = (function () {
    function BufferWhenOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    BufferWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator;
}());
var BufferWhenSubscriber = (function (_super) {
    __extends(BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.subscribing = false;
        _this.openBuffer();
        return _this;
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = undefined;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function () {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier;
        try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
        }
        catch (err) {
            return this.error(err);
        }
        closingSubscription = new Subscription_1.Subscription();
        this.closingSubscription = closingSubscription;
        this.add(closingSubscription);
        this.subscribing = true;
        closingSubscription.add(innerSubscribe_1.innerSubscribe(closingNotifier, new innerSubscribe_1.SimpleInnerSubscriber(this)));
        this.subscribing = false;
    };
    return BufferWhenSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../Subscription":319,"../innerSubscribe":321}],357:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return (operator.caught = caught);
    };
}
exports.catchError = catchError;
var CatchOperator = (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
var CatchSubscriber = (function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
    }
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(this);
            this.add(innerSubscriber);
            var innerSubscription = innerSubscribe_1.innerSubscribe(result, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                this.add(innerSubscription);
            }
        }
    };
    return CatchSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":321}],358:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var combineLatest_1 = require("../observable/combineLatest");
function combineAll(project) {
    return function (source) { return source.lift(new combineLatest_1.CombineLatestOperator(project)); };
}
exports.combineAll = combineAll;

},{"../observable/combineLatest":326}],359:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("../util/isArray");
var combineLatest_1 = require("../observable/combineLatest");
var from_1 = require("../observable/from");
var none = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0].slice();
    }
    return function (source) { return source.lift.call(from_1.from([source].concat(observables)), new combineLatest_1.CombineLatestOperator(project)); };
}
exports.combineLatest = combineLatest;

},{"../observable/combineLatest":326,"../observable/from":331,"../util/isArray":484}],360:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_1 = require("../observable/concat");
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };
}
exports.concat = concat;

},{"../observable/concat":327}],361:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mergeAll_1 = require("./mergeAll");
function concatAll() {
    return mergeAll_1.mergeAll(1);
}
exports.concatAll = concatAll;

},{"./mergeAll":394}],362:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mergeMap_1 = require("./mergeMap");
function concatMap(project, resultSelector) {
    return mergeMap_1.mergeMap(project, resultSelector, 1);
}
exports.concatMap = concatMap;

},{"./mergeMap":395}],363:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concatMap_1 = require("./concatMap");
function concatMapTo(innerObservable, resultSelector) {
    return concatMap_1.concatMap(function () { return innerObservable; }, resultSelector);
}
exports.concatMapTo = concatMapTo;

},{"./concatMap":362}],364:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function count(predicate) {
    return function (source) { return source.lift(new CountOperator(predicate, source)); };
}
exports.count = count;
var CountOperator = (function () {
    function CountOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    CountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
    };
    return CountOperator;
}());
var CountSubscriber = (function (_super) {
    __extends(CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.count = 0;
        _this.index = 0;
        return _this;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        }
        else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],365:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function debounce(durationSelector) {
    return function (source) { return source.lift(new DebounceOperator(durationSelector)); };
}
exports.debounce = debounce;
var DebounceOperator = (function () {
    function DebounceOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    DebounceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    };
    return DebounceOperator;
}());
var DebounceSubscriber = (function (_super) {
    __extends(DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = innerSubscribe_1.innerSubscribe(duration, new innerSubscribe_1.SimpleInnerSubscriber(this));
        if (subscription && !subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = undefined;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = undefined;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":321}],366:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var async_1 = require("../scheduler/async");
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
var DebounceTimeSubscriber = (function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            var lastValue = this.lastValue;
            this.lastValue = null;
            this.hasValue = false;
            this.destination.next(lastValue);
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}

},{"../Subscriber":318,"../scheduler/async":470}],367:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) { defaultValue = null; }
    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
}
exports.defaultIfEmpty = defaultIfEmpty;
var DefaultIfEmptyOperator = (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}());
var DefaultIfEmptySubscriber = (function (_super) {
    __extends(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],368:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var isDate_1 = require("../util/isDate");
var Subscriber_1 = require("../Subscriber");
var Notification_1 = require("../Notification");
function delay(delay, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteDelay = isDate_1.isDate(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
}
exports.delay = delay;
var DelayOperator = (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
var DelaySubscriber = (function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            this.unsubscribe();
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification_1.Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification_1.Notification.createComplete());
        this.unsubscribe();
    };
    return DelaySubscriber;
}(Subscriber_1.Subscriber));
var DelayMessage = (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());

},{"../Notification":310,"../Subscriber":318,"../scheduler/async":470,"../util/isDate":486}],369:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Observable_1 = require("../Observable");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
        return function (source) {
            return new SubscriptionDelayObservable(source, subscriptionDelay)
                .lift(new DelayWhenOperator(delayDurationSelector));
        };
    }
    return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };
}
exports.delayWhen = delayWhen;
var DelayWhenOperator = (function () {
    function DelayWhenOperator(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
    }
    DelayWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
    };
    return DelayWhenOperator;
}());
var DelayWhenSubscriber = (function (_super) {
    __extends(DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.delayDurationSelector = delayDurationSelector;
        _this.completed = false;
        _this.delayNotifierSubscriptions = [];
        _this.index = 0;
        return _this;
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        var index = this.index++;
        try {
            var delayNotifier = this.delayDurationSelector(value, index);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
        this.unsubscribe();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        if (subscriptionIdx !== -1) {
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        }
        return subscription.outerValue;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
            var destination = this.destination;
            destination.add(notifierSubscription);
            this.delayNotifierSubscriptions.push(notifierSubscription);
        }
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
var SubscriptionDelayObservable = (function (_super) {
    __extends(SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subscriptionDelay = subscriptionDelay;
        return _this;
    }
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(Observable_1.Observable));
var SubscriptionDelaySubscriber = (function (_super) {
    __extends(SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.source = source;
        _this.sourceSubscribed = false;
        return _this;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.unsubscribe();
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(Subscriber_1.Subscriber));

},{"../Observable":311,"../OuterSubscriber":313,"../Subscriber":318,"../util/subscribeToResult":503}],370:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function dematerialize() {
    return function dematerializeOperatorFunction(source) {
        return source.lift(new DeMaterializeOperator());
    };
}
exports.dematerialize = dematerialize;
var DeMaterializeOperator = (function () {
    function DeMaterializeOperator() {
    }
    DeMaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
    };
    return DeMaterializeOperator;
}());
var DeMaterializeSubscriber = (function (_super) {
    __extends(DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],371:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function distinct(keySelector, flushes) {
    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };
}
exports.distinct = distinct;
var DistinctOperator = (function () {
    function DistinctOperator(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
    }
    DistinctOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator;
}());
var DistinctSubscriber = (function (_super) {
    __extends(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.values = new Set();
        if (flushes) {
            _this.add(innerSubscribe_1.innerSubscribe(flushes, new innerSubscribe_1.SimpleInnerSubscriber(_this)));
        }
        return _this;
    }
    DistinctSubscriber.prototype.notifyNext = function () {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));
exports.DistinctSubscriber = DistinctSubscriber;

},{"../innerSubscribe":321}],372:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
exports.distinctUntilChanged = distinctUntilChanged;
var DistinctUntilChangedOperator = (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
var DistinctUntilChangedSubscriber = (function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === 'function') {
            _this.compare = compare;
        }
        return _this;
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var key;
        try {
            var keySelector = this.keySelector;
            key = keySelector ? keySelector(value) : value;
        }
        catch (err) {
            return this.destination.error(err);
        }
        var result = false;
        if (this.hasKey) {
            try {
                var compare = this.compare;
                result = compare(this.key, key);
            }
            catch (err) {
                return this.destination.error(err);
            }
        }
        else {
            this.hasKey = true;
        }
        if (!result) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],373:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var distinctUntilChanged_1 = require("./distinctUntilChanged");
function distinctUntilKeyChanged(key, compare) {
    return distinctUntilChanged_1.distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });
}
exports.distinctUntilKeyChanged = distinctUntilKeyChanged;

},{"./distinctUntilChanged":372}],374:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
var filter_1 = require("./filter");
var throwIfEmpty_1 = require("./throwIfEmpty");
var defaultIfEmpty_1 = require("./defaultIfEmpty");
var take_1 = require("./take");
function elementAt(index, defaultValue) {
    if (index < 0) {
        throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
    }
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(filter_1.filter(function (v, i) { return i === index; }), take_1.take(1), hasDefaultValue
        ? defaultIfEmpty_1.defaultIfEmpty(defaultValue)
        : throwIfEmpty_1.throwIfEmpty(function () { return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError(); })); };
}
exports.elementAt = elementAt;

},{"../util/ArgumentOutOfRangeError":475,"./defaultIfEmpty":367,"./filter":380,"./take":432,"./throwIfEmpty":439}],375:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_1 = require("../observable/concat");
var of_1 = require("../observable/of");
function endWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    return function (source) { return concat_1.concat(source, of_1.of.apply(void 0, array)); };
}
exports.endWith = endWith;

},{"../observable/concat":327,"../observable/of":340}],376:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function every(predicate, thisArg) {
    return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };
}
exports.every = every;
var EveryOperator = (function () {
    function EveryOperator(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
    }
    EveryOperator.prototype.call = function (observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
    };
    return EveryOperator;
}());
var EverySubscriber = (function (_super) {
    __extends(EverySubscriber, _super);
    function EverySubscriber(destination, predicate, thisArg, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.source = source;
        _this.index = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
    };
    EverySubscriber.prototype._next = function (value) {
        var result = false;
        try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (!result) {
            this.notifyComplete(false);
        }
    };
    EverySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return EverySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],377:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function exhaust() {
    return function (source) { return source.lift(new SwitchFirstOperator()); };
}
exports.exhaust = exhaust;
var SwitchFirstOperator = (function () {
    function SwitchFirstOperator() {
    }
    SwitchFirstOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
    };
    return SwitchFirstOperator;
}());
var SwitchFirstSubscriber = (function (_super) {
    __extends(SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasCompleted = false;
        _this.hasSubscription = false;
        return _this;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add(innerSubscribe_1.innerSubscribe(value, new innerSubscribe_1.SimpleInnerSubscriber(this)));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function () {
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":321}],378:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var map_1 = require("./map");
var from_1 = require("../observable/from");
var innerSubscribe_1 = require("../innerSubscribe");
function exhaustMap(project, resultSelector) {
    if (resultSelector) {
        return function (source) { return source.pipe(exhaustMap(function (a, i) { return from_1.from(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) {
        return source.lift(new ExhaustMapOperator(project));
    };
}
exports.exhaustMap = exhaustMap;
var ExhaustMapOperator = (function () {
    function ExhaustMapOperator(project) {
        this.project = project;
    }
    ExhaustMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
    };
    return ExhaustMapOperator;
}());
var ExhaustMapSubscriber = (function (_super) {
    __extends(ExhaustMapSubscriber, _super);
    function ExhaustMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
    }
    ExhaustMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    ExhaustMapSubscriber.prototype.tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.hasSubscription = true;
        this._innerSub(result);
    };
    ExhaustMapSubscriber.prototype._innerSub = function (result) {
        var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe_1.innerSubscribe(result, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    ExhaustMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExhaustMapSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    ExhaustMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    ExhaustMapSubscriber.prototype.notifyComplete = function () {
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return ExhaustMapSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":321,"../observable/from":331,"./map":389}],379:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function expand(project, concurrent, scheduler) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };
}
exports.expand = expand;
var ExpandOperator = (function () {
    function ExpandOperator(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
    }
    ExpandOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator;
}());
exports.ExpandOperator = ExpandOperator;
var ExpandSubscriber = (function (_super) {
    __extends(ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.scheduler = scheduler;
        _this.index = 0;
        _this.active = 0;
        _this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            _this.buffer = [];
        }
        return _this;
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            try {
                var project = this.project;
                var result = project(value, index);
                if (!this.scheduler) {
                    this.subscribeToProjection(result, value, index);
                }
                else {
                    var state = { subscriber: this, result: result, value: value, index: index };
                    var destination_1 = this.destination;
                    destination_1.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
                }
            }
            catch (e) {
                destination.error(e);
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        var destination = this.destination;
        destination.add(innerSubscribe_1.innerSubscribe(result, new innerSubscribe_1.SimpleInnerSubscriber(this)));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExpandSubscriber.prototype.notifyNext = function (innerValue) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function () {
        var buffer = this.buffer;
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));
exports.ExpandSubscriber = ExpandSubscriber;

},{"../innerSubscribe":321}],380:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
exports.filter = filter;
var FilterOperator = (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],381:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Subscription_1 = require("../Subscription");
function finalize(callback) {
    return function (source) { return source.lift(new FinallyOperator(callback)); };
}
exports.finalize = finalize;
var FinallyOperator = (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
var FinallySubscriber = (function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new Subscription_1.Subscription(callback));
        return _this;
    }
    return FinallySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318,"../Subscription":319}],382:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function find(predicate, thisArg) {
    if (typeof predicate !== 'function') {
        throw new TypeError('predicate is not a function');
    }
    return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };
}
exports.find = find;
var FindValueOperator = (function () {
    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
    }
    FindValueOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
    };
    return FindValueOperator;
}());
exports.FindValueOperator = FindValueOperator;
var FindValueSubscriber = (function (_super) {
    __extends(FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.yieldIndex = yieldIndex;
        _this.thisArg = thisArg;
        _this.index = 0;
        return _this;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
        this.unsubscribe();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(Subscriber_1.Subscriber));
exports.FindValueSubscriber = FindValueSubscriber;

},{"../Subscriber":318}],383:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var find_1 = require("../operators/find");
function findIndex(predicate, thisArg) {
    return function (source) { return source.lift(new find_1.FindValueOperator(predicate, source, true, thisArg)); };
}
exports.findIndex = findIndex;

},{"../operators/find":382}],384:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyError_1 = require("../util/EmptyError");
var filter_1 = require("./filter");
var take_1 = require("./take");
var defaultIfEmpty_1 = require("./defaultIfEmpty");
var throwIfEmpty_1 = require("./throwIfEmpty");
var identity_1 = require("../util/identity");
function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? filter_1.filter(function (v, i) { return predicate(v, i, source); }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new EmptyError_1.EmptyError(); })); };
}
exports.first = first;

},{"../util/EmptyError":476,"../util/identity":483,"./defaultIfEmpty":367,"./filter":380,"./take":432,"./throwIfEmpty":439}],385:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Subscription_1 = require("../Subscription");
var Observable_1 = require("../Observable");
var Subject_1 = require("../Subject");
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return function (source) {
        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
    };
}
exports.groupBy = groupBy;
var GroupByOperator = (function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}());
var GroupBySubscriber = (function (_super) {
    __extends(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = new Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = (this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject());
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber_1.Subscriber));
var GroupDurationSubscriber = (function (_super) {
    __extends(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(Subscriber_1.Subscriber));
var GroupedObservable = (function (_super) {
    __extends(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription_1.Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable_1.Observable));
exports.GroupedObservable = GroupedObservable;
var InnerRefCountSubscription = (function (_super) {
    __extends(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription_1.Subscription));

},{"../Observable":311,"../Subject":316,"../Subscriber":318,"../Subscription":319}],386:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function ignoreElements() {
    return function ignoreElementsOperatorFunction(source) {
        return source.lift(new IgnoreElementsOperator());
    };
}
exports.ignoreElements = ignoreElements;
var IgnoreElementsOperator = (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
var IgnoreElementsSubscriber = (function (_super) {
    __extends(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
    };
    return IgnoreElementsSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],387:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function isEmpty() {
    return function (source) { return source.lift(new IsEmptyOperator()); };
}
exports.isEmpty = isEmpty;
var IsEmptyOperator = (function () {
    function IsEmptyOperator() {
    }
    IsEmptyOperator.prototype.call = function (observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
    };
    return IsEmptyOperator;
}());
var IsEmptySubscriber = (function (_super) {
    __extends(IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],388:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyError_1 = require("../util/EmptyError");
var filter_1 = require("./filter");
var takeLast_1 = require("./takeLast");
var throwIfEmpty_1 = require("./throwIfEmpty");
var defaultIfEmpty_1 = require("./defaultIfEmpty");
var identity_1 = require("../util/identity");
function last(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? filter_1.filter(function (v, i) { return predicate(v, i, source); }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new EmptyError_1.EmptyError(); })); };
}
exports.last = last;

},{"../util/EmptyError":476,"../util/identity":483,"./defaultIfEmpty":367,"./filter":380,"./takeLast":433,"./throwIfEmpty":439}],389:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
exports.map = map;
var MapOperator = (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
exports.MapOperator = MapOperator;
var MapSubscriber = (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],390:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function mapTo(value) {
    return function (source) { return source.lift(new MapToOperator(value)); };
}
exports.mapTo = mapTo;
var MapToOperator = (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
var MapToSubscriber = (function (_super) {
    __extends(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],391:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Notification_1 = require("../Notification");
function materialize() {
    return function materializeOperatorFunction(source) {
        return source.lift(new MaterializeOperator());
    };
}
exports.materialize = materialize;
var MaterializeOperator = (function () {
    function MaterializeOperator() {
    }
    MaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
    };
    return MaterializeOperator;
}());
var MaterializeSubscriber = (function (_super) {
    __extends(MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(Notification_1.Notification.createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(Notification_1.Notification.createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(Notification_1.Notification.createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(Subscriber_1.Subscriber));

},{"../Notification":310,"../Subscriber":318}],392:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var reduce_1 = require("./reduce");
function max(comparer) {
    var max = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }
        : function (x, y) { return x > y ? x : y; };
    return reduce_1.reduce(max);
}
exports.max = max;

},{"./reduce":410}],393:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var merge_1 = require("../observable/merge");
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };
}
exports.merge = merge;

},{"../observable/merge":338}],394:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mergeMap_1 = require("./mergeMap");
var identity_1 = require("../util/identity");
function mergeAll(concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return mergeMap_1.mergeMap(identity_1.identity, concurrent);
}
exports.mergeAll = mergeAll;

},{"../util/identity":483,"./mergeMap":395}],395:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var map_1 = require("./map");
var from_1 = require("../observable/from");
var innerSubscribe_1 = require("../innerSubscribe");
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(mergeMap(function (a, i) { return from_1.from(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
exports.mergeMap = mergeMap;
var MergeMapOperator = (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());
exports.MergeMapOperator = MergeMapOperator;
var MergeMapSubscriber = (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish) {
        var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe_1.innerSubscribe(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeMapSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function () {
        var buffer = this.buffer;
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));
exports.MergeMapSubscriber = MergeMapSubscriber;
exports.flatMap = mergeMap;

},{"../innerSubscribe":321,"../observable/from":331,"./map":389}],396:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mergeMap_1 = require("./mergeMap");
function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'function') {
        return mergeMap_1.mergeMap(function () { return innerObservable; }, resultSelector, concurrent);
    }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return mergeMap_1.mergeMap(function () { return innerObservable; }, concurrent);
}
exports.mergeMapTo = mergeMapTo;

},{"./mergeMap":395}],397:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };
}
exports.mergeScan = mergeScan;
var MergeScanOperator = (function () {
    function MergeScanOperator(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
    }
    MergeScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
    };
    return MergeScanOperator;
}());
exports.MergeScanOperator = MergeScanOperator;
var MergeScanSubscriber = (function (_super) {
    __extends(MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this.acc = acc;
        _this.concurrent = concurrent;
        _this.hasValue = false;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var destination = this.destination;
            var ish = void 0;
            try {
                var accumulator = this.accumulator;
                ish = accumulator(this.acc, value, index);
            }
            catch (e) {
                return destination.error(e);
            }
            this.active++;
            this._innerSub(ish);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish) {
        var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe_1.innerSubscribe(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeScanSubscriber.prototype.notifyNext = function (innerValue) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function () {
        var buffer = this.buffer;
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));
exports.MergeScanSubscriber = MergeScanSubscriber;

},{"../innerSubscribe":321}],398:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var reduce_1 = require("./reduce");
function min(comparer) {
    var min = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }
        : function (x, y) { return x < y ? x : y; };
    return reduce_1.reduce(min);
}
exports.min = min;

},{"./reduce":410}],399:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ConnectableObservable_1 = require("../observable/ConnectableObservable");
function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === 'function') {
            subjectFactory = subjectOrSubjectFactory;
        }
        else {
            subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
            };
        }
        if (typeof selector === 'function') {
            return source.lift(new MulticastOperator(subjectFactory, selector));
        }
        var connectable = Object.create(source, ConnectableObservable_1.connectableObservableDescriptor);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    };
}
exports.multicast = multicast;
var MulticastOperator = (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());
exports.MulticastOperator = MulticastOperator;

},{"../observable/ConnectableObservable":322}],400:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Notification_1 = require("../Notification");
function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
exports.observeOn = observeOn;
var ObserveOnOperator = (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
exports.ObserveOnOperator = ObserveOnOperator;
var ObserveOnSubscriber = (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
        this.unsubscribe();
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber));
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());
exports.ObserveOnMessage = ObserveOnMessage;

},{"../Notification":310,"../Subscriber":318}],401:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var from_1 = require("../observable/from");
var isArray_1 = require("../util/isArray");
var innerSubscribe_1 = require("../innerSubscribe");
function onErrorResumeNext() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };
}
exports.onErrorResumeNext = onErrorResumeNext;
function onErrorResumeNextStatic() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    var source = undefined;
    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    source = nextSources.shift();
    return from_1.from(source).lift(new OnErrorResumeNextOperator(nextSources));
}
exports.onErrorResumeNextStatic = onErrorResumeNextStatic;
var OnErrorResumeNextOperator = (function () {
    function OnErrorResumeNextOperator(nextSources) {
        this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator;
}());
var OnErrorResumeNextSubscriber = (function (_super) {
    __extends(OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (!!next) {
            var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(this);
            var destination = this.destination;
            destination.add(innerSubscriber);
            var innerSubscription = innerSubscribe_1.innerSubscribe(next, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                destination.add(innerSubscription);
            }
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":321,"../observable/from":331,"../util/isArray":484}],402:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function pairwise() {
    return function (source) { return source.lift(new PairwiseOperator()); };
}
exports.pairwise = pairwise;
var PairwiseOperator = (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
var PairwiseSubscriber = (function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        var pair;
        if (this.hasPrev) {
            pair = [this.prev, value];
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
        if (pair) {
            this.destination.next(pair);
        }
    };
    return PairwiseSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],403:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var not_1 = require("../util/not");
var filter_1 = require("./filter");
function partition(predicate, thisArg) {
    return function (source) { return [
        filter_1.filter(predicate, thisArg)(source),
        filter_1.filter(not_1.not(predicate, thisArg))(source)
    ]; };
}
exports.partition = partition;

},{"../util/not":496,"./filter":380}],404:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var map_1 = require("./map");
function pluck() {
    var properties = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
        throw new Error('list of properties cannot be empty.');
    }
    return function (source) { return map_1.map(plucker(properties, length))(source); };
}
exports.pluck = pluck;
function plucker(props, length) {
    var mapper = function (x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
            var p = currentProp != null ? currentProp[props[i]] : undefined;
            if (p !== void 0) {
                currentProp = p;
            }
            else {
                return undefined;
            }
        }
        return currentProp;
    };
    return mapper;
}

},{"./map":389}],405:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var multicast_1 = require("./multicast");
function publish(selector) {
    return selector ?
        multicast_1.multicast(function () { return new Subject_1.Subject(); }, selector) :
        multicast_1.multicast(new Subject_1.Subject());
}
exports.publish = publish;

},{"../Subject":316,"./multicast":399}],406:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var BehaviorSubject_1 = require("../BehaviorSubject");
var multicast_1 = require("./multicast");
function publishBehavior(value) {
    return function (source) { return multicast_1.multicast(new BehaviorSubject_1.BehaviorSubject(value))(source); };
}
exports.publishBehavior = publishBehavior;

},{"../BehaviorSubject":308,"./multicast":399}],407:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncSubject_1 = require("../AsyncSubject");
var multicast_1 = require("./multicast");
function publishLast() {
    return function (source) { return multicast_1.multicast(new AsyncSubject_1.AsyncSubject())(source); };
}
exports.publishLast = publishLast;

},{"../AsyncSubject":307,"./multicast":399}],408:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReplaySubject_1 = require("../ReplaySubject");
var multicast_1 = require("./multicast");
function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
        scheduler = selectorOrScheduler;
    }
    var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
    var subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
    return function (source) { return multicast_1.multicast(function () { return subject; }, selector)(source); };
}
exports.publishReplay = publishReplay;

},{"../ReplaySubject":314,"./multicast":399}],409:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("../util/isArray");
var race_1 = require("../observable/race");
function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function raceOperatorFunction(source) {
        if (observables.length === 1 && isArray_1.isArray(observables[0])) {
            observables = observables[0];
        }
        return source.lift.call(race_1.race.apply(void 0, [source].concat(observables)));
    };
}
exports.race = race;

},{"../observable/race":344,"../util/isArray":484}],410:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var scan_1 = require("./scan");
var takeLast_1 = require("./takeLast");
var defaultIfEmpty_1 = require("./defaultIfEmpty");
var pipe_1 = require("../util/pipe");
function reduce(accumulator, seed) {
    if (arguments.length >= 2) {
        return function reduceOperatorFunctionWithSeed(source) {
            return pipe_1.pipe(scan_1.scan(accumulator, seed), takeLast_1.takeLast(1), defaultIfEmpty_1.defaultIfEmpty(seed))(source);
        };
    }
    return function reduceOperatorFunction(source) {
        return pipe_1.pipe(scan_1.scan(function (acc, value, index) { return accumulator(acc, value, index + 1); }), takeLast_1.takeLast(1))(source);
    };
}
exports.reduce = reduce;

},{"../util/pipe":497,"./defaultIfEmpty":367,"./scan":418,"./takeLast":433}],411:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
exports.refCount = refCount;
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],412:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var empty_1 = require("../observable/empty");
function repeat(count) {
    if (count === void 0) { count = -1; }
    return function (source) {
        if (count === 0) {
            return empty_1.empty();
        }
        else if (count < 0) {
            return source.lift(new RepeatOperator(-1, source));
        }
        else {
            return source.lift(new RepeatOperator(count - 1, source));
        }
    };
}
exports.repeat = repeat;
var RepeatOperator = (function () {
    function RepeatOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RepeatOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
    };
    return RepeatOperator;
}());
var RepeatSubscriber = (function (_super) {
    __extends(RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RepeatSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318,"../observable/empty":329}],413:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var innerSubscribe_1 = require("../innerSubscribe");
function repeatWhen(notifier) {
    return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };
}
exports.repeatWhen = repeatWhen;
var RepeatWhenOperator = (function () {
    function RepeatWhenOperator(notifier) {
        this.notifier = notifier;
    }
    RepeatWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
    };
    return RepeatWhenOperator;
}());
var RepeatWhenSubscriber = (function (_super) {
    __extends(RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        _this.sourceIsBeingSubscribedTo = true;
        return _this;
    }
    RepeatWhenSubscriber.prototype.notifyNext = function () {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
    };
    RepeatWhenSubscriber.prototype.notifyComplete = function () {
        if (this.sourceIsBeingSubscribedTo === false) {
            return _super.prototype.complete.call(this);
        }
    };
    RepeatWhenSubscriber.prototype.complete = function () {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
            if (!this.retries) {
                this.subscribeToRetries();
            }
            if (!this.retriesSubscription || this.retriesSubscription.closed) {
                return _super.prototype.complete.call(this);
            }
            this._unsubscribeAndRecycle();
            this.notifications.next(undefined);
        }
    };
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = undefined;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = undefined;
        }
        this.retries = undefined;
    };
    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this._unsubscribe = _unsubscribe;
        return this;
    };
    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
        this.notifications = new Subject_1.Subject();
        var retries;
        try {
            var notifier = this.notifier;
            retries = notifier(this.notifications);
        }
        catch (e) {
            return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = innerSubscribe_1.innerSubscribe(retries, new innerSubscribe_1.SimpleInnerSubscriber(this));
    };
    return RepeatWhenSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../Subject":316,"../innerSubscribe":321}],414:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function retry(count) {
    if (count === void 0) { count = -1; }
    return function (source) { return source.lift(new RetryOperator(count, source)); };
}
exports.retry = retry;
var RetryOperator = (function () {
    function RetryOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RetryOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator;
}());
var RetrySubscriber = (function (_super) {
    __extends(RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],415:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var innerSubscribe_1 = require("../innerSubscribe");
function retryWhen(notifier) {
    return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };
}
exports.retryWhen = retryWhen;
var RetryWhenOperator = (function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}());
var RetryWhenSubscriber = (function (_super) {
    __extends(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        return _this;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject_1.Subject();
                try {
                    var notifier = this.notifier;
                    retries = notifier(errors);
                }
                catch (e) {
                    return _super.prototype.error.call(this, e);
                }
                retriesSubscription = innerSubscribe_1.innerSubscribe(retries, new innerSubscribe_1.SimpleInnerSubscriber(this));
            }
            else {
                this.errors = undefined;
                this.retriesSubscription = undefined;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = undefined;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = undefined;
        }
        this.retries = undefined;
    };
    RetryWhenSubscriber.prototype.notifyNext = function () {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        this._unsubscribeAndRecycle();
        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../Subject":316,"../innerSubscribe":321}],416:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function sample(notifier) {
    return function (source) { return source.lift(new SampleOperator(notifier)); };
}
exports.sample = sample;
var SampleOperator = (function () {
    function SampleOperator(notifier) {
        this.notifier = notifier;
    }
    SampleOperator.prototype.call = function (subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(innerSubscribe_1.innerSubscribe(this.notifier, new innerSubscribe_1.SimpleInnerSubscriber(sampleSubscriber)));
        return subscription;
    };
    return SampleOperator;
}());
var SampleSubscriber = (function (_super) {
    __extends(SampleSubscriber, _super);
    function SampleSubscriber() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":321}],417:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var async_1 = require("../scheduler/async");
function sampleTime(period, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };
}
exports.sampleTime = sampleTime;
var SampleTimeOperator = (function () {
    function SampleTimeOperator(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
    }
    SampleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
    };
    return SampleTimeOperator;
}());
var SampleTimeSubscriber = (function (_super) {
    __extends(SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.period = period;
        _this.scheduler = scheduler;
        _this.hasValue = false;
        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));
        return _this;
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNotification(state) {
    var subscriber = state.subscriber, period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
}

},{"../Subscriber":318,"../scheduler/async":470}],418:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function scan(accumulator, seed) {
    var hasSeed = false;
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
exports.scan = scan;
var ScanOperator = (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) { hasSeed = false; }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
var ScanSubscriber = (function (_super) {
    __extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],419:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function sequenceEqual(compareTo, comparator) {
    return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparator)); };
}
exports.sequenceEqual = sequenceEqual;
var SequenceEqualOperator = (function () {
    function SequenceEqualOperator(compareTo, comparator) {
        this.compareTo = compareTo;
        this.comparator = comparator;
    }
    SequenceEqualOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
    };
    return SequenceEqualOperator;
}());
exports.SequenceEqualOperator = SequenceEqualOperator;
var SequenceEqualSubscriber = (function (_super) {
    __extends(SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparator) {
        var _this = _super.call(this, destination) || this;
        _this.compareTo = compareTo;
        _this.comparator = comparator;
        _this._a = [];
        _this._b = [];
        _this._oneComplete = false;
        _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
        return _this;
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        }
        else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
        this.unsubscribe();
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this, _a = _c._a, _b = _c._b, comparator = _c.comparator;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            try {
                areEqual = comparator ? comparator(a, b) : a === b;
            }
            catch (e) {
                this.destination.error(e);
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        }
        else {
            this._b.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype.completeB = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
    };
    return SequenceEqualSubscriber;
}(Subscriber_1.Subscriber));
exports.SequenceEqualSubscriber = SequenceEqualSubscriber;
var SequenceEqualCompareToSubscriber = (function (_super) {
    __extends(SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        return _this;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
        this.unsubscribe();
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent.completeB();
        this.unsubscribe();
    };
    return SequenceEqualCompareToSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],420:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var multicast_1 = require("./multicast");
var refCount_1 = require("./refCount");
var Subject_1 = require("../Subject");
function shareSubjectFactory() {
    return new Subject_1.Subject();
}
function share() {
    return function (source) { return refCount_1.refCount()(multicast_1.multicast(shareSubjectFactory)(source)); };
}
exports.share = share;

},{"../Subject":316,"./multicast":399,"./refCount":411}],421:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReplaySubject_1 = require("../ReplaySubject");
function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var config;
    if (configOrBufferSize && typeof configOrBufferSize === 'object') {
        config = configOrBufferSize;
    }
    else {
        config = {
            bufferSize: configOrBufferSize,
            windowTime: windowTime,
            refCount: false,
            scheduler: scheduler,
        };
    }
    return function (source) { return source.lift(shareReplayOperator(config)); };
}
exports.shareReplay = shareReplay;
function shareReplayOperator(_a) {
    var _b = _a.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler;
    var subject;
    var refCount = 0;
    var subscription;
    var hasError = false;
    var isComplete = false;
    return function shareReplayOperation(source) {
        refCount++;
        var innerSub;
        if (!subject || hasError) {
            hasError = false;
            subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
            innerSub = subject.subscribe(this);
            subscription = source.subscribe({
                next: function (value) {
                    subject.next(value);
                },
                error: function (err) {
                    hasError = true;
                    subject.error(err);
                },
                complete: function () {
                    isComplete = true;
                    subscription = undefined;
                    subject.complete();
                },
            });
            if (isComplete) {
                subscription = undefined;
            }
        }
        else {
            innerSub = subject.subscribe(this);
        }
        this.add(function () {
            refCount--;
            innerSub.unsubscribe();
            innerSub = undefined;
            if (subscription && !isComplete && useRefCount && refCount === 0) {
                subscription.unsubscribe();
                subscription = undefined;
                subject = undefined;
            }
        });
    };
}

},{"../ReplaySubject":314}],422:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var EmptyError_1 = require("../util/EmptyError");
function single(predicate) {
    return function (source) { return source.lift(new SingleOperator(predicate, source)); };
}
exports.single = single;
var SingleOperator = (function () {
    function SingleOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    SingleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
    };
    return SingleOperator;
}());
var SingleSubscriber = (function (_super) {
    __extends(SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.seenValue = false;
        _this.index = 0;
        return _this;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        }
        else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this.tryNext(value, index);
        }
        else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value, index) {
        try {
            if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        }
        else {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return SingleSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318,"../util/EmptyError":476}],423:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function skip(count) {
    return function (source) { return source.lift(new SkipOperator(count)); };
}
exports.skip = skip;
var SkipOperator = (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
var SkipSubscriber = (function (_super) {
    __extends(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],424:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
function skipLast(count) {
    return function (source) { return source.lift(new SkipLastOperator(count)); };
}
exports.skipLast = skipLast;
var SkipLastOperator = (function () {
    function SkipLastOperator(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    SkipLastOperator.prototype.call = function (subscriber, source) {
        if (this._skipCount === 0) {
            return source.subscribe(new Subscriber_1.Subscriber(subscriber));
        }
        else {
            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
    };
    return SkipLastOperator;
}());
var SkipLastSubscriber = (function (_super) {
    __extends(SkipLastSubscriber, _super);
    function SkipLastSubscriber(destination, _skipCount) {
        var _this = _super.call(this, destination) || this;
        _this._skipCount = _skipCount;
        _this._count = 0;
        _this._ring = new Array(_skipCount);
        return _this;
    }
    SkipLastSubscriber.prototype._next = function (value) {
        var skipCount = this._skipCount;
        var count = this._count++;
        if (count < skipCount) {
            this._ring[count] = value;
        }
        else {
            var currentIndex = count % skipCount;
            var ring = this._ring;
            var oldValue = ring[currentIndex];
            ring[currentIndex] = value;
            this.destination.next(oldValue);
        }
    };
    return SkipLastSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318,"../util/ArgumentOutOfRangeError":475}],425:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function skipUntil(notifier) {
    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };
}
exports.skipUntil = skipUntil;
var SkipUntilOperator = (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
    };
    return SkipUntilOperator;
}());
var SkipUntilSubscriber = (function (_super) {
    __extends(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(_this);
        _this.add(innerSubscriber);
        _this.innerSubscription = innerSubscriber;
        var innerSubscription = innerSubscribe_1.innerSubscribe(notifier, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            _this.add(innerSubscription);
            _this.innerSubscription = innerSubscription;
        }
        return _this;
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function () {
        this.hasValue = true;
        if (this.innerSubscription) {
            this.innerSubscription.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
    };
    return SkipUntilSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":321}],426:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function skipWhile(predicate) {
    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
}
exports.skipWhile = skipWhile;
var SkipWhileOperator = (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
var SkipWhileSubscriber = (function (_super) {
    __extends(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],427:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_1 = require("../observable/concat");
var isScheduler_1 = require("../util/isScheduler");
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        array.pop();
        return function (source) { return concat_1.concat(array, source, scheduler); };
    }
    else {
        return function (source) { return concat_1.concat(array, source); };
    }
}
exports.startWith = startWith;

},{"../observable/concat":327,"../util/isScheduler":494}],428:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var SubscribeOnObservable_1 = require("../observable/SubscribeOnObservable");
function subscribeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function subscribeOnOperatorFunction(source) {
        return source.lift(new SubscribeOnOperator(scheduler, delay));
    };
}
exports.subscribeOn = subscribeOn;
var SubscribeOnOperator = (function () {
    function SubscribeOnOperator(scheduler, delay) {
        this.scheduler = scheduler;
        this.delay = delay;
    }
    SubscribeOnOperator.prototype.call = function (subscriber, source) {
        return new SubscribeOnObservable_1.SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator;
}());

},{"../observable/SubscribeOnObservable":323}],429:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var switchMap_1 = require("./switchMap");
var identity_1 = require("../util/identity");
function switchAll() {
    return switchMap_1.switchMap(identity_1.identity);
}
exports.switchAll = switchAll;

},{"../util/identity":483,"./switchMap":430}],430:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var map_1 = require("./map");
var from_1 = require("../observable/from");
var innerSubscribe_1 = require("../innerSubscribe");
function switchMap(project, resultSelector) {
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(switchMap(function (a, i) { return from_1.from(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) { return source.lift(new SwitchMapOperator(project)); };
}
exports.switchMap = switchMap;
var SwitchMapOperator = (function () {
    function SwitchMapOperator(project) {
        this.project = project;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator;
}());
var SwitchMapSubscriber = (function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = innerSubscribe_1.innerSubscribe(result, innerSubscriber);
        if (this.innerSubscription !== innerSubscriber) {
            destination.add(this.innerSubscription);
        }
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
        this.unsubscribe();
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = undefined;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function () {
        this.innerSubscription = undefined;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    return SwitchMapSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":321,"../observable/from":331,"./map":389}],431:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var switchMap_1 = require("./switchMap");
function switchMapTo(innerObservable, resultSelector) {
    return resultSelector ? switchMap_1.switchMap(function () { return innerObservable; }, resultSelector) : switchMap_1.switchMap(function () { return innerObservable; });
}
exports.switchMapTo = switchMapTo;

},{"./switchMap":430}],432:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
var empty_1 = require("../observable/empty");
function take(count) {
    return function (source) {
        if (count === 0) {
            return empty_1.empty();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
exports.take = take;
var TakeOperator = (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
var TakeSubscriber = (function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318,"../observable/empty":329,"../util/ArgumentOutOfRangeError":475}],433:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
var empty_1 = require("../observable/empty");
function takeLast(count) {
    return function takeLastOperatorFunction(source) {
        if (count === 0) {
            return empty_1.empty();
        }
        else {
            return source.lift(new TakeLastOperator(count));
        }
    };
}
exports.takeLast = takeLast;
var TakeLastOperator = (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
var TakeLastSubscriber = (function (_super) {
    __extends(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318,"../observable/empty":329,"../util/ArgumentOutOfRangeError":475}],434:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
exports.takeUntil = takeUntil;
var TakeUntilOperator = (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = innerSubscribe_1.innerSubscribe(this.notifier, new innerSubscribe_1.SimpleInnerSubscriber(takeUntilSubscriber));
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
            takeUntilSubscriber.add(notifierSubscription);
            return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
    };
    return TakeUntilOperator;
}());
var TakeUntilSubscriber = (function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
    }
    TakeUntilSubscriber.prototype.notifyNext = function () {
        this.seenValue = true;
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
    };
    return TakeUntilSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":321}],435:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function takeWhile(predicate, inclusive) {
    if (inclusive === void 0) { inclusive = false; }
    return function (source) {
        return source.lift(new TakeWhileOperator(predicate, inclusive));
    };
}
exports.takeWhile = takeWhile;
var TakeWhileOperator = (function () {
    function TakeWhileOperator(predicate, inclusive) {
        this.predicate = predicate;
        this.inclusive = inclusive;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
    };
    return TakeWhileOperator;
}());
var TakeWhileSubscriber = (function (_super) {
    __extends(TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate, inclusive) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.inclusive = inclusive;
        _this.index = 0;
        return _this;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            if (this.inclusive) {
                destination.next(value);
            }
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318}],436:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var noop_1 = require("../util/noop");
var isFunction_1 = require("../util/isFunction");
function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
exports.tap = tap;
var DoOperator = (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
var TapSubscriber = (function (_super) {
    __extends(TapSubscriber, _super);
    function TapSubscriber(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = noop_1.noop;
        _this._tapError = noop_1.noop;
        _this._tapComplete = noop_1.noop;
        _this._tapError = error || noop_1.noop;
        _this._tapComplete = complete || noop_1.noop;
        if (isFunction_1.isFunction(observerOrNext)) {
            _this._context = _this;
            _this._tapNext = observerOrNext;
        }
        else if (observerOrNext) {
            _this._context = observerOrNext;
            _this._tapNext = observerOrNext.next || noop_1.noop;
            _this._tapError = observerOrNext.error || noop_1.noop;
            _this._tapComplete = observerOrNext.complete || noop_1.noop;
        }
        return _this;
    }
    TapSubscriber.prototype._next = function (value) {
        try {
            this._tapNext.call(this._context, value);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(value);
    };
    TapSubscriber.prototype._error = function (err) {
        try {
            this._tapError.call(this._context, err);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.error(err);
    };
    TapSubscriber.prototype._complete = function () {
        try {
            this._tapComplete.call(this._context);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        return this.destination.complete();
    };
    return TapSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":318,"../util/isFunction":487,"../util/noop":495}],437:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
exports.defaultThrottleConfig = {
    leading: true,
    trailing: false
};
function throttle(durationSelector, config) {
    if (config === void 0) { config = exports.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleOperator(durationSelector, !!config.leading, !!config.trailing)); };
}
exports.throttle = throttle;
var ThrottleOperator = (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
var ThrottleSubscriber = (function (_super) {
    __extends(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
            if (this._leading) {
                this.send();
            }
            else {
                this.throttle(value);
            }
        }
    };
    ThrottleSubscriber.prototype.send = function () {
        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
        if (_hasValue) {
            this.destination.next(_sendValue);
            this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = undefined;
    };
    ThrottleSubscriber.prototype.throttle = function (value) {
        var duration = this.tryDurationSelector(value);
        if (!!duration) {
            this.add(this._throttled = innerSubscribe_1.innerSubscribe(duration, new innerSubscribe_1.SimpleInnerSubscriber(this)));
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype.throttlingDone = function () {
        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
        if (_throttled) {
            _throttled.unsubscribe();
        }
        this._throttled = undefined;
        if (_trailing) {
            this.send();
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function () {
        this.throttlingDone();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this.throttlingDone();
    };
    return ThrottleSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":321}],438:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var async_1 = require("../scheduler/async");
var throttle_1 = require("./throttle");
function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    if (config === void 0) { config = throttle_1.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
}
exports.throttleTime = throttleTime;
var ThrottleTimeOperator = (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
var ThrottleTimeSubscriber = (function (_super) {
    __extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
            else if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
    };
    ThrottleTimeSubscriber.prototype._complete = function () {
        if (this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this.destination.complete();
        }
        else {
            this.destination.complete();
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}

},{"../Subscriber":318,"../scheduler/async":470,"./throttle":437}],439:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyError_1 = require("../util/EmptyError");
var Subscriber_1 = require("../Subscriber");
function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) { errorFactory = defaultErrorFactory; }
    return function (source) {
        return source.lift(new ThrowIfEmptyOperator(errorFactory));
    };
}
exports.throwIfEmpty = throwIfEmpty;
var ThrowIfEmptyOperator = (function () {
    function ThrowIfEmptyOperator(errorFactory) {
        this.errorFactory = errorFactory;
    }
    ThrowIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
    };
    return ThrowIfEmptyOperator;
}());
var ThrowIfEmptySubscriber = (function (_super) {
    __extends(ThrowIfEmptySubscriber, _super);
    function ThrowIfEmptySubscriber(destination, errorFactory) {
        var _this = _super.call(this, destination) || this;
        _this.errorFactory = errorFactory;
        _this.hasValue = false;
        return _this;
    }
    ThrowIfEmptySubscriber.prototype._next = function (value) {
        this.hasValue = true;
        this.destination.next(value);
    };
    ThrowIfEmptySubscriber.prototype._complete = function () {
        if (!this.hasValue) {
            var err = void 0;
            try {
                err = this.errorFactory();
            }
            catch (e) {
                err = e;
            }
            this.destination.error(err);
        }
        else {
            return this.destination.complete();
        }
    };
    return ThrowIfEmptySubscriber;
}(Subscriber_1.Subscriber));
function defaultErrorFactory() {
    return new EmptyError_1.EmptyError();
}

},{"../Subscriber":318,"../util/EmptyError":476}],440:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var scan_1 = require("./scan");
var defer_1 = require("../observable/defer");
var map_1 = require("./map");
function timeInterval(scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return defer_1.defer(function () {
        return source.pipe(scan_1.scan(function (_a, value) {
            var current = _a.current;
            return ({ value: value, current: scheduler.now(), last: current });
        }, { current: scheduler.now(), value: undefined, last: undefined }), map_1.map(function (_a) {
            var current = _a.current, last = _a.last, value = _a.value;
            return new TimeInterval(value, current - last);
        }));
    }); };
}
exports.timeInterval = timeInterval;
var TimeInterval = (function () {
    function TimeInterval(value, interval) {
        this.value = value;
        this.interval = interval;
    }
    return TimeInterval;
}());
exports.TimeInterval = TimeInterval;

},{"../observable/defer":328,"../scheduler/async":470,"./map":389,"./scan":418}],441:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var TimeoutError_1 = require("../util/TimeoutError");
var timeoutWith_1 = require("./timeoutWith");
var throwError_1 = require("../observable/throwError");
function timeout(due, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return timeoutWith_1.timeoutWith(due, throwError_1.throwError(new TimeoutError_1.TimeoutError()), scheduler);
}
exports.timeout = timeout;

},{"../observable/throwError":346,"../scheduler/async":470,"../util/TimeoutError":479,"./timeoutWith":442}],442:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var isDate_1 = require("../util/isDate");
var innerSubscribe_1 = require("../innerSubscribe");
function timeoutWith(due, withObservable, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) {
        var absoluteTimeout = isDate_1.isDate(due);
        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
    };
}
exports.timeoutWith = timeoutWith;
var TimeoutWithOperator = (function () {
    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }
    TimeoutWithOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator;
}());
var TimeoutWithSubscriber = (function (_super) {
    __extends(TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.scheduleTimeout();
        return _this;
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(innerSubscribe_1.innerSubscribe(withObservable, new innerSubscribe_1.SimpleInnerSubscriber(subscriber)));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = undefined;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":321,"../scheduler/async":470,"../util/isDate":486}],443:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var map_1 = require("./map");
function timestamp(scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return map_1.map(function (value) { return new Timestamp(value, scheduler.now()); });
}
exports.timestamp = timestamp;
var Timestamp = (function () {
    function Timestamp(value, timestamp) {
        this.value = value;
        this.timestamp = timestamp;
    }
    return Timestamp;
}());
exports.Timestamp = Timestamp;

},{"../scheduler/async":470,"./map":389}],444:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var reduce_1 = require("./reduce");
function toArrayReducer(arr, item, index) {
    if (index === 0) {
        return [item];
    }
    arr.push(item);
    return arr;
}
function toArray() {
    return reduce_1.reduce(toArrayReducer, []);
}
exports.toArray = toArray;

},{"./reduce":410}],445:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var innerSubscribe_1 = require("../innerSubscribe");
function window(windowBoundaries) {
    return function windowOperatorFunction(source) {
        return source.lift(new WindowOperator(windowBoundaries));
    };
}
exports.window = window;
var WindowOperator = (function () {
    function WindowOperator(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
            windowSubscriber.add(innerSubscribe_1.innerSubscribe(this.windowBoundaries, new innerSubscribe_1.SimpleInnerSubscriber(windowSubscriber)));
        }
        return sourceSubscription;
    };
    return WindowOperator;
}());
var WindowSubscriber = (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.window = new Subject_1.Subject();
        destination.next(_this.window);
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function () {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function () {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject_1.Subject();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../Subject":316,"../innerSubscribe":321}],446:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Subject_1 = require("../Subject");
function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) { startWindowEvery = 0; }
    return function windowCountOperatorFunction(source) {
        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
    };
}
exports.windowCount = windowCount;
var WindowCountOperator = (function () {
    function WindowCountOperator(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
    }
    WindowCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
    };
    return WindowCountOperator;
}());
var WindowCountSubscriber = (function (_super) {
    __extends(WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowSize = windowSize;
        _this.startWindowEvery = startWindowEvery;
        _this.windows = [new Subject_1.Subject()];
        _this.count = 0;
        destination.next(_this.windows[0]);
        return _this;
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new Subject_1.Subject();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subject":316,"../Subscriber":318}],447:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var async_1 = require("../scheduler/async");
var Subscriber_1 = require("../Subscriber");
var isNumeric_1 = require("../util/isNumeric");
var isScheduler_1 = require("../util/isScheduler");
function windowTime(windowTimeSpan) {
    var scheduler = async_1.async;
    var windowCreationInterval = null;
    var maxWindowSize = Number.POSITIVE_INFINITY;
    if (isScheduler_1.isScheduler(arguments[3])) {
        scheduler = arguments[3];
    }
    if (isScheduler_1.isScheduler(arguments[2])) {
        scheduler = arguments[2];
    }
    else if (isNumeric_1.isNumeric(arguments[2])) {
        maxWindowSize = Number(arguments[2]);
    }
    if (isScheduler_1.isScheduler(arguments[1])) {
        scheduler = arguments[1];
    }
    else if (isNumeric_1.isNumeric(arguments[1])) {
        windowCreationInterval = Number(arguments[1]);
    }
    return function windowTimeOperatorFunction(source) {
        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
    };
}
exports.windowTime = windowTime;
var WindowTimeOperator = (function () {
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
    }
    WindowTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    };
    return WindowTimeOperator;
}());
var CountedSubject = (function (_super) {
    __extends(CountedSubject, _super);
    function CountedSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(Subject_1.Subject));
var WindowTimeSubscriber = (function (_super) {
    __extends(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: _this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };
            _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
        return _this;
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
    if (window) {
        subscriber.closeWindow(window);
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}

},{"../Subject":316,"../Subscriber":318,"../scheduler/async":470,"../util/isNumeric":490,"../util/isScheduler":494}],448:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var Subscription_1 = require("../Subscription");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function windowToggle(openings, closingSelector) {
    return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };
}
exports.windowToggle = windowToggle;
var WindowToggleOperator = (function () {
    function WindowToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    WindowToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return WindowToggleOperator;
}());
var WindowToggleSubscriber = (function (_super) {
    __extends(WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(_this.openSubscription = subscribeToResult_1.subscribeToResult(_this, openings, openings));
        return _this;
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_1 = contexts[index];
                context_1.window.error(err);
                context_1.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_2 = contexts[index];
                context_2.window.complete();
                context_2.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_3 = contexts[index];
                context_3.window.unsubscribe();
                context_3.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingNotifier = void 0;
            try {
                var closingSelector = this.closingSelector;
                closingNotifier = closingSelector(innerValue);
            }
            catch (e) {
                return this.error(e);
            }
            var window_1 = new Subject_1.Subject();
            var subscription = new Subscription_1.Subscription();
            var context_4 = { window: window_1, subscription: subscription };
            this.contexts.push(context_4);
            var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context_4);
            if (innerSubscription.closed) {
                this.closeWindow(this.contexts.length - 1);
            }
            else {
                innerSubscription.context = context_4;
                subscription.add(innerSubscription);
            }
            this.destination.next(window_1);
        }
        else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":313,"../Subject":316,"../Subscription":319,"../util/subscribeToResult":503}],449:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function windowWhen(closingSelector) {
    return function windowWhenOperatorFunction(source) {
        return source.lift(new WindowOperator(closingSelector));
    };
}
exports.windowWhen = windowWhen;
var WindowOperator = (function () {
    function WindowOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
    };
    return WindowOperator;
}());
var WindowSubscriber = (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.closingSelector = closingSelector;
        _this.openWindow();
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) { innerSub = null; }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new Subject_1.Subject();
        this.destination.next(window);
        var closingNotifier;
        try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
        }
        catch (e) {
            this.destination.error(e);
            this.window.error(e);
            return;
        }
        this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));
    };
    return WindowSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":313,"../Subject":316,"../util/subscribeToResult":503}],450:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (source) {
        var project;
        if (typeof args[args.length - 1] === 'function') {
            project = args.pop();
        }
        var observables = args;
        return source.lift(new WithLatestFromOperator(observables, project));
    };
}
exports.withLatestFrom = withLatestFrom;
var WithLatestFromOperator = (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
var WithLatestFromSubscriber = (function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            _this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            _this.add(subscribeToResult_1.subscribeToResult(_this, observable, undefined, i));
        }
        return _this;
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":313,"../util/subscribeToResult":503}],451:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var zip_1 = require("../observable/zip");
function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function zipOperatorFunction(source) {
        return source.lift.call(zip_1.zip.apply(void 0, [source].concat(observables)));
    };
}
exports.zip = zip;

},{"../observable/zip":349}],452:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var zip_1 = require("../observable/zip");
function zipAll(project) {
    return function (source) { return source.lift(new zip_1.ZipOperator(project)); };
}
exports.zipAll = zipAll;

},{"../observable/zip":349}],453:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
function scheduleArray(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        var i = 0;
        sub.add(scheduler.schedule(function () {
            if (i === input.length) {
                subscriber.complete();
                return;
            }
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
                sub.add(this.schedule());
            }
        }));
        return sub;
    });
}
exports.scheduleArray = scheduleArray;

},{"../Observable":311,"../Subscription":319}],454:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
var iterator_1 = require("../symbol/iterator");
function scheduleIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        var iterator;
        sub.add(function () {
            if (iterator && typeof iterator.return === 'function') {
                iterator.return();
            }
        });
        sub.add(scheduler.schedule(function () {
            iterator = input[iterator_1.iterator]();
            sub.add(scheduler.schedule(function () {
                if (subscriber.closed) {
                    return;
                }
                var value;
                var done;
                try {
                    var result = iterator.next();
                    value = result.value;
                    done = result.done;
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(value);
                    this.schedule();
                }
            }));
        }));
        return sub;
    });
}
exports.scheduleIterable = scheduleIterable;

},{"../Observable":311,"../Subscription":319,"../symbol/iterator":472}],455:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
var observable_1 = require("../symbol/observable");
function scheduleObservable(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        sub.add(scheduler.schedule(function () {
            var observable = input[observable_1.observable]();
            sub.add(observable.subscribe({
                next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
            }));
        }));
        return sub;
    });
}
exports.scheduleObservable = scheduleObservable;

},{"../Observable":311,"../Subscription":319,"../symbol/observable":473}],456:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
function schedulePromise(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        sub.add(scheduler.schedule(function () { return input.then(function (value) {
            sub.add(scheduler.schedule(function () {
                subscriber.next(value);
                sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
            }));
        }, function (err) {
            sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
        }); }));
        return sub;
    });
}
exports.schedulePromise = schedulePromise;

},{"../Observable":311,"../Subscription":319}],457:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var scheduleObservable_1 = require("./scheduleObservable");
var schedulePromise_1 = require("./schedulePromise");
var scheduleArray_1 = require("./scheduleArray");
var scheduleIterable_1 = require("./scheduleIterable");
var isInteropObservable_1 = require("../util/isInteropObservable");
var isPromise_1 = require("../util/isPromise");
var isArrayLike_1 = require("../util/isArrayLike");
var isIterable_1 = require("../util/isIterable");
function scheduled(input, scheduler) {
    if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
            return scheduleObservable_1.scheduleObservable(input, scheduler);
        }
        else if (isPromise_1.isPromise(input)) {
            return schedulePromise_1.schedulePromise(input, scheduler);
        }
        else if (isArrayLike_1.isArrayLike(input)) {
            return scheduleArray_1.scheduleArray(input, scheduler);
        }
        else if (isIterable_1.isIterable(input) || typeof input === 'string') {
            return scheduleIterable_1.scheduleIterable(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}
exports.scheduled = scheduled;

},{"../util/isArrayLike":485,"../util/isInteropObservable":488,"../util/isIterable":489,"../util/isPromise":493,"./scheduleArray":453,"./scheduleIterable":454,"./scheduleObservable":455,"./schedulePromise":456}],458:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = require("../Subscription");
var Action = (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        return this;
    };
    return Action;
}(Subscription_1.Subscription));
exports.Action = Action;

},{"../Subscription":319}],459:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = require("./AsyncAction");
var AnimationFrameAction = (function (_super) {
    __extends(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AnimationFrameAction;
}(AsyncAction_1.AsyncAction));
exports.AnimationFrameAction = AnimationFrameAction;

},{"./AsyncAction":463}],460:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncScheduler_1 = require("./AsyncScheduler");
var AnimationFrameScheduler = (function (_super) {
    __extends(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.AnimationFrameScheduler = AnimationFrameScheduler;

},{"./AsyncScheduler":464}],461:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Immediate_1 = require("../util/Immediate");
var AsyncAction_1 = require("./AsyncAction");
var AsapAction = (function (_super) {
    __extends(AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = Immediate_1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            Immediate_1.Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction;
}(AsyncAction_1.AsyncAction));
exports.AsapAction = AsapAction;

},{"../util/Immediate":477,"./AsyncAction":463}],462:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncScheduler_1 = require("./AsyncScheduler");
var AsapScheduler = (function (_super) {
    __extends(AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.AsapScheduler = AsapScheduler;

},{"./AsyncScheduler":464}],463:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Action_1 = require("./Action");
var AsyncAction = (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        clearInterval(id);
        return undefined;
    };
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_1.Action));
exports.AsyncAction = AsyncAction;

},{"./Action":458}],464:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Scheduler_1 = require("../Scheduler");
var AsyncScheduler = (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler_1.Scheduler.now; }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler));
exports.AsyncScheduler = AsyncScheduler;

},{"../Scheduler":315}],465:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = require("./AsyncAction");
var QueueAction = (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1.AsyncAction));
exports.QueueAction = QueueAction;

},{"./AsyncAction":463}],466:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncScheduler_1 = require("./AsyncScheduler");
var QueueScheduler = (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.QueueScheduler = QueueScheduler;

},{"./AsyncScheduler":464}],467:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = require("./AsyncAction");
var AsyncScheduler_1 = require("./AsyncScheduler");
var VirtualTimeScheduler = (function (_super) {
    __extends(VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }
        if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
    }
    VirtualTimeScheduler.prototype.flush = function () {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
            actions.shift();
            this.frame = action.delay;
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.VirtualTimeScheduler = VirtualTimeScheduler;
var VirtualAction = (function (_super) {
    __extends(VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) { index = scheduler.index += 1; }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
    }
    VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    };
    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    };
    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return undefined;
    };
    VirtualAction.prototype._execute = function (state, delay) {
        if (this.active === true) {
            return _super.prototype._execute.call(this, state, delay);
        }
    };
    VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) {
                return 0;
            }
            else if (a.index > b.index) {
                return 1;
            }
            else {
                return -1;
            }
        }
        else if (a.delay > b.delay) {
            return 1;
        }
        else {
            return -1;
        }
    };
    return VirtualAction;
}(AsyncAction_1.AsyncAction));
exports.VirtualAction = VirtualAction;

},{"./AsyncAction":463,"./AsyncScheduler":464}],468:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AnimationFrameAction_1 = require("./AnimationFrameAction");
var AnimationFrameScheduler_1 = require("./AnimationFrameScheduler");
exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
exports.animationFrame = exports.animationFrameScheduler;

},{"./AnimationFrameAction":459,"./AnimationFrameScheduler":460}],469:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AsapAction_1 = require("./AsapAction");
var AsapScheduler_1 = require("./AsapScheduler");
exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
exports.asap = exports.asapScheduler;

},{"./AsapAction":461,"./AsapScheduler":462}],470:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = require("./AsyncAction");
var AsyncScheduler_1 = require("./AsyncScheduler");
exports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
exports.async = exports.asyncScheduler;

},{"./AsyncAction":463,"./AsyncScheduler":464}],471:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var QueueAction_1 = require("./QueueAction");
var QueueScheduler_1 = require("./QueueScheduler");
exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
exports.queue = exports.queueScheduler;

},{"./QueueAction":465,"./QueueScheduler":466}],472:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
exports.getSymbolIterator = getSymbolIterator;
exports.iterator = getSymbolIterator();
exports.$$iterator = exports.iterator;

},{}],473:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.observable = (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();

},{}],474:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rxSubscriber = (function () {
    return typeof Symbol === 'function'
        ? Symbol('rxSubscriber')
        : '@@rxSubscriber_' + Math.random();
})();
exports.$$rxSubscriber = exports.rxSubscriber;

},{}],475:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ArgumentOutOfRangeErrorImpl = (function () {
    function ArgumentOutOfRangeErrorImpl() {
        Error.call(this);
        this.message = 'argument out of range';
        this.name = 'ArgumentOutOfRangeError';
        return this;
    }
    ArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);
    return ArgumentOutOfRangeErrorImpl;
})();
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

},{}],476:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyErrorImpl = (function () {
    function EmptyErrorImpl() {
        Error.call(this);
        this.message = 'no elements in sequence';
        this.name = 'EmptyError';
        return this;
    }
    EmptyErrorImpl.prototype = Object.create(Error.prototype);
    return EmptyErrorImpl;
})();
exports.EmptyError = EmptyErrorImpl;

},{}],477:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var nextHandle = 1;
var RESOLVED = (function () { return Promise.resolve(); })();
var activeHandles = {};
function findAndClearHandle(handle) {
    if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
    }
    return false;
}
exports.Immediate = {
    setImmediate: function (cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        RESOLVED.then(function () { return findAndClearHandle(handle) && cb(); });
        return handle;
    },
    clearImmediate: function (handle) {
        findAndClearHandle(handle);
    },
};
exports.TestTools = {
    pending: function () {
        return Object.keys(activeHandles).length;
    }
};

},{}],478:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ObjectUnsubscribedErrorImpl = (function () {
    function ObjectUnsubscribedErrorImpl() {
        Error.call(this);
        this.message = 'object unsubscribed';
        this.name = 'ObjectUnsubscribedError';
        return this;
    }
    ObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);
    return ObjectUnsubscribedErrorImpl;
})();
exports.ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

},{}],479:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TimeoutErrorImpl = (function () {
    function TimeoutErrorImpl() {
        Error.call(this);
        this.message = 'Timeout has occurred';
        this.name = 'TimeoutError';
        return this;
    }
    TimeoutErrorImpl.prototype = Object.create(Error.prototype);
    return TimeoutErrorImpl;
})();
exports.TimeoutError = TimeoutErrorImpl;

},{}],480:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var UnsubscriptionErrorImpl = (function () {
    function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors ?
            errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
    }
    UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
    return UnsubscriptionErrorImpl;
})();
exports.UnsubscriptionError = UnsubscriptionErrorImpl;

},{}],481:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof Subscriber_1.Subscriber) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}
exports.canReportError = canReportError;

},{"../Subscriber":318}],482:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function hostReportError(err) {
    setTimeout(function () { throw err; }, 0);
}
exports.hostReportError = hostReportError;

},{}],483:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function identity(x) {
    return x;
}
exports.identity = identity;

},{}],484:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArray = (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();

},{}],485:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

},{}],486:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
exports.isDate = isDate;

},{}],487:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;

},{}],488:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var observable_1 = require("../symbol/observable");
function isInteropObservable(input) {
    return input && typeof input[observable_1.observable] === 'function';
}
exports.isInteropObservable = isInteropObservable;

},{"../symbol/observable":473}],489:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var iterator_1 = require("../symbol/iterator");
function isIterable(input) {
    return input && typeof input[iterator_1.iterator] === 'function';
}
exports.isIterable = isIterable;

},{"../symbol/iterator":472}],490:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("./isArray");
function isNumeric(val) {
    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;
}
exports.isNumeric = isNumeric;

},{"./isArray":484}],491:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isObject(x) {
    return x !== null && typeof x === 'object';
}
exports.isObject = isObject;

},{}],492:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
function isObservable(obj) {
    return !!obj && (obj instanceof Observable_1.Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));
}
exports.isObservable = isObservable;

},{"../Observable":311}],493:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isPromise(value) {
    return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;

},{}],494:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;

},{}],495:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function noop() { }
exports.noop = noop;

},{}],496:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function not(pred, thisArg) {
    function notPred() {
        return !(notPred.pred.apply(notPred.thisArg, arguments));
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
}
exports.not = not;

},{}],497:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var identity_1 = require("./identity");
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
exports.pipe = pipe;
function pipeFromArray(fns) {
    if (fns.length === 0) {
        return identity_1.identity;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
exports.pipeFromArray = pipeFromArray;

},{"./identity":483}],498:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var subscribeToArray_1 = require("./subscribeToArray");
var subscribeToPromise_1 = require("./subscribeToPromise");
var subscribeToIterable_1 = require("./subscribeToIterable");
var subscribeToObservable_1 = require("./subscribeToObservable");
var isArrayLike_1 = require("./isArrayLike");
var isPromise_1 = require("./isPromise");
var isObject_1 = require("./isObject");
var iterator_1 = require("../symbol/iterator");
var observable_1 = require("../symbol/observable");
exports.subscribeTo = function (result) {
    if (!!result && typeof result[observable_1.observable] === 'function') {
        return subscribeToObservable_1.subscribeToObservable(result);
    }
    else if (isArrayLike_1.isArrayLike(result)) {
        return subscribeToArray_1.subscribeToArray(result);
    }
    else if (isPromise_1.isPromise(result)) {
        return subscribeToPromise_1.subscribeToPromise(result);
    }
    else if (!!result && typeof result[iterator_1.iterator] === 'function') {
        return subscribeToIterable_1.subscribeToIterable(result);
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};

},{"../symbol/iterator":472,"../symbol/observable":473,"./isArrayLike":485,"./isObject":491,"./isPromise":493,"./subscribeToArray":499,"./subscribeToIterable":500,"./subscribeToObservable":501,"./subscribeToPromise":502}],499:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscribeToArray = function (array) { return function (subscriber) {
    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
        subscriber.next(array[i]);
    }
    subscriber.complete();
}; };

},{}],500:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var iterator_1 = require("../symbol/iterator");
exports.subscribeToIterable = function (iterable) { return function (subscriber) {
    var iterator = iterable[iterator_1.iterator]();
    do {
        var item = void 0;
        try {
            item = iterator.next();
        }
        catch (err) {
            subscriber.error(err);
            return subscriber;
        }
        if (item.done) {
            subscriber.complete();
            break;
        }
        subscriber.next(item.value);
        if (subscriber.closed) {
            break;
        }
    } while (true);
    if (typeof iterator.return === 'function') {
        subscriber.add(function () {
            if (iterator.return) {
                iterator.return();
            }
        });
    }
    return subscriber;
}; };

},{"../symbol/iterator":472}],501:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var observable_1 = require("../symbol/observable");
exports.subscribeToObservable = function (obj) { return function (subscriber) {
    var obs = obj[observable_1.observable]();
    if (typeof obs.subscribe !== 'function') {
        throw new TypeError('Provided object does not correctly implement Symbol.observable');
    }
    else {
        return obs.subscribe(subscriber);
    }
}; };

},{"../symbol/observable":473}],502:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var hostReportError_1 = require("./hostReportError");
exports.subscribeToPromise = function (promise) { return function (subscriber) {
    promise.then(function (value) {
        if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
        }
    }, function (err) { return subscriber.error(err); })
        .then(null, hostReportError_1.hostReportError);
    return subscriber;
}; };

},{"./hostReportError":482}],503:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var InnerSubscriber_1 = require("../InnerSubscriber");
var subscribeTo_1 = require("./subscribeTo");
var Observable_1 = require("../Observable");
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
    if (innerSubscriber === void 0) { innerSubscriber = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex); }
    if (innerSubscriber.closed) {
        return undefined;
    }
    if (result instanceof Observable_1.Observable) {
        return result.subscribe(innerSubscriber);
    }
    return subscribeTo_1.subscribeTo(result)(innerSubscriber);
}
exports.subscribeToResult = subscribeToResult;

},{"../InnerSubscriber":309,"../Observable":311,"./subscribeTo":498}],504:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var rxSubscriber_1 = require("../symbol/rxSubscriber");
var Observer_1 = require("../Observer");
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;

},{"../Observer":312,"../Subscriber":318,"../symbol/rxSubscriber":474}],505:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var audit_1 = require("../internal/operators/audit");
exports.audit = audit_1.audit;
var auditTime_1 = require("../internal/operators/auditTime");
exports.auditTime = auditTime_1.auditTime;
var buffer_1 = require("../internal/operators/buffer");
exports.buffer = buffer_1.buffer;
var bufferCount_1 = require("../internal/operators/bufferCount");
exports.bufferCount = bufferCount_1.bufferCount;
var bufferTime_1 = require("../internal/operators/bufferTime");
exports.bufferTime = bufferTime_1.bufferTime;
var bufferToggle_1 = require("../internal/operators/bufferToggle");
exports.bufferToggle = bufferToggle_1.bufferToggle;
var bufferWhen_1 = require("../internal/operators/bufferWhen");
exports.bufferWhen = bufferWhen_1.bufferWhen;
var catchError_1 = require("../internal/operators/catchError");
exports.catchError = catchError_1.catchError;
var combineAll_1 = require("../internal/operators/combineAll");
exports.combineAll = combineAll_1.combineAll;
var combineLatest_1 = require("../internal/operators/combineLatest");
exports.combineLatest = combineLatest_1.combineLatest;
var concat_1 = require("../internal/operators/concat");
exports.concat = concat_1.concat;
var concatAll_1 = require("../internal/operators/concatAll");
exports.concatAll = concatAll_1.concatAll;
var concatMap_1 = require("../internal/operators/concatMap");
exports.concatMap = concatMap_1.concatMap;
var concatMapTo_1 = require("../internal/operators/concatMapTo");
exports.concatMapTo = concatMapTo_1.concatMapTo;
var count_1 = require("../internal/operators/count");
exports.count = count_1.count;
var debounce_1 = require("../internal/operators/debounce");
exports.debounce = debounce_1.debounce;
var debounceTime_1 = require("../internal/operators/debounceTime");
exports.debounceTime = debounceTime_1.debounceTime;
var defaultIfEmpty_1 = require("../internal/operators/defaultIfEmpty");
exports.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;
var delay_1 = require("../internal/operators/delay");
exports.delay = delay_1.delay;
var delayWhen_1 = require("../internal/operators/delayWhen");
exports.delayWhen = delayWhen_1.delayWhen;
var dematerialize_1 = require("../internal/operators/dematerialize");
exports.dematerialize = dematerialize_1.dematerialize;
var distinct_1 = require("../internal/operators/distinct");
exports.distinct = distinct_1.distinct;
var distinctUntilChanged_1 = require("../internal/operators/distinctUntilChanged");
exports.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;
var distinctUntilKeyChanged_1 = require("../internal/operators/distinctUntilKeyChanged");
exports.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;
var elementAt_1 = require("../internal/operators/elementAt");
exports.elementAt = elementAt_1.elementAt;
var endWith_1 = require("../internal/operators/endWith");
exports.endWith = endWith_1.endWith;
var every_1 = require("../internal/operators/every");
exports.every = every_1.every;
var exhaust_1 = require("../internal/operators/exhaust");
exports.exhaust = exhaust_1.exhaust;
var exhaustMap_1 = require("../internal/operators/exhaustMap");
exports.exhaustMap = exhaustMap_1.exhaustMap;
var expand_1 = require("../internal/operators/expand");
exports.expand = expand_1.expand;
var filter_1 = require("../internal/operators/filter");
exports.filter = filter_1.filter;
var finalize_1 = require("../internal/operators/finalize");
exports.finalize = finalize_1.finalize;
var find_1 = require("../internal/operators/find");
exports.find = find_1.find;
var findIndex_1 = require("../internal/operators/findIndex");
exports.findIndex = findIndex_1.findIndex;
var first_1 = require("../internal/operators/first");
exports.first = first_1.first;
var groupBy_1 = require("../internal/operators/groupBy");
exports.groupBy = groupBy_1.groupBy;
var ignoreElements_1 = require("../internal/operators/ignoreElements");
exports.ignoreElements = ignoreElements_1.ignoreElements;
var isEmpty_1 = require("../internal/operators/isEmpty");
exports.isEmpty = isEmpty_1.isEmpty;
var last_1 = require("../internal/operators/last");
exports.last = last_1.last;
var map_1 = require("../internal/operators/map");
exports.map = map_1.map;
var mapTo_1 = require("../internal/operators/mapTo");
exports.mapTo = mapTo_1.mapTo;
var materialize_1 = require("../internal/operators/materialize");
exports.materialize = materialize_1.materialize;
var max_1 = require("../internal/operators/max");
exports.max = max_1.max;
var merge_1 = require("../internal/operators/merge");
exports.merge = merge_1.merge;
var mergeAll_1 = require("../internal/operators/mergeAll");
exports.mergeAll = mergeAll_1.mergeAll;
var mergeMap_1 = require("../internal/operators/mergeMap");
exports.mergeMap = mergeMap_1.mergeMap;
exports.flatMap = mergeMap_1.flatMap;
var mergeMapTo_1 = require("../internal/operators/mergeMapTo");
exports.mergeMapTo = mergeMapTo_1.mergeMapTo;
var mergeScan_1 = require("../internal/operators/mergeScan");
exports.mergeScan = mergeScan_1.mergeScan;
var min_1 = require("../internal/operators/min");
exports.min = min_1.min;
var multicast_1 = require("../internal/operators/multicast");
exports.multicast = multicast_1.multicast;
var observeOn_1 = require("../internal/operators/observeOn");
exports.observeOn = observeOn_1.observeOn;
var onErrorResumeNext_1 = require("../internal/operators/onErrorResumeNext");
exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;
var pairwise_1 = require("../internal/operators/pairwise");
exports.pairwise = pairwise_1.pairwise;
var partition_1 = require("../internal/operators/partition");
exports.partition = partition_1.partition;
var pluck_1 = require("../internal/operators/pluck");
exports.pluck = pluck_1.pluck;
var publish_1 = require("../internal/operators/publish");
exports.publish = publish_1.publish;
var publishBehavior_1 = require("../internal/operators/publishBehavior");
exports.publishBehavior = publishBehavior_1.publishBehavior;
var publishLast_1 = require("../internal/operators/publishLast");
exports.publishLast = publishLast_1.publishLast;
var publishReplay_1 = require("../internal/operators/publishReplay");
exports.publishReplay = publishReplay_1.publishReplay;
var race_1 = require("../internal/operators/race");
exports.race = race_1.race;
var reduce_1 = require("../internal/operators/reduce");
exports.reduce = reduce_1.reduce;
var repeat_1 = require("../internal/operators/repeat");
exports.repeat = repeat_1.repeat;
var repeatWhen_1 = require("../internal/operators/repeatWhen");
exports.repeatWhen = repeatWhen_1.repeatWhen;
var retry_1 = require("../internal/operators/retry");
exports.retry = retry_1.retry;
var retryWhen_1 = require("../internal/operators/retryWhen");
exports.retryWhen = retryWhen_1.retryWhen;
var refCount_1 = require("../internal/operators/refCount");
exports.refCount = refCount_1.refCount;
var sample_1 = require("../internal/operators/sample");
exports.sample = sample_1.sample;
var sampleTime_1 = require("../internal/operators/sampleTime");
exports.sampleTime = sampleTime_1.sampleTime;
var scan_1 = require("../internal/operators/scan");
exports.scan = scan_1.scan;
var sequenceEqual_1 = require("../internal/operators/sequenceEqual");
exports.sequenceEqual = sequenceEqual_1.sequenceEqual;
var share_1 = require("../internal/operators/share");
exports.share = share_1.share;
var shareReplay_1 = require("../internal/operators/shareReplay");
exports.shareReplay = shareReplay_1.shareReplay;
var single_1 = require("../internal/operators/single");
exports.single = single_1.single;
var skip_1 = require("../internal/operators/skip");
exports.skip = skip_1.skip;
var skipLast_1 = require("../internal/operators/skipLast");
exports.skipLast = skipLast_1.skipLast;
var skipUntil_1 = require("../internal/operators/skipUntil");
exports.skipUntil = skipUntil_1.skipUntil;
var skipWhile_1 = require("../internal/operators/skipWhile");
exports.skipWhile = skipWhile_1.skipWhile;
var startWith_1 = require("../internal/operators/startWith");
exports.startWith = startWith_1.startWith;
var subscribeOn_1 = require("../internal/operators/subscribeOn");
exports.subscribeOn = subscribeOn_1.subscribeOn;
var switchAll_1 = require("../internal/operators/switchAll");
exports.switchAll = switchAll_1.switchAll;
var switchMap_1 = require("../internal/operators/switchMap");
exports.switchMap = switchMap_1.switchMap;
var switchMapTo_1 = require("../internal/operators/switchMapTo");
exports.switchMapTo = switchMapTo_1.switchMapTo;
var take_1 = require("../internal/operators/take");
exports.take = take_1.take;
var takeLast_1 = require("../internal/operators/takeLast");
exports.takeLast = takeLast_1.takeLast;
var takeUntil_1 = require("../internal/operators/takeUntil");
exports.takeUntil = takeUntil_1.takeUntil;
var takeWhile_1 = require("../internal/operators/takeWhile");
exports.takeWhile = takeWhile_1.takeWhile;
var tap_1 = require("../internal/operators/tap");
exports.tap = tap_1.tap;
var throttle_1 = require("../internal/operators/throttle");
exports.throttle = throttle_1.throttle;
var throttleTime_1 = require("../internal/operators/throttleTime");
exports.throttleTime = throttleTime_1.throttleTime;
var throwIfEmpty_1 = require("../internal/operators/throwIfEmpty");
exports.throwIfEmpty = throwIfEmpty_1.throwIfEmpty;
var timeInterval_1 = require("../internal/operators/timeInterval");
exports.timeInterval = timeInterval_1.timeInterval;
var timeout_1 = require("../internal/operators/timeout");
exports.timeout = timeout_1.timeout;
var timeoutWith_1 = require("../internal/operators/timeoutWith");
exports.timeoutWith = timeoutWith_1.timeoutWith;
var timestamp_1 = require("../internal/operators/timestamp");
exports.timestamp = timestamp_1.timestamp;
var toArray_1 = require("../internal/operators/toArray");
exports.toArray = toArray_1.toArray;
var window_1 = require("../internal/operators/window");
exports.window = window_1.window;
var windowCount_1 = require("../internal/operators/windowCount");
exports.windowCount = windowCount_1.windowCount;
var windowTime_1 = require("../internal/operators/windowTime");
exports.windowTime = windowTime_1.windowTime;
var windowToggle_1 = require("../internal/operators/windowToggle");
exports.windowToggle = windowToggle_1.windowToggle;
var windowWhen_1 = require("../internal/operators/windowWhen");
exports.windowWhen = windowWhen_1.windowWhen;
var withLatestFrom_1 = require("../internal/operators/withLatestFrom");
exports.withLatestFrom = withLatestFrom_1.withLatestFrom;
var zip_1 = require("../internal/operators/zip");
exports.zip = zip_1.zip;
var zipAll_1 = require("../internal/operators/zipAll");
exports.zipAll = zipAll_1.zipAll;

},{"../internal/operators/audit":350,"../internal/operators/auditTime":351,"../internal/operators/buffer":352,"../internal/operators/bufferCount":353,"../internal/operators/bufferTime":354,"../internal/operators/bufferToggle":355,"../internal/operators/bufferWhen":356,"../internal/operators/catchError":357,"../internal/operators/combineAll":358,"../internal/operators/combineLatest":359,"../internal/operators/concat":360,"../internal/operators/concatAll":361,"../internal/operators/concatMap":362,"../internal/operators/concatMapTo":363,"../internal/operators/count":364,"../internal/operators/debounce":365,"../internal/operators/debounceTime":366,"../internal/operators/defaultIfEmpty":367,"../internal/operators/delay":368,"../internal/operators/delayWhen":369,"../internal/operators/dematerialize":370,"../internal/operators/distinct":371,"../internal/operators/distinctUntilChanged":372,"../internal/operators/distinctUntilKeyChanged":373,"../internal/operators/elementAt":374,"../internal/operators/endWith":375,"../internal/operators/every":376,"../internal/operators/exhaust":377,"../internal/operators/exhaustMap":378,"../internal/operators/expand":379,"../internal/operators/filter":380,"../internal/operators/finalize":381,"../internal/operators/find":382,"../internal/operators/findIndex":383,"../internal/operators/first":384,"../internal/operators/groupBy":385,"../internal/operators/ignoreElements":386,"../internal/operators/isEmpty":387,"../internal/operators/last":388,"../internal/operators/map":389,"../internal/operators/mapTo":390,"../internal/operators/materialize":391,"../internal/operators/max":392,"../internal/operators/merge":393,"../internal/operators/mergeAll":394,"../internal/operators/mergeMap":395,"../internal/operators/mergeMapTo":396,"../internal/operators/mergeScan":397,"../internal/operators/min":398,"../internal/operators/multicast":399,"../internal/operators/observeOn":400,"../internal/operators/onErrorResumeNext":401,"../internal/operators/pairwise":402,"../internal/operators/partition":403,"../internal/operators/pluck":404,"../internal/operators/publish":405,"../internal/operators/publishBehavior":406,"../internal/operators/publishLast":407,"../internal/operators/publishReplay":408,"../internal/operators/race":409,"../internal/operators/reduce":410,"../internal/operators/refCount":411,"../internal/operators/repeat":412,"../internal/operators/repeatWhen":413,"../internal/operators/retry":414,"../internal/operators/retryWhen":415,"../internal/operators/sample":416,"../internal/operators/sampleTime":417,"../internal/operators/scan":418,"../internal/operators/sequenceEqual":419,"../internal/operators/share":420,"../internal/operators/shareReplay":421,"../internal/operators/single":422,"../internal/operators/skip":423,"../internal/operators/skipLast":424,"../internal/operators/skipUntil":425,"../internal/operators/skipWhile":426,"../internal/operators/startWith":427,"../internal/operators/subscribeOn":428,"../internal/operators/switchAll":429,"../internal/operators/switchMap":430,"../internal/operators/switchMapTo":431,"../internal/operators/take":432,"../internal/operators/takeLast":433,"../internal/operators/takeUntil":434,"../internal/operators/takeWhile":435,"../internal/operators/tap":436,"../internal/operators/throttle":437,"../internal/operators/throttleTime":438,"../internal/operators/throwIfEmpty":439,"../internal/operators/timeInterval":440,"../internal/operators/timeout":441,"../internal/operators/timeoutWith":442,"../internal/operators/timestamp":443,"../internal/operators/toArray":444,"../internal/operators/window":445,"../internal/operators/windowCount":446,"../internal/operators/windowTime":447,"../internal/operators/windowToggle":448,"../internal/operators/windowWhen":449,"../internal/operators/withLatestFrom":450,"../internal/operators/zip":451,"../internal/operators/zipAll":452}],506:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"buffer":3,"dup":8}],507:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

},{"safe-buffer":506}],508:[function(require,module,exports){
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

},{"./sha":509,"./sha1":510,"./sha224":511,"./sha256":512,"./sha384":513,"./sha512":514}],509:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

},{"./hash":507,"inherits":285,"safe-buffer":506}],510:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

},{"./hash":507,"inherits":285,"safe-buffer":506}],511:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

},{"./hash":507,"./sha256":512,"inherits":285,"safe-buffer":506}],512:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

},{"./hash":507,"inherits":285,"safe-buffer":506}],513:[function(require,module,exports){
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

},{"./hash":507,"./sha512":514,"inherits":285,"safe-buffer":506}],514:[function(require,module,exports){
var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

},{"./hash":507,"inherits":285,"safe-buffer":506}],515:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"safe-buffer":506}],516:[function(require,module,exports){
(function (Buffer){(function (){
/*! typedarray-to-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * Convert a typed array to a Buffer without a copy
 *
 * Author:   Feross Aboukhadijeh <https://feross.org>
 * License:  MIT
 *
 * `npm install typedarray-to-buffer`
 */

module.exports = function typedarrayToBuffer (arr) {
  return ArrayBuffer.isView(arr)
    // To avoid a copy, use the typed array's underlying ArrayBuffer to back
    // new Buffer, respecting the "view", i.e. byteOffset and byteLength
    ? Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength)
    // Pass through all other types to `Buffer.from`
    : Buffer.from(arr)
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":3}],517:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],518:[function(require,module,exports){
(function (global){(function (){
var { AuBeaconWrapper } = require('autonomy-beacon-wrapper')
global.window.AuBeaconWrapper = AuBeaconWrapper

var { BeaconWallet } = require('@taquito/beacon-wallet')
global.window.BeaconWallet = BeaconWallet


// "key": "autonomy-app",
// "name": "Autonomy: Digital Art Wallet",
// "shortName": "Autonomy",
// "color": "",
// "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAADS0lEQVR4AeXBXWiVZQAA4Gcvh+lYP4xGBBsc7Wal2UyWQ9gWSAYzhSgcgtBUSCwKMfulS2+iG7vJlUGJSzHBqwSLZhAYKgmZNac3tQNbizpTapPJYTun6zGDL/e+dPE9T53aYE2OBTkX5FyQc0HOBTkX5FyQc0HOBTlXkMLpy5TKoireR2+72ApSODjEqR9EtekxetvFFuRckHNBzgU5F6QwUxHdTEUKQWyzc1wqie5Sidk5sQWxHTvH5LToJqc5fl5sQUzXJth3TDJ7j3JtQkxBDLNzfPYdXfspT0mmPEXXfo6cZXZODAVZnf6Rg2csMFPhUonJabfV3caWtRSbCUEm1SqlMie/59ur5ilP0f8Rrx5ldZGGegu89CS9j8qiIKvSJKd+kFlDPYd30dfpjr3yFCcusP0QMxXzTE5zZthtPb1aVkEqh3fR12nR+jo5vEsqQQpPPERfp2j6Ouluk0KQwnOPi27LWikEKRSbRVdslkKQwo2bortxUwpBCmeGRTc0LIUghc8vcHVCNCO/ceKCFIIUKrM8c4Cx6xZt7DrPvk9lVgoFqVyboP0d3tzElrUUmwl1MqnWGP2Tkxd59wuuT0ulTm2wZjFmKlz8lQ+GOHGemvT6Onl5Ax3Laai3GAWL1VBPdxvdbfS2s/MQ1ZokQh2fvEB/t1iCmPq72LdRMq9tpL9bTEFsb29mSUF0Swq8tVlsQWxNjaxZJro1y2hqFFuQQlOj6JoapRCkMFoW3WhZCkFsV8YZGRfdyDjDY2ILYqpW2TNITXw17D1KtSqmIJapW2wbYGhYMl//zLYPmb4lloKsSmV+GrPATIWLv3DkLL//ZYE6PNzCsmZCkEm1ymiZkXFq5jt+jm+G2d5Dx3Ia6i2wqpVisywKsjp9mRc/9Z9seIQD21jZ6o5cGWfPIEPD5vnjb9475V8N7GD3elkEqWxdx5evs7LVHVvRwldvsHWdVIIU7r+Hj3cSgkULgUM7eeBeKQQpbO/hrqWiuXspz3dJIUihY7noOh6UQpBCQ73oGuqlEORckHNBzgU5V5BVTxsDO2SyqlV0q1oZ2CGTnjZZFWS1ooUVLf43xWZ2rxdbkHNBzgU5F+RckHNBzgU5F+RckHP/AKis3ntPQOcLAAAAAElFTkSuQmCC",
// "universalLink": "https://autonomy.io/apps/tezos",
// "deepLink": "autonomy-tezos://"

var { DAppClient, NetworkType, PermissionScope, SignPayloadRequestOutput, BeaconMessageType } = require('@airgap/beacon-dapp')
global.window.DAppClient = DAppClient
global.window.NetworkType = NetworkType
global.window.PermissionScope = PermissionScope
global.window.SignPayloadRequestOutput = SignPayloadRequestOutput
global.window.BeaconMessageType = BeaconMessageType


const ABW = new AuBeaconWrapper('objkt.com', {name: 'alo', iconUrl:'google.com'});

$(document).ready(function(){
    $(".btn1").click(function(){
      console.log("Calling wrapper");
      ABW.showConnect().then(r => {
        if (r === 1){
          console.log("Au success test");
        } else if (r === 2) {
          // const dC = new DAppClient({name: "test other"});
          // dC.requestPermissions().then(() => console.log("Granted"))
          console.log("Beacon success test");
        }
      })
    });
});

/*
const alertConfig = {
    title: 'Choose your preferred wallet',
    body: `<p></p>`,
    pairingPayload: {
        p2pSyncCode: data.p2pPeerInfo,
        postmessageSyncCode: data.postmessagePeerInfo,
        preferredNetwork: data.preferredNetwork
    },
    // eslint-disable-next-line @typescript-eslint/unbound-method
    closeButtonCallback: data.abortedHandler,
    disclaimerText: data.disclaimerText
};



console.log(alertConfig);
console.log(alertConfig.pairingPayload);

p2pPeerInfo: () => {
  p2pTransport.connect().then().catch(console.error);
  return p2pTransport.getPairingRequestInfo();
},
postmessagePeerInfo: () => postMessageTransport.getPairingRequestInfo(),
preferredNetwork: this.preferredNetwork,
*/
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"@airgap/beacon-dapp":78,"@taquito/beacon-wallet":168,"autonomy-beacon-wrapper":211}]},{},[518]);
